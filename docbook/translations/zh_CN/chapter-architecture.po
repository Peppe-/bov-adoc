# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-10-31 08:35+0000\n"
"PO-Revision-Date: 2014-10-31 17:58+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-architecture.xml:11
#, no-c-format
msgid "Architecture"
msgstr "整体架构"

#. Tag: para
#: chapter-architecture.xml:13
#, no-c-format
msgid ""
"In <xref linkend=\"intro\"/>, we gave a short introduction to the general "
"architecture of Vaadin. This chapter looks deeper into the architecture at a "
"more technical level."
msgstr ""
"在 <xref linkend=\"intro\"/> 中, 我们简略的介绍了 Vaadin 的架构概要. 本章将在"
"技术层面上更深入的讲解这个问题."

#. Tag: title
#: chapter-architecture.xml:20
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-architecture.xml:22
#, no-c-format
msgid ""
"Vaadin provides two development models for web applications: for the client-"
"side (the browser) and for the server-side. The server-driven development "
"model is the more powerful one, allowing application development solely on "
"the server-side, by utilizing an AJAX-based Vaadin Client-Side Engine that "
"renders the user interface in the browser. The client-side model allows "
"developing widgets and applications in Java, which are compiled to "
"JavaScript and executed in the browser. The two models can share their UI "
"widgets, themes, and back-end code and services, and can be mixed together "
"easily."
msgstr ""
"Vaadin 为 Web 应用程序提供两种开发模式: 客户端 (浏览器端) 和服务器端. 服务器"
"端开发模型功能更为强大一些, 可以在服务器端开发完整的应用程序, 使用基于 AJAX "
"的 Vaadin 客户端引擎将 UI 展现在浏览器中. 客户端开发模型可以用 Java 语言开发 "
"widget 或客户端应用程序, 然后编译为 JavaScript 形式在浏览器内运行. 两种开发模"
"型可以共享 UI widget, theme, 以及后端代码和服务, 这两种开发模型也可以容易的结"
"合在一起."

#. Tag: title
#: chapter-architecture.xml:35
#, no-c-format
msgid "Vaadin Runtime Architecture"
msgstr "Vaadin 运行期架构"

#. Tag: para
#: chapter-architecture.xml:46
#, no-c-format
msgid ""
"gives a basic illustration of the client-side and server-side "
"communications, in a running situation where the page with the client-side "
"code (engine or application) has been initially loaded in the browser."
msgstr ""
"展示了客户端与服务器端通信的基本架构, 图中展示的是, 包含客户端代码 (客户端引"
"擎或应用程序) 的页面在浏览器中初期装载后的运行场景."

#. Tag: para
#: chapter-architecture.xml:53
#, no-c-format
msgid ""
"Vaadin Framework consists of a <emphasis>server-side API</emphasis>, a "
"<emphasis>client-side API</emphasis>, a horde of <emphasis>user interface "
"components/widgets</emphasis> on the both sides, <emphasis>themes</emphasis> "
"for controlling the appearance, and a <emphasis>data model</emphasis> that "
"allows binding the server-side components directly to data. For client-side "
"development, it includes the Vaadin Compiler, which allows compiling Java to "
"JavaScript."
msgstr ""
"Vaadin 框架包括 <emphasis>服务器端 API</emphasis>, <emphasis>客户端 API</"
"emphasis>, 一组 <emphasis>UI 组件和 widget</emphasis>,  UI 组件和 widget 在两"
"端都存在, <emphasis>theme</emphasis> 用于控制具体的 UI 表现, <emphasis>数据模"
"型</emphasis> 用于将服务器端组件直接绑定到数据上. 对于客户端开发模型, 还包括 "
"Vaadin Compiler, 可以将 Java 代码编译为 JavaScript."

#. Tag: para
#: chapter-architecture.xml:63
#, no-c-format
msgid ""
"A server-side Vaadin application runs as a servlet in a Java web server, "
"serving HTTP requests. The <classname>VaadinServlet</classname> is normally "
"used as the servlet class. The servlet receives client requests and "
"inteprets them as events for a particular user session. Events are "
"associated with user interface components and delivered to the event "
"listeners defined in the application. If the UI logic makes changes to the "
"server-side user interface components, the servlet renders them in the web "
"browser by generating a response. The client-side engine running in the "
"browser receives the responses and uses them to make any necessary changes "
"to the page in the browser."
msgstr ""
"服务器端 Vaadin 应用程序以 Servlet 形式运行在 Java Web 服务器中, 提供 HTTP 服"
"务. Servlet 类通常使用<classname>VaadinServlet</classname>. Servlet 接受客户"
"端请求, 并将它解释为某个用户 Session 的事件. 事件关联到 UI 组件上, 并被派发给"
"应用程序中指定的事件监听器. 如果 UI 逻辑变更了服务器端 UI 组件的状态, "
"Servlet 会将 UI 组件的状态变化通过 HTTP 应答返回给 Web 浏览器端. 客户端引擎运"
"行在浏览器内, 它接受服务器端的应答, 如果其中包含 UI 组件的状态变化, 它将相应"
"地修改浏览器内页面的状态."

#. Tag: para
#: chapter-architecture.xml:75
#, no-c-format
msgid ""
"The major parts of the server-driven development architecture and their "
"function are as follows:"
msgstr "服务器端开发架构包括的主要部分, 及各部分的功能如下:"

#. Tag: term
#: chapter-architecture.xml:83
#, no-c-format
msgid "User Interface"
msgstr "用户界面"

#. Tag: para
#: chapter-architecture.xml:85
#, no-c-format
msgid ""
"Vaadin applications provide a user interface for the user to interface with "
"the business logic and data of the application. At technical level, the UI "
"is realized as a <emphasis>&ui;</emphasis> class that extends <classname>com."
"vaadin.ui.&uiclass;</classname>. Its main task is to create the initial user "
"interface out of UI components and set up event listeners to handle user "
"input. The &ui; can then be loaded in the browser using an URL, or can be "
"embedded to any HTML page. For detailed information about implementing a "
"<classname>&uiclass;</classname>, see <xref linkend=\"application\"/>."
msgstr ""
"Vaadin 应用程序向用户提供 UI, 作为用户操作应用程序业务逻辑和数据的接口. 从技"
"术层面来说, UI 可被认为是 <emphasis>&ui;</emphasis> 类, 继承自 "
"<classname>com.vaadin.ui.&uiclass;</classname> 类. 它的主要任务是使用 UI 构造"
"出初始的用户界面, 并创建各种事件监听器来处理用户的输入. &ui; 可以用过访问其 "
"URL 来装载进浏览器, 也可以嵌入到任意的 HTML 页面内. 实现一个 "
"<classname>&uiclass;</classname> 的详细方法, 请参见 <xref linkend="
"\"application\"/>."

#. Tag: para
#: chapter-architecture.xml:99
#, no-c-format
msgid ""
"Please note that the term \"UI\" is used throughout this book to refer both "
"to the general UI concept as well as the technical UI class concept."
msgstr ""
"请注意, \"UI\" 这个词在本书中有时指一般的 UI 概念, 也有时指 Vaadin 中 UI 类的"
"概念."

#. Tag: term
#: chapter-architecture.xml:108
#, no-c-format
msgid "User Interface Components/Widgets"
msgstr "UI 组件和 Widget"

#. Tag: primary
#: chapter-architecture.xml:111
#, no-c-format
msgid "component"
msgstr "组件"

#. Tag: primary
#: chapter-architecture.xml:112
#, no-c-format
msgid "widget"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:113
#, no-c-format
msgid "field"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:113
#, no-c-format
msgid ""
"The user interface of a Vaadin application consists of components that are "
"created and laid out by the application. Each server-side component has a "
"client-side counterpart, a \"<emphasis>widget</emphasis>\", by which it is "
"rendered in the browser and with which the user interacts. The client-side "
"widgets can also be used by client-side applications. The server-side "
"components relay these events to the application logic. Field components "
"that have a value, which the user can view or edit, can be bound to a data "
"source (see below). For a more detailed description of the UI component "
"architecture, see <xref linkend=\"components\"/>."
msgstr ""
"应用程序创建一系列组件, 并管理其布局, 由此构成了 Vaadin 应用程序的 UI. 服务器"
"端的每个组件在客户端都有一个对应的模块, 也就是 \"<emphasis>widget</emphasis>"
"\", 组件将通过 widget 展现在浏览器中,  用户也正是通过 widget 来与应用程序交"
"互. 客户端 widget 也可以供客户端应用程序使用. 服务器端组件把它的事件转发给应"
"用程序逻辑. 拥有某种数据值供用户查看和编辑的 Field 组件, 可以与数据源绑定在一"
"起 (详情见后文). 关于 UI 组件架构, 更详细的介绍请参见 <xref linkend="
"\"components\"/>."

#. Tag: term
#: chapter-architecture.xml:131
#, no-c-format
msgid "<term>Client-Side Engine</term>"
msgstr "<term>客户端引擎</term>"

#. Tag: primary
#: chapter-architecture.xml:134 chapter-architecture.xml:540
#, no-c-format
msgid "<primary>Client-Side Engine</primary>"
msgstr "<primary>客户端引擎</primary>"

#. Tag: primary
#: chapter-architecture.xml:135 chapter-architecture.xml:285
#: chapter-architecture.xml:286 chapter-architecture.xml:432
#, no-c-format
msgid "<primary>Google Web Toolkit</primary>"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:136
#, no-c-format
msgid "HTTP"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:136
#, no-c-format
msgid ""
"The Client-Side Engine of Vaadin manages the rendering of the UI in the web "
"browser by employing various client-side <emphasis>widgets</emphasis>, "
"counterparts of the server-side components. It communicates user interaction "
"to the server-side, and then again renders the changes in the UI. The "
"communications are made using asynchronous HTTP or HTTPS requests. See <xref "
"linkend=\"architecture.client-side\"/>."
msgstr ""
"Vaadin 的客户端引擎负责将 UI 展现在 Web 浏览器中, 它将使用到各种客户端 "
"<emphasis>widget</emphasis>, widget 将与服务器端组件一一对应. 客户端引擎将用"
"户的交互动作发送给服务器端, 然后将服务器端 UI 的变化展现到浏览器端. 客户端与"
"服务器端的通信使用异步的 HTTP 或 HTTPS 请求. 详情参见 <xref linkend="
"\"architecture.client-side\"/>."

#. Tag: term
#: chapter-architecture.xml:150
#, no-c-format
msgid "Vaadin Servlet"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:153
#, no-c-format
msgid "VaadinServlet"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:153
#, no-c-format
msgid ""
"Server-side Vaadin applications work on top of the Java Servlet API (see "
"<xref linkend=\"architecture.technology.servlet\"/>). The Vaadin servlet, or "
"more exactly the <classname>VaadinServlet</classname> class, receives "
"requests from different clients, determines which user session they belong "
"to by tracking the sessions with cookies, and delegates the requests to "
"their corresponding sessions. You can customize the Vaadin servlet by "
"extending it."
msgstr ""
"客户端 Vaadin 应用程序工作在 Java Servlet API 的之上(详情参见 <xref linkend="
"\"architecture.technology.servlet\"/>). Vaadin servlet, 更确切的说 "
"<classname>VaadinServlet</classname> 类, 从不同的客户端接受请求, 从 cookie 中"
"取出 Session 信息, 判定请求属于哪个用户 Session, 然后将请求转发到它所属的 "
"Session. 你可以继承 Vaadin servlet 来改造它."

#. Tag: term
#: chapter-architecture.xml:168
#, no-c-format
msgid "Themes"
msgstr "Theme"

#. Tag: primary
#: chapter-architecture.xml:171
#, no-c-format
msgid "theme"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:172 chapter-architecture.xml:341
#: chapter-architecture.xml:390
#, no-c-format
msgid "<primary>CSS</primary>"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:173 chapter-architecture.xml:344
#, no-c-format
msgid "Sass"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:174
#, no-c-format
msgid "HTML templates"
msgstr "HTML 模板"

#. Tag: para
#: chapter-architecture.xml:174
#, no-c-format
msgid ""
"Vaadin makes a separation between the appearance and component structure of "
"the user interface. While the UI logic is handled as Java code, the "
"presentation is defined in <emphasis>themes</emphasis> as CSS or Sass. "
"Vaadin provides a number of default themes. User themes can, in addition to "
"style sheets, include HTML templates that define custom layouts and other "
"resources, such as images and fonts. Themes are discussed in detail in <xref "
"linkend=\"themes\"/>."
msgstr ""
"Vaadin 将 UI 的组件结构与具体的表现分隔为不同的部分. UI 的逻辑由 Java 代码来"
"处理, 界面表现则定义在 <emphasis>theme</emphasis> 中, theme 使用 CSS 或 Sass "
"形式. Vaadin 提供了很多默认 theme. 用户自定义的 theme 除样式表(style sheet)"
"外, 还可以包含 HTML 模板, 用来定制 HTML 元素布局和其他资源, 比如图片, 字体. "
"关于 Theme 的详细介绍请参见 <xref linkend=\"themes\"/>."

#. Tag: term
#: chapter-architecture.xml:189
#, no-c-format
msgid "Events"
msgstr "事件"

#. Tag: primary
#: chapter-architecture.xml:192
#, no-c-format
msgid "events"
msgstr "事件"

#. Tag: para
#: chapter-architecture.xml:192
#, no-c-format
msgid ""
"Interaction with user interface components creates events, which are first "
"processed on the client-side by the widgets, then passed all the way through "
"the HTTP server, Vaadin servlet, and the user interface components to the "
"event listeners defined in the application. See <xref linkend=\"architecture."
"events\"/>."
msgstr ""
"用户与 UI 组件的交互将产生事件, 事件首先由客户端的 widget 处理, 然后依次传递"
"给 HTTP 服务器, Vaadin Servlet, UI 组件, 最后到达应用程序中指定的事件监听器. "
"详情参见 <xref linkend=\"architecture.events\"/>."

#. Tag: term
#: chapter-architecture.xml:204
#, no-c-format
msgid "Server Push"
msgstr "服务器端 PUSH"

#. Tag: primary
#: chapter-architecture.xml:207
#, no-c-format
msgid "server push"
msgstr "服务器端 PUSH"

#. Tag: para
#: chapter-architecture.xml:207
#, no-c-format
msgid ""
"In addition to the event-driven programming model, Vaadin supports server "
"push, where the UI changes are pushed directly from the server to the client "
"without a client request or an event. This makes it possible to update UIs "
"immediately from other threads and other UIs, without having to wait for a "
"request. See <xref linkend=\"advanced.push\"/>."
msgstr ""
"除服务器端开发模式外, Vaadin 还支持服务器端 PUSH 功能, UI 的变化可以从服务器"
"端直接 PUSH 到客户端, 而不必由客户端发起请求或发送事件来获得 UI 的更新信息. "
"这个功能使得我们可以从其他线程或其他 UI 中直接立即更新某个 UI, 而不必等待客户"
"端发起请求之后才刷新浏览器端的 UI. 详情参见 <xref linkend=\"advanced.push\"/"
">."

#. Tag: term
#: chapter-architecture.xml:220
#, no-c-format
msgid "<term>Data Binding</term>"
msgstr "<term>数据绑定</term>"

#. Tag: primary
#: chapter-architecture.xml:223
#, no-c-format
msgid "Data Model"
msgstr "数据模型"

#. Tag: primary
#: chapter-architecture.xml:224
#, no-c-format
msgid "<primary>Data Binding</primary>"
msgstr "<primary>数据绑定</primary>"

#. Tag: para
#: chapter-architecture.xml:224
#, no-c-format
msgid ""
"In addition to the user interface model, Vaadin provides a <emphasis>data "
"model</emphasis> for binding data presented in field components, such as "
"text fields, check boxes and selection components, to a data source. Using "
"the data model, the user interface components can update the application "
"data directly, often without the need for any control code. All the field "
"components in Vaadin use this data model internally, but any of them can be "
"bound to a separate data source as well. <indexterm><primary>SQL</primary></"
"indexterm> For example, you can bind a table component to an SQL query "
"response. For a complete overview of the Vaadin Data Model, please refer to "
"<xref linkend=\"datamodel\"/>."
msgstr ""
"除 UI 模型外, Vaadin 还提供了 <emphasis>数据模型</emphasis>, 用于将 Field 组"
"件 (比如文本框, 复选框, 单选框) 中展现的数据, 绑定到数据源上. 使用数据模型, "
"UI 组件可以直接更新应用程序数据, 通常不必编写任何控制代码. Vaadin 中所有 "
"Field 组件内部都使用这个数据模型, 当然它们也都可以任意绑定到不同类型的数据"
"源. 比如使用 <indexterm><primary>SQL</primary></indexterm> 数据源, 你可以绑定"
"一个 Table 组件到 SQL 查询结果上. Vaadin 数据模型的详细介绍, 请参见 <xref "
"linkend=\"datamodel\"/>."

#. Tag: term
#: chapter-architecture.xml:245
#, no-c-format
msgid "Client-Side Applications"
msgstr "客户端应用程序"

#. Tag: para
#: chapter-architecture.xml:247
#, no-c-format
msgid ""
"In addition to server-side web applications, Vaadin supports client-side "
"application modules, which run in the browser. Client-side modules can use "
"the same widgets, themes, and back-end services as server-side Vaadin "
"applications. They are useful when you have a need for highly responsive UI "
"logic, such as for games or for serving a large number of clients with "
"possibly stateless server-side code, and for various other purposes, such as "
"offering an off-line mode for server-side applications. Please see <xref "
"linkend=\"clientsideapp\"/> for further details."
msgstr ""
"除服务器端 Web 应用程序外, Vaadin 还支持客户端应用程序模块的开发. 客户端模块"
"将运行在浏览器内, 可以与服务器端应用程序一样, 使用相同的 widget, theme, 和后"
"端服务. 客户端模块主要用于开发高流畅度的 UI 逻辑, 比如游戏客户端, 或高并发量"
"客户端加无状态服务器端, 也可以用于其他场景, 比如为服务器端应用程序提供离线模"
"式功能. 详情请参见 <xref linkend=\"clientsideapp\"/>."

#. Tag: term
#: chapter-architecture.xml:263
#, no-c-format
msgid "Back-end"
msgstr "后端"

#. Tag: para
#: chapter-architecture.xml:265
#, no-c-format
msgid ""
"Vaadin is meant for building user interfaces, and it is recommended that "
"other application layers should be kept separate from the UI. The business "
"logic can run in the same servlet as the UI code, usually separated at least "
"by a Java API, possibly as EJBs, or distributed to a remote back-end "
"service. The data storage is usually distributed to a database management "
"system, and is typically accessed through a persistence solution, such as "
"JPA."
msgstr ""
"Vaadin 的主要目的是构建 UI, 我们建议应用程序的其他逻辑层应该与 UI 层分离开. "
"业务逻辑可以与 UI 代码运行在同一个 Servlet 内, 但至少要以 Java API 的形式分离"
"开, 或者使用 EJB 也可. 业务逻辑也可以以后端服务的方式分散到其他服务器上. 数据"
"存储通常分散到数据库系统中, 然后某种持久化方案来进行访问, 比如使用 JPA."

#. Tag: title
#: chapter-architecture.xml:282
#, no-c-format
msgid "Technological Background"
msgstr "技术背景"

#. Tag: para
#: chapter-architecture.xml:286
#, no-c-format
msgid ""
"This section provides an introduction to the various technologies and "
"designs, which Vaadin is based on. This knowledge is not necessary for using "
"Vaadin, but provides some background if you need to make low-level "
"extensions to Vaadin."
msgstr ""
"本节介绍 Vaadin 背后的一些技术背景和设计思路. 这些知识对于 Vaadin 的使用并非"
"必须的, 但如果你需要对 Vaadin 做一些底层扩充, 就非常有用了."

#. Tag: title
#: chapter-architecture.xml:295
#, no-c-format
msgid "HTML and JavaScript"
msgstr "HTML 和 JavaScript"

#. Tag: primary
#: chapter-architecture.xml:298
#, no-c-format
msgid "HTML"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:301 chapter-architecture.xml:388
#, no-c-format
msgid "JavaScript"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:304
#, no-c-format
msgid ""
"The World Wide Web, with all its websites and most of the web applications, "
"is based on the use of the Hypertext Markup Language (HTML). HTML defines "
"the structure and formatting of web pages, and allows inclusion of graphics "
"and other resources. It is based on a hierarchy of elements marked with "
"start and end tags, such as <literal>&lt;div&gt; ... &lt;/div&gt;</literal>. "
"Vaadin uses HTML version 5, although conservatively, to the extent supported "
"by the major browsers, and their currently most widely used versions."
msgstr ""
"World Wide Web 上所有的网站和大多数应用程序, 都是基于超文本标记语言 (HTML) 构"
"建的. HTML 定义了网页的构造和格式, 还可以在网页中包含图像和其他资源. HTML 由"
"元素(element)的阶层组成, 元素则由起始 tag 和结束 tag 来表示, 比如 "
"<literal>&lt;div&gt; ... &lt;/div&gt;</literal>. Vaadin 使用 HTML 5, 但 HTML "
"5 还没有被所有的浏览器完整地支持, 因此 Vaadin 很小心地只使用了 HTML 5 中主流"
"浏览器最常用版本目前支持的部分."

#. Tag: primary
#: chapter-architecture.xml:316 chapter-architecture.xml:391
#, no-c-format
msgid "<primary>DOM</primary>"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:316
#, no-c-format
msgid ""
"JavaScript, on the other hand, is a programming language for embedding "
"programs in HTML pages. JavaScript programs can manipulate a HTML page "
"through the Document Object Model (DOM) of the page. They can also handle "
"user interaction events. The Client-Side Engine of Vaadin and its client-"
"side widgets do exactly this, although it is actually programmed in Java, "
"which is compiled to JavaScript with the Vaadin Client Compiler."
msgstr ""
"JavaScript, 是一种嵌入到 HTML 页面中的编程语言. JavaScript 程序可以通过页面的"
"文档对象模型 (DOM) 操纵 HTML 页面的内容. 也可以处理用户交互事件. Vaadin 的客"
"户端引擎和客户端 widget 所做的工作正是如此, 虽然它们其实是用 Java 开发的, 但"
"它们被 Vaadin Client Compiler 编译为 JavaScript 代码."

#. Tag: para
#: chapter-architecture.xml:326
#, no-c-format
msgid ""
"Vaadin largely hides the use of HTML, allowing you to concentrate on the UI "
"component structure and logic. In server-side development, the UI is "
"developed in Java using UI components and rendered by the client-side engine "
"as HTML, but it is possible to use HTML templates for defining the layout, "
"as well as HTML formatting in many text elements. Also when developing "
"client-side widgets and UIs, the built-in widgets in the framework hide most "
"of HTML DOM manipulation."
msgstr ""
"Vaadin 隐藏了 HTML 的使用细节, 因此你可以专注于 UI 组件的结构和控制逻辑. 在服"
"务器端开发中, UI 用 Java 语言使用 UI 组件来开发, 然后被客户端引擎展现为 HTML "
"形式, 但也可以使用 HTML 模板来定义 HTML 元素的结构和格式. 开发客户端 widget "
"和 UI 时, Vaadin 内建的 widget 同样隐藏了操纵 HTML DOM 的大部分细节."

#. Tag: title
#: chapter-architecture.xml:338
#, no-c-format
msgid "Styling with CSS and Sass"
msgstr "使用 CSS 和 Sass 控制样式"

#. Tag: para
#: chapter-architecture.xml:347
#, no-c-format
msgid ""
"While HTML defines the content and structure of a web page, "
"<emphasis>Cascading Style Sheet</emphasis> (CSS) is a language for defining "
"the visual style, such as colors, text sizes, and margins. CSS is based on a "
"set of rules that are matched with the HTML structure by the browser. The "
"properties defined in the rules determine the visual appearance of the "
"matching HTML elements."
msgstr ""
"HTML 定义了 Web 页面的内容和结构, <emphasis>层叠样式表</emphasis> (CSS) 则是"
"一种语言用来定义页面的显示风格, 比如颜色, 文字大小, 留白尺寸. CSS 基于一组规"
"则, 浏览器将这些规则匹配到 HTML 元素结构上. CSS 规则中的定义的各种属性决定了"
"与规则匹配的 HTML 元素的视觉表现."

#. Tag: programlisting
#: chapter-architecture.xml:356
#, no-c-format
msgid ""
"<![CDATA[/* Define the color of labels in my view */\n"
".myview .v-label {\n"
"  color: blue;\n"
"}]]>"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:359
#, no-c-format
msgid "SCSS"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:360
#, no-c-format
msgid "CSS3"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:360
#, no-c-format
msgid ""
"<emphasis>Sass</emphasis>, or <emphasis>Syntactically Awesome Stylesheets</"
"emphasis>, is an extension of the CSS language, which allows the use of "
"variables, nesting, and many other syntactic features that make the use of "
"CSS easier and clearer. Sass has two alternative formats, SCSS, which is a "
"superset of the syntax of CSS3, and an older indented syntax, which is more "
"concise. The Vaadin Sass compiler supports the SCSS syntax."
msgstr ""
"<emphasis>Sass</emphasis>, 全称 <emphasis>优良语法样式表(Syntactically "
"Awesome Stylesheets)</emphasis>, 是 CSS 语言的扩展, 允许使用变量, 嵌套, 以及"
"其他各种语法特性, 使得对 CSS 的使用更加简便, 更加清晰. Sass 有两种格式, 一种"
"是 SCSS 格式, 是 CSS3 语法的超集, 另一种是SASS格式, 是更为简单一些的老式的缩"
"进式语法, Vaadin 的 Sass 编译器支持的是 SCSS 语法."

#. Tag: primary
#: chapter-architecture.xml:371
#, no-c-format
msgid "themes"
msgstr "theme"

#. Tag: para
#: chapter-architecture.xml:371
#, no-c-format
msgid ""
"Vaadin handles styling with <emphasis>themes</emphasis> defined with CSS or "
"Sass, and associated images, fonts, and other resources. Vaadin themes are "
"specifically written in Sass. In development mode, Sass files are compiled "
"automatically to CSS. For production use, you compile the Sass files to CSS "
"with the included compiler. The use of themes is documented in detail in "
"<xref linkend=\"themes\"/>, which also gives an introduction to CSS and Sass."
msgstr ""
"Vaadin 管理页面元素样式时, 使用 CSS 或 Sass 定义的 <emphasis>theme</"
"emphasis>, 以及与 theme 相关联的图像, 字体, 和其他资源. Vaadin 的 theme 使用 "
"Sass 来书写. 开发模式下, Sass 文件会被自动编译为 CSS. 生产环境下, 你可以使用 "
"Vaadin 附带的编译器将 Sass 文件编译为 CSS. theme 使用方法的详细说明请参见 "
"<xref linkend=\"themes\"/>, 这一章还介绍了 CSS 和 Sass."

#. Tag: title
#: chapter-architecture.xml:384
#, no-c-format
msgid "<title>AJAX</title>"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:386
#, no-c-format
msgid "<primary>AJAX</primary>"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:387
#, no-c-format
msgid "<primary>XML</primary>"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:389
#, no-c-format
msgid "HTML 5"
msgstr ""

#. Tag: primary
#: chapter-architecture.xml:392
#, no-c-format
msgid "XMLHttpRequest"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:392
#, no-c-format
msgid ""
"AJAX, short for Asynchronous JavaScript and XML, is a technique for "
"developing web applications with responsive user interaction, similar to "
"traditional desktop applications. Conventional web applications, be they "
"JavaScript-enabled or not, can get new page content from the server only by "
"loading an entire new page. AJAX-enabled pages, on the other hand, handle "
"the user interaction in JavaScript, send a request to the server "
"asynchronously (without reloading the page), receive updated content in the "
"response, and modify the page accordingly. This way, only small parts of the "
"page data need to be loaded. This goal is archieved by the use of a certain "
"set of technologies: HTML, CSS, DOM, JavaScript, and the XMLHttpRequest API "
"in JavaScript. XML is just one way to serialize data between the client and "
"the server, and in Vaadin it is serialized with the more efficient JSON."
msgstr ""
"AJAX, 全称是异步JavaScript与XML技术(Asynchronous JavaScript and XML), 常用来"
"开发具有高度交互性 UI 的 Web 应用程序, 这类 Web 应用程序的 UI 类似于传统的桌"
"面应用程序. 传统的 Web 应用程序, 不论有没有 JavaScript 支持, 要从服务器得到新"
"的页面内容时只能装载整个全新的页面. 带有 AJAX 支持的页面则不同, 它使用 "
"JavaScript 来处理用户交互, 向服务器发送异步的请求(不会重装载整个页面), 通过服"
"务器的应答得到更新后的内容, 然后根据新内容修改页面内相应的部分. 通过这种方"
"式, 只有页面中的一小部分数据需要重新装载. 上述目的是通过使用以下几种技术实现"
"的: HTML, CSS, DOM, JavaScript, 以及 JavaScript 的 XMLHttpRequest API. XML 只"
"是客户端与服务器端之间序列化数据的其中一种方法, 在 Vaadin 中, 数据的序列化使"
"用更高效的 JSON 方式."

#. Tag: para
#: chapter-architecture.xml:410
#, no-c-format
msgid ""
"The asynchronous requests used in AJAX are made possible by the "
"<methodname>XMLHttpRequest</methodname> class in JavaScript. The API feature "
"is available in all major browsers and is under way to become a W3C standard."
msgstr ""
"AJAX 使用的异步请求由 JavaScript 中的 <methodname>XMLHttpRequest</"
"methodname> 类实现. 这个 API 在所有的主流浏览器中都是可用的, 而且它即将成为 "
"W3C 标准."

#. Tag: para
#: chapter-architecture.xml:417
#, no-c-format
msgid ""
"The communication of complex data between the browser and the server "
"requires some sort of <emphasis>serialization</emphasis> (or "
"<emphasis>marshalling</emphasis>) of data objects. The Vaadin servlet and "
"the client-side engine handle the serialization of shared state objects from "
"the server-side components to the client-side widgets, as well as "
"serialization of RPC calls between the widgets and the server-side "
"components."
msgstr ""
"在浏览器与服务器之间传递复杂数据需要将数据对象 <emphasis>序列化"
"(serialization)</emphasis> (或者叫 <emphasis>汇集(marshalling)</emphasis>). "
"Vaadin Servlet 和客户端引擎会将共享的状态对象从服务器端组件序列化到客户端, 同"
"时也会处理 widget 与服务器端组件之间的远程过程调用(RPC)的序列化问题."

#. Tag: title
#: chapter-architecture.xml:429
#, no-c-format
msgid "<title>Google Web Toolkit</title>"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:432
#, no-c-format
msgid ""
"The client-side framework of Vaadin is based on the Google Web Toolkit "
"(GWT). Its purpose is to make it possible to develop web user interfaces "
"that run in the browser easily with Java instead of JavaScript. Client-side "
"modules are developed with Java and compiled into JavaScript with the Vaadin "
"Compiler, which is an extension of the GWT Compiler. The client-side "
"framework also hides much of the HTML DOM manipulation and enables handling "
"browser events in Java."
msgstr ""
"Vaadin 的客户端框架构建在 Google Web Toolkit (GWT) 的基础之上. 它的目的是帮助"
"程序员使用 Java 语言便利地开发浏览器内运行的 Web UI, 而不是使用 JavaScript. "
"客户端模块用 Java 语言开发然后由 Vaadin Compiler 编译为 JavaScript , Vaadin "
"Compiler 是 GWT Compiler 的扩展. 客户端框架还隐藏了很多 HTML DOM 操纵的细节, "
"还运行我们用 Java 语言来处理浏览器端的各种事件."

#. Tag: para
#: chapter-architecture.xml:443
#, no-c-format
msgid ""
"GWT is essentially a client-side technology, normally used to develop user "
"interface logic in the web browser. Pure client-side modules still need to "
"communicate with a server using RPC calls and by serializing any data. The "
"server-driven development mode in Vaadin effectively hides all the client-"
"server communications and allows handling user interaction logic in a server-"
"side application. This makes the architecture of an AJAX-based web "
"application much simpler. Nevertheless, Vaadin also allows developing pure "
"client-side applications, as described in <xref linkend=\"clientsideapp\"/>."
msgstr ""
"GWT 本质上是一种客户端技术, 通常用于开发 Web 浏览器端的 UI 逻辑. 纯客户端模块"
"仍然需要与服务器通信, 方法是使用 RPC 调用, 并序列化需要的数据. Vaadin 的服务"
"器端开发非常有效地隐藏了客户端和服务器端之间的所有通信细节, 并允许我们在服务"
"器端应用程序内处理 UI 逻辑. 这就使得基于 AJAX 的 Web 应用程序的架构变得简单得"
"多. 当然, Vaadin 仍然可以开发纯客户端应用程序, 详情参见 <xref linkend="
"\"clientsideapp\"/>."

#. Tag: para
#: chapter-architecture.xml:455
#, no-c-format
msgid ""
"See <xref linkend=\"architecture.client-side\"/> for a description of how "
"the client-side framework based on GWT is used in the Client-Side Engine of "
"Vaadin. <xref linkend=\"clientside\"/> provides information about the client-"
"side development, and <xref linkend=\"gwt\"/> about the integration of "
"client-side widgets with the server-side components."
msgstr ""
"Vaadin 的客户端引擎是如何使用基于 GWT 的客户端框架的, 详情请参见 <xref "
"linkend=\"architecture.client-side\"/>. 关于客户端开发, 请参见 <xref linkend="
"\"clientside\"/>, 关于客户端 widget 与服务器端组件的集成, 请参见 <xref "
"linkend=\"gwt\"/>."

#. Tag: title
#: chapter-architecture.xml:465
#, no-c-format
msgid "Java Servlets"
msgstr "Java Servlet"

#. Tag: para
#: chapter-architecture.xml:467
#, no-c-format
msgid ""
"A Java Servlet is a class that is executed in a Java web server (a "
"<emphasis>Servlet container</emphasis>) to extend the capabilities of the "
"server. In practice, it is normally a part of a <emphasis>web application</"
"emphasis>, which can contain HTML pages to provide static content, and "
"JavaServer Pages (JSP) and Java Servlets to provide dynamic content. This is "
"illustrated in <xref linkend=\"figure.architecture.technology.servlet\"/>."
msgstr ""
"Java Servlet 是一个类, 运行在 Java Web 服务器内(也叫 <emphasis>Servlet 容器</"
"emphasis>), 用于为服务器扩展新的功能. 实际运用中, Java Servlet 通常是 "
"<emphasis>Web 应用程序</emphasis> 的一部分, Web 应用程序中可以包含 HTML 页面"
"来提供静态内容, 还可以包含 JavaServer Page (JSP) 和 Java Servlet 来提供动态内"
"容. 详情参见 <xref linkend=\"figure.architecture.technology.servlet\"/>."

#. Tag: title
#: chapter-architecture.xml:478
#, no-c-format
msgid "Java Web Applications and Servlets"
msgstr "Java Web 应用程序和 Servlet"

#. Tag: para
#: chapter-architecture.xml:489
#, no-c-format
msgid ""
"Web applications are usually packaged and deployed to a server as "
"<emphasis>WAR</emphasis> (<emphasis>Web application ARchive</emphasis>) "
"files, which are Java JAR packages, which in turn are ZIP compressed "
"packages. The web application is defined in a <filename>WEB-INF/web.xml</"
"filename> deployment descriptor, which defines the servlet classes and also "
"the mappings from request URL paths to the servlets. This is described in "
"more detail in <xref linkend=\"application.environment.web-xml\"/>. The "
"class path for the servlets and their dependencies includes the "
"<filename>WEB-INF/classes</filename> and <filename>WEB-INF/lib</filename> "
"folders. The <filename>WEB-INF</filename> is a special hidden folder that "
"can not be accessed by its URL path."
msgstr ""
"Web 应用程序部署到服务器上之前, 通常需要打包为 <emphasis>WAR</emphasis> "
"(<emphasis>Web application ARchive</emphasis>) 文件形式, WAR 也是 Java JAR 文"
"件格式, JAR 文件实际上是一种 ZIP 压缩后的包. Web 应用程序通过部署描述文件 "
"<filename>WEB-INF/web.xml</filename> 来定义, 部署描述文件定义了 Servlet 类, "
"以及客户端请求的 URL 路径与各个 Servlet 之间的对应关系. 详情参见 <xref "
"linkend=\"application.environment.web-xml\"/>. Servlet 以及它依赖的其他类的查"
"找路径包括 <filename>WEB-INF/classes</filename> 和 <filename>WEB-INF/lib</"
"filename> 文件夹. <filename>WEB-INF</filename> 是一个特殊的隐藏文件夹, 它将无"
"法从外部以 URL 路径地方式访问."

#. Tag: para
#: chapter-architecture.xml:504
#, no-c-format
msgid ""
"The servlets are Java classes that handle HTTP requests passed to them by "
"the server through the <emphasis>Java Servlet API</emphasis>. They can "
"generate HTML or other content as a response. JSP pages, on the other hand, "
"are HTML pages, which allow including Java source code embedded in the "
"pages. They are actually translated to Java source files by the container "
"and then compiled to servlets."
msgstr ""
"Servlet 是 Java 类, 它处理服务器通过 <emphasis>Java Servlet API</emphasis> 传"
"递给它的 HTTP 请求. Servlet 可以通过应答的方式产生 HTML 或其他类型的内容. "
"JSP 页面则是 HTML 页面, 其中允许嵌入 Java 源代码. 实际上 Servlet 容器会将 "
"JSP 转换为等价的 Java 源文件, 然后编译为Servlet."

#. Tag: para
#: chapter-architecture.xml:513
#, no-c-format
msgid ""
"The UIs of server-side Vaadin applications run as servlets. They are wrapped "
"inside a <classname>VaadinServlet</classname> servlet class, which handles "
"session tracking and other tasks. On the initial request, it returns an HTML "
"loader page and then mostly JSON responses to synchronize the widgets and "
"their server-side counterparts. It also serves various resources, such as "
"themes. The server-side UIs are implemented as classes extending the "
"<classname>UI</classname> class, as described in <xref linkend=\"application"
"\"/>. The class is given as a parameter to the Vaadin Servlet in the "
"<filename>web.xml</filename> deployment descriptor."
msgstr ""
"服务器端 Vaadin 应用程序的 UI 以 Servlet 的形式运行. UI 被包裹在 "
"<classname>VaadinServlet</classname> Servlet 类之内, VaadinServlet 会处理 "
"session 追踪以及其他一些任务. 在最初的客户端请求发生时, 它会返回一个 HTML 装"
"载页, 以及大部分 JSON 应答, 用于 同步 widget 及与 widget 对应的服务器端组件. "
"它还会对外提供各种资源, 比如 theme. 服务器端 UI 以从 <classname>UI</"
"classname> 继承的类的形式实现 , 详情参见 <xref linkend=\"application\"/>. 在"
"部署描述文件 <filename>web.xml</filename> 中, UI 类将以参数的形式传递给 "
"Vaadin Servlet."

#. Tag: para
#: chapter-architecture.xml:525
#, no-c-format
msgid ""
"The Vaadin Client-Side Engine as well as client-side Vaadin applications are "
"loaded to the browser as static JavaScript files. The client-side engine, or "
"widget set in technical terms, needs to be located under the "
"<filename>VAADIN/widgetsets</filename> path in the web application. The "
"precompiled default widget set is served from the <filename>vaadin-client-"
"compiled</filename> JAR by the Vaadin Servlet."
msgstr ""
"Vaadin 客户端引擎和客户端 Vaadin 应用程序都以静态 JavaScript 的形式装载到浏览"
"器中. 客户端引擎, 用技术上术语的术语来说也可以叫做 Widget 群, 需要位于 Web 应"
"用程序的 <filename>VAADIN/widgetsets</filename> 路径下. 预编译的默认 Widget "
"群位于 <filename>vaadin-client-compiled</filename> JAR 包中, 由 Vaadin "
"Servlet 向外提供."

#. Tag: title
#: chapter-architecture.xml:537
#, no-c-format
msgid "<title>Client-Side Engine</title>"
msgstr "<title>客户端引擎</title>"

#. Tag: para
#: chapter-architecture.xml:540
#, no-c-format
msgid ""
"The user interface of a server-side Vaadin application is rendered in the "
"browser by the Vaadin Client-Side Engine. It is loaded in the browser when "
"the page with the Vaadin UI is opened. The server-side UI components are "
"rendered using <emphasis>widgets</emphasis> (as they are called in Google "
"Web Toolkit) on the client-side. The client-side engine is illustrated in "
"<xref linkend=\"figure.architecture.client-side\"/>."
msgstr ""
"服务器端 Vaadin 应用程序的 UI 由 Vaadin 客户端引擎展现在浏览器中. 当包含 "
"Vaadin UI 的页面在浏览器中打开时, Vaadin 客户端引擎就被装载进浏览器了. 服务器"
"端 UI 组件在客户端的展现由 <emphasis>widget</emphasis>(与 Google Web Toolkit "
"中的术语一样) 负责. 客户端引擎的架构参见 <xref linkend=\"figure.architecture."
"client-side\"/>."

#. Tag: title
#: chapter-architecture.xml:551
#, no-c-format
msgid "Vaadin Client-Side Engine"
msgstr "Vaadin 客户端引擎"

#. Tag: para
#: chapter-architecture.xml:562
#, no-c-format
msgid ""
"The client-side framework includes two kinds of built-in widgets: GWT "
"widgets and Vaadin-specific widgets. The two widget collections have "
"significant overlap, where the Vaadin widgets provide a bit different "
"features than the GWT widgets. In addition, many add-on widgets and their "
"server-side counterparts exist, and you can easily download and install "
"them, as described in <xref linkend=\"addons\"/>. You can also develop your "
"own widgets, as described in <xref linkend=\"clientside\"/>."
msgstr ""
"客户端框剪包含两种内建的 Widget: GWT widget 和 Vaadin 特有的 widget. 两种 "
"widget 的内容有很大的重叠, 但 Vaadin widget 提供的功能与 GWT widget 略有不"
"同. 此外, 还存在大量的 widget 插件及其服务器端对用组件, 你可以很容易地下载并"
"安装它们, 详情参见 <xref linkend=\"addons\"/>. 你也可以开发自己的 widget, 详"
"情参见 <xref linkend=\"clientside\"/>."

#. Tag: para
#: chapter-architecture.xml:572
#, no-c-format
msgid ""
"The rendering with widgets, as well as the communication to the server-side, "
"is handled in the <classname>ApplicationConnection</classname>. Connecting "
"the widgets with their server-side counterparts is done in "
"<emphasis>connectors</emphasis>, and there is one for each widget that has a "
"server-side counterpart. The framework handles serialization of component "
"state transparently, and includes an RPC mechanism between the two sides. "
"Integration of widgets with their server-side counterpart components is "
"described in <xref linkend=\"gwt\"/>."
msgstr ""
"通过 Widget 展现 UI 组件, 以及与服务器端通信, 由 "
"<classname>ApplicationConnection</classname> 类负责处理. 由 "
"<emphasis>connector</emphasis> 负责将 Widget 与它对应的服务器端组件连接在一"
"起, 对每一个拥有服务器端对应组件的客户端 widget 来说, 都存在一个 connector. "
"框架负责组件状态数据的序列化, 并且在客户端与服务器端两端都包含 RPC 机制. 如何"
"集成 Widget 与其服务器端对应组件, 详情参见 <xref linkend=\"gwt\"/>."

#. Tag: title
#: chapter-architecture.xml:585
#, no-c-format
msgid "Events and Listeners"
msgstr "事件和监听器"

#. Tag: para
#: chapter-architecture.xml:587
#, no-c-format
msgid ""
"Vaadin offers an event-driven programming model for handling user "
"interaction. When a user does something in the user interface, such as "
"clicks a button or selects an item, the application needs to know about it. "
"Many Java-based user interface frameworks follow the <emphasis>Event-"
"Listener pattern</emphasis> (also known as the Observer design pattern) to "
"communicate user input to the application logic. So does Vaadin. The design "
"pattern involves two kinds of elements: an object that generates (\"fires\" "
"or \"emits\") events and a number of listeners that listen for the events. "
"When such an event occurs, the object sends a notification about it to all "
"the listeners. In a typical case, there is only one listener."
msgstr ""
"Vaadin 提供了一种事件驱动的编程模型, 用于处理用户交互. 当用户在 UI 中执行了某"
"种操作, 比如点击按钮, 或选择一个数据项, 应用程序需要意识到这种用户操作. 很多"
"基于 Java 的 UI 开发框架都遵循 <emphasis>事件/监听器设计模式</emphasis> (也"
"叫 观察者(Observer) 设计模式), 用于将用户操作与应用程序逻辑之间的沟通. "
"Vaadin 也使用同样的思路. 这种设计模式包含两个元素: 一个对象负责产生(或者叫 "
"\"激发\" 或 \"发起\") 事件, 以及复数个监听器负责监听事件. 当事件发生时, 对象"
"负责向所有的监听器发送事件通知. 对于一个事件, 通常情况下只有一个监听器."

#. Tag: para
#: chapter-architecture.xml:600
#, no-c-format
msgid ""
"Events can serve many kinds of purposes. In Vaadin, the usual purpose of "
"events is handling user interaction in a user interface. Session management "
"can require special events, such as time-out, in which case the event would "
"actually be the lack of user interaction. Time-out is a special case of "
"timed or scheduled events, where an event occurs at a specific date and time "
"or when a set time has passed."
msgstr ""
"事件可以用来实现很多种目的. 在 Vaadin 中, 事件通常用于处理用户在 UI 中的操"
"作. Session 管理可能需要用到特别的事件, 比如超时事件, 这种情况下事件其实与用"
"户操作无关. 超时是定时事件的一种特殊情况, 定时事件是指在某个特定的日期/时刻发"
"生的事件, 或者某段特定长度的时间流逝之后发生的事件."

#. Tag: para
#: chapter-architecture.xml:609
#, no-c-format
msgid ""
"To receive events of a particular type, an application must register a "
"listener object with the event source. The listeners are registered in the "
"components with an <methodname>add*Listener()</methodname> method (with a "
"method name specific to the listener)."
msgstr ""
"要接受某种特定类型的事件, 应用程序必须向事件的发生源注册监听器对象. 监听器使"
"用 <methodname>add*Listener()</methodname> 方法注册到组件上 (方法名与具体的监"
"听器类型一一对应)."

#. Tag: para
#: chapter-architecture.xml:616
#, no-c-format
msgid ""
"Most components that have related events define their own event class and "
"the corresponding listener class. For example, the <classname>Button</"
"classname> has <classname>Button.ClickEvent</classname> events, which can be "
"listened to through the <classname>Button.ClickListener</classname> "
"interface."
msgstr ""
"大多数与事件有关的组件都定义了它们独有的事件类, 以及与事件对应的监听器类. 比"
"如, the <classname>Button</classname> 的事件是 <classname>Button.ClickEvent</"
"classname> , 这个事件由 <classname>Button.ClickListener</classname> 监听器负"
"责监听."

#. Tag: para
#: chapter-architecture.xml:623
#, no-c-format
msgid ""
"In the following, we handle button clicks with a listener implemented as an "
"anonymous class:"
msgstr ""
"下面, 我们使用一个由匿名类 (anonymous class) 实现的监听器来处理按钮的点击事"
"件:"

#. Tag: programlisting
#: chapter-architecture.xml:628
#, no-c-format
msgid ""
"<![CDATA[final Button button = new Button(\"Push it!\");\n"
"\n"
"button.addClickListener(new Button.ClickListener() {\n"
"    public void buttonClick(ClickEvent event) {\n"
"        button.setCaption(\"You pushed it!\");\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-architecture.xml:630
#, no-c-format
msgid ""
"illustrates the case where an application-specific class inherits the "
"<classname>Button.ClickListener</classname> interface to be able to listen "
"for button click events. The application must instantiate the listener class "
"and register it with <methodname>addClickListener()</methodname>. It can be "
"an anonymous class, such as the one above. When an event occurs, an event "
"object is instantiated, in this case a <classname>Button.ClickEvent</"
"classname>. The event object knows the related UI component, in this case "
"the <classname>Button</classname>."
msgstr ""
"展示了一个应用程序专有的类继承自 <classname>Button.ClickListener</classname> "
"接口, 监听按钮的点击事件. 应用程序必须创建监听器类的示例, 然后使用 "
"<methodname>addClickListener()</methodname> 方法注册它. 监听器可以是匿名类, "
"就象上面的例子那样. 当事件发生时, 事件对象将被初始化好, 在上例中是 "
"<classname>Button.ClickEvent</classname> 对象. 事件对象知道与自己相关的 UI 组"
"件是谁, 在上例中是 <classname>Button</classname> 对象."

#. Tag: title
#: chapter-architecture.xml:644
#, no-c-format
msgid "Class Diagram of a Button Click Listener"
msgstr "按钮点击事件监听器的类结构图"

#. Tag: para
#: chapter-architecture.xml:655
#, no-c-format
msgid ""
"In the ancient times of C programming, <emphasis>callback functions</"
"emphasis> filled largely the same need as listeners do now. In object-"
"oriented languages, we usually only have classes and methods, not functions, "
"so the application has to give a class interface instead of a callback "
"function pointer to the framework."
msgstr ""
"今天的监听器的大部分功能, 在古老的 C 编程时代, 由 <emphasis>回调函数"
"(callback function)</emphasis> 实现. 在面向对象语言中, 我们通常只有类和方法可"
"用, 而没有函数的概念, 因此应用程序必须向开发框架提供一个类接口, 而不再是回调"
"函数指针."

#. Tag: para
#: chapter-architecture.xml:663
#, no-c-format
msgid "goes into details of handling events in practice."
msgstr "详细讲解事件处理的更多实例."
