# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-11-10 11:57+0000\n"
"PO-Revision-Date: 2014-11-10 20:59+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-mobile.xml:11
#, no-c-format
msgid "Mobile Applications with TouchKit"
msgstr "使用 TouchKit 创建移动设备应用程序"

#. Tag: primary
#: chapter-mobile.xml:14
#, no-c-format
msgid "TouchKit"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:17
#, no-c-format
msgid ""
"This chapter describes how to create mobile applications using the Vaadin "
"TouchKit."
msgstr "本章介绍如何使用 Vaadin TouchKit 创建移动设备应用程序."

#. Tag: title
#: chapter-mobile.xml:22
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-mobile.xml:24
#, no-c-format
msgid ""
"Web browsing is becoming ever increasingly mobile and web applications need "
"to satisfy users with both desktop computers and mobile devices, such as "
"phones and tablets. While the mobile browsers can show the pages just like "
"in regular browsers, the screen size, finger accuracy, and mobile browser "
"features need to be considered to make the experience more pleasant. Vaadin "
"TouchKit gives the power of Vaadin for creating mobile user interfaces that "
"complement the regular web user interfaces of your applications. Just like "
"the purpose of the Vaadin Framework is to make desktop-like web "
"applications, the purpose of TouchKit is to allow creation of web "
"applications that give the look and feel of native mobile applications."
msgstr ""
"移动设备上的 Web 浏览正在显著增加, Web 应用程序必须同时满足桌面计算机用户和移"
"动设备用户的需求, 比如手机和平板用户. 虽然移动设备浏览器可以象通常的浏览器一"
"样显示页面, 但为了使得用户体验更加舒适, 还应该注意屏幕尺寸, 手指触碰的精确"
"性, 以及移动设备浏览器中其他应该考虑的因素. 在 Vaadin 创建通常 Web UI 的能力"
"之外, Vaadin TouchKit 还为 Vaadin 添加了创建移动设备 UI 的能力. Vaadin "
"Framework 的目的是创建类似桌面程序的 Web 应用程序, 与此类似, TouchKit 的目的"
"是创建外观与本地移动设备应用程序类似的 Web 应用程序."

#. Tag: title
#: chapter-mobile.xml:38
#, no-c-format
msgid "The Parking Demo for Vaadin TouchKit"
msgstr "Vaadin TouchKit 的 Parking 示例程序"

#. Tag: para
#: chapter-mobile.xml:49
#, no-c-format
msgid ""
"Creating a mobile UI is much like creating a regular Vaadin UI. You can use "
"all the regular Vaadin components and add-ons available from Vaadin "
"Directory, but most importantly, you can use the special TouchKit components "
"that are optimized for mobile devices."
msgstr ""
"创建移动设备 UI 与创建通常的 Vaadin UI 很类似. 你可以使用所有通常的 Vaadin 组"
"件和 Vaadin Directory 中的所有 add-on, 但最重要的, 你可以使用针对移动设备优化"
"过的 TouchKit 组件."

#. Tag: programlisting
#: chapter-mobile.xml:56
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Theme(\"mobiletheme\")\n"
"@Widgetset(\"com.example.myapp.MyAppWidgetSet\")\n"
"@Title(\"My Mobile App\")\n"
"public class SimplePhoneUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        // Define a view\n"
"        class MyView extends NavigationView {\n"
"            public MyView() {\n"
"                super(\"Planet Details\");\n"
"\n"
"                CssLayout content = new CssLayout();\n"
"                setContent(content);\n"
"\n"
"                VerticalComponentGroup group =\n"
"                        new VerticalComponentGroup();\n"
"                content.addComponent(group);\n"
"\n"
"                group.addComponent(new TextField(\"Planet\"));\n"
"                group.addComponent(new NumberField(\"Found\"));\n"
"                group.addComponent(new Switch(\"Probed\"));\n"
"\n"
"                setRightComponent(new Button(\"OK\"));\n"
"            }\n"
"        }\n"
"\n"
"        // Use it as the content root\n"
"        setContent(new MyView());\n"
"    }\n"
"    ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:58
#, no-c-format
msgid ""
"The above example omits the definition of the servlet class, does not have "
"any UI logic yet, and you would normally implement some views, etc. The "
"resulting UI is shown in <xref linkend=\"figure.mobile.overview.example\"/>."
msgstr ""
"上例省略了 Servlet 类的定义, 也没有任何 UI 逻辑代码, 还省略了通常需要实现的视"
"图, 等等. UI 的运行结果见 <xref linkend=\"figure.mobile.overview.example\"/>."

#. Tag: title
#: chapter-mobile.xml:65
#, no-c-format
msgid "Simple TouchKit UI"
msgstr "简单的 TouchKit UI"

#. Tag: para
#: chapter-mobile.xml:73
#, no-c-format
msgid ""
"TouchKit supports many special mobile browser features, such as geolocation, "
"context-specific input fields, and home screen launching. On iOS, special "
"features such as splash screen and web app mode are supported."
msgstr ""
"TouchKit 支持移动设备浏览器的很多特殊功能, 比如地理位置, 上下文相关的输入 "
"Field, 以及返回 Home 界面. 在 iOS 上, 还支持 Splash 画面和 Web 应用程序模式."

#. Tag: para
#: chapter-mobile.xml:79
#, no-c-format
msgid ""
"In addition to developing regular server-side UIs, TouchKit allows a special "
"<emphasis>offline mode</emphasis>, which is a client-side Vaadin UI that is "
"stored in the browser cache and switched to automatically when the network "
"connection is not available, either when starting the application or while "
"using it. For more information, see <xref linkend=\"mobile.offline\"/>."
msgstr ""
"除了开发通常的服务器端 UI 之外, TouchKit 还支持特殊的 <emphasis>离线模式"
"(offline mode)</emphasis>, 这是一种客户端 Vaadin UI, 保存在浏览器缓存中. 无论"
"是在启动应用程序时, 还是在使用途中, 当网络连接不可用时, 都会自动切换到离线模"
"式. 详情请参见 <xref linkend=\"mobile.offline\"/>."

#. Tag: para
#: chapter-mobile.xml:87
#, no-c-format
msgid ""
"In this chapter, we first consider some special aspects of mobile browsing. "
"Then, we look how to create a project that uses TouchKit. TouchKit offers a "
"number of specialized mobile components, which are described in a dedicated "
"section. We treat phone and tablet applications separately, and discuss "
"testing briefly."
msgstr ""
"本章中, 我们首先考虑移动设备浏览中的一些特殊问题. 然后, 我们再讨论如何使用 "
"TouchKit 创建一个工程. TouchKit 提供了很多特殊的移动设备 UI 组件, 详情将在后"
"面的小节中介绍. 我们会将手机和平板应用程序区别对待, 还将简要地讨论测试问题."

#. Tag: title
#: chapter-mobile.xml:96
#, no-c-format
msgid "TouchKit Demos"
msgstr "TouchKit 示例"

#. Tag: para
#: chapter-mobile.xml:98
#, no-c-format
msgid ""
"The Parking Demo showcases the most important TouchKit features for a mobile "
"location-based business application. The app itself is for helping parking "
"enforcement officers write parking tickets on the streets. It uses "
"geolocation, image acquisition from the camera of the mobile device, map "
"navigation, data visualization with Vaadin Charts, and dynamic UIs with "
"responsive layouts. You can try it out at <link xlink:href=\"http://demo."
"vaadin.com/parking\">http://demo.vaadin.com/parking</link>. See <xref "
"linkend=\"mobile.installation.parking-demo\"/> for instructions for "
"importing the project in Eclipse. <phrase condition=\"web\">The <link xlink:"
"href=\"https://github.com/vaadin/parking-demo\">source code is available and "
"browseable at Github</link>.</phrase>"
msgstr ""
"Parking 实例程序演示了基于地理位置的移动设备商业应用程序中 TouchKit 最重要的"
"功能. 这个应用程序的目的是帮助执法人员在街边开违章处罚单. 它使用的功能包括地"
"理位置功能, 通过移动设备摄像头获取图像, 地图导航, 通过 Vaadin Chart 可视化表"
"示数据, 以及由条件式布局实现的动态 UI. 你可以在以下地址试用这个程序: <link "
"xlink:href=\"http://demo.vaadin.com/parking\">http://demo.vaadin.com/"
"parking</link>. 关于如何将这个工程导入到 Eclipse 内, 请参见 <xref linkend="
"\"mobile.installation.parking-demo\"/>. <phrase condition=\"web\"><link "
"xlink:href=\"https://github.com/vaadin/parking-demo\">通过 Github 可以浏览或"
"下载它的源代码</link>.</phrase>"

#. Tag: para
#: chapter-mobile.xml:114
#, no-c-format
msgid ""
"Mobile Mail is another demo application, which shows how to implement "
"browsing of deep category trees and make forms. You can try it out at <link "
"xlink:href=\"http://demo.vaadin.com/mobilemail\">http://demo.vaadin.com/"
"mobilemail</link>. <phrase condition=\"web\">You can <link xlink:href="
"\"https://github.com/vaadin/mobilemail-demo\">browse the source code</link> "
"of the demo at Github.</phrase>"
msgstr ""
"另一个示例应用程序是 Mobile Mail, 它演示了如何实现深度分类目录树(category "
"tree), 以及如何创建 Form. 你可以在以下地址试用这个程序: <link xlink:href="
"\"http://demo.vaadin.com/mobilemail\">http://demo.vaadin.com/mobilemail</"
"link>. <phrase condition=\"web\">你还可以在 Github <link xlink:href="
"\"https://github.com/vaadin/mobilemail-demo\">查看这个示例程序的源代码</"
"link>.</phrase>"

#. Tag: para
#: chapter-mobile.xml:125
#, no-c-format
msgid ""
"Some of the examples given in this chapter can be seen in action at <link "
"xlink:href=\"http://demo.vaadin.com/touchkit-sampler/\">demo.vaadin.com/"
"touchkit-sampler</link>. <phrase condition=\"web\">You can browse the source "
"code at the <link xlink:href=\"https://github.com/vaadin-samples/touchkit-"
"sampler\">source repository</link> or clone it with Git.</phrase>"
msgstr ""
"本章中的一部分示例程序可以在以下地址查看其实际运行效果: <link xlink:href="
"\"http://demo.vaadin.com/touchkit-sampler/\">demo.vaadin.com/touchkit-"
"sampler</link>. <phrase condition=\"web\">你可以在 <link xlink:href="
"\"https://github.com/vaadin-samples/touchkit-sampler\">GitHub 源代码库</"
"link> 中查看源代码, 或使用 Git 来复制源代码库.</phrase>"

#. Tag: title
#: chapter-mobile.xml:136
#, no-c-format
msgid "Licensing"
msgstr "许可协议"

#. Tag: para
#: chapter-mobile.xml:138
#, no-c-format
msgid ""
"Vaadin TouchKit is a commercial product licensed under a dual-licensing "
"scheme. The AGPL license allows open-source development, while the CVAL "
"license needs to be purchased for closed-source use, including web "
"deployments and internal use. Commercial licenses can be purchased from "
"Vaadin Directory, where you can also find the license details and download "
"Vaadin TouchKit."
msgstr ""
"Vaadin TouchKit 是一个商业产品, 使用双许可协议. AGPL 许可协议允许开源项目使用"
"这个组件, CVAL 协议需要购买许可, 允许用于闭源项目, 包括 Web 开发和内部使用. "
"商业许可可以通过 Vaadin Directory 购买, 你在这里可以找到许可协议的详细文本, "
"并下载 Vaadin TouchKit."

#. Tag: title
#: chapter-mobile.xml:150
#, no-c-format
msgid "Considerations Regarding Mobile Browsing"
msgstr "针对移动设备浏览器应当考虑的问题"

#. Tag: para
#: chapter-mobile.xml:152
#, no-c-format
msgid ""
"When developing web applications that support mobile browsing, you need to "
"consider various issues that are different from non-mobile use. TouchKit is "
"designed to help with these issues."
msgstr ""
"开发支持移动设备的 Web 应用程序时, 你需要考虑很多与非移动设备不同的问题. "
"TouchKit 就是用来帮助你解决这些问题."

#. Tag: title
#: chapter-mobile.xml:159
#, no-c-format
msgid "Mobile Human Interface"
msgstr "移动设备的人机界面"

#. Tag: para
#: chapter-mobile.xml:161
#, no-c-format
msgid ""
"Mobile devices use very different human interfaces than regular computers. "
"For example, the screen can be rotated easily to switch between portrait and "
"landscape views. This does not just change the dimensions of the display, "
"but also affects how to arrange components for the best user experience. In "
"addition to TouchKit, responsive layouts help in allowing flexible layouts, "
"as described in <xref linkend=\"themes.responsive\"/>."
msgstr ""
"移动设备使用一种与通常的计算机非常不同的人机界面. 比如, 屏幕可以很容易地在横"
"向和纵向之间旋转. 这个变化不仅改变了显示器的尺寸, 而且还影响到如何排列组件才"
"能实现最好的用户体验. 除 TouchKit 外, Responsive add-on 也可以帮助应用程序实"
"现灵活的动态布局, 详情请参见 <xref linkend=\"themes.responsive\"/>."

#. Tag: para
#: chapter-mobile.xml:170
#, no-c-format
msgid ""
"The user interface is used with a finger instead of a mouse, so there are no "
"features such as \"right-finger-button\". When using a mouse you can click "
"double-click or right-click, but on a touch device, you are using "
"interactions such as tap and \"long tap\". Finger gestures also play a large "
"role, such as using a vertical swipe gesture for scrolling instead of a "
"scroll bar. Some browsers also allow using two- or multiple-finger gestures."
msgstr ""
"移动设备的 UI 通过手指来使用, 而不是鼠标, 因此不存在 \"右键点击\" 之类的功"
"能. 使用鼠标时你可以在 UI 组件上双击(double-click)或点击右键(right-click), 但"
"在触摸式设备中通常使用点击(tap) 和 \"长按(long tap)\" 来代替. 手指的动作也起"
"到很重要的作用, 比如使用一个垂直的拉动来滚动屏幕, 而不是使用滚动条. 某些浏览"
"器还允许使用两个或多个手指的动作."

#. Tag: para
#: chapter-mobile.xml:180
#, no-c-format
msgid ""
"There is normally no physical keyboard, but an on-screen keyboard, which can "
"change depending on the context. You also need to ensure that it does not "
"hide the input field to which the user is trying to enter data when it pops "
"up. This should be handled by the browser, but is among the issues that "
"requires special testing."
msgstr ""
"通常没有物理键盘, 而只有一个屏幕上的虚拟键盘, 而且键盘会根据环境上下文而发生"
"变化. 你还需要确保键盘弹出时, 不会遮挡住用户试图输入数据的那个输入组件. 这一"
"点本来应该由浏览器负责处理, 但这个问题在测试时需要特别注意."

#. Tag: title
#: chapter-mobile.xml:190
#, no-c-format
msgid "Bandwidth and Performance"
msgstr "带宽与性能"

#. Tag: para
#: chapter-mobile.xml:192
#, no-c-format
msgid ""
"Mobile Internet connections are often significantly slower than with fixed "
"lines. With a low-end mobile connection, such as 384 kbps, just loading the "
"Vaadin client-side engine can take several seconds. This can be helped by "
"compiling a widget set that includes only the widgets for the used "
"components, as described in <xref linkend=\"mobile.optimization\"/>, by "
"compiling the theme into the widget set, and so forth."
msgstr ""
"移动设备的 Internet 连接通常会比有线连接慢很多. 使用低速的移动设备网络连接"
"时, 比如 384 kbps, 仅仅装载 Vaadin 客户端引擎本身也会耗费几秒钟时间. 为解决这"
"个问题, 可以编译Widget Set, 将 theme 编译到 widget set 之内, 使它只包含实际用"
"到的组件所需要的 Widget, 详情请参见 <xref linkend=\"mobile.optimization\"/>."

#. Tag: para
#: chapter-mobile.xml:201
#, no-c-format
msgid ""
"Even with mobile broadband, the latency can be significant factor, "
"especially with highly interactive rich applications. The latency is usually "
"almost unnoticeable in fixed lines, typically less than 100 ms, while mobile "
"Edge connections typically have latency around 500 ms, and sometimes much "
"higher during hiccups. You may need to limit the use of the immediate mode, "
"text change events, and polling. The latency compensation in some "
"components, such as <classname>NavigationManager</classname>, allows view "
"change animations to occur while the server request to display the result is "
"being made."
msgstr ""
"即使使用移动设备的低带宽, 应用程序的延迟也是重要的因素, 尤其是在高度交互的丰"
"富应用程序(Rich Application)中更是如此. 在有线连接中通常几乎注意不到存在延"
"迟, 一般会少于 100 毫秒, 而在移动设备的 EDGE(Enhanced Data rates for GSM "
"Evolution) 连接中通常会达到 500 毫秒左右, 在网络不稳定时延迟有时甚至会更高. "
"你可能会需要减少使用 immediate 模式, text change 事件, 以及轮询(polling). 某"
"些组件中的延迟补偿功能, 比如 <classname>NavigationManager</classname> 中, 允"
"许在向服务器发送请求的过程中显示一个视图变更动画."

#. Tag: para
#: chapter-mobile.xml:213
#, no-c-format
msgid ""
"Further, the choice of components affects performance. TouchKit components "
"are designed to be light-weight. Of the other Vaadin components, some are "
"more light-weight than others. Especially, most other layout components have "
"a more deeper DOM structure and are slower to render than the light-weight "
"<classname>CssLayout</classname>. TouchKit also includes special styling for "
"<classname>CssLayout</classname>."
msgstr ""
"此外, 选择使用什么组件也会影响性能. TouchKit 组件被设计得十分轻便. 其他 "
"Vaadin 组件, 一部分比其他组件更轻便一些. 尤其是, 与轻量级的 "
"<classname>CssLayout</classname> 相比, 大部分其他布局组件都带有更深的 DOM 结"
"构, 因此渲染过程会更慢一些. TouchKit 也包含了一些特殊的样式可用于 "
"<classname>CssLayout</classname>."

#. Tag: title
#: chapter-mobile.xml:224
#, no-c-format
msgid "Mobile Features"
msgstr "移动设备的功能特性"

#. Tag: para
#: chapter-mobile.xml:226
#, no-c-format
msgid ""
"Phones and tablets have many integrated features that are often available in "
"the browser interface as well. Location-awareness is one of the most recent "
"features. And of course, you can also make phone calls."
msgstr ""
"手机和平板有很多集成的功能特性, 通常在浏览器 UI 中也可以使用. 地理位置感知是"
"最近的功能特性之一. 当然, 你也可以发起一通电话通话."

#. Tag: title
#: chapter-mobile.xml:234
#, no-c-format
msgid "Compatibility"
msgstr "兼容性"

#. Tag: para
#: chapter-mobile.xml:236
#, no-c-format
msgid ""
"The mobile browsing field is currently evolving at a quick pace and the "
"special conventions introduced by leading manufacturers may, in the next few "
"years, stabilize as new web standards. The browser support in TouchKit "
"originally concentrated on WebKit, which appears to be emerging as the "
"leading mobile browser core. In addition to Apple's products, also the "
"default browser in Android uses WebKit as the layout engine. Yet they have "
"differences, as the Android's JavaScript engine, which is highly relevant "
"for Vaadin, is the Google Chrome's V8 engine. As of TouchKit 4, Internet "
"Explorer on Windows Phone is also supported."
msgstr ""
"移动设备浏览领域正在快速发展中, 而且领先的厂商还引入了特别的习惯约定, 在未来"
"的几年中, 这些约定将会稳定下来, 成为新的 Web 标准. TouchKit 主要支持 WebKit "
"系列浏览器, 这个引擎似乎正在成为移动设备上最领先的浏览器内核. 除 Apple 产品之"
"外, Android 的默认浏览器也使用 WebKit 作为排版引擎. 当然这些浏览器也存在区"
"别, Android 的 JavaScript 引擎, 使用的是 Google Chrome 的 V8 引擎, Vaadin 与"
"浏览器的 JavaScript 引擎存在紧密的关系. 从 TouchKit 4 开始, 也支持 Windows "
"Phone 上的 Internet Explorer 浏览器."

#. Tag: para
#: chapter-mobile.xml:248
#, no-c-format
msgid ""
"For the list of devices supported by the latest TouchKit version, see the "
"<link xlink:href=\"https://vaadin.com/add-ons/touchkit\">TouchKit product "
"page</link> at the Vaadin site."
msgstr ""
"关于最新版的 TouchKit 所支持的移动设备列表, 请参见 Vaadin 网站上的 <link "
"xlink:href=\"https://vaadin.com/add-ons/touchkit\">TouchKit 产品页面</link>."

#. Tag: para
#: chapter-mobile.xml:254
#, no-c-format
msgid ""
"Vaadin TouchKit aims to follow the quickly evolving APIs of these major "
"platforms, with the assumption that other browsers will follow their lead in "
"standardization. Other platforms will be supported if they rise in "
"popularity."
msgstr ""
"Vaadin TouchKit 会遵循这些主要平台上快速演变中的 API, 它假定其他浏览器也会遵"
"循这些领先者制定的标准. 如果其他平台的用户份额增加, 那么 TouchKit 也会支持它"
"们."

#. Tag: title
#: chapter-mobile.xml:262
#, no-c-format
msgid "Back Button"
msgstr "回退按钮"

#. Tag: para
#: chapter-mobile.xml:264
#, no-c-format
msgid ""
"Some mobile devices, especially Android and Windows Phone devices, have a "
"dedicated back button, while iOS devices in particular do not. TouchKit does "
"not provide any particular support for the button, but as it is a regular "
"browser back button, you can handle it with URI fragments, as described in "
"<xref linkend=\"advanced.urifu\"/>. For iOS, the browser back button is "
"hidden if the user adds the application to the home screen, in which case "
"you need to implement application-specific logic for the back-navigation."
msgstr ""
"某些移动设备, 尤其是 Android 和 Windows Phone 设备, 有一个专门的回退按钮, 而 "
"iOS 设备则没有. TouchKit 不对回退按钮提供特别的支持, 但是, 由于这是一个通常的"
"浏览器回退按钮, 你可以通过 URI 片段来管理它, 详情请参见 <xref linkend="
"\"advanced.urifu\"/>. 对于 iOS, 如果用户将应用程序添加到了 Home 画面, 浏览器"
"回退按钮会被隐藏, 这种情况下你需要实现一段特别的应用程序逻辑来实现回退浏览."

#. Tag: title
#: chapter-mobile.xml:279
#, no-c-format
msgid "Installing Vaadin TouchKit"
msgstr "安装 Vaadin TouchKit"

#. Tag: para
#: chapter-mobile.xml:281
#, no-c-format
msgid ""
"You can download and install TouchKit from Vaadin Directory at <link xlink:"
"href=\"https://vaadin.com/addon/vaadin-touchkit\">vaadin.com/addon/vaadin-"
"touchkit</link> as an installation package, or get it with Maven or Ivy. If "
"your project is not compatible with the AGPL license, you can purchase CVAL "
"licenses from Vaadin Directory or subscribe to the Pro Tools package at "
"<link xlink:href=\"https://vaadin.com/pro\">vaadin.com/pro</link>."
msgstr ""
"你可以通过 Vaadin Directory 以安装包的形式下载并安装 TouchKit, 地址是 <link "
"xlink:href=\"https://vaadin.com/addon/vaadin-touchkit\">https://vaadin.com/"
"addon/vaadin-touchkit</link>, 也可以通过 Maven 或 Ivy 得到它. 如果你的工程不"
"能使用 AGPL 许可协议, 你可以通过 Vaadin Directory 购买 CVAL 许可协议, 或者通"
"过 <link xlink:href=\"https://vaadin.com/pro\">vaadin.com/pro</link> 订购 "
"Pro Tools 工具包."

#. Tag: para
#: chapter-mobile.xml:290
#, no-c-format
msgid ""
"Add-on installation is described in detail in <xref linkend=\"addons\"/>. "
"The add-on includes a widget set, so you need to compile the widget set for "
"your project."
msgstr ""
"关于 Add-on 的安装方法, 详情请参见 <xref linkend=\"addons\"/>. 这个 Add-on 包"
"含 Widget Set, 因此你需要编译为你的工程编译 Widget Set."

#. Tag: title
#: chapter-mobile.xml:297
#, no-c-format
msgid "Installing as Ivy Dependency"
msgstr "以 Ivy 依赖项方式安装"

#. Tag: para
#: chapter-mobile.xml:299
#, no-c-format
msgid ""
"If you use the add-on in an Eclipse project created with the Vaadin Plugin "
"for Eclipse, you can define an Ivy dependency to automatically download the "
"library. Include the following declaration inside the <literal>dependencies</"
"literal> section in the <filename>ivy.xml</filename>:"
msgstr ""
"如果你在通过 Vaadin Plugin for Eclipse 创建的工程中使用这个 Add-on, 你可以定"
"义一个 Ivy 依赖项目, 即可自动下载库文件. 请将以下声明加入到 <filename>ivy."
"xml</filename> 文件的 <literal>dependencies</literal> 小节中:"

#. Tag: programlisting
#: chapter-mobile.xml:307
#, no-c-format
msgid ""
"&lt;dependency org=\"com.vaadin.addon\"\n"
"            name=\"vaadin-touchkit-agpl\"\n"
"            rev=\"<emphasis role=\"bold\">latest.release</emphasis>\"\n"
"            conf=\"default->default\" /&gt;"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:309
#, no-c-format
msgid ""
"You can use <literal>latest.release</literal> revision tag to always use the "
"latest release or specify a version by its version number. IvyDE should "
"resolve the dependency immediately as you save the file. See <xref linkend="
"\"addons.eclipse\"/> for further details."
msgstr ""
"你可以使用 <literal>latest.release</literal> 版本标记来使用最新发布版, 或者指"
"定一个具体的版本号. 当你保存这个文件时 IvyDE 会立即解析依赖项目. 详情请参见 "
"<xref linkend=\"addons.eclipse\"/>."

#. Tag: title
#: chapter-mobile.xml:318
#, no-c-format
msgid "Defining the Maven Dependency"
msgstr "声明 Maven 依赖项"

#. Tag: para
#: chapter-mobile.xml:320
#, no-c-format
msgid ""
"You can install Vaadin TouchKit in a Maven project by adding it as a "
"dependency, as described below, or by using the Maven archetype, as "
"described in <xref linkend=\"mobile.project.maven\"/>."
msgstr ""
"在 Maven 工程中, 你可以将 Vaadin TouchKit 添加为一个依赖项目来安装它, 详情见"
"后述, 也可以使用 Maven archetype, 详情请参见 <xref linkend=\"mobile.project."
"maven\"/>."

#. Tag: para
#: chapter-mobile.xml:326
#, no-c-format
msgid ""
"To use TouchKit in a Vaadin project, you need to include the following "
"dependency in the POM. The <literal>artifactId</literal> should be "
"<literal>vaadin-touchkit-agpl</literal> or <literal>vaadin-touchkit-cval</"
"literal>, depending on which license suits your project requirements."
msgstr ""
"为了在 Vaadin 工程中使用 TouchKit, 你需要在 POM 中包含以下依赖项目. "
"<literal>artifactId</literal> 应该是 <literal>vaadin-touchkit-agpl</literal> "
"或 <literal>vaadin-touchkit-cval</literal>, 使用哪一个取决于那种许可协议适合"
"于你的项目需求."

#. Tag: programlisting
#: chapter-mobile.xml:334
#, no-c-format
msgid ""
"&lt;dependency&gt;\n"
"    &lt;groupId&gt;com.vaadin.addon&lt;/groupId&gt;\n"
"    &lt;artifactId&gt;vaadin-touchkit-<emphasis role=\"bold\">agpl</"
"emphasis>&lt;/artifactId&gt;\n"
"    &lt;version&gt;<emphasis role=\"bold\">LATEST</emphasis>&lt;/"
"version&gt;\n"
"&lt;/dependency&gt;"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:336
#, no-c-format
msgid ""
"You can use the <parameter>LATEST</parameter> version as shown above or a "
"specific version by its version number."
msgstr ""
"你可以和上例一样, 使用 <parameter>LATEST</parameter> 版本号, 也可以指定一个具"
"体的版本号."

#. Tag: para
#: chapter-mobile.xml:341
#, no-c-format
msgid ""
"You also need to define the repository for the Vaadin add-ons under the "
"<literal>&lt;repositories&gt;</literal> element:"
msgstr ""
"你还需要在 <literal>&lt;repositories&gt;</literal> 元素下为 Vaadin add-on 定"
"义 repository:"

#. Tag: programlisting
#: chapter-mobile.xml:346
#, no-c-format
msgid ""
"<![CDATA[<repository>\n"
"    <id>vaadin-addons</id>\n"
"    <url>http://maven.vaadin.com/vaadin-addons</url>\n"
"</repository>]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:348
#, no-c-format
msgid ""
"Finally, you need to enable the widget set compilation in the POM, as "
"described in <xref linkend=\"addons.maven.widgetset\"/>, and compile it."
msgstr ""
"最后, 你还需要在 POM 中启动 Widget Set 编译功能, 详情请参见 <xref linkend="
"\"addons.maven.widgetset\"/>, 然后编译 Widget Set."

#. Tag: title
#: chapter-mobile.xml:355
#, no-c-format
msgid "Installing the Zip Package"
msgstr "使用 Zip 包安装"

#. Tag: para
#: chapter-mobile.xml:357
#, no-c-format
msgid ""
"Vaadin TouchKit is distributed as a Zip package that contains the TouchKit "
"JAR, a JavaDoc JAR, license texts, and other documentation. You can download "
"the Zip package from Vaadin Directory. A different package is provided for "
"each of the two licenses, and Directory asks for your choice."
msgstr ""
"Vaadin TouchKit 以 Zip 包的形式发布, 其中包含 TouchKit JAR, JavaDoc JAR, 许可"
"协议文本文件, 以及其他文档. 你可以从 Vaadin Directory 下载 Zip 包. 针对两种不"
"同的许可协议, 提供了两个不同的安装包, Vaadin Directory 将会询问你选择哪一个."

#. Tag: para
#: chapter-mobile.xml:365
#, no-c-format
msgid ""
"The TouchKit JAR in the package should be put in the <filename>WEB-INF/lib</"
"filename> folder of the web application."
msgstr ""
"安装包中的 TouchKit JAR 应该放在 Web 应用程序的 <filename>WEB-INF/lib</"
"filename> 文件夹下."

#. Tag: para
#: chapter-mobile.xml:370
#, no-c-format
msgid ""
"Please see the <filename>README.html</filename> for more information about "
"the package contents."
msgstr "关于安装包的内容, 详情请参见 <filename>README.html</filename> 文件."

#. Tag: title
#: chapter-mobile.xml:378
#, no-c-format
msgid "Importing the Parking Demo"
msgstr "导入 Parking 示例程序"

#. Tag: para
#: chapter-mobile.xml:380
#, no-c-format
msgid ""
"The Parking Demo, illustrated in <xref linkend=\"figure.mobile.overview."
"touchkit\"/> in the overview, showcases most of the functionality in Vaadin "
"TouchKit. You can try out the demo online with a TouchKit-compatible browser "
"at <link xlink:href=\"http://demo.vaadin.com/parking\">demo.vaadin.com/"
"parking</link>."
msgstr ""
"Parking 示例程序, 参见概述中的 <xref linkend=\"figure.mobile.overview."
"touchkit\"/>, 演示了 Vaadin TouchKit 中的大部分功能. 你可以使用兼容 TouchKit "
"的 浏览器在线试用这个示例程序, 地址是 <link xlink:href=\"http://demo.vaadin."
"com/parking\">demo.vaadin.com/parking</link>."

#. Tag: para
#: chapter-mobile.xml:388
#, no-c-format
msgid ""
"You can browse the sources on-line or, more conveniently, import the project "
"in Eclipse (or other IDE). As the project is Maven-based, Eclipse users need "
"to install the m2e plugin to be able to import Maven projects, as well as "
"EGit to be able to import Git repositories. Once they are installed, you "
"should be able to import Parking Demo as follows."
msgstr ""
"你可以在线浏览这个示例程序的源代码, 或者使用更便利的方式, 将这个工程导入到 "
"Eclipse (或其他 IDE) 中. 由于这个工程是一个 Maven 工程, Eclipse 用户需要安装 "
"m2e 插件, 才能导入 Maven 工程, 此外还需要 EGit 插件来导入 Git 源代码库. 这些"
"插件安装完毕后, 你就可以导入 Parking 示例程序了, 方法如下."

#. Tag: listitem
#: chapter-mobile.xml:397
#, no-c-format
msgid ""
"Select <menuchoice><guimenu>File</guimenu><guimenuitem>Import</guimenuitem></"
"menuchoice>"
msgstr ""
"选择菜单项 <menuchoice><guimenu>File</guimenu><guimenuitem>Import</"
"guimenuitem></menuchoice>"

#. Tag: listitem
#: chapter-mobile.xml:398
#, no-c-format
msgid ""
"Select <menuchoice><guimenu>Maven</guimenu><guimenuitem>Check out Maven "
"Project from SCM</guimenuitem></menuchoice>, and click <guibutton>Next</"
"guibutton>."
msgstr ""
"选择 <menuchoice><guimenu>Maven</guimenu><guimenuitem>Check out Maven "
"Project from SCM</guimenuitem></menuchoice>, 然后单击 <guibutton>Next</"
"guibutton> 按钮."

#. Tag: para
#: chapter-mobile.xml:401
#, no-c-format
msgid ""
"You may need to install the EGit SCM connector if you have not done so "
"previously. If Git is not available in the SCM list, click <guibutton>m2e "
"marketplace</guibutton>, select the EGit connector, and click "
"<guibutton>Finish</guibutton>. You need to restart Eclipse and redo the "
"earlier steps above."
msgstr ""
"在 Eclipse 中需要使用源代码管理工具 EGit 来访问 Git 源代码库, 如果你没有安装"
"过, 那么需要安装它. 如果 Git 没有出现在你的 Eclipse 源代码管理工具列表中, 请"
"点击 <guibutton>m2e marketplace</guibutton>, 选择 EGit, 然后点击 "
"<guibutton>Finish</guibutton>.安装完毕后需要重启 Eclipse, 并重新执行前面说的 "
"import 步骤."

#. Tag: para
#: chapter-mobile.xml:409
#, no-c-format
msgid ""
"Instead of using m2e EGit connector, you can also check out the project with "
"another Git tool and then import it in Eclipse as a Maven project."
msgstr ""
"除了使用 m2e EGit 之外, 还可以使用其他 Git 工具从源代码库中取出工程源代码, 然"
"后在 Eclipse 中将它导入为一个 Maven 工程."

#. Tag: listitem
#: chapter-mobile.xml:416
#, no-c-format
msgid ""
"In <guilabel>SCM URL</guilabel>, select <guilabel>git</guilabel> and enter "
"the repository URL <uri>https://github.com/vaadin/parking-demo</uri>."
msgstr ""
"在 <guilabel>SCM URL</guilabel> 项目中, 选择 <guilabel>git</guilabel>, 并输入"
"源代码库的 URL <uri>https://github.com/vaadin/parking-demo</uri>."

#. Tag: listitem
#: chapter-mobile.xml:421
#, no-c-format
msgid "Click <guibutton>Finish</guibutton>."
msgstr "点击 <guibutton>Finish</guibutton> 按钮."

#. Tag: listitem
#: chapter-mobile.xml:423
#, no-c-format
msgid ""
"Compile the widget set either by clicking <guibutton>Compile Widgetset</"
"guibutton> in the Eclipse toolbar or by running the <literal>vaadin:compile</"
"literal> goal with Maven."
msgstr ""
"编译 widget set, 方法是点击 Eclipse 工具条上的 <guibutton>Compile Widgetset</"
"guibutton> 按钮, 或者使用 Maven 运行 <literal>vaadin:compile</literal> 目标."

#. Tag: listitem
#: chapter-mobile.xml:429
#, no-c-format
msgid ""
"Deploy the application to a server. See <xref linkend=\"getting-started."
"first-project.server\"/> for instructions for deploying in Eclipse."
msgstr ""
"将应用程序发布到服务器上. 关于在 Eclipse 中发布程序的方法, 详情请参见 <xref "
"linkend=\"getting-started.first-project.server\"/>."

#. Tag: listitem
#: chapter-mobile.xml:435
#, no-c-format
msgid ""
"Open the URL <uri>http://localhost:8080/parking</uri> with a mobile device "
"or a WebKit-compatible browser, such as Safari or Chrome, to run the Parking "
"Demo."
msgstr ""
"使用移动设备, 或使用一个兼容 WebKit 的浏览器(比如 Safari 或 Chrome), 访问应用"
"程序地址 <uri>http://localhost:8080/parking</uri>, 来运行  Parking 示例程序."

#. Tag: title
#: chapter-mobile.xml:444
#, no-c-format
msgid "Creating a New TouchKit Project"
msgstr "创建新的 TouchKit 工程"

#. Tag: para
#: chapter-mobile.xml:446
#, no-c-format
msgid ""
"The easiest ways to create a new TouchKit application project are to either "
"use the Maven archetype or create the project as a regular Vaadin project "
"with the Vaadin Plugin for Eclipse and then modify it for TouchKit."
msgstr ""
"插件新的 TouchKit 应用程序的最简便方法是使用 Maven archetype, 或者先使用 "
"Vaadin Plugin for Eclipse 创建通常的 Vaadin 工程, 然后再将它修改为 TouchKit "
"工程."

#. Tag: title
#: chapter-mobile.xml:453
#, no-c-format
msgid "Using the Maven Archetype"
msgstr "使用 Maven Archetype"

#. Tag: para
#: chapter-mobile.xml:455
#, no-c-format
msgid ""
"You can create a new TouchKit application project using the Maven "
"<parameter>vaadin-archetype-touchkit</parameter> archetype. Creating Vaadin "
"projects with Maven is described in more detail in <xref linkend=\"getting-"
"started.maven\"/>."
msgstr ""
"你可以使用 Maven <parameter>vaadin-archetype-touchkit</parameter> archetype "
"来创建新的 TouchKit 应用程序工程. 关于使用 Maven 创建 Vaadin 工程, 详情请参"
"见 <xref linkend=\"getting-started.maven\"/>."

#. Tag: para
#: chapter-mobile.xml:462
#, no-c-format
msgid "For example, to create a project from the command-line, you could do:"
msgstr "比如, 要从命令行创建一个工程, 你可以执行以下命令:"

#. Tag: screen
#: chapter-mobile.xml:466
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>mvn</command> archetype:generate \\\n"
"  -DarchetypeGroupId=com.vaadin \\\n"
"  -DarchetypeArtifactId=vaadin-archetype-touchkit \\\n"
"  -DarchetypeVersion=<replaceable>4.0.0</replaceable> \\\n"
"  -DgroupId=<replaceable>example.com</replaceable> -"
"DartifactId=<replaceable>myproject</replaceable> \\\n"
"  -Dversion=<replaceable>0.1.0</replaceable> \\\n"
"  -DApplicationName=<replaceable>My</replaceable> -Dpackaging=war"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:468
#, no-c-format
msgid ""
"The <parameter>ApplicationName</parameter> parameter for the archetype is "
"used as a prefix for the various stub class names. For example, the above "
"\"My\" name results in classes such as <classname>MyTouchKitUI</classname>."
msgstr ""
"archetype 的 <parameter>ApplicationName</parameter> 参数被用作各种框架代码类"
"名称的前缀. 比如, 上例中的名称 \"My\" 会导致生成的类名为 "
"<classname>MyTouchKitUI</classname> 等."

#. Tag: para
#: chapter-mobile.xml:474
#, no-c-format
msgid "The generated project has the following source files:"
msgstr "生成的工程将包含以下源代码文件:"

#. Tag: filename
#: chapter-mobile.xml:480
#, no-c-format
msgid "MyTouchKitUI.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:482
#, no-c-format
msgid ""
"The mobile UI for the TouchKit application. See <xref linkend=\"mobile."
"elements.ui\"/> for the basics of a TouchKit UI. The example UI uses "
"<classname>TabBarView</classname> as the content. The first tab features a "
"<classname>MenuView</classname> (see below), a navigation view stub defined "
"in the project."
msgstr ""
"TouchKit 应用程序的移动设备 UI. 关于 TouchKit UI 的基本概念, 请参见 <xref "
"linkend=\"mobile.elements.ui\"/>. 示例程序的 UI 使用 <classname>TabBarView</"
"classname> 作为根内容. 第一个 tab 包含一个 <classname>MenuView</classname> "
"(详情将在后文中介绍), 以及一个工程中定义的功能导航视图框架."

#. Tag: filename
#: chapter-mobile.xml:493
#, no-c-format
msgid "MyFallbackUI.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:495
#, no-c-format
msgid ""
"A fallback UI for browsers unsupported by TouchKit, such as regular desktop "
"browsers. See <xref linkend=\"mobile.features.fallback\"/> for more "
"information about fallback UIs."
msgstr ""
"针对 TouchKit 不支持的浏览器的后备(fallback) UI, 比如通常的桌面浏览器. 关于后"
"备(fallback) UI, 详情请参见 <xref linkend=\"mobile.features.fallback\"/>."

#. Tag: filename
#: chapter-mobile.xml:504
#, no-c-format
msgid "MyServlet.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:506
#, no-c-format
msgid ""
"The servlet class for the UI, defined using the <literal>@WebServlet</"
"literal> annotation in Servlet API 3.0. The generated servlet customizes "
"TouchKit to define the <classname>MyUIProvider</classname>, which sets the "
"fallback UI. See <xref linkend=\"mobile.elements.servlet\"/> for more "
"details about defining a custom servlet to customize TouchKit."
msgstr ""
"UI 的 Servlet 类, 使用 Servlet API 3.0 中的 <literal>@WebServlet</literal> 注"
"解来定义. 生成的 Servlet 定制了 TouchKit, 定义了 <classname>MyUIProvider</"
"classname>, <classname>MyUIProvider</classname> 负责设定后备 UI. 关于如何自定"
"义 Servlet 来定制 TouchKit, 详情请参见 <xref linkend=\"mobile.elements."
"servlet\"/>."

#. Tag: filename
#: chapter-mobile.xml:517
#, no-c-format
msgid "MyUIProvider.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:519
#, no-c-format
msgid ""
"Creates either the <classname>MyTouchKitUI</classname> for supported mobile "
"browsers or <classname>MyFallBackUI</classname> for unsupported browsers. "
"See <xref linkend=\"mobile.features.fallback\"/> for more information about "
"fallback UIs."
msgstr ""
"针对 TouchKit 支持的浏览器, 它负责创建 <classname>MyTouchKitUI</classname>, "
"针对不支持的浏览器, 负责创建 <classname>MyFallBackUI</classname>. 关于后备 "
"UI, 详情请参见 <xref linkend=\"mobile.features.fallback\"/>."

#. Tag: filename
#: chapter-mobile.xml:529
#, no-c-format
msgid "MenuView.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:531
#, no-c-format
msgid ""
"Presents a stub for a menu view. The menu is made of "
"<classname>NavigationButton</classname>s laid out in a "
"<classname>VerticalComponentGroup</classname>. Clicking a button navigates "
"to another view; in the stub to a <classname>FormView</classname> (see "
"below)."
msgstr ""
"这是菜单视图的框架代码. 菜单由 <classname>VerticalComponentGroup</classname> "
"中的一组 <classname>NavigationButton</classname> 构成. 点击一个按钮后将会导航"
"跳转到另一个视图; 在框架代码中是跳转到 <classname>FormView</classname> (详情"
"见后文)."

#. Tag: filename
#: chapter-mobile.xml:541
#, no-c-format
msgid "FormView.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:543
#, no-c-format
msgid "Presents a stub for a data input form."
msgstr "这是数据输入 Form 的框架代码."

#. Tag: filename
#: chapter-mobile.xml:549
#, no-c-format
msgid "gwt/AppWidgetSet.gwt.xml"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:551
#, no-c-format
msgid ""
"Widget set descriptor for the project. When compiled, it is automatically "
"updated to include possible other add-on widget sets in the project."
msgstr ""
"工程的 Widget set 描述文件. 编译时, 这个文件将被自动更新, 然后会包含工程内可"
"能存在的其他 add-on 的 widget set."

#. Tag: filename
#: chapter-mobile.xml:559
#, no-c-format
msgid "gwt/client/MyOfflineDataService.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:561
#, no-c-format
msgid ""
"A data service stub for storing data in the offline mode. See <xref linkend="
"\"mobile.offline\"/>."
msgstr ""
"数据服务程序的框架代码, 用于在离线模式下保存数据. 详情请参见 <xref linkend="
"\"mobile.offline\"/>."

#. Tag: filename
#: chapter-mobile.xml:568
#, no-c-format
msgid "gwt/client/MyPersistToServerRpc.java"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:570
#, no-c-format
msgid "Client-to-Server RPC stub to persist offline data to the server-side."
msgstr ""
"客户端到服务器端 RPC 调用的框架代码, 用于将离线模式下的数据保存到服务器端."

#. Tag: para
#: chapter-mobile.xml:578
#, no-c-format
msgid ""
"If you import the project to Eclipse or other IDE, you at least need to "
"compile the widget set to be able to deploy the project. You can to do that "
"with Maven integration in the IDE, or from command-line with:"
msgstr ""
"如果你将工程导入到 Eclipse 或其他 IDE 中, 你至少需要编译 widget set, 然后才可"
"以发布这个工程. 你可以使用 IDE 中集成的 Maven 来执行这个任务, 或者在命令行中"
"执行以下命令:"

#. Tag: screen
#: chapter-mobile.xml:584
#, no-c-format
msgid "<prompt>$</prompt> <command>mvn</command> vaadin:compile"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:586
#, no-c-format
msgid ""
"See <xref linkend=\"getting-started.maven\"/>. At least in Eclipse, you "
"should now be able to import and deploy the project to a development server. "
"You can also compile the project and launch it in a Jetty web server (port "
"8080) from command-line as follows:"
msgstr ""
"详情请参见 <xref linkend=\"getting-started.maven\"/>. 至少在 Eclipse 中, 现在"
"你应该可以导入一个工程, 并将它发布到开发服务器上了. 你也可以编译工程, 并在 "
"Jetty web 服务器(port 8080) 中启动它, 方法是使用以下命令:"

#. Tag: screen
#: chapter-mobile.xml:593
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>mvn</command> package\n"
"<prompt>$</prompt> <command>mvn</command> jetty:run"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:595
#, no-c-format
msgid ""
"Note that a project generated by the archetype defines the servlet with the "
"<literal>@WebServlet</literal> annotation defined in Servlet API 3.0. The "
"application server must support Servlet 3.0. For example, if you use Tomcat, "
"you need at least Tomcat 7."
msgstr ""
"注意, Archetype 生成的工程会使用 Servlet API 3.0 中的 <literal>@WebServlet</"
"literal> 注解来定义 Servlet. 应用程序服务器必须支持 Servlet 3.0. 比如, 如果你"
"使用 Tomcat, 那么至少需要 Tomcat 7 以上版本."

#. Tag: title
#: chapter-mobile.xml:604
#, no-c-format
msgid "Starting from a New Eclipse Project"
msgstr "从新的 Eclipse 工程开始创建 TouchKit 工程"

#. Tag: para
#: chapter-mobile.xml:606
#, no-c-format
msgid ""
"You can create a new TouchKit project from a regular Vaadin project created "
"with the Vaadin Plugin for Eclipse (see <xref linkend=\"getting-started."
"first-project\"/>)."
msgstr ""
"Vaadin Plugin for Eclipse 可以创建通常的 Vaadin 工程(参见 <xref linkend="
"\"getting-started.first-project\"/>), 你可以通过这个工程来创建 TouchKit 工程."

#. Tag: para
#: chapter-mobile.xml:612
#, no-c-format
msgid "After creating the project, you need to do the following tasks:"
msgstr "创建工程之后, 你需要执行以下操作:"

#. Tag: para
#: chapter-mobile.xml:618
#, no-c-format
msgid ""
"Install the TouchKit library in the project by including it in the "
"<filename>ivy.xml</filename><phrase condition=\"web\">, as described in "
"<xref linkend=\"mobile.elements.ivy\"/>,</phrase> and compile the widget set."
msgstr ""
"在 <filename>ivy.xml</filename> 中添加 TouchKit 的依赖项目, 将 TouchKit 库安"
"装到工程中<phrase condition=\"web\">, 详情请参见 <xref linkend=\"mobile."
"elements.ivy\"/>,</phrase> 然后编译 Widget Set."

#. Tag: para
#: chapter-mobile.xml:627
#, no-c-format
msgid ""
"Extend <classname>TouchkitServlet</classname> instead of "
"<classname>VaadinServlet</classname> in the servlet class, as described in "
"<xref linkend=\"mobile.elements.servlet\"/>. It is recommended that you "
"extract the static inner class created by the wizard to a regular class, as "
"you most probably need to do additional configuration in it."
msgstr ""
"在 Servlet 类中继承 <classname>TouchkitServlet</classname> 而不是原有的 "
"<classname>VaadinServlet</classname>, 详情请参见 <xref linkend=\"mobile."
"elements.servlet\"/>. 建议将向导创建的静态内部类抽取为一个通常的类, 因为你很"
"可能会需要在其中添加一些额外的配置."

#. Tag: programlisting
#: chapter-mobile.xml:636
#, no-c-format
msgid ""
"<?pocket-size 70% ?>@WebServlet(value = \"/*\",\n"
"            asyncSupported = true)\n"
"@VaadinServletConfiguration(\n"
"        productionMode = false,\n"
"        ui = MyMobileUI.class)\n"
"public class MyProjectServlet extends <emphasis role=\"bold"
"\">TouchKitServlet</emphasis> {\n"
"}"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:640
#, no-c-format
msgid ""
"If you intend to define a fallback UI later, as described in <xref linkend="
"\"mobile.features.fallback\"/>, you may want to copy the original UI class "
"stub to use it as a fallback UI class."
msgstr ""
"如果你希望将来再定义后备 UI(参见 <xref linkend=\"mobile.features.fallback\"/"
">), 你可以复制原来的 UI 类的框架代码, 直接将它用作后备 UI 类."

#. Tag: para
#: chapter-mobile.xml:648
#, no-c-format
msgid ""
"To get started quickly, disable the use of custom theme by using "
"<literal>@Theme(\"touchkit\")</literal> in the UI class. To create a custom "
"mobile theme later, see <xref linkend=\"mobile.elements.theme\"/>."
msgstr ""
"为了快速启动我们的工程, 可以在 UI 类中使用 <literal>@Theme(\"touchkit\")</"
"literal> 来禁用自定义 Theme. 如果将来想要创建自定义的移动设备 Theme, 请参见 "
"<xref linkend=\"mobile.elements.theme\"/>."

#. Tag: programlisting
#: chapter-mobile.xml:655
#, no-c-format
msgid ""
"<?pocket-size 75% ?>@Theme(\"<emphasis role=\"bold\">touchkit</emphasis>\")\n"
"public class MyMobileUI extends UI {"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:659
#, no-c-format
msgid ""
"Build the mobile UI preferring TouchKit components instead of the core "
"Vaadin components, as described in <xref linkend=\"mobile.elements.ui\"/>."
msgstr ""
"使用 TouchKit 组件而不是通常的 Vaadin 核心组件来构建移动设备 UI, 详情请参见 "
"<xref linkend=\"mobile.elements.ui\"/>."

#. Tag: para
#: chapter-mobile.xml:667
#, no-c-format
msgid ""
"We cover these and various other tasks in more detail in <xref linkend="
"\"mobile.elements\"/>."
msgstr ""
"相关问题, 以及其他更多问题, 我们将在 <xref linkend=\"mobile.elements\"/> 中详"
"细讨论."

#. Tag: title
#: chapter-mobile.xml:675
#, no-c-format
msgid "Elements of a TouchKit Application"
msgstr "TouchKit 应用程序的组成元素"

#. Tag: para
#: chapter-mobile.xml:677
#, no-c-format
msgid ""
"At minimum, a TouchKit application requires a UI class, which is defined in "
"a deployment descriptor, as usual for Vaadin applications. You usually "
"define a servlet class, where you can also do some TouchKit-specific "
"configuration. You may also need to have a custom theme. These and other "
"tasks are described in the following subsections."
msgstr ""
"与通常的 Vaadin 应用程序一样, TouchKit 应用程序至少徐亚一个 UI 类, 它定义在部"
"署描述文件中. 你通常会定义一个 Servlet 类, 在这个类中也可以进行一些 TouchKit "
"独有的配置. 你还可能需要使用自定义 Theme. 这些任务, 以及其他任务, 都将在后续"
"的小节中详细介绍."

#. Tag: title
#: chapter-mobile.xml:686
#, no-c-format
msgid "The Servlet Class"
msgstr "Servlet 类"

#. Tag: para
#: chapter-mobile.xml:688
#, no-c-format
msgid ""
"When using a Servlet 3.0 compatible application server, you usually define "
"the UI and make basic configuration with a servlet class with the "
"<literal>@WebServlet</literal> annotation. Vaadin Plugin for Eclipse creates "
"the servlet class as a static inner class of the UI class, while the Maven "
"archetype creates it as a separate class, which is usually the preferred way."
msgstr ""
"使用 Servlet 3.0 兼容的应用程序服务器时, 你通常可以通过带有 "
"<literal>@WebServlet</literal> 注解的 Servlet 类来定义 UI, 并进行基本的配置. "
"Vaadin Plugin for Eclipse 会将 Servlet 类创建为 UI 类的静态内部类, 而 Maven "
"archetype 会将它创建为独立的类, 这种方式通常更好一些."

#. Tag: para
#: chapter-mobile.xml:697
#, no-c-format
msgid ""
"The servlet class must define the UI class as usual. Additionally, you can "
"configure the following TouchKit features in the servlet class:"
msgstr ""
"通常, Servlet 类必须定义 UI 类. 此外, 你还可以在 Servlet 类中对 TouchKit 进行"
"以下配置:"

#. Tag: listitem
#: chapter-mobile.xml:703
#, no-c-format
msgid "Customize bookmark or home screen icon"
msgstr "自定义书签图标或 Home 画面图标"

#. Tag: listitem
#: chapter-mobile.xml:704
#, no-c-format
msgid "Customize splash screen image"
msgstr "自定义 Splash 画面图片"

#. Tag: listitem
#: chapter-mobile.xml:705
#, no-c-format
msgid "Customize status bar in iOS"
msgstr "自定义 iOS 中的状态栏"

#. Tag: listitem
#: chapter-mobile.xml:706
#, no-c-format
msgid "Use special web app mode in iOS"
msgstr "在 iOS 中使用特殊的 Web 应用程序模式"

#. Tag: listitem
#: chapter-mobile.xml:707
#, no-c-format
msgid "Provide a fallback UI (<xref linkend=\"mobile.features.fallback\"/>)"
msgstr "提供一个后备 UI (<xref linkend=\"mobile.features.fallback\"/>)"

#. Tag: listitem
#: chapter-mobile.xml:708
#, no-c-format
msgid "Enable offline mode"
msgstr "启用离线模式"

#. Tag: para
#: chapter-mobile.xml:711
#, no-c-format
msgid ""
"A custom servlet should normally extend the <classname>TouchKitServlet</"
"classname>. You should place your code in <methodname>servletInitialized()</"
"methodname> and call the super method in the beginning."
msgstr ""
"自定义的 Servlet 通常应该继承 <classname>TouchKitServlet</classname>. 你应该"
"将你的代码放在 <methodname>servletInitialized()</methodname> 方法内, 并在方法"
"内首先调用父类方法."

#. Tag: programlisting
#: chapter-mobile.xml:718
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyServlet extends TouchKitServlet "
"{\n"
"    @Override\n"
"    protected void servletInitialized() throws ServletException {\n"
"        super.servletInitialized();\n"
"\n"
"        ... customization ...\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:720
#, no-c-format
msgid ""
"If you need to rather extend some other servlet, possibly in another add-on, "
"it should be trivial to reimplement the functionality of "
"<classname>TouchKitServlet</classname>, which is just to manage the TouchKit "
"settings object."
msgstr ""
"如果你需要继承其他的 Servlet, 比如别的 add-on 内的某个 Servlet, 这种情况下, "
"重新实现 <classname>TouchKitServlet</classname> 的功能并不复杂, 因为它只是负"
"责管理 TouchKit 的一些设置对象."

#. Tag: para
#: chapter-mobile.xml:727
#, no-c-format
msgid ""
"If using <filename>web.xml</filename> deployment descriptor instead of the "
"<classname>@WebServlet</classname>, you only need to implement custom "
"servlet class if you need to do any of the above configuration, which you "
"typically need to do."
msgstr ""
"如果使用 <filename>web.xml</filename> 部署描述文件, 而不是 "
"<classname>@WebServlet</classname> 注解, 只有当你所需要实现上述自定义配置时, "
"你才需要实现自定义的 Servlet 类, 当然通常你都会需要这些自定义配置."

#. Tag: title
#: chapter-mobile.xml:736
#, no-c-format
msgid ""
"Defining Servlet and UI with <filename>web.xml</filename> Deployment "
"Descriptor"
msgstr "使用 <filename>web.xml</filename> 部署描述文件定义 Servlet 和 UI"

#. Tag: para
#: chapter-mobile.xml:738
#, no-c-format
msgid ""
"If using an old style <filename>web.xml</filename> deployment descriptor, "
"you need to define the special <classname>TouchKitServlet</classname> class "
"instead of the regular <classname>VaadinServlet</classname> in the "
"<filename>web.xml</filename> deployment descriptor. Often you need to make "
"some configuration or add special logic in a custom servlet, as described in "
"the previous section, in which case you need to define your servlet in the "
"deployment descriptor."
msgstr ""
"如果使用老式的 <filename>web.xml</filename> 部署描述文件, 你需要在 "
"<filename>web.xml</filename> 中使用 <classname>TouchKitServlet</classname> 类"
"而不是通常的 <classname>VaadinServlet</classname>. 在前一节中我们讨论过, 通常"
"你会需要进行一些配置, 或者在自定义 Servlet 中添加一些特殊的逻辑, 这种情况下你"
"需要在部署描述文件中使用你自己的 Servlet."

#. Tag: programlisting
#: chapter-mobile.xml:748
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;servlet&gt;\n"
"  &lt;servlet-name&gt;Vaadin UI Servlet&lt;/servlet-name&gt;\n"
"  &lt;servlet-class&gt;\n"
"    <emphasis role=\"bold\">com.vaadin.addon.touchkit.server."
"TouchKitServlet</emphasis>\n"
"  &lt;/servlet-class&gt;\n"
"  &lt;init-param&gt;\n"
"    &lt;description&gt;Vaadin UI class to start&lt;/description&gt;\n"
"    &lt;param-name&gt;ui&lt;/param-name&gt;\n"
"    &lt;param-value&gt;<emphasis role=\"bold\">com.example.myapp.MyMobileUI</"
"emphasis>&lt;/param-value&gt;\n"
"  &lt;/init-param&gt;\n"
"&lt;/servlet&gt;"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:752
#, no-c-format
msgid "TouchKit Settings"
msgstr "TouchKit 设定"

#. Tag: para
#: chapter-mobile.xml:754
#, no-c-format
msgid ""
"TouchKit has a number of settings that you can customize for your needs. The "
"<classname>TouchKitSettings</classname> configuration object is managed by "
"<classname>TouchKitServlet</classname>, so if you make any modifications to "
"it, you need to implement a custom servlet, as described earlier."
msgstr ""
"TouchKit 中存在很多设定, 你可以按照自己的需求进行定制. "
"<classname>TouchKitSettings</classname> 配置信息对象由 "
"<classname>TouchKitServlet</classname> 负责管理, 因此你可以任意修改它, 前文介"
"绍已经过, 你需要实现一个自定义 Servlet."

#. Tag: programlisting
#: chapter-mobile.xml:762
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyServlet extends TouchKitServlet "
"{\n"
"    @Override\n"
"    protected void servletInitialized() throws ServletException {\n"
"        super.servletInitialized();\n"
"\n"
"        TouchKitSettings s = getTouchKitSettings();\n"
"        ...\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:764
#, no-c-format
msgid ""
"The settings include special settings for iOS devices, which are contained "
"in a separate <classname>IosWebAppSettings</classname> object, available "
"from the TouchKit settings with <methodname>getIosWebAppSettings()</"
"methodname>."
msgstr ""
"设定项目中还包括一些 iOS 设备独有的设定, 这些设定信息包含在单独的 "
"<classname>IosWebAppSettings</classname> 对象中, 可以通过 TouchKit 设定对象"
"的 <methodname>getIosWebAppSettings()</methodname> 方法得到."

#. Tag: title
#: chapter-mobile.xml:772
#, no-c-format
msgid "Application Icons"
msgstr "应用程序图标"

#. Tag: para
#: chapter-mobile.xml:774
#, no-c-format
msgid ""
"The location bar, bookmarks, and other places can display an icon for the "
"web application. You can set the icon, or more exactly icons, in an "
"<classname>ApplicationIcons</classname> object, which manages icons for "
"different resolutions. The most properly sized icon for the context is used. "
"iOS devices prefer icons with 57&#215;57, 72&#215;72, and 144&#215;144 "
"pixels, and Android devices 36&#215;36, 48&#215;48, 72&#215;72, and "
"96&#215;96 pixels."
msgstr ""
"移动设备的地址栏, 书签, 以及其他位置都可以显示 Web 应用程序的图标. 你可以在 "
"<classname>ApplicationIcons</classname> 对象中设置图标(可以有多个), 这个对象"
"负责管理不同分辨率下使用的各种图标. 尺寸与当前环境最适应的图标会被自动使用. "
"iOS 设备上比较适当的图标尺寸是 57&#215;57, 72&#215;72, and 144&#215;144 像"
"素, Android 设备是 36&#215;36, 48&#215;48, 72&#215;72, and 96&#215;96 像素."

#. Tag: para
#: chapter-mobile.xml:784
#, no-c-format
msgid ""
"You can add an icon to the application icons collection with "
"<methodname>addApplicationIcon()</methodname>. You can acquire the base URL "
"for your application from the servlet context, as shown in the following "
"example."
msgstr ""
"你可以使用 <methodname>addApplicationIcon()</methodname> 方法, 将图标添加到应"
"用程序的图标集中. 应用程序的 URL 起始地址可以通过 Servlet Context 得到, 如下"
"例."

#. Tag: programlisting
#: chapter-mobile.xml:791
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[TouchKitSettings s = getTouchKitSettings();\n"
"String contextPath = getServletConfig()\n"
"    .getServletContext().getContextPath();\n"
"s.getApplicationIcons().addApplicationIcon(\n"
"    contextPath + \"VAADIN/themes/mytheme/icon.png\");]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:793
#, no-c-format
msgid ""
"The basic method just takes the icon name, while the other one lets you "
"define its size. It also has a <parameter>preComposed</parameter> parameter, "
"which when true, instructs Safari from adding effects to the icon in iOS."
msgstr ""
"这个方法的基本版本只接受图标名称作为参数, 另一个版本则允许你定义它的尺寸. 它"
"还有一个 <parameter>preComposed</parameter> 参数, 当这个参数为 true 时, 会告"
"诉 Safari 浏览器, 在 iOS 中对这个图标添加效果."

#. Tag: title
#: chapter-mobile.xml:802
#, no-c-format
msgid "Viewport Settings"
msgstr "Viewport 设定"

#. Tag: para
#: chapter-mobile.xml:804
#, no-c-format
msgid ""
"The <classname>ViewPortSettings</classname> object, which you can get from "
"the TouchKit settings with <methodname>getViewPortSettings()</methodname>, "
"manages settings related to the display, most importantly the scaling "
"limitations."
msgstr ""
"<classname>ViewPortSettings</classname> 对象, 可以通过 TouchKit 设定对象的 "
"<methodname>getViewPortSettings()</methodname> 方法得到, 它负责管理与显示相关"
"的设定, 其中最重要的是缩放限定."

#. Tag: programlisting
#: chapter-mobile.xml:811
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[TouchKitSettings s = getTouchKitSettings();\n"
"ViewPortSettings vp = s.getViewPortSettings();\n"
"vp.setViewPortUserScalable(true);\n"
"...]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:813 chapter-mobile.xml:851
#, no-c-format
msgid ""
"See the <link xlink:href=\"http://developer.apple.com/library/safari/"
"\">Safari Development Library</link> at the Apple developer's site for more "
"details regarding the functionality in the iOS browser."
msgstr ""
"关于 iOS 浏览器中的这个功能, 详情请参见 Apple 开发者网站的 <link xlink:href="
"\"http://developer.apple.com/library/safari/\">Safari 开发库</link>."

#. Tag: title
#: chapter-mobile.xml:822
#, no-c-format
msgid "Startup Image for iOS"
msgstr "iOS 中的启动画面图片"

#. Tag: para
#: chapter-mobile.xml:824
#, no-c-format
msgid ""
"iOS browser supports a startup (splash) image that is shown while the "
"application is loading. You can set it in the <classname>IosWebAppSettings</"
"classname> object with <methodname>setStartupImage()</methodname>. You can "
"acquire the base URL for your application from the servlet context, as shown "
"in the following example."
msgstr ""
"iOS 浏览器支持在应用程序装载过程中显示一个启动(splash) 图片. 你可以通过 "
"<classname>IosWebAppSettings</classname> 对象的 "
"<methodname>setStartupImage()</methodname> 方法来设置这个图片. 应用程序的 "
"URL 起始地址可以通过 Servlet Context 得到, 如下例."

#. Tag: programlisting
#: chapter-mobile.xml:833
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[TouchKitSettings s = getTouchKitSettings();\n"
"String contextPath = getServletConfig().getServletContext()\n"
"    .getContextPath();\n"
"s.getIosWebAppSettings().setStartupImage(\n"
"    contextPath + \"VAADIN/themes/mytheme/startup.png\");]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:838
#, no-c-format
msgid "Web App Capability for iOS"
msgstr "iOS 中的 Web 应用程序能力"

#. Tag: para
#: chapter-mobile.xml:840
#, no-c-format
msgid ""
"iOS supports a special web app mode for bookmarks added and started from the "
"home screen. With the mode enabled, the client may, among other things, hide "
"the browser's own UI to give more space for the web application. The mode is "
"enabled by a header that tells the browser whether the application is "
"designed to be used as a web application rather than a web page."
msgstr ""
"iOS 支持一种特别的 Web 应用程序模式, 可以从书签或从 Home 画面启动. 当这个模式"
"启用时, 客户端可能会隐藏浏览器自身的 UI, 以便为 Web 应用程序让出更多的屏幕空"
"间, 当然其他原因也可能导致这个效果. 这个模式通过 Header 信息来启用, Header 信"
"息负责告诉浏览器, 这个应用程序是设计为以 Web 应用程序方式使用, 还是作为 Web "
"页面来使用."

#. Tag: programlisting
#: chapter-mobile.xml:849
#, no-c-format
msgid ""
"<![CDATA[TouchKitSettings s = getTouchKitSettings();\n"
"s.getIosWebAppSettings().setWebAppCapable(true);]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:860
#, no-c-format
msgid "Cache Manifest"
msgstr "缓存 Manifest"

#. Tag: para
#: chapter-mobile.xml:862
#, no-c-format
msgid ""
"The <classname>ApplicationCacheSettings</classname> object manages the cache "
"manifest, which is used to configure how the browser caches the page and "
"other resources for the web app. See <xref linkend=\"mobile.offline\"/> for "
"more details about its use."
msgstr ""
"<classname>ApplicationCacheSettings</classname> 对象管理缓存 Manifest, 这个设"
"置用来配置浏览器如何为这个 Web 应用程序缓存页面和其他资源. 关于它的使用方法, "
"详情请参见 <xref linkend=\"mobile.offline\"/>."

#. Tag: title
#: chapter-mobile.xml:872
#, no-c-format
msgid "The UI"
msgstr "UI"

#. Tag: para
#: chapter-mobile.xml:874
#, no-c-format
msgid ""
"Mobile UIs extend the <classname>UI</classname> class as usual and construct "
"the user interface from components."
msgstr ""
"移动设备 UI 与通常的 Vaadin 应用程序一样, 继承自 <classname>UI</classname> "
"类, 并使用组件来构建 UI."

#. Tag: programlisting
#: chapter-mobile.xml:879
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Theme(\"mobiletheme\")\n"
"@Widgetset(\"com.example.myapp.MyAppWidgetSet\")\n"
"@Title(\"My Simple App\")\n"
"public class SimplePhoneUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        // Create the content root layout for the UI\n"
"        TabBarView mainView = new TabBarView();\n"
"        setContent(mainView);\n"
"\n"
"        ...\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:881
#, no-c-format
msgid ""
"As TouchKit comes with a custom widget set, you need to use a combining "
"widget set for your project, defined with the <literal>@Widgetset</literal> "
"annotation for the UI. The combining widget set descriptor is automatically "
"generated by the Vaadin Plugin for Eclipse and in Maven when you install or "
"define the TouchKit add-on."
msgstr ""
"由于 TouchKit 附带了自定义的 Widget Set, 因此你需要为你的工程使用一个组合的 "
"Widget Set, 使用 <literal>@Widgetset</literal> 注解为 UI 定义 Widget Set. 如"
"过你安装了 TouchKit add-on, Vaadin Plugin for Eclipse 和 Maven 会自动生成组"
"合 Widget Set 的描述文件."

#. Tag: para
#: chapter-mobile.xml:889
#, no-c-format
msgid ""
"Most commonly, you will use a combination of the major three TouchKit "
"components as the basis of the UI: <classname>TabBarView</classname>, "
"<classname>NavigationView</classname>, or <classname>NavigationManager</"
"classname>."
msgstr ""
"通常情况下, 你会组合使用 TouchKit 的三个主要组件作为 UI 的基础: "
"<classname>TabBarView</classname>, <classname>NavigationView</classname>, 或 "
"<classname>NavigationManager</classname>."

#. Tag: para
#: chapter-mobile.xml:896
#, no-c-format
msgid ""
"If a offline UI is provided, it needs to be enabled in the initialization of "
"the UI, as described in <xref linkend=\"mobile.offline\"/>. This code is "
"included in the project stub created by the Maven archetype."
msgstr ""
"如果提供了离线 UI, 那么需要在 UI 的初始化处理中启用这个离线 UI, 详情请参见 "
"<xref linkend=\"mobile.offline\"/>. 这段代码已经包含在由 Maven archetype 自动"
"创建的工程框架代码中了."

#. Tag: title
#: chapter-mobile.xml:916
#, no-c-format
msgid "Mobile Widget Set"
msgstr "移动设备 Widget Set"

#. Tag: para
#: chapter-mobile.xml:918
#, no-c-format
msgid ""
"TouchKit includes a widget set and therefore requires compiling a project "
"widget set that includes it, as described in <xref linkend=\"addons\"/>. The "
"project widget set descriptor is automatically generated during the "
"compilation process, whether you use Maven or the Eclipse plugin."
msgstr ""
"TouchKit 包含 Widget Set, 因此需要为你的工程编译 Widget Set, 将 TouchKit 的 "
"Widget Set 包含在内, 详情请参见 <xref linkend=\"addons\"/>. 无论你使用 Maven "
"还是 Eclipse plugin, 编译过程中都会自动产生工程 Widget Set 的描述文件."

#. Tag: para
#: chapter-mobile.xml:926
#, no-c-format
msgid ""
"Note that if you have a TouchKit UI in the same project as a non-TouchKit "
"UI, you probably do not want to compile the TouchKit widget set into its "
"widget set. As the automatic generation of the descriptor includes all the "
"widget sets that it finds from the class path, the result can be unwanted, "
"and you need to edit the widget set descriptor manually."
msgstr ""
"注意, 如果你在非 TouchKit UI 的工程内使用了一部分 TouchKit UI, 你可能不希望"
"将 TouchKit 的 Widget Set 编译到工程的 Widget Set 内. 由于自动生成的 Widget "
"Set 描述文件会包含它在类路径中发现的一切 Widget Set, 因此结果可能是你不希望"
"的, 这时你需要手工编辑 Widget Set 描述文件."

#. Tag: title
#: chapter-mobile.xml:936
#, no-c-format
msgid "Mobile Theme"
msgstr "移动设备 Theme"

#. Tag: para
#: chapter-mobile.xml:938
#, no-c-format
msgid ""
"You can use both Sass and CSS themes for TouchKit applications, although "
"they are defined a bit differently from regular Vaadin themes. To optimize "
"how a theme is loaded, you can build it into a GWT client bundle."
msgstr ""
"对于 TouchKit 应用程序, Sass 和 CSS 格式的 Theme 都可以使用, 虽然他们的定义方"
"式与通常的 Vaadin Theme 略有不同. 为了优化 Theme 的装载过程, 你可以将 Theme "
"构建到 GWT client bundle 之内."

#. Tag: title
#: chapter-mobile.xml:945
#, no-c-format
msgid "Defining a Regular Theme"
msgstr "定义一个通常的 Theme"

#. Tag: para
#: chapter-mobile.xml:947
#, no-c-format
msgid ""
"Using plain CSS is often the easiest way to define a simple theme for a "
"mobile application, as using Sass would not yield all the same benefits as "
"in a regular Vaadin application. TouchKit includes its own base theme in its "
"widget set, so you do not need to <literal>@import</literal> it explicitly."
msgstr ""
"为移动设备应用程序定义一个简单的 Theme, 最简单的方式通常是使用单纯的 CSS, 因"
"为使用 Sass 将无法象在通常的 Vaadin 应用程序中那样得到同样的益处. TouchKit "
"的 Widget Set 中包含了它自己的基础 Theme, 因此你不需要显式地 "
"<literal>@import</literal> 它."

#. Tag: para
#: chapter-mobile.xml:955
#, no-c-format
msgid ""
"A CSS theme is defined in a file located at <filename>VAADIN/themes/"
"mymobiletheme/styles.css</filename>. As importing the base does not need to "
"(and should not) be done, it could simply be as follows:"
msgstr ""
"CSS Theme 定义在 <filename>VAADIN/themes/mymobiletheme/styles.css</filename> "
"文件中. 由于不需要(而且不应该) import 基础 Theme, 因此 CSS Theme 文件可以非常"
"简单, 如下例:"

#. Tag: programlisting
#: chapter-mobile.xml:962
#, no-c-format
msgid ""
"<![CDATA[.stylishlabel {\n"
"    color: red;\n"
"    font-style: italic;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:964
#, no-c-format
msgid ""
"You need to set the theme with the <literal>@Theme(\"mymobiletheme\")</"
"literal> annotation for your UI class, as usual."
msgstr ""
"和通常一样, 你需要在你的 UI 类中使用 <literal>@Theme(\"mymobiletheme\")</"
"literal> 注解来设置 Theme."

#. Tag: para
#: chapter-mobile.xml:970
#, no-c-format
msgid ""
"You can also use Sass by creating a <filename>styles.scss</filename> and "
"then compiling it to CSS with the Vaadin theme compiler. However, as above, "
"you should not include a base theme. The rules do not need to be wrapped in "
"a selector with the theme name, as is recommended for regular Vaadin themes."
msgstr ""
"你也可以使用 Sass, 首先创建 <filename>styles.scss</filename> 文件, 然后使用 "
"Vaadin Theme 编译器将它编译为 CSS. 但是, 如上文所说, 你不应该 include 基础 "
"Theme. CSS 规则不需要包装在 Theme 名称选择器之中, 但在通常的 Vaadin Theme 中"
"是需要这样做的."

#. Tag: title
#: chapter-mobile.xml:980
#, no-c-format
msgid "Responsive Mobile Themes"
msgstr "Responsive 移动设备 Theme"

#. Tag: para
#: chapter-mobile.xml:982
#, no-c-format
msgid ""
"The Responsive add-on is especially useful for mobile themes, as it makes it "
"easy to adapt a layout for phones and tablets and for changing the screen "
"orientation. With the add-on, changing the UI layout according to screen "
"orientation is handled entirely on the client-side by the add-on, using "
"special CSS selectors in the theme. See <xref linkend=\"themes.responsive\"/"
"> for details about the add-on."
msgstr ""
"Responsive add-on 对于移动设备 Theme 非常有用, 因为通过它, 应用程序可以很方便"
"地适应手机和平板上的不同布局, 而且可以适应屏幕方向的旋转. 使用这个 add-on, 当"
"屏幕旋转方向变化时, 相应的 UI 布局变化, 完全由这个 add-on 在客户端处理, 使用 "
"Theme 中的特殊的 CSS 选择器实现. 关于这个 add-on, 详情请参见 <xref linkend="
"\"themes.responsive\"/>."

#. Tag: para
#: chapter-mobile.xml:992
#, no-c-format
msgid ""
"The Parking Demo uses the add-on. From its source code, which is available "
"at Github, you can learn how the conditional selectors are used in the <link "
"xlink:href=\"https://github.com/vaadin/parking-demo/tree/master/src/main/"
"resources/com/vaadin/demo/parking/widgetset/client/theme\">CSS defined in a "
"GWT client bundle</link>."
msgstr ""
"Parking 示例程序使用了这个 add-on. 通过它的源代码(在 Github 上可以得到), 你可"
"以学习如何使用条件选择器: <link xlink:href=\"https://github.com/vaadin/"
"parking-demo/tree/master/src/main/resources/com/vaadin/demo/parking/"
"widgetset/client/theme\">GWT 客户端 bundle 中定义的 CSS</link>."

#. Tag: para
#: chapter-mobile.xml:1000
#, no-c-format
msgid ""
"For example, the CSS for the <guilabel>Stats</guilabel> tab in the Parking "
"demo defines a responsive selector as follows, to allow fitting two charts "
"side-by-side if there is enough room horizontally:"
msgstr ""
"比如, Parking 示例程序中 <guilabel>Stats</guilabel> tab 的 CSS, 定义了一个条"
"件式的选择器, 如下所示, 目的是如果水平方向的空间足够时, 将两个图表并排显示:"

#. Tag: programlisting
#: chapter-mobile.xml:1006
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[.stats .statschart {\n"
"    margin-bottom: 30px;\n"
"    float: left;\n"
"    width: 100%;\n"
"}\n"
"\n"
".v-ui[width-range~=\"801px-\"] .stats .statschart {\n"
"    width: 48% !important;\n"
"    margin: 0 1%;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1008
#, no-c-format
msgid ""
"Normally, if there's 800 pixels or less space horizontally, each chart takes "
"100% of the screen width, causing the second one to wrap to the next line in "
"the containing <classname>CssLayout</classname>. If there is more space, the "
"two charts are shown in 48% width, so that both can fit in the same line. "
"<phrase condition=\"web\">This follows the flexible wrapping pattern "
"described in <xref linkend=\"themes.responsive.wrap\"/>.</phrase>"
msgstr ""
"通常, 如果屏幕水平宽度为 800 像素或更低, 那么每个图表都将占据 100% 的宽度, 因"
"此第二个图表会折行, 显示在 <classname>CssLayout</classname> 容器中的下一行. "
"如果宽度超过 800 像素, 两个图表都会占据 48% 宽度, 因此它们都会显示在同一行"
"内. <phrase condition=\"web\">这种方式遵循灵活折行模式, 关于这种模式, 详情请"
"参见 <xref linkend=\"themes.responsive.wrap\"/>.</phrase>"

#. Tag: title
#: chapter-mobile.xml:1020
#, no-c-format
msgid "Defining a Theme in a GWT Client Bundle"
msgstr "在 GWT Client Bundle 中定义 Theme"

#. Tag: para
#: chapter-mobile.xml:1022
#, no-c-format
msgid ""
"Using a GWT theme instead of a regular Vaadin theme offers several "
"performance benefits on mobile devices by reducing the number of resources "
"loaded separately. All the resources, such as images and stylesheets, can be "
"loaded with the widget set. Images can be handled as sprites tiled in bundle "
"images."
msgstr ""
"使用 GWT Theme 而不是通常的 Vaadin Theme, 这种方式会在移动设备上带来一些性能"
"上的益处, 因为可以减少装载的资源数量. 所有的资源, 比如图片, 样式表, 都可以和 "
"Widget Set 一起装载. 图片可以作为平铺(tile)在 Bundle 图片中的精灵(sprite)来处"
"理."

#. Tag: para
#: chapter-mobile.xml:1030
#, no-c-format
msgid ""
"The GWT CSS classes have their own special format, a bit similar to Sass "
"themes. See <link xlink:href=\"https://developers.google.com/web-toolkit/doc/"
"latest/DevGuideClientBundle\">GWT Developer's Guide for detailed information "
"about client bundles</link> and how to define image, CSS, and other "
"resources."
msgstr ""
"GWT CSS 中的类有它们独有的格式, 与 Sass Theme 有些类似. 关于 Client Bundle, "
"以及如何定义图片, CSS, 以及其他资源, 详情请参见 <link xlink:href=\"https://"
"developers.google.com/web-toolkit/doc/latest/DevGuideClientBundle\">GWT "
"Developer's Guide</link>."

#. Tag: para
#: chapter-mobile.xml:1038
#, no-c-format
msgid ""
"To use a GWT client bundle in a TouchKit application, you need to define a "
"<emphasis>theme loader</emphasis> that extends the TouchKit "
"<classname>ThemeLoader</classname> and implements the <methodname>load()</"
"methodname> method to inject the bundle. The theme loader and the client "
"bundle are a client-side classes that are compiled into the widget set, and "
"must therefore be defined under the <filename>client</filename> directory."
msgstr ""
"要在 TouchKit 应用程序中使用 GWT Client Bundle, 你需要定义一个 "
"<emphasis>Theme 装载器</emphasis>, 它继承自 TouchKit <classname>ThemeLoader</"
"classname> 类, 并实现 <methodname>load()</methodname> 方法来注入 Bundle. "
"Theme 装载器和 Client Bundle 都是客户端类, 会被编译进入 Widget Set, 因此必须"
"定义在 <filename>client</filename> 目录之下."

#. Tag: para
#: chapter-mobile.xml:1048
#, no-c-format
msgid "For example, in the Parking Demo we have as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-mobile.xml:1052
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class ParkingThemeLoader extends "
"ThemeLoader {\n"
"    @Override\n"
"    public final void load() {\n"
"        // First load the default TouchKit theme...\n"
"        super.load();\n"
"\n"
"        // ... and add Parking Demo CSS from its own bundle\n"
"        ParkingBundle.INSTANCE.fontsCss().ensureInjected();\n"
"        ParkingBundle.INSTANCE.css().ensureInjected();\n"
"        ParkingBundle.INSTANCE.ticketsCss().ensureInjected();\n"
"        ParkingBundle.INSTANCE.statsCss().ensureInjected();\n"
"        ParkingBundle.INSTANCE.shiftsCss().ensureInjected();\n"
"        ParkingBundle.INSTANCE.mapCss().ensureInjected();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1054
#, no-c-format
msgid ""
"You can call <methodname>super.load()</methodname> to load the default "
"TouchKit theme, but you can omit the call if you do not want to use it. In "
"such case, your GWT theme should import the Vaadin base theme explicitly."
msgstr ""
"你可以调用 <methodname>super.load()</methodname> 方法来装载默认的 TouchKit "
"Theme, 但如果你不希望使用这个 Theme, 也可以省略这个调用. 这种情况下, 你的 "
"GWT Theme 就应该显式地 import Vaadin 的基础 Theme."

#. Tag: para
#: chapter-mobile.xml:1061
#, no-c-format
msgid ""
"The theme loader must be defined in the <filename>.gwt.xml</filename> widget "
"set descriptor as follows:"
msgstr ""
"Theme 装载器必须在 <filename>.gwt.xml</filename> Widget Set 描述文件中定义如"
"下:"

#. Tag: programlisting
#: chapter-mobile.xml:1066
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;replace-with\n"
"    class=\"<emphasis role=\"bold\">com.vaadin.demo.parking.widgetset.client."
"theme.ParkingThemeLoader</emphasis>\"&gt;\n"
"    &lt;when-type-is\n"
"        class=\"com.vaadin.addon.touchkit.gwt.client.ThemeLoader\" /&gt;\n"
"&lt;/replace-with&gt;"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1068
#, no-c-format
msgid ""
"See the Parking Demo sources for a complete example of defining a GWT theme."
msgstr "关于如何定义 GWT theme, 完整的例子请参见 Parking 示例程序的源代码."

#. Tag: title
#: chapter-mobile.xml:1076
#, no-c-format
msgid "Using Font Icons"
msgstr "使用字体图标"

#. Tag: para
#: chapter-mobile.xml:1078
#, no-c-format
msgid ""
"You can use font icons, as described in <xref linkend=\"themes.fonticon\"/>, "
"also with most TouchKit components."
msgstr ""
"在大多数 TouchKit 组件中, 你也可以使用字体图标, 详情请参见 <xref linkend="
"\"themes.fonticon\"/>."

#. Tag: title
#: chapter-mobile.xml:1084
#, no-c-format
msgid "Font Icons in <classname>TabBarView</classname>"
msgstr "<classname>TabBarView</classname> 中的字体图标"

#. Tag: para
#: chapter-mobile.xml:1092
#, no-c-format
msgid ""
"For example, as is done in the UI stub of a TouchKit project created from "
"the Maven archetype:"
msgstr "比如, 通过 Maven archetype 创建的工程中, UI 框架代码是这样实现的:"

#. Tag: programlisting
#: chapter-mobile.xml:1097
#, no-c-format
msgid ""
"<![CDATA[// Have a tab bar with multiple tab views\n"
"TabBarView tabBarView = new TabBarView();\n"
"\n"
"// Have a tab\n"
"... create view1 ...\n"
"Tab tab1 = tabBarView.addTab(view1);\n"
"\n"
"// Use the \"book\" icon for the tab\n"
"tab1.setIcon(FontAwesome.BOOK);]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:1102
#, no-c-format
msgid "Mobile User Interface Components"
msgstr "移动设备 UI 组件"

#. Tag: para
#: chapter-mobile.xml:1104
#, no-c-format
msgid ""
"TouchKit introduces a number of components special to mobile user interfaces "
"to give better user interaction and to utilize the special features in "
"mobile devices."
msgstr ""
"为了实现更好的用户交互, 也为了使用移动设备的各种特殊功能, TouchKit 引入了很多"
"移动设备 UI 的专用组件."

#. Tag: classname
#: chapter-mobile.xml:1112 chapter-mobile.xml:1221
#, no-c-format
msgid "NavigationView"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1114
#, no-c-format
msgid ""
"A view with a navigation bar (<classname>NavigationBar</classname> for "
"navigating back and forth in a <classname>NavigationManager</classname>."
msgstr ""
"带导航条的视图. (<classname>NavigationBar</classname> 类可以在 "
"<classname>NavigationManager</classname> 内回退和前进)."

#. Tag: classname
#: chapter-mobile.xml:1122 chapter-mobile.xml:1319
#, no-c-format
msgid "<classname>Toolbar</classname>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1124
#, no-c-format
msgid ""
"A horizontal layout especially for buttons. A sub-component of "
"<classname>TabBarView</classname> or <classname>NavigationView</classname>."
msgstr ""
"一个水平布局, 专用于排列按钮. 用作 <classname>TabBarView</classname> 或 "
"<classname>NavigationView</classname> 中的子组件."

#. Tag: classname
#: chapter-mobile.xml:1132 chapter-mobile.xml:1349
#, no-c-format
msgid "NavigationManager"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1134
#, no-c-format
msgid ""
"A component container that enables slide animations between the components "
"while the server request is being made for the purpose of latency "
"compensation. The components are typically <classname>NavigationView</"
"classname>s or <classname>SwipeView</classname>s."
msgstr ""
"一个组件容器, 向服务器发送请求时, 为了解决服务器响应延迟问题, 它会在组件切换"
"之间的等待过程中显示滑动式动画效果. 这个容器内的组件通常是 "
"<classname>NavigationView</classname> 或 <classname>SwipeView</classname>."

#. Tag: classname
#: chapter-mobile.xml:1144 chapter-mobile.xml:1468
#, no-c-format
msgid "NavigationButton"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1146
#, no-c-format
msgid ""
"A special button for initiating view change in a "
"<classname>NavigationManager</classname> on the client-side, for the purpose "
"of latency compensation."
msgstr ""
"一个特殊的按钮, 它在客户端触发 <classname>NavigationManager</classname> 内的"
"视图切换, 用于解决服务器响应延迟问题."

#. Tag: classname
#: chapter-mobile.xml:1154 chapter-mobile.xml:1571
#, no-c-format
msgid "Popover"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1156
#, no-c-format
msgid "A floating pop-up frame that can be positioned relative to a component."
msgstr "一个浮动的, 弹出式 frame, 可以使用组件的相对位置来定位."

#. Tag: classname
#: chapter-mobile.xml:1162 chapter-mobile.xml:1669
#, no-c-format
msgid "SwipeView"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1164
#, no-c-format
msgid ""
"A view for navigating back and forth in a <classname>NavigationManager</"
"classname> using horizontal swipe gestures."
msgstr ""
"一种视图, 使用水平滑动手势, 在 <classname>NavigationManager</classname> 内回"
"退或前进."

#. Tag: classname
#: chapter-mobile.xml:1172 chapter-mobile.xml:1708 chapter-mobile.xml:1732
#, no-c-format
msgid "Switch"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1174
#, no-c-format
msgid "A sliding on/off toggle for boolean values."
msgstr "一种滑动式 on/off 切换按钮, 用于输入布尔值."

#. Tag: classname
#: chapter-mobile.xml:1180 chapter-mobile.xml:1753 chapter-mobile.xml:1771
#, no-c-format
msgid "VerticalComponentGroup"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1182
#, no-c-format
msgid "A vertical layout for grouping components."
msgstr "一种垂直布局, 用于组件分组."

#. Tag: classname
#: chapter-mobile.xml:1188 chapter-mobile.xml:1793 chapter-mobile.xml:1809
#, no-c-format
msgid "HorizontalButtonGroup"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1190
#, no-c-format
msgid "A horizontal layout for grouping especially buttons."
msgstr "一种水平布局, 用于特殊按钮的分组."

#. Tag: classname
#: chapter-mobile.xml:1196 chapter-mobile.xml:1846
#, no-c-format
msgid "TabBarView"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1198
#, no-c-format
msgid ""
"A tabbed view with a content area on the top and a <classname>Toolbar</"
"classname> for navigating between sub-views on the bottom."
msgstr ""
"一种 tab 分页视图, 它的内容区域位于上方, 用于在各 tab 子视图之间切换的 "
"<classname>Toolbar</classname> 位于下方."

#. Tag: term
#: chapter-mobile.xml:1206
#, no-c-format
msgid ""
"<classname>EmailField</classname>, <classname>NumberField</classname>, and "
"<classname>UrlField</classname>"
msgstr ""
"<classname>EmailField</classname>, <classname>NumberField</classname>, 以及 "
"<classname>UrlField</classname>"

#. Tag: para
#: chapter-mobile.xml:1208
#, no-c-format
msgid ""
"Text fields for inputting specifically email addresses, numbers, and URLs, "
"respectively, with a specific virtual keyboard."
msgstr "文本输入组件, 使用特殊的虚拟键盘, 分别输入 EMail 地址, 数字, 以及 URL."

#. Tag: para
#: chapter-mobile.xml:1216
#, no-c-format
msgid "The components are detailed in the following subsections."
msgstr "以上各组件的细节, 将在后续小节中详情介绍."

#. Tag: para
#: chapter-mobile.xml:1223
#, no-c-format
msgid ""
"The <classname>NavigationView</classname> is a layout component that "
"consists of a navigation bar and a content area. The content area is "
"scrollable, so there is no need to use an inner panel component. In "
"addition, there can be an optional toolbar component at the bottom of the "
"view. A <classname>NavigationView</classname> is often used inside a "
"<classname>NavigationManager</classname> to get view change animations."
msgstr ""
"<classname>NavigationView</classname> 是一个布局组件, 其中包含一个导航条和一"
"个内容区域. 内容区域是可以滚动的, 因此不必再内嵌一个 panel 组件. 此外, 在 "
"View 的底部还可以有一个可选的 toolbar 组件. <classname>NavigationView</"
"classname> 通常用在 <classname>NavigationManager</classname> 之内, 以便得到视"
"图变化时的动画效果."

#. Tag: title
#: chapter-mobile.xml:1233
#, no-c-format
msgid "Layout of the <classname>NavigationView</classname>"
msgstr "<classname>NavigationView</classname> 的布局"

#. Tag: para
#: chapter-mobile.xml:1244
#, no-c-format
msgid ""
"<classname>NavigationView</classname> has a full size by default. The "
"content area is expanding, so that it takes all the space left over from the "
"navigation bar and toolbar."
msgstr ""
"<classname>NavigationView</classname> 默认为全尺寸. 内容区域会扩展, 占据导航"
"条和工具条之外的所有空间."

#. Tag: title
#: chapter-mobile.xml:1251
#, no-c-format
msgid "Navigation Bar"
msgstr "导航条"

#. Tag: para
#: chapter-mobile.xml:1253
#, no-c-format
msgid ""
"The navigation bar at the top of <classname>NavigationView</classname> is a "
"separate <classname>NavigationBar</classname> component. It has two "
"component slots, with one on the left and one on the right. The caption is "
"displayed in the middle. The <classname>NavigationBar</classname> component "
"can be used independently as well."
msgstr ""
"<classname>NavigationView</classname> 上部的导航条是一个独立的 "
"<classname>NavigationBar</classname> 组件. 其中包含两个组件区域, 左侧和右侧各"
"有一个. 标题将显示在中间. <classname>NavigationBar</classname> 组件也可以单独"
"使用."

#. Tag: para
#: chapter-mobile.xml:1262
#, no-c-format
msgid ""
"When the <classname>NavigationBar</classname> is used for navigation and you "
"set the previous component with <methodname>setPreviousComponent()</"
"methodname>, the left slot is automatically filled with a <guibutton>Back</"
"guibutton> button. This is done automatically if you use the "
"<classname>NavigationView</classname> inside a <classname>NavigationManager</"
"classname>."
msgstr ""
"当使用 <classname>NavigationBar</classname> 来控制导航, 并且使用 "
"<methodname>setPreviousComponent()</methodname> 方法设置了前一个组件, 那么左"
"侧的组件区域会自动出现一个 <guibutton>Back</guibutton> 按钮. 如果你在 "
"<classname>NavigationManager</classname> 之内使用 <classname>NavigationView</"
"classname>, 这个动作将会自动完成."

#. Tag: para
#: chapter-mobile.xml:1271
#, no-c-format
msgid ""
"You can get access to the navigation bar component with "
"<methodname>getNavigationBar()</methodname> to use its manipulator methods "
"directly, but <classname>NavigationView</classname> also offers some "
"shorthand methods: <methodname>setLeftComponent()</methodname>, "
"<methodname>setRightComponent()</methodname>, and a setter and a getter for "
"the caption."
msgstr ""
"你可以通过 <methodname>getNavigationBar()</methodname> 方法得到导航条组件, 以"
"便直接调用它的控制方法, 但 <classname>NavigationView</classname> 也提供了一些"
"快捷方法: <methodname>setLeftComponent()</methodname>, "
"<methodname>setRightComponent()</methodname>, 以及标题属性的 set 和 get 方法."

#. Tag: title
#: chapter-mobile.xml:1282
#, no-c-format
msgid "<title>Toolbar</title>"
msgstr "<title>工具条</title>"

#. Tag: para
#: chapter-mobile.xml:1284
#, no-c-format
msgid ""
"A slot for an optional toolbar is located at the bottom of the "
"<classname>NavigationView</classname>. The toolbar can be any component, but "
"a <classname>Toolbar</classname> component made for this purpose is included "
"in TouchKit. It is described in <xref linkend=\"mobile.components.toolbar\"/"
">. You could also use a <classname>HorizontalLayout</classname> or "
"<classname>CssLayout</classname>."
msgstr ""
"可选的工具条区域位于 <classname>NavigationView</classname> 的底部. 工具条可以"
"是任意组件, 但 TouchKit 提供了 <classname>Toolbar</classname> 组件专用于实现"
"工具条. 关于这个组件, 详情请参见 <xref linkend=\"mobile.components.toolbar\"/"
">. 你也可以使用 <classname>HorizontalLayout</classname> 或 "
"<classname>CssLayout</classname> 作为工具条."

#. Tag: para
#: chapter-mobile.xml:1294
#, no-c-format
msgid ""
"You usually fill the tool bar with <classname>Button</classname> components "
"with an icon and no textual caption. You set the toolbar with "
"<methodname>setToolbar()</methodname>."
msgstr ""
"工具条中的内容通常会使用有图标无标题的 <classname>Button</classname> 组件. 可"
"以通过 <methodname>setToolbar()</methodname> 方法来设置工具条."

#. Tag: title
#: chapter-mobile.xml:1302 chapter-mobile.xml:1337 chapter-mobile.xml:1544
#: chapter-mobile.xml:1655 chapter-mobile.xml:1741 chapter-mobile.xml:1780
#: chapter-mobile.xml:1832 chapter-mobile.xml:1902 chapter-mobile.xml:1938
#: chapter-mobile.xml:1972 chapter-mobile.xml:1999
#, no-c-format
msgid "Styling with CSS"
msgstr "使用 CSS 控制样式"

#. Tag: programlisting
#: chapter-mobile.xml:1304
#, no-c-format
msgid ""
"<![CDATA[.v-touchkit-navview { }\n"
"  .v-touchkit-navview-wrapper {}\n"
"  .v-touchkit-navview-toolbar {}\n"
".v-touchkit-navview .v-touchkit-navview-notoolbar {}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1306
#, no-c-format
msgid ""
"The root element has the <literal>v-touchkit-navview</literal> class. The "
"content area is wrapped inside a <literal>v-touchkit-navview-wrapper</"
"literal> element. If the view has a toolbar, the toolbar slot has the "
"<literal>v-touchkit-navview-toolbar</literal> style, but if not, the top-"
"level element has the <literal>v-touchkit-navview-notoolbar</literal> style."
msgstr ""
"根元素带有 <literal>v-touchkit-navview</literal> 样式. 内容区域封装在 "
"<literal>v-touchkit-navview-wrapper</literal> 样式元素之内. 如果 View 带有工"
"具条, 工具条区域将带有 <literal>v-touchkit-navview-toolbar</literal> 样式, 但"
"如果没有, 则最顶层元素将带有 <literal>v-touchkit-navview-notoolbar</literal> "
"样式."

#. Tag: para
#: chapter-mobile.xml:1321
#, no-c-format
msgid ""
"The <classname>Toolbar</classname> is a horizontal layout component intended "
"for containing <classname>Button</classname> components. The toolbar has by "
"default 100% horizontal width and a fixed height. The components are spread "
"evenly in the horizontal direction. <classname>Toolbar</classname> is used "
"in a <classname>TabBarView</classname>, as described in <xref linkend="
"\"mobile.components.tabbarview\" xrefstyle=\"select:label\"/>."
msgstr ""
"<classname>Toolbar</classname> 是一个水平布局组件, 用于容纳 "
"<classname>Button</classname> 组件. 工具条默认占据 100% 宽度, 并带有固定高"
"度. 内部的子组件将在水平方向上平均分布. <classname>Toolbar</classname> 会在 "
"<classname>TabBarView</classname> 之内使用, 详情请参见 <xref linkend="
"\"mobile.components.tabbarview\" xrefstyle=\"select:label\"/>."

#. Tag: para
#: chapter-mobile.xml:1331
#, no-c-format
msgid ""
"For a description of the inherited features, please refer to <xref linkend="
"\"layout.orderedlayout\"/>."
msgstr ""
"关于这个组件从父类中集成得到的功能, 详情请参见 <xref linkend=\"layout."
"orderedlayout\"/>."

#. Tag: programlisting
#: chapter-mobile.xml:1339
#, no-c-format
msgid "<![CDATA[.v-touchkit-toolbar { }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1341
#, no-c-format
msgid ""
"The component has an overall <literal>v-touchkit-toolbar</literal> style."
msgstr "这个组件的最外层样式为 <literal>v-touchkit-toolbar</literal>."

#. Tag: para
#: chapter-mobile.xml:1351
#, no-c-format
msgid ""
"The <classname>NavigationManager</classname> is a visual effect component "
"that gives sliding animation when switching between views. You can register "
"three components: the currently displayed component, the previous one on the "
"left, and the next component on the right. You can set these components with "
"<methodname>setCurrentComponent()</methodname>, "
"<methodname>setPreviousComponent()</methodname>, and "
"<methodname>setNextComponent()</methodname>, respectively."
msgstr ""
"<classname>NavigationManager</classname> 是一个视觉效果组件, 在多个视图间切换"
"时显示滑动式动画效果. 你可以注册三个组件: 当前显示的组件, 位于左侧的前一个组"
"件, 位于右侧的下一个组件. 你可以使用 <methodname>setCurrentComponent()</"
"methodname>, <methodname>setPreviousComponent()</methodname>, 和 "
"<methodname>setNextComponent()</methodname> 方法设置这些组件."

#. Tag: para
#: chapter-mobile.xml:1361
#, no-c-format
msgid ""
"The <classname>NavigationManager</classname> component is illustrated in "
"<xref linkend=\"figure.mobile.components.navigationpanel\"/>."
msgstr ""
"<classname>NavigationManager</classname> 组件见 <xref linkend=\"figure."
"mobile.components.navigationpanel\"/>."

#. Tag: title
#: chapter-mobile.xml:1367
#, no-c-format
msgid ""
"<classname>NavigationManager</classname> with Three "
"<classname>NavigationView</classname>s"
msgstr ""
"包含三个 <classname>NavigationView</classname> 的 "
"<classname>NavigationManager</classname>"

#. Tag: para
#: chapter-mobile.xml:1378
#, no-c-format
msgid ""
"The navigation manager is important for responsiveness, because the previous "
"and next components are cached and the slide animation started before server "
"is contacted to load the new next or previous views."
msgstr ""
"导航管理器对于提高应用程序的相应速度是很重要的, 因为前一个和后一个组件已存在"
"于缓存中, 而且在访问服务器, 装载新的前一个或后一个组件时, 还会显示滑动式动画"
"效果."

#. Tag: para
#: chapter-mobile.xml:1384
#, no-c-format
msgid ""
"You give the initial view as a parameter for the constructor. Typically, you "
"use a navigation manager as the UI content or inside a "
"<classname>TabBarView</classname>."
msgstr ""
"你需要在这个组件的构造函数中用参数指定初始视图. 通常会将导航管理器用作 UI 内"
"容, 或者用在 <classname>TabBarView</classname> 之内."

#. Tag: programlisting
#: chapter-mobile.xml:1390
#, no-c-format
msgid ""
"<![CDATA[public class MyUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        NavigationManager manager =\n"
"               new NavigationManager(new MainView());\n"
"        setContent(manager);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:1393
#, no-c-format
msgid "Changing Views"
msgstr "切换视图"

#. Tag: para
#: chapter-mobile.xml:1395
#, no-c-format
msgid ""
"Switching between the views (components) is normally done with predefined "
"navigation targets to enhance responsiveness. Clicking a "
"<classname>NavigationButton</classname> or a button in a navigation bar "
"starts navigation automatically without a server roundtrip. Swipe gestures "
"are supported with the <classname>SwipeView</classname> component."
msgstr ""
"在多个视图(组件)之间切换, 通常使用预定义的导航目标来实现, 以便提高相应速度. "
"点击 <classname>NavigationButton</classname>, 也就是导航条上的按钮, 会自动启"
"动导航跳转, 而不必发起一次服务器请求. 屏幕滑动手势通过 <classname>SwipeView</"
"classname> 组件来支持."

#. Tag: para
#: chapter-mobile.xml:1404
#, no-c-format
msgid ""
"Navigation can also be done programmatically with the "
"<methodname>navigateTo()</methodname> method. If breadcrumbs are enabled, "
"the current view is also pushed to the breadcrumb stack. To navigate back, "
"you can call <methodname>navigateBack()</methodname>, which is also called "
"implicitly if a <guibutton>Back</guibutton> button is clicked in a "
"<classname>NavigationView</classname>. Also, if navigation is done to the "
"\"previous\" component, <methodname>navigateBack()</methodname> is done "
"implicitly."
msgstr ""
"导航跳转也可以使用 <methodname>navigateTo()</methodname> 方法编程实现. 如果启"
"动了面包屑导航(Breadcrumb), 那么当前视图也会被压入到面包屑导航的历史堆栈中. "
"要回退跳转, 你可以调用 <methodname>navigateBack()</methodname> 方法, 如果在 "
"<classname>NavigationView</classname> 之内点击了 <guibutton>Back</guibutton> "
"按钮, 也会隐含地调用这个方法. 而且, 如果导航跳转到了 \"前一个\" 组件, 实际上"
"就是隐含地调用了 <methodname>navigateBack()</methodname> 方法."

#. Tag: para
#: chapter-mobile.xml:1415
#, no-c-format
msgid ""
"When navigation occurs, the current component is moved as the previous or "
"next component, according to the direction of the navigation."
msgstr ""
"当导航跳转发生时, 当前组件会被移动, 变为前一个或后一个组件, 具体变为哪一个, "
"取决于跳转方向是向前还是向后."

#. Tag: title
#: chapter-mobile.xml:1422
#, no-c-format
msgid "Handling View Changes"
msgstr "处理视图变化事件"

#. Tag: para
#: chapter-mobile.xml:1424
#, no-c-format
msgid ""
"While you can put any components in the manager, some special features are "
"enabled when using the <classname>NavigationView</classname>. When a view "
"becomes visible, the <methodname>onBecomingVisible()</methodname> method in "
"the view is called. You can override it, just remember to call the "
"superclass method."
msgstr ""
"你可以向导航管理器添加任何类型的组件, 但如果使用 <classname>NavigationView</"
"classname>, 可以启用一些特殊功能. 当一个视图变为可见时, 这个视图的 "
"<methodname>onBecomingVisible()</methodname> 方法会被调用. 你可以重载这个方"
"法, 但要记得调用父类的方法."

#. Tag: programlisting
#: chapter-mobile.xml:1432
#, no-c-format
msgid ""
"<![CDATA[@Override\n"
"protected void onBecomingVisible() {\n"
"    super.onBecomingVisible();\n"
"\n"
"    ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1434
#, no-c-format
msgid ""
"Otherwise, you can handle navigation changes in the manager with a "
"<interfacename>NavigationListener</interfacename>. The <parameter>direction</"
"parameter> property tells whether the navigation was done forward or "
"backward in the breadcrumb stack, that is, whether navigation was done with "
"<methodname>navigateTo()</methodname> or <methodname>navigateBack</"
"methodname>. The current component, accessible with "
"<methodname>getCurrentComponent()</methodname>, refers to the navigation "
"target component."
msgstr ""
"此外, 你还可以使用 <interfacename>NavigationListener</interfacename> 来处理导"
"航管理器中的跳转变更事件. <parameter>direction</parameter> 属性可用来判断在面"
"包屑导航历史堆栈中的跳转方向是向前还是向后, 也就是, 导航跳转是 "
"<methodname>navigateTo()</methodname> 还是 <methodname>navigateBack</"
"methodname>. 当前组件, 可以通过 <methodname>getCurrentComponent()</"
"methodname> 方法得到, 得到的结果指向导航跳转的目标组件."

#. Tag: programlisting
#: chapter-mobile.xml:1445
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[manager.addNavigationListener(new "
"NavigationListener() {\n"
"    @Override\n"
"    public void navigate(NavigationEvent event) {\n"
"        if (event.getDirection() ==\n"
"                NavigationEvent.Direction.BACK) {\n"
"            // Do something\n"
"            Notification.show(\"You came back to \" +\n"
"                manager.getCurrentComponent().getCaption());\n"
"        }\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:1449
#, no-c-format
msgid "Tracking Breadcrumbs"
msgstr "追踪面包屑导航历史"

#. Tag: para
#: chapter-mobile.xml:1451
#, no-c-format
msgid ""
"<classname>NavigationManager</classname> also handles <emphasis>breadcrumb</"
"emphasis> tracking. The <methodname>navigateTo()</methodname> pushes the "
"current view on the top of the breadcrumb stack and "
"<methodname>navigateBack()</methodname> can be called to return to the "
"previous breadcrumb level."
msgstr ""
"<classname>NavigationManager</classname> 还会对 <emphasis>面包屑导航</"
"emphasis> 进行追踪. <methodname>navigateTo()</methodname> 方法会将当前视图压"
"入面包屑导航历史堆栈的顶部, 调用 <methodname>navigateBack()</methodname> 方法"
"可以回退到面包屑导航历史的前一级."

#. Tag: para
#: chapter-mobile.xml:1459
#, no-c-format
msgid ""
"Notice that calling <methodname>navigateTo()</methodname> with the \"previous"
"\" component is equivalent to calling <methodname>navigateBack()</"
"methodname>."
msgstr ""
"注意, 以 \"前一个\" 组件为参数调用 <methodname>navigateTo()</methodname> 方"
"法, 等于调用 <methodname>navigateBack()</methodname>."

#. Tag: para
#: chapter-mobile.xml:1470
#, no-c-format
msgid ""
"The <classname>NavigationButton</classname> is a special version of the "
"regular <classname>Button</classname> component, designed for navigation "
"inside a <classname>NavigationManager</classname> (see <xref linkend="
"\"mobile.components.navigationpanel\"/>). Clicking a navigation button will "
"automatically navigate to the defined target view. The view change animation "
"does not need to make a server request first, but starts immediately after "
"clicking the button. If you leave the target view empty, an empty "
"placeholder view is shown in the animation. The view is filled after it gets "
"the content from the server."
msgstr ""
"<classname>NavigationButton</classname> 是通常的 <classname>Button</"
"classname> 组件的一个特殊版本, 用于在 <classname>NavigationManager</"
"classname> 之内导航跳转 (详情请参见 <xref linkend=\"mobile.components."
"navigationpanel\"/>). 点击一个导航按钮会自动跳转到一个预定义的目标视图. 视图"
"切换时的动画效果不必等待服务器请求结束, 可以在按钮点击后立即显示. 如果你没有"
"定义跳转的目标视图, 动画中会显示一个空的占位视图. 当从服务器得到真实内容后, "
"这个内容会填充到视图之内."

#. Tag: para
#: chapter-mobile.xml:1482
#, no-c-format
msgid ""
"A navigation button does not have a particular border by default, because "
"multiple navigation buttons are typically used inside a "
"<classname>VerticalComponentGroup</classname> to create menus, as "
"illustrated in <xref linkend=\"figure.mobile.components.navigationbutton\"/>."
msgstr ""
"导航按钮默认不带边框, 因为通常会在 <classname>VerticalComponentGroup</"
"classname> 内使用多个导航按钮来创建菜单, 见 <xref linkend=\"figure.mobile."
"components.navigationbutton\"/>."

#. Tag: title
#: chapter-mobile.xml:1491
#, no-c-format
msgid ""
"<classname>NavigationButton</classname>s Inside a Vertical Component Group"
msgstr "垂直的组件 Group 内的 <classname>NavigationButton</classname>"

#. Tag: para
#: chapter-mobile.xml:1499
#, no-c-format
msgid ""
"A navigation button has a caption and can have a description and an icon. If "
"not given explicitly, the caption is taken from the caption of the "
"navigation view if it is initialized before the button. The icon is "
"positioned left of the caption, and the description is aligned on the right "
"side of the button."
msgstr ""
"导航按钮带有标题, 也可以有描述信息和图标. 如果导航视图在按钮之前初始化完毕, "
"而且没有明确给出按钮的标题, 那么按钮会使用对应的导航视图的标题. 图标显示在标"
"题左侧, 描述信息在按钮右侧."

#. Tag: para
#: chapter-mobile.xml:1507
#, no-c-format
msgid ""
"You can give the target view either in the constructor or with "
"<methodname>setTargetView()</methodname>, or create it later by handling the "
"button click."
msgstr ""
"你可以通过构造函数来指定跳转的目标视图, 也可以通过 "
"<methodname>setTargetView()</methodname> 方法, 或者在按钮点击事件中再创建视"
"图."

#. Tag: programlisting
#: chapter-mobile.xml:1513
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[// Button caption comes from the view caption\n"
"box.addComponent(new NavigationButton(new PopoverView()));\n"
"\n"
"// Give button caption explicitly\n"
"box.addComponent(new NavigationButton(\"Decorated Popover\",\n"
"                   new DecoratedPopoverView()));]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1515
#, no-c-format
msgid ""
"If the target view is not created or initialized before the button is "
"clicked, it does not yet have a caption during the animation. The default is "
"to use the button caption as a temporary target view caption, but you can "
"set it explicitly with <methodname>setTargetViewCaption()</methodname>. The "
"temporary caption is shown during the slide animation and until the content "
"for the view has been received from the server. It is then replaced with the "
"proper caption of the view, and you normally want to have it the same. The "
"temporary caption is also used as the caption of button if it is not given "
"explicitly."
msgstr ""
"如果在按钮点击之前, 目标视图没有创建或初始化, 那么在视图切换的动画中将没有标"
"题. 默认行为是使用按钮的标题作为目标视图的临时标题, 但你也可以使用 "
"<methodname>setTargetViewCaption()</methodname> 方法明确设置这个标题. 临时标"
"题会在视图切换时的滑动式动画效果显示期间内显示, 直到从服务器端得到视图内容"
"后, 才会消失. 然后会被视图真实的标题替换, 你通常会希望这两个标题相同. 如果导"
"航按钮的标题未被明确指定, 视图的临时标题还会被用作按钮标题."

#. Tag: programlisting
#: chapter-mobile.xml:1528
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[\n"
"final NavigationButton navButton = new NavigationButton();\n"
"navButton.setTargetViewCaption(\"Text Input Fields\");\n"
"navButton.addClickListener(\n"
"    new NavigationButtonClickListener() {\n"
"\n"
"    @Override\n"
"    public void buttonClick(NavigationButtonClickEvent event) {\n"
"        navButton.getNavigationManager()\n"
"            .navigateTo(new FieldView());\n"
"    }\n"
"});\n"
"box.addComponent(navButton);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1530
#, no-c-format
msgid ""
"Creating views dynamically this way is recommended to reduce the memory "
"footprint."
msgstr "我们推荐通过这种方式来动态创建视图, 因为可以减少内存消耗量."

#. Tag: para
#: chapter-mobile.xml:1535
#, no-c-format
msgid ""
"Notice that the automatic navigation will only work if the button is inside "
"a <classname>NavigationManager</classname> (in a view managed by it). If you "
"just want to use the button as a visual element, you can use it like a "
"regular <classname>Button</classname> and handle the click events with a "
"<classname>ClickListener</classname>."
msgstr ""
"注意, 只有按钮在 <classname>NavigationManager</classname> 之内(也就是在它管理"
"的视图之内)时, 自动导航跳转才会有效. 如果你只希望将导航按钮用作一个可视元素, "
"你可以象通常的 <classname>Button</classname> 一样使用它, 并通过 "
"<classname>ClickListener</classname> 来处理它的点击事件."

#. Tag: programlisting
#: chapter-mobile.xml:1546
#, no-c-format
msgid ""
"<![CDATA[.v-touchkit-navbutton { }\n"
"  .v-touchkit-navbutton-desc { }\n"
"  .v-icon { }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1548
#, no-c-format
msgid ""
"The component has an overall <literal>v-touchkit-navbutton</literal> style. "
"If the component description is set with <methodname>setDescription()</"
"methodname>, it is shown in a separate <literal>&lt;span&gt;</literal> "
"element with the <literal>v-touchkit-navbutton-desc</literal> style. The "
"description has an alternative <literal>emphasis</literal> style, as well as "
"a stronger capsule-like <literal>pill</literal> style with rounded corners, "
"which you can enable with <methodname>addStyleName()</methodname>."
msgstr ""
"这个组件的最外层样式是 <literal>v-touchkit-navbutton</literal>. 如果使用 "
"<methodname>setDescription()</methodname> 方法为这个组件设置了描述信息, 描述"
"信息将显示在一个单独的 <literal>&lt;span&gt;</literal> 元素内, 这个元素将带"
"有 <literal>v-touchkit-navbutton-desc</literal> 样式. 描述信息还会带有一个可"
"选的 <literal>emphasis</literal> 样式, 还可以带有一个更粗的, 圆角的, 胶囊形状"
"的 <literal>pill</literal> 样式, 你可以通过 <methodname>addStyleName()</"
"methodname> 方法添加这个样式."

#. Tag: para
#: chapter-mobile.xml:1560
#, no-c-format
msgid ""
"The default style of the navigation button is designed for placing the "
"buttons inside a <classname>VerticalComponentGroup</classname>. It has a "
"different style when it is in a <classname>HorizontalButtonGroup</classname> "
"and when in the left or right slot of the <classname>NavigationBar</"
"classname>."
msgstr ""
"导航按钮默认样式的设计目的, 是为了将按钮放置在 "
"<classname>VerticalComponentGroup</classname> 之内. 当它放置在 "
"<classname>HorizontalButtonGroup</classname> 之内时, 以及在 "
"<classname>NavigationBar</classname> 的左侧或右侧区域时, 都会有不同的样式."

#. Tag: para
#: chapter-mobile.xml:1573
#, no-c-format
msgid ""
"<classname>Popover</classname> is much like a regular Vaadin sub-window, "
"useful for quickly displaying some options or a small form related to an "
"action. Unlike regular sub-windows, it does not support dragging or resizing "
"by the user. As sub-windows usually require a rather large screen size, the "
"<classname>Popover</classname> is most useful for tablet devices. When used "
"on smaller devices, such as phones, the <classname>Popover</classname> "
"automatically fills the entire screen."
msgstr ""
"<classname>Popover</classname> 与通常的 Vaadin 子窗口非常类似, 可以用于快速显"
"示某种选项, 或者与某个动作相关的小的 Form. 与通常的子窗口不同, 它不允许用户拖"
"放位置或拖动大小. 由于子窗口通常需要更大的屏幕尺寸, <classname>Popover</"
"classname> 比子窗口更适合于平板设备. 当在更小的设备上使用时, 比如手机, "
"<classname>Popover</classname> 会自动充满整个屏幕."

#. Tag: title
#: chapter-mobile.xml:1584
#, no-c-format
msgid "<classname>Popover</classname> in a Phone"
msgstr "手机上的 <classname>Popover</classname>"

#. Tag: para
#: chapter-mobile.xml:1592
#, no-c-format
msgid ""
"It is customary to use a <classname>NavigationView</classname> to have "
"border decorations and caption. In the following, we subclass "
"<classname>Popover</classname> to create the content."
msgstr ""
"我们通常会使用 <classname>NavigationView</classname>, 以便实现边框装饰效果和"
"标题. 下例中, 我们继承一个 <classname>Popover</classname> 来创建其中的内容."

#. Tag: programlisting
#: chapter-mobile.xml:1598
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[class DetailsPopover extends Popover {\n"
"    public DetailsPopover() {\n"
"        setWidth(\"350px\");\n"
"        setHeight(\"65%\");\n"
"\n"
"        // Have some details to display\n"
"        VerticalLayout layout = new VerticalLayout();\n"
"        ...\n"
"\n"
"        NavigationView c = new NavigationView(layout);\n"
"        c.setCaption(\"Details\");\n"
"        setContent(c);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1600
#, no-c-format
msgid ""
"A <classname>Popover</classname> can be opened relative to a component by "
"calling <methodname>showRelativeTo()</methodname>. In the following example, "
"we open the popover when a table item is clicked."
msgstr ""
"可以使用 <methodname>showRelativeTo()</methodname> 方法, 在相对于某个组件的位"
"置上打开 <classname>Popover</classname>. 下例中, 我们在 Table 中的项目被点击"
"时打开 popover."

#. Tag: programlisting
#: chapter-mobile.xml:1606
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[\n"
"Table table = new Table(\"Planets\", planetData());\n"
"table.addItemClickListener(new ItemClickListener() {\n"
"    @Override\n"
"    public void itemClick(ItemClickEvent event) {\n"
"        DetailsPopover popover = new DetailsPopover();\n"
"\n"
"        // Show it relative to the navigation bar of\n"
"        // the current NavigationView.\n"
"        popover.showRelativeTo(view.getNavigationBar());\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1608
#, no-c-format
msgid ""
"You can also add the <classname>Popover</classname> to the <classname>UI</"
"classname> with <methodname>addWindow()</methodname>."
msgstr ""
"也可以使用 <methodname>addWindow()</methodname> 方法将 <classname>Popover</"
"classname> 添加到 <classname>UI</classname> 内."

#. Tag: para
#: chapter-mobile.xml:1613
#, no-c-format
msgid ""
"A popover is shown in a tablet device as illustrated <xref linkend=\"figure."
"mobile.components.popover.tablet\"/>. In this example, we have a "
"<classname>CssLayout</classname> with some buttons as the popover content."
msgstr ""
"Popover 显示在平板设备上的效果, 见<xref linkend=\"figure.mobile.components."
"popover.tablet\"/>. 在这个示例中, Popover 中的内容是一个  "
"<classname>CssLayout</classname>, 以及一些按钮."

#. Tag: title
#: chapter-mobile.xml:1621
#, no-c-format
msgid "<classname>Popover</classname> in a Tablet Device"
msgstr "显示在平板设备上的 <classname>Popover</classname>"

#. Tag: title
#: chapter-mobile.xml:1630
#, no-c-format
msgid "Closing a Popover"
msgstr "关闭一个 Popover"

#. Tag: para
#: chapter-mobile.xml:1632
#, no-c-format
msgid ""
"When <parameter>closable</parameter> is enabled in a <classname>Popover</"
"classname>, as it is by default, it can be closed by clicking anywhere "
"outside the popup area. This may not be enough if the popover fills the "
"entire screen, in which case the user gets stuck. The popover can be closed "
"programmatically by calling <methodname>close()</methodname>. You can, for "
"example, add a <interfacename>MouseEvents.ClickListener</interfacename> to "
"the popover to allow closing it by clicking anywhere inside it."
msgstr ""
"<classname>Popover</classname> 的 <parameter>closable</parameter> 选项默认是"
"启用的, 这时可以点击弹出区域之外的任何地方来关闭它. 如果 Popover 充满整个屏"
"幕, 这个功能就无法使用了, 用户将无法继续操作. Popover 可以通过程序调用 "
"<methodname>close()</methodname> 方法来关闭. 比如, 你可以为 Popover 添加一个 "
"<interfacename>MouseEvents.ClickListener</interfacename> 监听器, 允许用户点"
"击 Popover 内部区域时关闭它."

#. Tag: para
#: chapter-mobile.xml:1643
#, no-c-format
msgid ""
"If the popover has editable fields, you may want to have a close button in "
"the navigation bar of the <classname>NavigationView</classname>. In the "
"following example, we add a close button to the right slot of the navigation "
"bar (you need to include the icon in your theme)."
msgstr ""
"如果 Popover 中包含可编辑的 Field, 你可能会希望在 <classname>NavigationView</"
"classname> 的导航条中带有一个关闭按钮. 下例中, 我们在导航条的右侧区域中添加了"
"一个关闭按钮(你需要在你的 Theme 中包含图标)."

#. Tag: programlisting
#: chapter-mobile.xml:1651
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[class DetailsPopover extends Popover\n"
"      implements Button.ClickListener {\n"
"    public DetailsPopover(Table table, Object itemId) {\n"
"        setWidth(\"350px\");\n"
"        setHeight(\"65%\");\n"
"        Layout layout = new FormLayout();\n"
"        ... create the content ...\n"
"\n"
"        // Decorate with navigation view\n"
"        NavigationView content = new NavigationView(layout);\n"
"        content.setCaption(\"Details\");\n"
"        setContent(content);\n"
"\n"
"        // Have a close button\n"
"        Button close = new Button(null, this);\n"
"        close.setIcon(new ThemeResource(\"close64.png\"));\n"
"        content.setRightComponent(close);\n"
"    }\n"
"\n"
"    public void buttonClick(ClickEvent event) {\n"
"        close();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: programlisting
#: chapter-mobile.xml:1657
#, no-c-format
msgid ""
"<![CDATA[.v-touchkit-popover .v-touchkit-fullscreen { }\n"
"  .v-touchkit-popover .v-touchkit-relative { }\n"
"  .v-touchkit-popover .v-touchkit-plain { }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1659
#, no-c-format
msgid ""
"The component has an overall <literal>v-touchkit-popover</literal> style. If "
"full-screen, it also has the <literal>v-touchkit-fullscreen</literal> style, "
"if positioned relatively it has <literal>v-touchkit-relative</literal>, and "
"if not, the <literal>v-touchkit-plain</literal> style."
msgstr ""
"这个组件的最外层样式是 <literal>v-touchkit-popover</literal>. 如果处于全屏模"
"式, 它还会带有 <literal>v-touchkit-fullscreen</literal> 样式, 如果它在相对于"
"某个组件的位置上弹出, 它会带有 <literal>v-touchkit-relative</literal> 样式, "
"否则会带有 <literal>v-touchkit-plain</literal> 样式."

#. Tag: para
#: chapter-mobile.xml:1671
#, no-c-format
msgid ""
"The <classname>SwipeView</classname> is a wrapper that allows navigating "
"between views by swiping them horizontally left or right. The component "
"works together with a <classname>NavigationManager</classname> (see <xref "
"linkend=\"mobile.components.swipeview\"/>) to change between the views when "
"swiped, and to animate the change. A <classname>SwipeView</classname> should "
"be an immediate child of the <classname>NavigationManager</classname>, but "
"can contain a <classname>NavigationView</classname> to provide button "
"navigation as well."
msgstr ""
"<classname>SwipeView</classname> 是一个封装容器, 允许通过向左或向右的水平滑动"
"手势来实现视图之间的导航跳转. 这个组件与 <classname>NavigationManager</"
"classname> 一起配合工作 (详情请参见 <xref linkend=\"mobile.components."
"swipeview\"/>), 实现滑动时的视图切换, 以及视图切换时的动画效果. "
"<classname>SwipeView</classname> 应该是 <classname>NavigationManager</"
"classname> 的直接子元素, 但在它内部也可以包含 <classname>NavigationView</"
"classname>, 来实现按钮方式的导航跳转."

#. Tag: para
#: chapter-mobile.xml:1683
#, no-c-format
msgid ""
"Let us have a selection of photographs to browse. We extend "
"<classname>NavigationManager</classname> that creates the slide effect and "
"create actual image views dynamically. In the constructor, we create the two "
"first ones."
msgstr ""
"下面我们来实现一个选择照片的浏览界面. 我们继承 <classname>NavigationManager</"
"classname> 来实现滑动效果, 然后动态创建一个真实的图片查看视图. 在构造函数中, "
"我们创建前两幅图片的查看视图."

#. Tag: programlisting
#: chapter-mobile.xml:1690
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[class SlideShow extends NavigationManager\n"
"      implements NavigationListener {\n"
"    String imageNames[] = {\"Mercury.jpg\", \"Venus.jpg\",\n"
"        \"Earth.jpg\", \"Mars.jpg\", \"Jupiter.jpg\",\n"
"        \"Saturn.jpg\", \"Uranus.jpg\", \"Neptune.jpg\"};\n"
"    int pos = 0;\n"
"\n"
"    public SlideShow() {\n"
"        // Set up the initial views\n"
"        navigateTo(createView(pos));\n"
"        setNextComponent(createView(pos+1));\n"
"\n"
"        addNavigationListener(this);\n"
"    }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1692
#, no-c-format
msgid ""
"The individual views have a <classname>SwipeView</classname> and the top."
msgstr ""
"各个图片查看视图中包含一个 <classname>SwipeView</classname> and the top(译"
"注: 此句貌似原文有错误, 待校)."

#. Tag: programlisting
#: chapter-mobile.xml:1696
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[    SwipeView createView(int pos) {\n"
"        SwipeView view = new SwipeView();\n"
"        view.setSizeFull();\n"
"\n"
"        // Use an inner layout to center the image\n"
"        VerticalLayout layout = new VerticalLayout();\n"
"        layout.setSizeFull();\n"
"\n"
"        Image image = new Image(null, new ThemeResource(\n"
"            \"planets/\" + imageNames[pos]));\n"
"        layout.addComponent(image);\n"
"        layout.setComponentAlignment(image,\n"
"            Alignment.MIDDLE_CENTER);\n"
"\n"
"        view.setContent(layout);\n"
"        return view;\n"
"    }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1698
#, no-c-format
msgid ""
"When the view is swiped to either direction, we need to set the next image "
"in that direction dynamically in the <classname>NavigationManager</"
"classname>."
msgstr ""
"当视图被朝左侧或右侧滑动时, 我们需要在 <classname>NavigationManager</"
"classname> 中动态地设置滑动方向上的下一幅图片."

#. Tag: programlisting
#: chapter-mobile.xml:1704
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@Override\n"
"public void navigate(NavigationEvent event) {\n"
"    switch (event.getDirection()) {\n"
"        case FORWARD:\n"
"            if (++pos < imageNames.length-1)\n"
"                setNextComponent(createView(pos+1));\n"
"            break;\n"
"        case BACK:\n"
"            if (--pos > 0)\n"
"                setPreviousComponent(createView(pos-1));\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1710
#, no-c-format
msgid ""
"The <classname>Switch</classname> component is a two-state selector that can "
"be toggled either by tapping or sliding and looks like the switch button in "
"Apple iOS. It extends <classname>CheckBox</classname> and has therefore "
"<classname>Boolean</classname> value type. The caption is managed by the "
"containing layout."
msgstr ""
"<classname>Switch</classname> 组件是一个二状态选择器, 外观类似于 Apple iOS 中"
"的切换按钮, 它的值可以通过点击或滑动来切换. 它继承自 <classname>CheckBox</"
"classname> , 因此值类型为 <classname>Boolean</classname> 型. 它的标题由包含它"
"的布局组件来管理."

#. Tag: programlisting
#: chapter-mobile.xml:1718
#, no-c-format
msgid ""
"<![CDATA[VerticalComponentGroup group =\n"
"        new VerticalComponentGroup();\n"
"Switch myswitch = new Switch(\"To be or not to be?\");\n"
"myswitch.setValue(true);\n"
"group.addComponent(myswitch);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1720
#, no-c-format
msgid ""
"As with other field components, you can handle value changes with a "
"<interfacename>ValueChangeListener</interfacename>. Use "
"<methodname>setImmediate(true)</methodname> to get them immediately when "
"toggled."
msgstr ""
"和其他的 Field 组件一样, 你可以使用 <interfacename>ValueChangeListener</"
"interfacename> 来处理值的变更事件. 使用 <methodname>setImmediate(true)</"
"methodname> 方法, 可以将它设置为立即模式, 在输入值发生变化时立即触发事件."

#. Tag: para
#: chapter-mobile.xml:1727
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.mobile.components.switch\"/>."
msgstr "运行结果见 <xref linkend=\"figure.mobile.components.switch\"/>."

#. Tag: programlisting
#: chapter-mobile.xml:1743
#, no-c-format
msgid ""
"<![CDATA[.v-touchkit-switch { }\n"
"  .v-touchkit-switch-slider { }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1745
#, no-c-format
msgid ""
"The component has an overall <literal>v-touchkit-switch</literal> style. The "
"slider element has <literal>v-touchkit-switch-slider</literal> style."
msgstr ""
"这个组件的最外层样式是 <literal>v-touchkit-switch</literal>. 滑块元素的样式"
"是 <literal>v-touchkit-switch-slider</literal>."

#. Tag: para
#: chapter-mobile.xml:1755
#, no-c-format
msgid ""
"The <classname>VerticalComponentGroup</classname> is a layout component for "
"grouping components in a vertical stack with a border. Component captions "
"are placed left of the components, and the components are aligned right. The "
"component group is typically used for forms or with "
"<classname>NavigationButton</classname> to create navigation menus."
msgstr ""
"<classname>VerticalComponentGroup</classname> 是一个布局组件, 用于将组件以垂"
"直层叠的方式组织在一起, 并带有边框. 组件标题放在组件左侧, 组件本身则朝右侧对"
"齐. 组件 Group 通常用在 Form 内, 或者和 <classname>NavigationButton</"
"classname> 一起使用, 创建导航菜单."

#. Tag: programlisting
#: chapter-mobile.xml:1763
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[VerticalComponentGroup group =\n"
"    new VerticalComponentGroup(\"TouchKit Components\");\n"
"group.setWidth(\"100%\");\n"
"\n"
"// Navigation to sub-views\n"
"group.addComponent(new NavigationButton(\n"
"    new PopoverView()));\n"
"group.addComponent(new NavigationButton(\n"
"    new DecoratedPopoverView()));\n"
"\n"
"layout.addComponent(box);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1765
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.mobile.components."
"verticalcomponentgroup\"/>."
msgstr ""
"运行结果见 <xref linkend=\"figure.mobile.components.verticalcomponentgroup\"/"
">."

#. Tag: programlisting
#: chapter-mobile.xml:1782
#, no-c-format
msgid "<![CDATA[.v-touchkit-verticalcomponentgroup { }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1784
#, no-c-format
msgid ""
"The component has an overall <literal>v-touchkit-verticalcomponentgroup</"
"literal> style. If the component has a caption, the <literal>v-touchkit-has-"
"caption</literal> style is added."
msgstr ""
"这个组件的最外层样式为 <literal>v-touchkit-verticalcomponentgroup</literal>. "
"如果组件带有标题, 则会添加 <literal>v-touchkit-has-caption</literal> 样式."

#. Tag: para
#: chapter-mobile.xml:1794
#, no-c-format
msgid ""
"The <classname>HorizontalButtonGroup</classname> is intended for grouping "
"buttons inside the slots of a <classname>VerticalComponentGroup</classname> "
"with a special button group style."
msgstr ""
"<classname>HorizontalButtonGroup</classname> 用于在 "
"<classname>VerticalComponentGroup</classname> 之内将按钮组织在一起, 并使用一"
"种特殊的按钮 Group 样式."

#. Tag: programlisting
#: chapter-mobile.xml:1801
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[VerticalComponentGroup vertical =\n"
"        new VerticalComponentGroup();\n"
"vertical.addComponent(new TextField(\"Name\"));\n"
"\n"
"HorizontalButtonGroup buttons =\n"
"        new HorizontalButtonGroup();\n"
"buttons.addComponent(new Button(\"OK\"));\n"
"buttons.addComponent(new Button(\"Cancel\"));\n"
"vertical.addComponent(buttons);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1803
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.mobile.components."
"horizontalbuttongroup\"/>"
msgstr ""
"运行结果见 <xref linkend=\"figure.mobile.components.horizontalbuttongroup\"/>"

#. Tag: para
#: chapter-mobile.xml:1817
#, no-c-format
msgid ""
"You can also make single buttons prettier by wrapping them in the component. "
"Also the <classname>Upload</classname> component has a button, and you can "
"give it the <literal>v-button</literal> style to make it look like a button "
"would in the group<phrase condition=\"web\">, as is done in <xref linkend="
"\"mobile.features.upload\"/></phrase>."
msgstr ""
"你也可以将单个的按钮包装在这个组件之内, 以美化按钮的显示效果. "
"<classname>Upload</classname> 组件也带有按钮, 你可以为这个按钮添加 "
"<literal>v-button</literal> 样式, 使它的外观与 Button Group 内的按钮一致"
"<phrase condition=\"web\">, 详情请参见 <xref linkend=\"mobile.features.upload"
"\"/></phrase>."

#. Tag: para
#: chapter-mobile.xml:1825
#, no-c-format
msgid ""
"Despite the name, and the fact that the button group is intended for "
"buttons, you can, in fact, put any components inside it. Whether the result "
"is meaningful, depends on the component."
msgstr ""
"Button Group 的设计目的是为了组织按钮, 但你实际上可以不理会这一点, 在这个组件"
"内部放置任意类型的组件. 这样做的结果是否有意义, 取决于具体的组件."

#. Tag: programlisting
#: chapter-mobile.xml:1834
#, no-c-format
msgid "<![CDATA[.v-touchkit-horizontalbuttongroup { }]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1836
#, no-c-format
msgid ""
"The component has an overall <literal>v-touchkit-horizontalbuttongroup</"
"literal> style. As noted above, the TouchKit style sheet includes special "
"rules for components that have the <literal>v-button</literal> style inside "
"the group."
msgstr ""
"这个组件的最外层样式为 <literal>v-touchkit-horizontalbuttongroup</literal>. "
"我们前面提到过, TouchKit 的样式表, 对于 Group 之内的带有 <literal>v-button</"
"literal> 样式的组件, 包含了一些特殊规则."

#. Tag: para
#: chapter-mobile.xml:1848
#, no-c-format
msgid ""
"The <classname>TabBarView</classname> is a layout component that consist of "
"a tab bar at the bottom of the screen and a content area. Each tab has a "
"content component which is displayed when the tab is selected."
msgstr ""
"<classname>TabBarView</classname> 是一个布局组件, 包括屏幕底部的 Tab 条和内容"
"区域. 每个 Tab 都包含自己的内容组件, 当 Tab 选中时就会显示对应的内容组件."

#. Tag: title
#: chapter-mobile.xml:1855
#, no-c-format
msgid ""
"<classname>TabBar</classname> with Four <classname>NavigationView</"
"classname>s"
msgstr ""
"包含四个 <classname>NavigationView</classname> 的 <classname>TabBar</"
"classname>"

#. Tag: para
#: chapter-mobile.xml:1866
#, no-c-format
msgid ""
"<classname>TabBarView</classname> implements "
"<interfacename>ComponentContainer</interfacename>, but uses its own "
"specialized API for monipulating tabs. To add a new tab, you need to call "
"<methodname>addTab()</methodname> with the content component. It creates the "
"tab and returns a <classname>Tab</classname> object for managing it. You "
"should set at least the caption and icon for a tab."
msgstr ""
"<classname>TabBarView</classname> 实现了 <interfacename>ComponentContainer</"
"interfacename> 接口, 但使用它自己独自的 API 来操纵 Tab. 要添加新 Tab, 你需要"
"调用 <methodname>addTab()</methodname>, 参数是新 Tab 的内容组件. 这个方法将创"
"建 Tab 并返回一个 <classname>Tab</classname> 对象来管理这个新 Tab. 对于一个 "
"Tab, 你至少需要设置它的标题和图标."

#. Tag: programlisting
#: chapter-mobile.xml:1875
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[TabBarView bar = new TabBarView();\n"
"\n"
"// Create some Vaadin component to use as content\n"
"Label content = new Label(\"Really simple content\");\n"
"\n"
"// Create a tab for it\n"
"Tab tab = bar.addTab(label);\n"
"\n"
"// Set tab name and/or icon\n"
"tab.setCaption(\"tab name\");\n"
"tab.setIcon(new ThemeResource(...));]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1877
#, no-c-format
msgid ""
"A tab can be removed with <methodname>removeTab()</methodname>. Note that "
"the <interfacename>ComponentContainer</interfacename> methods "
"<methodname>addComponent()</methodname> and <methodname>removeComponent()</"
"methodname> will throw an <classname>UnsupportedOperationException</"
"classname> if used."
msgstr ""
"Tab 可以通过 <methodname>removeTab()</methodname> 方法删除. 注意, 如果使用 "
"<interfacename>ComponentContainer</interfacename> 中的 "
"<methodname>addComponent()</methodname> 和 <methodname>removeComponent()</"
"methodname> 方法, 会抛出 <classname>UnsupportedOperationException</"
"classname> 异常."

#. Tag: title
#: chapter-mobile.xml:1886
#, no-c-format
msgid "Changing Tab Selection"
msgstr "改变选中的 Tab"

#. Tag: para
#: chapter-mobile.xml:1888
#, no-c-format
msgid ""
"Current tab selection can be accessed with <methodname>getSelectedTab()</"
"methodname> and set with <methodname>setSelectedTab()</methodname>. Changing "
"tab selection either by the user or programmatically causes a "
"<interfacename>SelectedTabChangeEvent</interfacename>, which you can handle "
"with a <interfacename>SelectedTabChangeListener</interfacename>."
msgstr ""
"当前选中的 Tab 可以通过 <methodname>getSelectedTab()</methodname> 方法得到, "
"也可以通过 <methodname>setSelectedTab()</methodname> 方法来设置. 无论是用户操"
"作还是通过程序改变选中的 Tab, 都会导致一个 "
"<interfacename>SelectedTabChangeEvent</interfacename> 事件, 你可以通过 "
"<interfacename>SelectedTabChangeListener</interfacename> 来处理这个事件."

#. Tag: programlisting
#: chapter-mobile.xml:1898
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[Tab selectedTab = bar.getSelectedTab();\n"
"bar.setSelectedTab(selectedTab);]]>"
msgstr ""

#. Tag: programlisting
#: chapter-mobile.xml:1904
#, no-c-format
msgid ""
"<![CDATA[.v-touchkit-tabbar {}\n"
".v-touchkit-tabbar-wrapper {}\n"
".v-touchkit-tabbar-toolbar {} ]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1906
#, no-c-format
msgid ""
"The component has overall <literal>v-touchkit-tabbar</literal> style. "
"Content area is wrapped inside a <literal>v-touchkit-tabbar-wrapper</"
"literal> element. Tab bar control area itself has the <literal>v-touchkit-"
"tabbar-toolbar</literal> style."
msgstr ""
"这个组件的最外层样式为 <literal>v-touchkit-tabbar</literal>. 内容区域封装在 "
"<literal>v-touchkit-tabbar-wrapper</literal> 样式的元素之内. Tab 条控制区域本"
"身的样式为 <literal>v-touchkit-tabbar-toolbar</literal>."

#. Tag: classname
#: chapter-mobile.xml:1917
#, no-c-format
msgid "EmailField"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1919
#, no-c-format
msgid ""
"The <classname>EmailField</classname> is just like the regular "
"<classname>TextField</classname>, except that it has automatic "
"capitalization and correction turned off. Mobile devices also recognize the "
"field as an email field and can offer a virtual keyboard for the purpose, so "
"that it includes the at (<literal>@</literal>) and period (<literal>.</"
"literal>) characters, and possibly a shorthand for <literal>.com</literal>."
msgstr ""
"<classname>EmailField</classname> 与通常的 <classname>TextField</classname> "
"很类似, 区别是它关闭了自动首字母大写和自动校正功能. 移动设备也会将这个组件识"
"别为一个 EMail Field, 并会显示一个虚拟键盘用于输入 EMail, 因此这个虚拟键盘会"
"包括 <literal>@</literal> 符号和点号(<literal>.</literal>), 可能还会包含一个 "
"<literal>.com</literal> 的快捷键."

#. Tag: title
#: chapter-mobile.xml:1929
#, no-c-format
msgid "<classname>EmailField</classname> while editing"
msgstr "编辑中的 <classname>EmailField</classname>"

#. Tag: programlisting
#: chapter-mobile.xml:1940 chapter-mobile.xml:2001
#, no-c-format
msgid ""
"<![CDATA[.v-textfield {}\n"
".v-textfield.v-textfield-error {}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1942
#, no-c-format
msgid ""
"The <classname>EmailField</classname> has an overall <literal>v-textfield</"
"literal> style, just like a regular <classname>TextField</classname> "
"component would. It will get also the <literal>v-textfield-error</literal> "
"if there is a component error, for example, from failed validation."
msgstr ""
"<classname>EmailField</classname> 的最外层样式是 <literal>v-textfield</"
"literal>, 与通常的 <classname>TextField</classname> 组件一样. 如果组件中包含"
"错误, 比如校验失败时, 它还会带有 <literal>v-textfield-error</literal> 样式."

#. Tag: classname
#: chapter-mobile.xml:1953
#, no-c-format
msgid "NumberField"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1955
#, no-c-format
msgid ""
"The <classname>NumberField</classname> is just like the regular "
"<classname>TextField</classname>, except that it is marked as a numeric "
"input field for mobile devices, so that they will show a numeric virtual "
"keyboard rather than the default alphanumeric."
msgstr ""
"<classname>NumberField</classname> 与通常的 <classname>TextField</classname> "
"类似, 区别是它被标记为移动设备上的数字输入 Field, 因此会显示虚拟的数字键盘, "
"而不是默认的字母-数字键盘."

#. Tag: title
#: chapter-mobile.xml:1963
#, no-c-format
msgid "<classname>NumberField</classname> while editing"
msgstr "编辑中的 <classname>NumberField</classname>"

#. Tag: programlisting
#: chapter-mobile.xml:1974
#, no-c-format
msgid ""
"<![CDATA[.v-textfield {}\n"
".v-textfield.v-numberfield-error {}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1976
#, no-c-format
msgid ""
"The <classname>NumberField</classname> has an overall <literal>v-textfield</"
"literal> style, just like a regular <classname>TextField</classname> "
"component would. It will get also the <literal>v-numberfield-error</literal> "
"if there is a component error, for example, from failed validation."
msgstr ""
"<classname>NumberField</classname> 组件的最外层样式为 <literal>v-textfield</"
"literal>, 与通常的 <classname>TextField</classname> 组件一样. 如果组件中包含"
"错误, 比如校验失败时, 它还会带有 <literal>v-numberfield-error</literal> 样式."

#. Tag: classname
#: chapter-mobile.xml:1987
#, no-c-format
msgid "UrlField"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:1989
#, no-c-format
msgid ""
"The <classname>UrlField</classname> is just like the regular "
"<classname>TextField</classname>, except that it is marked as a URL input "
"field for mobile devices, so that they will show a URL input virtual "
"keyboard rather than the default alphanumeric. It has convenience methods "
"<methodname>getUrl()</methodname> and <methodname>setUrl(URL url)</"
"methodname> for converting input value from and to java.net.URL."
msgstr ""
"<classname>UrlField</classname> 与通常的 <classname>TextField</classname> 类"
"似, 区别是它被标记为移动设备上的 URL 输入 Field, 因此会显示一个 URL 输入用的"
"虚拟键盘, 而不是默认的字母-数字键盘. 这个组件有一个便捷方法 "
"<methodname>getUrl()</methodname> 和 <methodname>setUrl(URL url)</"
"methodname>, 用于将输入的值与 java.net.URL 类型相互转换."

#. Tag: para
#: chapter-mobile.xml:2003
#, no-c-format
msgid ""
"The <classname>UrlField</classname> has an overall <literal>v-textfield</"
"literal> style, just like a regular <classname>TextField</classname> "
"component would."
msgstr ""
"<classname>UrlField</classname> 的最外层样式是 <literal>v-textfield</"
"literal>, 与通常的 <classname>TextField</classname> 组件一样."

#. Tag: title
#: chapter-mobile.xml:2013
#, no-c-format
msgid "Advanced Mobile Features"
msgstr "移动设备高级特性"

#. Tag: title
#: chapter-mobile.xml:2016
#, no-c-format
msgid "Providing a Fallback UI"
msgstr "提供一个备用(Fallback)UI"

#. Tag: para
#: chapter-mobile.xml:2018
#, no-c-format
msgid ""
"You may need to use the same URL and hence the same servlet for both the "
"mobile TouchKit UI and for regular browsers. In this case, you need to "
"recognize the mobile browsers compatible with Vaadin TouchKit and provide a "
"fallback UI for any other browsers. The fallback UI can be a regular Vaadin "
"UI, a \"Sorry!\" message, or a redirection to an alternate user interface."
msgstr ""
"你可能会需要对移动设备的 TouchKit UI 和通常的浏览器使用同一个 URL, 因此也就是"
"使用同一个 Servlet. 这种情况下, 你需要识别出兼容 Vaadin TouchKit 的移动设备浏"
"览器, 并对其他浏览器提供一个备用(Fallback) UI. 备用 UI 可以是通常的 Vaadin "
"UI, 可以是一条 \"Sorry!\" 信息, 或者重定向到另一个 UI."

#. Tag: para
#: chapter-mobile.xml:2027
#, no-c-format
msgid ""
"You can handle the fallback logic in a custom <classname>UIProvider</"
"classname> that creates the UIs in the servlet. As TouchKit supports only "
"WebKit and Windows Phone browsers, you can do the recognition by checking if "
"the <parameter>user-agent</parameter> string contains the sub-strings "
"\"<literal>webkit</literal>\" or \"<literal>windows phone</literal>\" as "
"follows:"
msgstr ""
"你可以在 Servlet 的负责创建 UI 的自定义 <classname>UIProvider</classname> 内"
"处理 Fallback 逻辑 . 由于 TouchKit 只支持基于 WebKit 的浏览器以及 Windows "
"Phone 的浏览器, 你可通过检查 <parameter>user-agent</parameter> 字符串中是否存"
"在 \"<literal>webkit</literal>\" 或 \"<literal>windows phone</literal>\" 子串"
"来识别浏览器类型, 如下例:"

#. Tag: programlisting
#: chapter-mobile.xml:2036
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyUIProvider extends UIProvider {\n"
"    @Override\n"
"    public Class<? extends UI>\n"
"              getUIClass(UIClassSelectionEvent event) {\n"
"        String ua = event.getRequest()\n"
"                .getHeader(\"user-agent\").toLowerCase();\n"
"        if (   ua.toLowerCase().contains(\"webkit\")\n"
"            || ua.toLowerCase().contains(\"windows phone 8\")\n"
"            || ua.toLowerCase().contains(\"windows phone 9\")) {\n"
"            return MyUI.class;\n"
"        } else {\n"
"            return MyFallbackUI.class;\n"
"        }\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2038
#, no-c-format
msgid ""
"The custom UI provider has to be added in a custom servlet class, which you "
"need to define in the <filename>web.xml</filename>, as described in <xref "
"linkend=\"mobile.elements.settings\"/>. For example, as follows:"
msgstr ""
"自定义的 UI Provider 必须添加到自定义的 Servlet 类中, 你需要在 <filename>web."
"xml</filename> 中定义这个 Servlet 类, 详情请参见 <xref linkend=\"mobile."
"elements.settings\"/>. 如下例:"

#. Tag: programlisting
#: chapter-mobile.xml:2044
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyServlet extends TouchKitServlet "
"{\n"
"    private MyUIProvider uiProvider = new MyUIProvider();\n"
"\n"
"    @Override\n"
"    protected void servletInitialized() throws ServletException {\n"
"        super.servletInitialized();\n"
"\n"
"        getService().addSessionInitListener(\n"
"                new SessionInitListener() {\n"
"            @Override\n"
"            public void sessionInit(SessionInitEvent event)\n"
"                    throws ServiceException {\n"
"                event.getSession().addUIProvider(uiProvider);\n"
"            }\n"
"        });\n"
"\n"
"        ... other custom servlet settings ...\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2046
#, no-c-format
msgid "See the Parking Demo for a working example."
msgstr "实际可运行的例子, 请参见 Parking 示例程序."

#. Tag: title
#: chapter-mobile.xml:2052
#, no-c-format
msgid "Geolocation"
msgstr "地理位置"

#. Tag: para
#: chapter-mobile.xml:2054
#, no-c-format
msgid ""
"The geolocation feature in TouchKit allows receiving the geographical "
"location from the mobile device. The browser will ask the user to confirm "
"that the web site is allowed to get the location information. Tapping "
"<guibutton>Share Location</guibutton> gives the permission. The browser will "
"give the position acquired by GPS, cellular positioning, or Wi-Fi "
"positioning, as enabled in the device."
msgstr ""
"TouchKit 中的地理位置功能可以从移动设备得到地理位置信息. 浏览器将会询问用户, "
"要求确认是否允许当前网站获取位置信息. 点击 <guibutton>Share Location</"
"guibutton> 按钮会允许网站获取位置信息. 浏览器将向服务器报告位置信息, 位置信息"
"通过 GPS 定位, 移动电话蜂窝网络定位, 或 Wi-Fi 定位来获取, 具体使用何种手段由"
"移动设备的许可设定决定."

#. Tag: para
#: chapter-mobile.xml:2063
#, no-c-format
msgid ""
"Geolocation is requested by calling the static <methodname>detect()</"
"methodname> method in <classname>Geolocator</classname>. You need to provide "
"a <classname>PositionCallback</classname> handler that is called when the "
"device has an answer for your request. If the geolocation request succeeds, "
"<methodname>onSuccess()</methodname> is called. Otherwise, for example, if "
"the user did not allow sharing of his location, <methodname>onFailure()</"
"methodname> is called. The geolocation data is provided in a "
"<classname>Position</classname> object."
msgstr ""
"地理位置通过调用 <classname>Geolocator</classname> 中的静态方法 "
"<methodname>detect()</methodname> 来取得. 你需要提供一个 "
"<classname>PositionCallback</classname> 处理程序, 当移动设备对你的请求有相应"
"时, 这个处理程序将被调用. 如果地理位置定位请求成功, 将会调用 "
"<methodname>onSuccess()</methodname> 方法. 如果请求失败, 比如, 如果用户没有允"
"许共享他的位置信息, 将会调用 <methodname>onFailure()</methodname> 方法. 地理"
"位置数据将以 <classname>Position</classname> 对象的形式提供."

#. Tag: programlisting
#: chapter-mobile.xml:2075
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Geolocator.detect(new PositionCallback() {\n"
"    public void onSuccess(Position position) {\n"
"        double latitude  = position.getLatitude();\n"
"        double longitude = position.getLongitude();\n"
"        double accuracy  = position.getAccuracy();\n"
"\n"
"        ...\n"
"    }\n"
"\n"
"    public void onFailure(int errorCode) {\n"
"        ...\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2077
#, no-c-format
msgid ""
"The position is given as degrees with fractions in the WGS84 coordinate "
"system used by GPS. The longitude is positive to East and negative to West "
"of the prime meridian of WGS84. The accuracy is given in meters. In addition "
"to the above data, the following are also provided:"
msgstr ""
"位置信息以带小数的度单位数值表示, 与 GPS 一样, 使用 WGS84 坐标系. 经度数值的"
"正数表示东经(WGS84 坐标系的本初子午线以东), 负数表示西经(本初子午线以西). 精"
"度值单位为米. 此外, 还提供了以下数据:"

#. Tag: listitem
#: chapter-mobile.xml:2085
#, no-c-format
msgid "Altitude"
msgstr "海拔高度"

#. Tag: listitem
#: chapter-mobile.xml:2086
#, no-c-format
msgid "Altitude accuracy"
msgstr "海拔高度精度"

#. Tag: listitem
#: chapter-mobile.xml:2087
#, no-c-format
msgid "Heading"
msgstr "移动方向"

#. Tag: listitem
#: chapter-mobile.xml:2088
#, no-c-format
msgid "Speed"
msgstr "移动速度"

#. Tag: para
#: chapter-mobile.xml:2091
#, no-c-format
msgid "If any of the position data is unavailable, its value will be zero."
msgstr "如果位置信息数据中的任何一项无法取得, 它的值将为 0."

#. Tag: para
#: chapter-mobile.xml:2095
#, no-c-format
msgid ""
"The <methodname>onFailure()</methodname> is called if the positioning fails "
"for some reason. The <parameter>errorCode</parameter> explains the reason. "
"Error 1 is returned if the permission was denied, 2 if the position is "
"unavailable, 3 on positioning timeout, and 0 on an unknown error."
msgstr ""
"如果因为某种原因无法取得地理位置信息, 则会调用 <methodname>onFailure()</"
"methodname> 方法. <parameter>errorCode</parameter> 代表错误原因. 如果没有地理"
"位置信息的取得权限, 会返回错误号 1 , 如果地理位置信息不可用, 会返回错误号 2, "
"定位处理超时, 会返回错误号 3, 未知错误, 会返回错误号 0."

#. Tag: para
#: chapter-mobile.xml:2103
#, no-c-format
msgid ""
"Notice that geolocation can take significant time, depending on the location "
"method used by the device. With Wi-Fi and cellular positioning, the time is "
"usually less than 30 seconds. With unassisted GPS, it can reach 15 minutes "
"on a fresh device and even longer if the reception is bad. However, once a "
"location fix has been made, updates to the location will be faster. If you "
"are making navigation software, you need to update the position data fairly "
"frequently by calling the <methodname>detect()</methodname> method in "
"<classname>Geolocator</classname> multiple times."
msgstr ""
"注意, 地理位置定位处理有可能耗费很长的时间, 具体如何取决于移动设备使用的定位"
"方法. 使用 Wi-Fi 网络定位或移动电话蜂窝网络定位时, 定位时间通常少于 30 秒. 在"
"新的设备上, 单独使用 GPS 初次进行定位时, 如果 GPS 接收信号较差, 定位时间可能"
"会长达 15 分钟, 甚至更长. 但是, 一旦定位完成, 之后的位置更新会很迅速. 如果你"
"在开发导航软件, 你需要多次调用 <classname>Geolocator</classname> 类中的 "
"<methodname>detect()</methodname> 方法来频繁地更新位置信息数据."

#. Tag: title
#: chapter-mobile.xml:2116
#, no-c-format
msgid "Displaying Position on a Map"
msgstr "在地图上显示当前位置"

#. Tag: para
#: chapter-mobile.xml:2118
#, no-c-format
msgid ""
"Geographical positions are often visualized with a map. There are countless "
"ways to do that, for example, in the Parking Demo we use the <link xlink:"
"href=\"http://vaadin.com/directory#addon/v-leaflet\">V-Leaflet</link> add-on "
"component."
msgstr ""
"地理位置信息通常使用地图来表示. 有无数种方法来实现, 比如, 在 Parking 示例程序"
"中我们使用 <link xlink:href=\"http://vaadin.com/directory#addon/v-leaflet"
"\">V-Leaflet</link> add-on 组件来实现."

#. Tag: para
#: chapter-mobile.xml:2126
#, no-c-format
msgid ""
"Notice that the geolocation gives the position in the WGS84 coordinate "
"system used by GPS. The same system is conveniently used by many Internet "
"map services, but is not in any way universal. Further, in some countries, "
"map data is legally required to have erroneus coordinates."
msgstr ""
"注意, 地理位置信息给出的位置信息使用的是 WGS84 坐标系, 与 GPS 一样. 很多 "
"Internet 地图服务使用的也是同样的坐标系, 但并不保证所有的地图服务都是如此. 不"
"仅如此, 在某些国家, 甚至还有法律要求地图数据不能给出正确坐标, 而必须包含一定"
"程度的偏差."

#. Tag: para
#: chapter-mobile.xml:2134
#, no-c-format
msgid ""
"The <classname>MapView</classname> in the Parking Demo is a TouchKit "
"navigation view that uses the <classname>LMap</classname> component from the "
"add-on to display the map:"
msgstr ""
"Parking 示例程序中的 <classname>MapView</classname> 是一个 TouchKit 导航视"
"图, 它使用 add-on 中的 <classname>LMap</classname> 组件来显示地图:"

#. Tag: programlisting
#: chapter-mobile.xml:2140
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MapView extends CssLayout\n"
"      implements PositionCallback, LeafletClickListener {\n"
"    private LMap map;\n"
"    private final LMarker you = new LMarker();\n"
"    ...]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2142
#, no-c-format
msgid "Position is requested from the device when a button is clicked:"
msgstr "当按钮按下时, 就会向移动设备请求位置信息:"

#. Tag: programlisting
#: chapter-mobile.xml:2146
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[locatebutton = new Button(\"\", new "
"ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(final ClickEvent event) {\n"
"        Geolocator.detect(MapView.this);\n"
"    }\n"
"});\n"
"locatebutton.addStyleName(\"locatebutton\");\n"
"locatebutton.setWidth(30, Unit.PIXELS);\n"
"locatebutton.setHeight(30, Unit.PIXELS);\n"
"locatebutton.setDisableOnClick(true);\n"
"addComponent(locatebutton);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2148
#, no-c-format
msgid "When TouchKit gets the position, we center the map as follows:"
msgstr "当 TouchKit 得到位置信息时, 我们相应地移动地图位置, 如下:"

#. Tag: programlisting
#: chapter-mobile.xml:2152
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@Override\n"
"public void onSuccess(final Position position) {\n"
"    ParkingUI app = ParkingUI.getApp();\n"
"    app.setCurrentLatitude(position.getLatitude());\n"
"    app.setCurrentLongitude(position.getLongitude());\n"
"\n"
"    setCenter();\n"
"\n"
"    // Enable centering on current position manually\n"
"    locatebutton.setEnabled(true);\n"
"}\n"
"\n"
"private void setCenter() {\n"
"    if (map != null)\n"
"        map.setCenter(you.getPoint());\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2157
#, no-c-format
msgid "Storing Data in the Local Storage"
msgstr "在本地存储中保存数据"

#. Tag: para
#: chapter-mobile.xml:2159
#, no-c-format
msgid ""
"The <classname>LocalStorage</classname> UI extension allows storing data in "
"the HTML5 local storage from the server-side application. The storage is a "
"singleton, which you can get with <methodname>LocalStorage.get()</"
"methodname>."
msgstr ""
"<classname>LocalStorage</classname> UI 扩展允许服务器端应用程序使用 HTML5 本"
"地存储来保存数据. Storage 是一个单例, 你可以使用 <methodname>LocalStorage."
"get()</methodname> 方法得到它."

#. Tag: programlisting
#: chapter-mobile.xml:2166
#, no-c-format
msgid "<![CDATA[final LocalStorage storage = LocalStorage.get();]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2169
#, no-c-format
msgid "Storing Data"
msgstr "存储数据"

#. Tag: para
#: chapter-mobile.xml:2171
#, no-c-format
msgid ""
"You can store data in the local storage as key-value pairs with the "
"<methodname>put()</methodname> method. Both the key and value must be "
"strings. Storing the data requires a client round-trip, so the success or "
"failure of the store operation can be handled with an optional "
"<interfacename>LocalStorageCallback</interfacename>."
msgstr ""
"你可以使用 <methodname>put()</methodname> 方法, 用键-值对(key-value pair)形式"
"在本地存储中保存数据. 键和值都必须是字符串. 保存数据会导致一次客户端调用, 因"
"此存储操作的成功或失败可以通过可选的 <interfacename>LocalStorageCallback</"
"interfacename> 来处理."

#. Tag: programlisting
#: chapter-mobile.xml:2179
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Editor for the value to be stored\n"
"final TextField valueEditor = new TextField(\"Value\");\n"
"valueEditor.setNullRepresentation(\"\");\n"
"layout.addComponent(valueEditor);\n"
"\n"
"Button store = new Button(\"Store\", new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        storage.put(\"value\", valueEditor.getValue(),\n"
"                    new LocalStorageCallback() {\n"
"            @Override\n"
"            public void onSuccess(String value) {\n"
"                Notification.show(\"Stored\");\n"
"            }\n"
"\n"
"            @Override\n"
"            public void onFailure(FailureEvent error) {\n"
"                Notification.show(\"Storing Failed\");\n"
"            }\n"
"        });\n"
"    }\n"
"}));\n"
"layout.addComponent(store);]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2183
#, no-c-format
msgid "Retrieving Data from the Storage"
msgstr "从存储中取得数据"

#. Tag: para
#: chapter-mobile.xml:2185
#, no-c-format
msgid ""
"You can retrieve data from the local storage with the <methodname>get()</"
"methodname> method. It takes the key and a "
"<interfacename>LocalStorageCallback</interfacename> to receive the retrieved "
"value, or a failure. Retrieving the value to the server-side requires a "
"client rount-trip and another server request is made to send the value with "
"the callback."
msgstr ""
"你可以使用 <methodname>get()</methodname> 方法从本地存储中取得数据. 这个方法"
"的参数是数据的键, 以及一个 <interfacename>LocalStorageCallback</"
"interfacename>, 这个回调程序负责接收取得的值, 或者失败信息. 将值取得到服务器"
"端需要一次客户端调用, 还需要在回调程序中发起一次服务器端请求来发送数据值."

#. Tag: programlisting
#: chapter-mobile.xml:2194
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[storage.get(\"value\", new "
"LocalStorageCallback() {\n"
"    @Override\n"
"    public void onSuccess(String value) {\n"
"        valueEditor.setValue(value);\n"
"        Notification.show(\"Value Retrieved\");\n"
"    }\n"
"\n"
"    @Override\n"
"    public void onFailure(FailureEvent error) {\n"
"        Notification.show(\"Failed because: \" +\n"
"                          error.getMessage());\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2200
#, no-c-format
msgid "Uploading Content"
msgstr "上传内容"

#. Tag: para
#: chapter-mobile.xml:2202
#, no-c-format
msgid ""
"Uploading content from a mobile device works just like with regular Vaadin "
"applications using the <classname>Upload</classname> component."
msgstr ""
"从移动设备上传内容与通常的 Vaadin 应用程序一样, 使用 <classname>Upload</"
"classname> 组件实现."

#. Tag: para
#: chapter-mobile.xml:2207
#, no-c-format
msgid ""
"In an offline UI or client-side code in general, you need to handle "
"uploading differently, using a special upload widget or handler."
msgstr ""
"但在离线 UI 或客户端代码中, 你需要用别的方式来实现内容的上传, 使用一个特殊的"
"上传 Widget 或上传处理程序."

#. Tag: title
#: chapter-mobile.xml:2213
#, no-c-format
msgid "Server-Side <classname>Upload</classname> Component"
msgstr "服务器端 <classname>Upload</classname> 组件"

#. Tag: para
#: chapter-mobile.xml:2215
#, no-c-format
msgid ""
"In a server-side UI, you can use the regular <classname>Upload</classname> "
"component described in <xref linkend=\"components.upload\"/>. When choosing "
"a file, the device will ask to select the file from files, gallery, camera, "
"or other possible sources, depending on the device. The only difference to "
"normal use is that the upload component must be in <emphasis>immediate</"
"emphasis> mode."
msgstr ""
"在服务器端 UI 中, 你可以使用通常的 <classname>Upload</classname> 组件, 详情请"
"参见 <xref linkend=\"components.upload\"/>. 选择文件时, 移动设备将会要求用户"
"选择文件, 文件来源是本地文件系统, 相册, 摄像头, 会其他可能的来源, 具体情况由"
"移动设备决定. 通常使用中唯一的区别是, 上传组件必须处于 <emphasis>立即"
"(immediate)</emphasis> 模式."

#. Tag: para
#: chapter-mobile.xml:2225
#, no-c-format
msgid ""
"Uploading is supported by most mobile operating systems, such as iOS, "
"Android, and Windows RT devices, but not in some, such as WP8."
msgstr ""
"大多数移动设备操作系统都支持上传, 比如 iOS, Android, 以及 Windows RT 移动设"
"备, 但某些操作系统不支持, 比如 WP8."

#. Tag: para
#: chapter-mobile.xml:2230
#, no-c-format
msgid ""
"The following example shows how to implement simple upload to an in-memory "
"storage."
msgstr "下例演示如何实现一个简单的文件上传, 并将上传的内容保存到内存中."

#. Tag: programlisting
#: chapter-mobile.xml:2235
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Display the image - only a placeholder "
"first\n"
"final Image image = new Image();\n"
"image.setWidth(\"100%\");\n"
"image.setVisible(false);\n"
"layout.addComponent(image);\n"
"\n"
"// Implement both receiver that saves upload in a file and\n"
"// listener for successful upload\n"
"class ImageUploader implements Receiver, SucceededListener,\n"
"                               ProgressListener {\n"
"    final static int maxLength = 10000000;\n"
"    ByteArrayOutputStream fos = null;\n"
"    String filename;\n"
"    Upload upload;\n"
"\n"
"    public ImageUploader(Upload upload) {\n"
"        this.upload = upload;\n"
"    }\n"
"\n"
"    public OutputStream receiveUpload(String filename,\n"
"                                      String mimeType) {\n"
"        this.filename = filename;\n"
"        fos = new ByteArrayOutputStream(maxLength + 1);\n"
"        return fos; // Return the output stream to write to\n"
"    }\n"
"\n"
"    @Override\n"
"    public void updateProgress(long readBytes,\n"
"                               long contentLength) {\n"
"        if (readBytes > maxLength) {\n"
"            Notification.show(\"Too big content\");\n"
"            upload.interruptUpload();\n"
"        }\n"
"    }\n"
"\n"
"    public void uploadSucceeded(SucceededEvent event) {\n"
"        // Show the uploaded file in the image viewer\n"
"        image.setSource(new StreamResource(new StreamSource() {\n"
"            @Override\n"
"            public InputStream getStream() {\n"
"                byte[] bytes = fos.toByteArray();\n"
"                return new ByteArrayInputStream(bytes);\n"
"            }\n"
"        }, filename));\n"
"\n"
"        image.setVisible(true);\n"
"    }\n"
"};\n"
"\n"
"Upload upload = new Upload();\n"
"ImageUploader uploader = new ImageUploader(upload);\n"
"upload.setReceiver(uploader);\n"
"upload.addSucceededListener(uploader);\n"
"upload.setImmediate(true); // Only button\n"
"\n"
"// Wrap it in a button group to give better style\n"
"HorizontalButtonGroup group = new HorizontalButtonGroup();\n"
"group.addComponent(upload);\n"
"layout.addComponent(group);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2237
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.mobile.features.upload\"/> "
"(&copy;2001 Marko Gr&ouml;nroos)."
msgstr ""
"运行结果见 <xref linkend=\"figure.mobile.features.upload\"/> (&copy;2001 "
"Marko Gr&ouml;nroos)."

#. Tag: title
#: chapter-mobile.xml:2243
#, no-c-format
msgid "Mobile Upload"
msgstr "移动设备中的内容上传"

#. Tag: title
#: chapter-mobile.xml:2256
#, no-c-format
msgid "Upload on the Client-Side"
msgstr "在客户端代码中实现内容上传"

#. Tag: para
#: chapter-mobile.xml:2258
#, no-c-format
msgid ""
"When making a client-side widget that handles file upload, such as for "
"offline mode, you can use the GWT <link xlink:href=\"http://www.gwtproject."
"org/javadoc/latest/com/google/gwt/user/client/ui/FileUpload.html"
"\"><classname>FileUpload</classname> component</link>. In such case, you "
"need to communicate the image data to the server with an RPC call."
msgstr ""
"开发一个处理文件上传的 Widget 时, 比如用于离线模式的文件上传组件, 你可以使用 "
"GWT 的 <link xlink:href=\"http://www.gwtproject.org/javadoc/latest/com/"
"google/gwt/user/client/ui/FileUpload.html\"><classname>FileUpload</"
"classname> 组件</link>. 这种情况下, 你需要通过 RPC 调用将图片数据传递给服务"
"器."

#. Tag: para
#: chapter-mobile.xml:2266
#, no-c-format
msgid ""
"On a mobile device, the perhaps most common upload task is to capture images "
"with the integrated camera. To display them in the client-side UI correctly, "
"you want make sure that they have reasonable size and correct orientation, "
"without making a server round-trip to do the corrections. To send them to "
"the server, you want to avoid using too much bandwidth. The "
"<classname>ImageUpload</classname> widget included in the <literal>lib-gwt-"
"imageupload</literal> add-on, <link xlink:href=\"https://vaadin.com/"
"directory#addon/lib-gwt-imageupload\">available from Vaadin Directory</"
"link>, allows launching the camera application in the device and capturing "
"an image. It further allows defining an image manipulation pipeline with "
"transformations to reduce the image size if necessary, correct the "
"orientation according to EXIF data, and so forth. The corrected image is "
"loaded to a memory buffer, which you can display in another widget, send to "
"the server, or store in the local store."
msgstr ""
"在移动设备中, 最常见的上传任务可能就是使用设备上集成的摄像头拍摄一张照片. 为"
"了在客户端 UI 中正确地显示照片, 你会希望确保照片尺寸和方向的准确性, 而不需要"
"发起一次服务器通信来做这个纠正处理. 将照片发送到服务器时, 你会希望避免使用太"
"多的带宽. <literal>lib-gwt-imageupload</literal> add-on(<link xlink:href="
"\"https://vaadin.com/directory#addon/lib-gwt-imageupload\">可从 Vaadin "
"Directory 得到</link>) 中的 <classname>ImageUpload</classname> Widget, 可以启"
"动移动设备中的摄像头应用程序, 并拍摄一张照片. 如果需要, 它还可以使用变换处理"
"来定义一个图像处理管道, 以便减小图片尺寸, 还可以将图片方向修正为与 EXIF 数据"
"一致, 等等. 修正后的图片会装载到内存缓冲区中, 你可以使用其他 Widget 来显示"
"它, 发送到服务器, 或者保存到奥本地存储中."

#. Tag: para
#: chapter-mobile.xml:2284
#, no-c-format
msgid ""
"In the following, we allow capturing an image with the camera, normalize the "
"image and reduce its size, and reduce the size further for displaying it in "
"a thumbnail. Notice that the image data is encoded as a URL, which can be "
"used as such in CSS, for example."
msgstr ""
"下例中, 我们使用摄像头拍摄一张照片, 修正图片并缩减它的尺寸, 然后再次缩减尺寸"
"以便在缩略图中显示它. 注意, 图像数据会被编码为一个 URL, 因此编码后的数据可以"
"使用在很多场合, 比如  CSS 中."

#. Tag: programlisting
#: chapter-mobile.xml:2291
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[final ImageUpload fileUpload = new "
"ImageUpload();\n"
"\n"
"// Have a separate button to initiate the upload\n"
"final VButton takePhotoButton = new VButton();\n"
"takePhotoButton.addClickHandler(new ClickHandler() {\n"
"    @Override\n"
"    public void onClick(ClickEvent event) {\n"
"        fileUpload.click();\n"
"    }\n"
"});\n"
"\n"
"// Capture images from the camera, instead of allowing to\n"
"// choose from gallery or other sources.\n"
"fileUpload.setCapture(true);\n"
"\n"
"// Normalize the orientation and make size suitable for\n"
"// sending to server\n"
"EXIFOrientationNormalizer normalizer =\n"
"        new EXIFOrientationNormalizer();\n"
"normalizer.setMaxWidth(1024);\n"
"normalizer.setMaxHeight(1024);\n"
"fileUpload.addImageManipulator(normalizer);\n"
"fileUpload.addImageLoadedHandler(new ImageLoadedHandler() {\n"
"    @Override\n"
"    public void onImageLoaded(ImageLoadedEvent event) {\n"
"        // Store the image data as encoded URL\n"
"        setImage(event.getImageData().getDataURL());\n"
"    }\n"
"});\n"
"\n"
"// Reduce the size further for displaying a thumbnail\n"
"ImageTransformer thumbGenerator = new ImageTransformer();\n"
"thumbGenerator.setImageDataSource(fileUpload);\n"
"thumbGenerator.setMaxWidth(75);\n"
"thumbGenerator.setMaxHeigth(75);\n"
"thumbGenerator.addImageLoadedHandler(new ImageLoadedHandler() {\n"
"   @Override\n"
"   public void onImageLoaded(ImageLoadedEvent event) {\n"
"       // Store the thumbnail image data as encoded URL\n"
"       setThumbnail(event.getImageData().getDataURL());\n"
"   }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2293
#, no-c-format
msgid "See the Parking Demo for more details about the usage of the add-on."
msgstr "关于这个 add-on 的使用方法, 更多细节请参见 Parking 示例程序."

#. Tag: title
#: chapter-mobile.xml:2301
#, no-c-format
msgid "Offline Mode"
msgstr "离线模式(Offline Mode)"

#. Tag: para
#: chapter-mobile.xml:2303
#, no-c-format
msgid ""
"While regular Vaadin TouchKit applications are server-side applications, "
"TouchKit allows a special <emphasis>offline mode</emphasis>, which is a "
"client-side Vaadin UI that is switched to automatically when the network "
"connection is not available. The offline UI is included in the widget set of "
"the regular server-side UI and stored in the browser cache. By providing a "
"special cache manifest, the browser caches the page so strongly that it "
"persists even after browser restart, effectively making it an offline "
"application."
msgstr ""
"Vaadin TouchKit 应用程序通常都是服务器端应用程序, 但 TouchKit 也允许一种特殊"
"的 <emphasis>离线模式</emphasis>, 这种模式是一个客户端 Vaadin UI, 当网络连接"
"断开时就会自动切换到它. 离线 UI 包含在通常的服务器端 UI 的 Widget Set 之内, "
"并被保存在浏览器缓存之内. 只要提供一个特殊的缓存配置, 浏览器就会使用很高级别"
"来缓存这个页面, 甚至浏览器重启之后页面也还可以继续存在, 因此 TouchKit 应用程"
"序可以成为一种离线应用程序."

#. Tag: title
#: chapter-mobile.xml:2315
#, no-c-format
msgid "Offline Mode in the Parking Demo"
msgstr "Parking 示例程序中的离线模式"

#. Tag: para
#: chapter-mobile.xml:2323
#, no-c-format
msgid ""
"During offline operation, the offline UI can store data in the HTML5 local "
"storage of the mobile browser and then passed to the server-side application "
"when the connection is again available."
msgstr ""
"在离线操作过程中, 离线 UI 可以将数据存储在移动设备浏览器的 HTML5 本地存储之"
"内, 然后在网络连接恢复后再传递给服务器端应用程序."

#. Tag: para
#: chapter-mobile.xml:2329
#, no-c-format
msgid ""
"The offline mode is enabled in the project stub created by the Maven "
"archetype (see <xref linkend=\"mobile.project.maven\"/>), with stubs for the "
"offline data storage and server RPC classes."
msgstr ""
"通过 Maven archetype 创建的工程(详情请参见 <xref linkend=\"mobile.project."
"maven\"/>), 它的框架代码会激活离线模式, 还包含了离线数据存储以及向服务器端发"
"起 RPC 调用的类框架代码."

#. Tag: para
#: chapter-mobile.xml:2335
#, no-c-format
msgid ""
"See the Parking demo and its source code for complete examples of the "
"offline mode."
msgstr "关于离线模式的完整示例, 请参见 Parking 示例程序, 以及它的源代码."

#. Tag: title
#: chapter-mobile.xml:2341
#, no-c-format
msgid "Enabling the Cache Manifest"
msgstr "启用缓存配置(Cache Manifest)"

#. Tag: para
#: chapter-mobile.xml:2343
#, no-c-format
msgid ""
"HTML5 supports a <emphasis>cache manifest</emphasis>, which makes offline "
"web applications possible. It controls how different resources are cached. "
"The manifest is generated by TouchKit, but you need to enable it in the "
"TouchKit settings. To do so, you need to define a custom servlet, as "
"described in <xref linkend=\"mobile.elements.servlet\"/>, and call "
"<methodname>setCacheManifestEnabled(true)</methodname> for the cache "
"settings, as follows:"
msgstr ""
"HTML5 支持 <emphasis>缓存配置(cache manifest)</emphasis>, 因此可以利用这个功"
"能来实现离线 Web 应用程序. 这个配置控制如何缓存各种资源. 配置会由 TouchKit 产"
"生, 但你需要在 TouchKit 设定中启用它. 为了实现这一点, 你需要定义一个自定义 "
"Servlet, 详情请参见 <xref linkend=\"mobile.elements.servlet\"/>, 并对缓存设定"
"调用<methodname>setCacheManifestEnabled(true)</methodname>, 如下:"

#. Tag: programlisting
#: chapter-mobile.xml:2353
#, no-c-format
msgid ""
"<![CDATA[TouchKitSettings s = getTouchKitSettings();\n"
"...\n"
"s.getApplicationCacheSettings()\n"
" .setCacheManifestEnabled(true);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2355
#, no-c-format
msgid ""
"You also need to define a MIME type for the manifest in the <filename>web."
"xml</filename> deployment descriptor as follows:"
msgstr ""
"你还需要在 <filename>web.xml</filename> 部署描述文件中为 manifest 定义一个 "
"MIME 类型, 如下:"

#. Tag: programlisting
#: chapter-mobile.xml:2360
#, no-c-format
msgid ""
"<![CDATA[<mime-mapping>\n"
"        <extension>manifest</extension>\n"
"        <mime-type>text/cache-manifest</mime-type>\n"
"</mime-mapping>]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2364
#, no-c-format
msgid "Enabling Offline Mode"
msgstr "启用离线模式"

#. Tag: para
#: chapter-mobile.xml:2366
#, no-c-format
msgid ""
"To enable the offline mode, you need to add the <classname>OfflineMode</"
"classname> extension to the UI."
msgstr ""
"要启用离线模式, 你需要向 UI 添加 <classname>OfflineMode</classname> 扩展."

#. Tag: programlisting
#: chapter-mobile.xml:2371
#, no-c-format
msgid ""
"<![CDATA[OfflineMode offlineMode = new OfflineMode();\n"
"offlineMode.extend(this);\n"
"\n"
"// Maintain the session when the browser app closes\n"
"offlineMode.setPersistentSessionCookie(true);\n"
"\n"
"// Define the timeout in secs to wait when a server\n"
"// request is sent before falling back to offline mode\n"
"offlineMode.setOfflineModeTimeout(15);]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2373
#, no-c-format
msgid ""
"The above code is included in the project stub created by the Maven "
"archetype (see <xref linkend=\"mobile.project.maven\"/>)."
msgstr ""
"由 Maven archetype 创建的工程(详情请参见 <xref linkend=\"mobile.project.maven"
"\"/>), 它的框架代码中已经包含了以上代码."

#. Tag: para
#: chapter-mobile.xml:2378
#, no-c-format
msgid ""
"You can extend the <classname>OfflineMode</classname> extension to transfer "
"data conveniently from the offline UI to the server-side, as described in "
"<xref linkend=\"mobile.offline.data\"/>."
msgstr ""
"你可以继承 <classname>OfflineMode</classname> 扩展, 以便以适当的方式, 从离线 "
"UI 向服务器端传输数据, 详情请参见 <xref linkend=\"mobile.offline.data\"/>."

#. Tag: title
#: chapter-mobile.xml:2386
#, no-c-format
msgid "The Offline User Interface"
msgstr "离线模式下的 UI"

#. Tag: para
#: chapter-mobile.xml:2388
#, no-c-format
msgid ""
"An offline mode is built like any other client-side module, as described in "
"<xref linkend=\"clientside\"/>. You can use any GWT, Vaadin, add-on, and "
"also TouchKit widgets in the offline user interface."
msgstr ""
"离线模式的构建方法与其他客户端模块一样, 详情请参见 <xref linkend=\"clientside"
"\"/>. 在离线 UI 中你可以使用任意的 GWT Widget, Vaadin Widget, add-on Widget, "
"以及 TouchKit 的 Widget."

#. Tag: para
#: chapter-mobile.xml:2394
#, no-c-format
msgid ""
"Most typically, a client-side application builds a simplified UI for data "
"browsing and entry. It stores the data in the HTML5 local storage. It "
"watches if the server connection is restored, and if it is, it sends any "
"collected data to the server and suggests to return to the online mode."
msgstr ""
"最常见的情况, 客户端应用程序会创建一个简单的 UI, 用于浏览和输入数据. 它会将数"
"据存储在 HTML5 本地存储中. 然后它会监视服务器连接是否恢复, 如果恢复了, 就将用"
"户输入的数据发送到服务器, 并提示用户回到连线模式."

#. Tag: para
#: chapter-mobile.xml:2401
#, no-c-format
msgid ""
"The Parking Demo provides an example implementation of an offline mode user "
"interface. The Ticket view is implemented as a fat client-side widget, where "
"the server-side view only communicates the state to the widget."
msgstr ""
"Parking 示例程序提供了离线模式 UI 的一个示例实现. Ticket 视图实现为一个胖客户"
"端 Widget, 而服务器端视图只负责将状态数据发送给 Widget 端."

#. Tag: title
#: chapter-mobile.xml:2410
#, no-c-format
msgid "Sending Data to Server"
msgstr "向服务器发送数据"

#. Tag: para
#: chapter-mobile.xml:2412
#, no-c-format
msgid ""
"Once the connection is available, the offline UI can send any collected data "
"to the server-side. You can send the data from the offline UI, for example, "
"by making a server RPC call to a server-side UI extension, as described in "
"<xref linkend=\"gwt.rpc\"/>."
msgstr ""
"一旦网络连接恢复, 离线模式 UI 就可以将用户输入的数据发送到服务器端. 比如, 你"
"可以向一个服务器端的 UI 扩展发起服务器 RPC 调用, 来实现从离线 UI 向服务器的数"
"据发送, 详情请参见 <xref linkend=\"gwt.rpc\"/>."

#. Tag: title
#: chapter-mobile.xml:2421
#, no-c-format
msgid "The Offline Theme"
msgstr "离线模式下的 Theme"

#. Tag: para
#: chapter-mobile.xml:2423
#, no-c-format
msgid ""
"Normally, client-side modules have their own stylesheets in the "
"<filename>public</filename> folder that is compiled into the client-side "
"target, as described in <xref linkend=\"gwt.styling\"/> and <xref linkend="
"\"clientside.module.stylesheet\"/>. However, you may want to have the "
"offline mode have the same visual style as the online mode. To use the same "
"theme as the server-side application, you need to define the theme path in "
"the widget set definition file as follows."
msgstr ""
"通常, 客户端模块带有自己的样式表, 保存在 <filename>public</filename> 文件夹"
"中, 并被编译到客户端目标模块中, 详情请参见 <xref linkend=\"gwt.styling\"/> 以"
"及 <xref linkend=\"clientside.module.stylesheet\"/>. 但是, 你也有可能会希望让"
"离线模式使用与连线模式相同的样式. 要使用与服务器端应用程序相同的 Theme, 你需"
"要在 Widget Set 定义文件中定义 Theme 路径, 如下."

#. Tag: programlisting
#: chapter-mobile.xml:2433
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;set-configuration-property\n"
"    name='touchkit.manifestlinker.additionalCacheRoot'\n"
"    value='src/main/webapp/VAADIN/themes/<replaceable>mytheme</"
"replaceable>:../../../VAADIN/themes/<replaceable>mytheme</replaceable> /&gt;"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2435
#, no-c-format
msgid ""
"You need to follow a CSS style structure required by the Vaadin theme in "
"your offline application. If you use any Vaadin widgets, as described in "
"<xref linkend=\"clientsidewidgets.vaadin\"/>, they will use the Vaadin theme."
msgstr ""
"在你的离线应用程序中, 你需要遵循 Vaadin Theme 所要求的 CSS 样式结构. 如果使用"
"了任何的 Vaadin Widget, 详情请参见 <xref linkend=\"clientsidewidgets.vaadin"
"\"/>, 它们都会使用 Vaadin Theme."

#. Tag: title
#: chapter-mobile.xml:2444
#, no-c-format
msgid "Building an Optimized Widget Set"
msgstr "构建最优化的 Widget Set"

#. Tag: para
#: chapter-mobile.xml:2446
#, no-c-format
msgid ""
"Mobile networks are generally somewhat slower than DSL Internet connections. "
"When starting a Vaadin application, the widget set is the biggest resource "
"that needs to be loaded in the browser. As most of the Vaadin components are "
"not used by most applications, especially mobile ones, it is beneficial to "
"create an optimized version of the widget set."
msgstr ""
"移动设备的网络通常会比 DSL Internet 连接要慢. 当启动一个 Vaadin 应用程序时, "
"Widget Set 是浏览器需要装载的资源中最大的. 对于大多数应用程序来说, 尤其是对于"
"移动设备上的应用程序, 大多数 Vaadin 组件其实不会被用到, 因此创建优化版的 "
"Widget Set 是很有益处的."

#. Tag: para
#: chapter-mobile.xml:2454
#, no-c-format
msgid ""
"Vaadin supports lazy loading of individual widget implementations when they "
"are needed. The <classname>TouchKitWidgetSet</classname> used in TouchKit "
"applications optimizes the widgetset to only download the most essential "
"widgets first and then load other widget implementation lazily. This is a "
"good compromise for most TouchKit applications. Nevertheless, because of the "
"high latency of most mobile networks, loading the widget set in small pieces "
"might not be the best solution for every case. With custom optimization, you "
"can create a monolithic widget set stripped off all unnecessary widgets. "
"Together with proper GZip compression, is should be quite light-weight for "
"mobile browsers."
msgstr ""
"对于单独的 Widget, Vaadin 可以在需要时才延迟加载它. 在 TouchKit 应用程序中使"
"用的 <classname>TouchKitWidgetSet</classname> 对 Widget Set 进行了优化, 最初"
"只会下载最必要的 Widget, 然后再延迟装载其他 Widget. 对于大多数 TouchKit 应用"
"程序, 这是一种很好的这种方案. 但是, 由于大多数移动设备网络的速度很慢, 将 "
"Widget Set 分为小片来装载可能不是所有情况下的最佳方案. 通过一些自定义优化, 你"
"可以去除所有不必要的 Widget, 创建一个整体的 Widget Set. 再配合适当的 GZip 压"
"缩, 对于移动设备浏览器来说, 它将会非常轻量."

#. Tag: para
#: chapter-mobile.xml:2467
#, no-c-format
msgid ""
"However, if the application has big components which are rarely used or not "
"on the initial views, it may be best to load those widgets eagerly or lazily."
msgstr ""
"但是, 如果应用程序中存在很大的组件, 这些组件很少使用, 或者并不存在于初期视图"
"中, 那么最好延迟装载这些组件的 Widget."

#. Tag: para
#: chapter-mobile.xml:2473
#, no-c-format
msgid ""
"You can find a working example of widget set optimization in the "
"<filename>ParkingWidgetset.gwt.xml</filename> and "
"<filename>WidgetLoaderFactory.java</filename> in the Parking Demo sources."
msgstr ""
"关于 Widget Set 优化, 你可以在 Parking 源代码的 <filename>ParkingWidgetset."
"gwt.xml</filename> 和 <filename>WidgetLoaderFactory.java</filename> 文件中找"
"到可以实际运行的示例."

#. Tag: title
#: chapter-mobile.xml:2480
#, no-c-format
msgid "Generating the Widget Map"
msgstr "生成 Widget Map"

#. Tag: para
#: chapter-mobile.xml:2482
#, no-c-format
msgid ""
"You can fine-tune a widget set by using a custom "
"<classname>WidgetMapGenerator</classname> implementation. The generator "
"class should extend <classname>TouchKitBundleLoaderFactory</classname> and "
"override its <methodname>getConnectorsForWidgetset()</methodname> method. "
"The method returns the connector classes of the widgets used in the widget "
"set."
msgstr ""
"你可以使用自定义的 <classname>WidgetMapGenerator</classname> 实现来对 Widget "
"Set 进行调优. Generator 类应该继承 <classname>TouchKitBundleLoaderFactory</"
"classname>, 并重载 <methodname>getConnectorsForWidgetset()</methodname> 方"
"法. 这个方法返回 Widget Set 中使用的 Widget 的连接器类."

#. Tag: para
#: chapter-mobile.xml:2491
#, no-c-format
msgid ""
"The list of used connectors (and their widgets) can be built manually if you "
"know what components you use in your application. You can also, for example, "
"use a debugger to dig into the <classname>CommunicationManager</classname> "
"class in Vaadin, which opens all the views of the running application. It "
"contains a set of all components that have been used so far."
msgstr ""
"如果你知道你的应用程序中使用了哪些组件, 那么可以手动构建使用的连接器(以及对应"
"的 Widget)列表. 你还可以, 比如, 使用调试器来研究一下 Vaadin 的 "
"<classname>CommunicationManager</classname> 类, 它会打开运行中的应用程序内的"
"所有视图. 这个类中会包含一个集合, 其内容是到目前为止所用到的所有组件."

#. Tag: para
#: chapter-mobile.xml:2500
#, no-c-format
msgid ""
"In Parking Demo, we first build a list of the connector class names in the "
"constructor as follows:"
msgstr "在 Parking 示例程序中, 我们首先在构造函数中构建连接器类名的列表, 如下:"

#. Tag: programlisting
#: chapter-mobile.xml:2505
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[\n"
"public class WidgetLoaderFactory\n"
"       extends TouchKitBundleLoaderFactory {\n"
"    private final ArrayList<String> usedConnectors;\n"
"\n"
"    public WidgetLoaderFactory() {\n"
"        usedConnectors = new ArrayList<String>();\n"
"        usedConnectors.add(ButtonConnector.class.getName());\n"
"        usedConnectors.add(ChartConnector.class.getName());\n"
"        usedConnectors.add(CssLayoutConnector.class.getName());\n"
"        ...]]>"
msgstr ""

#. Tag: para
#: chapter-mobile.xml:2507
#, no-c-format
msgid ""
"Then we use the list it in the <methodname>getConnectorsForWidgetset()</"
"methodname> to create the proper list of class type definitions by filtering "
"them from all class type definitions. <classname>JClassType</classname> is "
"used for type definition."
msgstr ""
"然后我们在 <methodname>getConnectorsForWidgetset()</methodname> 方法中, 使用"
"这个列表从所有类型定义中过滤出需要的类, 创建适当的类型定义列表. "
"<classname>JClassType</classname> 用来表达类型定义."

#. Tag: programlisting
#: chapter-mobile.xml:2515
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[@Override\n"
"protected Collection<JClassType> getConnectorsForWidgetset(\n"
"        TreeLogger logger, TypeOracle typeOracle)\n"
"        throws UnableToCompleteException {\n"
"    // The usedConnectors list should contain all the\n"
"    // connectors that we need in the app, so we\n"
"    // can leave all others away.\n"
"\n"
"    // Get all connectors in the unoptimized widget set\n"
"    Collection<JClassType> connectorsForWidgetset = super\n"
"            .getConnectorsForWidgetset(logger, typeOracle);\n"
"\n"
"    // Filter the connectors using the used list\n"
"    ArrayList<JClassType> arrayList =\n"
"            new ArrayList<JClassType>();\n"
"    for (JClassType jClassType : connectorsForWidgetset) {\n"
"        String qualifiedSourceName =\n"
"            jClassType.getQualifiedSourceName();\n"
"        if (usedConnectors.contains(qualifiedSourceName)) {\n"
"            arrayList.add(jClassType);\n"
"        }\n"
"    }\n"
"    return arrayList;\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2519
#, no-c-format
msgid "Defining the Widget Loading Style"
msgstr "定义 Widget 的装载方式"

#. Tag: para
#: chapter-mobile.xml:2521
#, no-c-format
msgid ""
"The <methodname>getLoadStyle()</methodname> method should return the widget "
"loading style, which should be <parameter>EAGER</parameter> to get a "
"monolithic widgetset."
msgstr ""
"<methodname>getLoadStyle()</methodname> 方法返回 Widget 的装载方式, 为了实现"
"整体的 Widget Set, 返回值应该是 <parameter>EAGER</parameter>."

#. Tag: programlisting
#: chapter-mobile.xml:2527
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[    @Override\n"
"    protected LoadStyle getLoadStyle(JClassType connectorType) {\n"
"        return LoadStyle.EAGER;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2531
#, no-c-format
msgid "Applying the Custom Widget Map Generator"
msgstr "应用自定义的 Widget Map Generator"

#. Tag: para
#: chapter-mobile.xml:2533
#, no-c-format
msgid ""
"It needs to be defined in the <filename>.gwt.xml</filename> widget set "
"definition file as follows:"
msgstr "需要在 <filename>.gwt.xml</filename> Widget Set 定义文件中定义, 如下:"

#. Tag: programlisting
#: chapter-mobile.xml:2538
#, no-c-format
msgid ""
"&lt;generate-with class=\"<replaceable>com.myprj.WidgetLoaderFactory</"
"replaceable>\"&gt;\n"
"    &lt;when-type-assignable class=\"com.vaadin.client.metadata."
"ConnectorBundleLoader\" /&gt;\n"
"&lt;/generate-with&gt;"
msgstr ""

#. Tag: title
#: chapter-mobile.xml:2542
#, no-c-format
msgid "Deployment"
msgstr "部署"

#. Tag: para
#: chapter-mobile.xml:2544
#, no-c-format
msgid ""
"Note that you need to enable GZip compression for your deployment if you "
"wish to optimize the startup time and minimize the amount of transferred "
"data. The best method for doing that highly depends on your hosting setup, "
"so we do not cover it here."
msgstr ""
"注意, 如果你希望优化应用程序的启动时间, 并将数据传输量降到最低, 你需要为你的"
"应用程序启用 GZip 压缩功能. 这个问题的最佳实现方法与你的服务器主机设置高度相"
"关, 因此本书不讨论这个问题."

#. Tag: title
#: chapter-mobile.xml:2554
#, no-c-format
msgid "Testing and Debugging on Mobile Devices"
msgstr "在移动设备上测试和调试"

#. Tag: para
#: chapter-mobile.xml:2556
#, no-c-format
msgid ""
"Testing places special challenges for mobile devices. The mobile browsers "
"may not have much debugging features and you may not be able to install "
"third-party debugging add-ons, such as the Chrome Developer Tools."
msgstr ""
"对于移动设备来说, 测试时一个特殊的挑战. 移动设备浏览器可能并不带有很多调试功"
"能, 你可能无法安装第三方调试插件, 比如 Chrome Developer Tools."

#. Tag: title
#: chapter-mobile.xml:2563
#, no-c-format
msgid "Debugging"
msgstr "调试"

#. Tag: para
#: chapter-mobile.xml:2565
#, no-c-format
msgid ""
"The debug window, as described in <xref linkend=\"advanced.debug\"/>, works "
"on mobile browsers as well, even if it is a bit harder to use."
msgstr ""
"Debug 窗口(详情请参见 <xref linkend=\"advanced.debug\"/>), 在移动设备浏览器中"
"也可以工作, 虽然稍微有些难用."

#. Tag: para
#: chapter-mobile.xml:2571
#, no-c-format
msgid ""
"The lack of in-browser analysis tools can be helped with simple client-side "
"coding. For example, you can dump the HTML content of the page with the "
"<parameter>innerHTML</parameter> property in the HTML DOM. To do so, you "
"need to execute a JavaScript call from the server-side and handle its "
"response with a call-back method, as described in <xref linkend=\"advanced."
"javascript.callback\"/>."
msgstr ""
"虽然缺少浏览器内的分析工具, 但可以通过简单的呵护端代码来补救. 比如, 你可以使"
"用 HTML DOM 中的 <parameter>innerHTML</parameter> 属性来保存页面的 HTML 内"
"容. 为了实现这个目的, 你需要从服务端执行一个 JavaScript 调用, 并使用一个回调"
"方法来处理它的应答, 详情请参见 <xref linkend=\"advanced.javascript.callback"
"\"/>."

#. Tag: title
#: chapter-mobile.xml:2581
#, no-c-format
msgid "Desktop Debugging"
msgstr "桌面调试"

#. Tag: para
#: chapter-mobile.xml:2583
#, no-c-format
msgid ""
"TouchKit supports especially WebKit-based browsers, which are used in iOS "
"and Android devices. You can therefore reach a decent compatibility by using "
"a desktop browser based on WebKit, such as Google Chrome. Features such as "
"geolocation are also supported by desktop browsers. If you make your phone/"
"tablet-detection and orientation detection using screen size, you can easily "
"emulate the modes by resizing the browser. Also, the browsers have special "
"development settings to emulate some features in touch devices."
msgstr ""
"TouchKit 优先支持基于 WebKit 的浏览器, iOS 和 Android 设备使用的都是这类浏览"
"器. 因此你可以使用 WebKit 的桌面浏览器实现与移动设备浏览大致的兼容, 比如使用 "
"Google Chrome. 桌面浏览器也支持地理位置信息之类的功能. 如果你的应用程序需要自"
"动适应手机/Tablet 环境的不同屏幕尺寸, 以及不同的屏幕方向, 你可以简单地拖动浏"
"览器大小来模拟各种屏幕模式. 此外, 浏览器还带有特殊的开发设定, 来模拟触摸设备"
"上的某些功能."

#. Tag: title
#: chapter-mobile.xml:2596
#, no-c-format
msgid "Remote Debugging"
msgstr "远程调试"

#. Tag: para
#: chapter-mobile.xml:2598
#, no-c-format
msgid ""
"Both Safari and <link xlink:href=\"https://developers.google.com/chrome-"
"developer-tools/docs/remote-debugging\">Chrome</link> support remote "
"debugging, which allows you to debug the supported mobile browsers remotely "
"from a desktop browser."
msgstr ""
"Safari 和 <link xlink:href=\"https://developers.google.com/chrome-developer-"
"tools/docs/remote-debugging\">Chrome</link> 都支持远程调试, 这个功能允许你从"
"桌面浏览器来远程调试移动设备浏览器."
