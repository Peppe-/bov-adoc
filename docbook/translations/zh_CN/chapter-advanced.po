# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-11-05 03:35+0000\n"
"PO-Revision-Date: 2014-11-05 13:13+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-advanced.xml:11
#, no-c-format
msgid "Advanced Web Application Topics"
msgstr "Web 应用程序开发的高级问题"

#. Tag: para
#: chapter-advanced.xml:13
#, no-c-format
msgid ""
"This chapter covers various features and topics often needed in applications."
msgstr "本章将介绍应用程序开发中常见的一些功能和问题."

#. Tag: title
#: chapter-advanced.xml:19
#, no-c-format
msgid "Handling Browser Windows"
msgstr "管理浏览器窗口"

#. Tag: para
#: chapter-advanced.xml:21
#, no-c-format
msgid ""
"The UI of a Vaadin application runs in a web page displayed in a browser "
"window or tab. An application can be used from multiple UIs in different "
"windows or tabs, either opened by the user using an URL or by the Vaadin "
"application."
msgstr ""
"Vaadin 应用程序的 UI 运行在 Web 页面内, Web 页面则显示在浏览器窗口或 Tab 中. "
"应用程序可以由不同窗口或不同 Tab 中的多个 UI 使用, 这些窗口或 Tab 可以是用户"
"通过 URL 打开的, 也可以是 Vaadin 应用程序打开的."

#. Tag: para
#: chapter-advanced.xml:28
#, no-c-format
msgid ""
"In addition to native browser windows, Vaadin has a <classname>Window</"
"classname> component, which is a floating panel or <emphasis>sub-window</"
"emphasis> inside a page, as described in <xref linkend=\"layout.sub-window\"/"
">."
msgstr ""
"除浏览器原生的窗口外, Vaadin 还有一个 <classname>Window</classname> 组件, 它"
"是页面内的一个浮动的 panel, 或者叫 <emphasis>子窗口</emphasis>, 详情请参见 "
"<xref linkend=\"layout.sub-window\"/>."

#. Tag: listitem
#: chapter-advanced.xml:36
#, no-c-format
msgid ""
"<emphasis>Native popup windows</emphasis>. An application can open popup "
"windows for sub-tasks."
msgstr ""
"<emphasis>原生弹出式窗口</emphasis>. 应用程序为执行某种子任务, 可以打开弹出式"
"窗口."

#. Tag: listitem
#: chapter-advanced.xml:40
#, no-c-format
msgid ""
"<emphasis>Page-based browsing</emphasis>. The application can allow the user "
"to open certain content to different windows. For example, in a messaging "
"application, it can be useful to open different messages to different "
"windows so that the user can browse through them while writing a new message."
msgstr ""
"<emphasis>基于页面的浏览</emphasis>. 应用程序可以允许用户在其他窗口中打开特定"
"的内容. 比如, 在消息管理程序中, 就会需要在不同的窗口中打开不同的消息, 以便用"
"户一边输入新消息一边浏览这些已有的消息."

#. Tag: listitem
#: chapter-advanced.xml:47
#, no-c-format
msgid ""
"<emphasis>Bookmarking</emphasis>. Bookmarks in the web browser can provide "
"an entry-point to some content provided by an application."
msgstr ""
"<emphasis>书签</emphasis>. Web 浏览器中的书签可以记录下应用程序中某些内容的入"
"口地址."

#. Tag: listitem
#: chapter-advanced.xml:51
#, no-c-format
msgid ""
"<emphasis>Embedding UIs</emphasis>. UIs can be embedded in web pages, thus "
"making it possible to provide different views to an application from "
"different pages or even from the same page, while keeping the same session. "
"See <xref linkend=\"advanced.embedding\"/>."
msgstr ""
"<emphasis>嵌入式 UI</emphasis>. UI 可以嵌入到 Web 页面中, 因此可以通过不同的"
"页面为同一个应用程序提供不同的界面, 甚至可以在同一个界面内提供不同的界面, 同"
"时还能将这些界面保持在同一个 session 内. 详情请参见 <xref linkend=\"advanced."
"embedding\"/>."

#. Tag: para
#: chapter-advanced.xml:59
#, no-c-format
msgid ""
"Use of multiple windows in an application may require defining and providing "
"different UIs for the different windows. The UIs of an application share the "
"same user session, that is, the <classname>VaadinSession</classname> object, "
"as described in <xref linkend=\"application.lifecycle.session\"/>. Each UI "
"is identified by a URL that is used to access it, which makes it possible to "
"bookmark application UIs. UI instances can even be created dynamically based "
"on the URLs or other request parameters, such as browser information, as "
"described in <xref linkend=\"application.lifecycle.ui\"/>."
msgstr ""
"在应用程序内使用多窗口可能需要为不同的窗口定义和提供不同的 UI. 应用程序中的 "
"UI 共用相同的 session, 也就是同一个 <classname>VaadinSession</classname> 对"
"象, 详情请参见 <xref linkend=\"application.lifecycle.session\"/>. 各个 UI 通"
"过与它绑定的 URL 来区分, 因此可以将应用程序中各 UI 的地址保存为浏览器书签. "
"UI 实例甚至可以根据 URL 或其他请求参数来动态创建, 比如根据浏览器信息不同来创"
"建不同的 UI, 详情请参见 <xref linkend=\"application.lifecycle.ui\"/>."

#. Tag: para
#: chapter-advanced.xml:70
#, no-c-format
msgid ""
"Because of the special nature of AJAX applications, use of multiple windows "
"uses require some caveats."
msgstr "由于 AJAX 应用程序的特殊性质, 使用多窗口也会存在一些限制."

#. Tag: title
#: chapter-advanced.xml:77
#, no-c-format
msgid "Opening Popup Windows"
msgstr "打开弹出式窗口"

#. Tag: primary
#: chapter-advanced.xml:79
#, no-c-format
msgid "popup windows"
msgstr ""

#. Tag: primary
#: chapter-advanced.xml:82
#, no-c-format
msgid "windows"
msgstr ""

#. Tag: secondary
#: chapter-advanced.xml:83
#, no-c-format
msgid "popup"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:86
#, no-c-format
msgid ""
"Popup windows are native browser windows or tabs opened by user interaction "
"with an existing window. Due to browser security reasons, it is made "
"incovenient for a web page to open popup windows using JavaScript commands. "
"At the least, the browser will ask for a permission to open the popup, if it "
"is possible at all. This limitation can be circumvented by letting the "
"browser open the new window or tab directly by its URL when the user clicks "
"some target. This is realized in Vaadin with the "
"<classname>BrowserWindowOpener</classname> component extension, which causes "
"the browser to open a window or tab when the component is clicked."
msgstr ""
"弹出窗口是浏览器原生的窗口或 Tab, 它通过用户在一个既存窗口中的操作来打开. 由"
"于浏览器安全性上的限制, 在 Web 页面中使用 JavaScript 命令来打开弹出窗口是很不"
"方便的. 即使浏览器可以打开弹出窗口, 至少它也会询问用户是否允许打开弹出窗口. "
"可以用一些手段来绕过这个限制, 方法是当用户点击某些元素时, 直接使用 URL 来让浏"
"览器打开新窗口或新 Tab. 这种方法在 Vaadin 中是通过 "
"<classname>BrowserWindowOpener</classname> 组件扩展实现的, 它可以在组件被点击"
"时让浏览器打开新窗口或新 Tab."

#. Tag: title
#: chapter-advanced.xml:99
#, no-c-format
msgid "The Popup Window UI"
msgstr "弹出窗口 UI"

#. Tag: para
#: chapter-advanced.xml:101
#, no-c-format
msgid ""
"A popup Window displays an <classname>UI</classname>. The UI of a popup "
"window is defined just like a main UI in a Vaadin application, and it can "
"have a theme, title, and so forth."
msgstr ""
"弹出窗口也会显示一个 <classname>UI</classname>. 弹出窗口的 UI 的声明与 "
"Vaadin 应用程序的 UI 类似, 它也可以拥有 theme, 标题, 等等."

#. Tag: para
#: chapter-advanced.xml:107 chapter-advanced.xml:170 chapter-advanced.xml:419
#: chapter-advanced.xml:560 chapter-advanced.xml:3515
#, no-c-format
msgid "For example:"
msgstr "比如:"

#. Tag: programlisting
#: chapter-advanced.xml:111
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@Theme(\"book-examples\")\n"
"public static class MyPopupUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        getPage().setTitle(\"Popup Window\");\n"
"        \n"
"        // Have some content for it\n"
"        VerticalLayout content = new VerticalLayout();\n"
"        Label label =\n"
"            new Label(\"I just popped up to say hi!\");\n"
"        label.setSizeUndefined();\n"
"        content.addComponent(label);\n"
"        content.setComponentAlignment(label,\n"
"            Alignment.MIDDLE_CENTER);\n"
"        content.setSizeFull();\n"
"        setContent(content);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:115
#, no-c-format
msgid "Popping It Up"
msgstr "弹出它"

#. Tag: para
#: chapter-advanced.xml:117
#, no-c-format
msgid ""
"A popup window is opened using the <classname>BrowserWindowOpener</"
"classname> extension, which you can attach to any component. The constructor "
"of the extension takes the class object of the UI class to be opened as a "
"parameter."
msgstr ""
"弹出窗口使用 <classname>BrowserWindowOpener</classname> 扩展来弹出, 你可以将"
"这个扩展绑定到任意组件上. 它的构造函数参数是希望打开的 UI 类."

#. Tag: para
#: chapter-advanced.xml:124
#, no-c-format
msgid ""
"You can configure the features of the popup window with "
"<methodname>setFeatures()</methodname>. It takes as its parameter a comma-"
"separated list of window features, as defined in the HTML specification."
msgstr ""
"你可以使用 <methodname>setFeatures()</methodname> 方法来配置弹出窗口的特性. "
"这个方法的参数是逗号分隔的窗口特性列表, 窗口特性遵照 HTML 规约中的定义."

#. Tag: term
#: chapter-advanced.xml:133
#, no-c-format
msgid "<varname>status</varname>=<parameter>0|1</parameter>"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:134
#, no-c-format
msgid "Whether the status bar at the bottom of the window should be enabled."
msgstr "窗口下方的状态栏是否显示."

#. Tag: term
#: chapter-advanced.xml:137
#, no-c-format
msgid "<varname></varname><parameter></parameter>"
msgstr ""

#. Tag: varname
#: chapter-advanced.xml:141
#, no-c-format
msgid "scrollbars"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:142
#, no-c-format
msgid ""
"Enables scrollbars in the window if the document area is bigger than the "
"view area of the window."
msgstr "当文档内容比窗口中的视图区域更大时, 显示滚动条."

#. Tag: varname
#: chapter-advanced.xml:145
#, no-c-format
msgid "resizable"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:146
#, no-c-format
msgid "Allows the user to resize the browser window (no effect for tabs)."
msgstr "允许用户拉伸浏览器窗口大小(对 Tab 无效)."

#. Tag: varname
#: chapter-advanced.xml:149
#, no-c-format
msgid "menubar"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:150
#, no-c-format
msgid "Enables the browser menu bar."
msgstr "显示浏览器菜单栏."

#. Tag: varname
#: chapter-advanced.xml:153
#, no-c-format
msgid "location"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:154
#, no-c-format
msgid "Enables the location bar."
msgstr "显示地址栏."

#. Tag: varname
#: chapter-advanced.xml:157
#, no-c-format
msgid "toolbar"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:158
#, no-c-format
msgid "Enables the browser toolbar."
msgstr "显示浏览器工具栏."

#. Tag: term
#: chapter-advanced.xml:161
#, no-c-format
msgid "<varname>height</varname>=<parameter>value</parameter>"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:162
#, no-c-format
msgid "Specifies the height of the window in pixels."
msgstr "指定窗口高度, 单位为像素."

#. Tag: term
#: chapter-advanced.xml:165
#, no-c-format
msgid "<varname>width</varname>=<parameter>value</parameter>"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:166
#, no-c-format
msgid "Specifies the width of the window in pixels."
msgstr "指定窗口宽度, 单位为像素."

#. Tag: programlisting
#: chapter-advanced.xml:174
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create an opener extension\n"
"BrowserWindowOpener opener =\n"
"    new BrowserWindowOpener(MyPopupUI.class);\n"
"opener.setFeatures(\"height=200,width=300,resizable\");\n"
"\n"
"// Attach it to a button\n"
"Button button = new Button(\"Pop It Up\");\n"
"opener.extend(button);]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:176
#, no-c-format
msgid ""
"The resulting popup window, which appears when the button is clicked, is "
"shown in <xref linkend=\"figure.advanced.windows.popup.popping\"/>."
msgstr ""
"按钮按下后出现弹出窗口, 运行结果见 <xref linkend=\"figure.advanced.windows."
"popup.popping\"/>."

#. Tag: title
#: chapter-advanced.xml:182
#, no-c-format
msgid "A Popup Window"
msgstr "弹出窗口"

#. Tag: title
#: chapter-advanced.xml:195
#, no-c-format
msgid "Popup Window Name (Target)"
msgstr "弹出窗口的名称(Target)"

#. Tag: para
#: chapter-advanced.xml:197
#, no-c-format
msgid ""
"The target name is one of the default HTML target names (<parameter>_new</"
"parameter>, <parameter>_blank</parameter>, <parameter>_top</parameter>, "
"etc.) or a custom target name. How the window is exactly opened depends on "
"the browser. Browsers that support tabbed browsing can open the window in "
"another tab, depending on the browser settings."
msgstr ""
"窗口的 target 名称可以是 HTML 默认 target 名称之一(<parameter>_new</"
"parameter>, <parameter>_blank</parameter>, <parameter>_top</parameter>, 等"
"等.), 也可以是自定义的 target 名称. 窗口具体会如何打开, 由浏览器决定. 支持 "
"tab 式浏览的浏览器可能会在另一个 tab 内打开窗口, 具体取决于浏览器的设置."

#. Tag: title
#: chapter-advanced.xml:208
#, no-c-format
msgid "URL and Session"
msgstr "URL 与 Session"

#. Tag: para
#: chapter-advanced.xml:210
#, no-c-format
msgid ""
"The URL path for a popup window UI is by default determined from the UI "
"class name, by prefixig it with \"<literal>popup/</literal>\". For example, "
"for the example UI giver earlier, the URL would be <literal>/book-examples/"
"book/popup/MyPopupUI</literal>."
msgstr ""
"弹出窗口 UI 的 URL 路径默认由 UI 的类名决定, 使用 \"<literal>popup/</literal>"
"\" 前缀. 比如, 对于前面例子中给出的 UI, 它的 URL 将是 <literal>/book-"
"examples/book/popup/MyPopupUI</literal>."

#. Tag: title
#: chapter-advanced.xml:221
#, no-c-format
msgid "Closing Popup Windows"
msgstr "关闭弹出式窗口"

#. Tag: para
#: chapter-advanced.xml:223
#, no-c-format
msgid ""
"Besides closing popup windows from a native window close button, you can "
"close them programmatically by calling the JavaScript <methodname>close()</"
"methodname> method as follows."
msgstr "除了使用浏览器的窗口关闭按钮来关闭弹出窗口之外, 你还可以调用 JavaScript 的 <methodname>close()</methodname> 方法来关闭它, 如下:"

#. Tag: programlisting
#: chapter-advanced.xml:229
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyPopup extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        setContent(new Button(\"Close Window\", event -> {// Java 8\n"
"            // Close the popup\n"
"            JavaScript.eval(\"close()\");\n"
"\n"
"            // Detach the UI from the session\n"
"            getUI().close();\n"
"        }));\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:273
#, no-c-format
msgid "Embedding UIs in Web Pages"
msgstr "在 Web 页面中嵌入 UI"

#. Tag: para
#: chapter-advanced.xml:275
#, no-c-format
msgid ""
"Many web sites are not all Vaadin, but Vaadin UIs are used only for specific "
"functionalities. In practice, many web applications are a mixture of dynamic "
"web pages, such as JSP, and Vaadin UIs embedded in such pages."
msgstr ""
"很多 Web 站点并不是完全使用 Vaadin 开发的, 但 Vaadin UI 在其中用于某些特定的"
"功能. 实际应用中, 很多 Web 应用程序是由动态 Web 页面混合而成的, 比如 JSP, "
"Vaadin UI 则嵌入在这些页面之内."

#. Tag: para
#: chapter-advanced.xml:281
#, no-c-format
msgid ""
"Embedding Vaadin UIs in web pages is easy and there are several different "
"ways to embed them. One is to have a <literal>&lt;div&gt;</literal> "
"placeholder for the UI and load the Vaadin Client-Side Engine with some "
"simple JavaScript code. Another method is even easier, which is to simply "
"use the <literal>&lt;iframe&gt;</literal> element. Both of these methods "
"have advantages and disadvantages. One disadvantage of the <literal>&lt;"
"iframe&gt;</literal> method is that the size of the <literal>&lt;iframe&gt;</"
"literal> element is not flexible according to the content while the "
"<literal>&lt;div&gt;</literal> method allows such flexibility. The following "
"sections look closer into these two embedding methods."
msgstr ""
"将 Vaadin UI 嵌入到 Web 页面之内是很容易的, 而且有几种不同方法可以实现 UI 的"
"嵌入. 第一种方法是为 UI 使用一个 <literal>&lt;div&gt;</literal> 占位符, 然后"
"使用一段简单的 JavaScript 代码装载 Vaadin 客户端引擎. 另一种方法更简单, 只需"
"要使用 <literal>&lt;iframe&gt;</literal> 元素即可. 这些方法都有各自的优点和缺"
"点. <literal>&lt;iframe&gt;</literal> 方法的缺点之一是 <literal>&lt;"
"iframe&gt;</literal> 元素的尺寸不能灵活适应 UI 的内容, 而 <literal>&lt;"
"div&gt;</literal> 则是可以的. 以下小节详细介绍这两种嵌入方法."

#. Tag: title
#: chapter-advanced.xml:301
#, no-c-format
msgid "Embedding Inside a <literal>div</literal> Element"
msgstr "在 <literal>div</literal> 元素内嵌入 UI"

#. Tag: para
#: chapter-advanced.xml:303
#, no-c-format
msgid ""
"You can embed one or more Vaadin UIs inside a web page with a method that is "
"equivalent to loading the initial page content from the Vaadin servlet in a "
"non-embedded UI. Normally, the <classname>VaadinServlet</classname> "
"generates an initial page that contains the correct parameters for the "
"specific UI. You can easily configure it to load multiple Vaadin UIs in the "
"same page. They can have different widget sets and different themes."
msgstr ""
"你可以在 Web 页面内嵌入一个或多个 Vaadin UI, 方法与非嵌入式 UI 中通过 Vaadin "
"Servlet 来装载初始化页面的方法相同. 通常, <classname>VaadinServlet</"
"classname> 会生成初始化页面, 其中包含用于装载特定 UI 的正确参数. 你可以很容易"
"的配置它, 使它在同一个页面内装载多个 Vaadin UI. 这些 UI 可以使用不同的 "
"Widget 群和不同的 theme."

#. Tag: para
#: chapter-advanced.xml:312
#, no-c-format
msgid "Embedding an UI requires the following basic tasks:"
msgstr "嵌入 UI 需要完成以下基本任务:"

#. Tag: listitem
#: chapter-advanced.xml:317
#, no-c-format
msgid "Set up the page header"
msgstr "设置页面的 header 部"

#. Tag: listitem
#: chapter-advanced.xml:318
#, no-c-format
msgid "Include a GWT history frame in the page"
msgstr "在页面内包含 GWT 的历史 frame"

#. Tag: listitem
#: chapter-advanced.xml:319
#, no-c-format
msgid "Call the <filename>vaadinBootstrap.js</filename> file"
msgstr "调用 <filename>vaadinBootstrap.js</filename> 文件"

#. Tag: listitem
#: chapter-advanced.xml:320
#, no-c-format
msgid "Define the <literal>&lt;div&gt;</literal> element for the UI"
msgstr "为 UI 定义 <literal>&lt;div&gt;</literal> 元素"

#. Tag: listitem
#: chapter-advanced.xml:321
#, no-c-format
msgid "Configure and initialize the UI"
msgstr "配置并初始化 UI"

#. Tag: para
#: chapter-advanced.xml:324
#, no-c-format
msgid ""
"Notice that you can view the loader page for the UI easily by opening the UI "
"in a web browser and viewing the HTML source code of the page. You could "
"just copy and paste the embedding code from the page, but some modifications "
"and additional settings are required, mainly related to the URLs that have "
"to be made relative to the page instead of the servlet URL."
msgstr ""
"注意, 你可以很容易地查看 UI 的装载页面, 方法是在 Web 浏览器中打开 UI, 然后查"
"看这个页面的 HTML 源代码. 你可以从这个页面中将负责嵌入 UI 的部分代码复制并粘"
"贴出来, 但可能需要少量的修改和一些额外的设置, 主要的修改与 URL 相关, URL 路径"
"必须修改为相对于新的装载页面, 而不是相对于 Servlet URL."

#. Tag: emphasis
#: chapter-advanced.xml:333
#, no-c-format
msgid ""
"The DIV embedding API is about to change soon after printing this book "
"edition. A tutorial that describes the feature should be made available at "
"the Vaadin website."
msgstr ""
"本书出版后, DIV 嵌入的相关 API 可能很快会修改. Vaadin 网站上应该会有关于这个"
"功能的教程."

#. Tag: title
#: chapter-advanced.xml:339
#, no-c-format
msgid "The Head Matter"
msgstr "Head 部分"

#. Tag: para
#: chapter-advanced.xml:341
#, no-c-format
msgid ""
"The HTML page in which the Vaadin UI is embedded should be a valid HTML 5 "
"document. The content of the head element is largely up to you. The "
"character encoding must be UTF-8. Some meta declarations are necessary for "
"compatibility. You can also set the page favicon in the head element."
msgstr ""
"嵌入 Vaadin UI 的 HTML 页面必须是合法的 HTML 5 文档. Head 元素的内容很大程度上由你决定. 字符编码必须是 UTF-8. 为"
"保持兼容性, 还必须定义一些其他 meta 信息. 你还可以在 Head 元素中设置页面的 "
"favicon."

#. Tag: programlisting
#: chapter-advanced.xml:349
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;!DOCTYPE html&gt;\n"
"&lt;html&gt;\n"
"  &lt;head&gt;\n"
"    &lt;meta http-equiv=\"Content-Type\"\n"
"          content=\"text/html; charset=UTF-8\" /&gt;\n"
"    &lt;meta http-equiv=\"X-UA-Compatible\"\n"
"          content=\"IE=9;chrome=1\" /&gt;\n"
"\n"
"    &lt;title&gt;<replaceable>This is my Embedding Page</replaceable>&lt;/"
"title&gt;\n"
"  \n"
"    &lt;!-- Set up the favicon from the Vaadin theme --&gt;\n"
"    &lt;link rel=\"shortcut icon\" type=\"image/vnd.microsoft.icon\"\n"
"          href=\"/VAADIN/themes/<replaceable>reindeer</replaceable>/favicon."
"ico\" /&gt;\n"
"    &lt;link rel=\"icon\" type=\"image/vnd.microsoft.icon\"\n"
"             href=\"/VAADIN/themes/<replaceable>reindeer</replaceable>/"
"favicon.ico\" /&gt; \n"
"  &lt;/head&gt;"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:353
#, no-c-format
msgid "The Body Matter"
msgstr "Body 部分"

#. Tag: para
#: chapter-advanced.xml:355
#, no-c-format
msgid ""
"The page content must include some Vaadin-related definitions before you can "
"embed Vaadin UIs in it."
msgstr "在嵌入 Vaadin UI 之前, 页面内容中必须包含一些 Vaadin 相关的定义信息."

#. Tag: para
#: chapter-advanced.xml:360
#, no-c-format
msgid ""
"The <filename>vaadinBootstrap.js</filename> script makes definitions for "
"starting up the UI. It must be called before initializing the UI. The source "
"path must be relative to the path of the embedding page."
msgstr ""
"<filename>vaadinBootstrap.js</filename> 脚本定义了 UI 启动相关的内容. 在初始"
"化 UI 之前必须调用这个脚本. 这个脚本的源文件路径必须设置为相对于嵌入 UI 的页"
"面路径."

#. Tag: programlisting
#: chapter-advanced.xml:367
#, no-c-format
msgid ""
"&lt;body&gt;\n"
"  &lt;script type=\"text/javascript\"\n"
"          src=\"<replaceable>./</replaceable>VAADIN/vaadinBootstrap.js\"&gt;"
"&lt;/script&gt;"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:369
#, no-c-format
msgid ""
"The bootstrap script is served by the Vaadin servlet from inside the "
"<filename>vaadin-server</filename> JAR."
msgstr ""
"启动脚本由 <filename>vaadin-server</filename> JAR 内的 Vaadin Servlet 对外提"
"供."

#. Tag: para
#: chapter-advanced.xml:374
#, no-c-format
msgid ""
"Vaadin, or more precisely GWT, requires an invisible history frame, which is "
"used for tracking the page or fragment history in the browser."
msgstr ""
"Vaadin, 更确切的说是 GWT, 需要一个不可见的历史 frame, 用来在浏览器内追踪页面"
"或页面片段的历史."

#. Tag: programlisting
#: chapter-advanced.xml:380
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[  <iframe tabindex=\"-1\" id="
"\"__gwt_historyFrame\"\n"
"          style=\"position: absolute; width: 0; height: 0;\n"
"                 border: 0; overflow: hidden\"\n"
"          src=\"javascript:false\"></iframe>]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:384
#, no-c-format
msgid "UI Placeholder Element"
msgstr "UI 占位元素"

#. Tag: para
#: chapter-advanced.xml:386
#, no-c-format
msgid ""
"A Vaadin UI is embedded in a placeholder <literal>&lt;div&gt;</literal> "
"element. It should have the following features:"
msgstr ""
"Vaadin UI 嵌入在 <literal>&lt;div&gt;</literal> 占位元素内. 它的设置必须如下:"

#. Tag: listitem
#: chapter-advanced.xml:393
#, no-c-format
msgid ""
"The <literal>&lt;div&gt;</literal> element must have an <literal>id</"
"literal> attribute, which must be a unique ID in the page, normally "
"something that identifies the servlet of the UI uniquely."
msgstr ""
"<literal>&lt;div&gt;</literal> 元素必须有 <literal>id</literal> 属性, 值必须"
"是页面内的唯一 ID, 通常是一个可以唯一标识 UI 的 Servlet 的字符串."

#. Tag: listitem
#: chapter-advanced.xml:398
#, no-c-format
msgid "It must have at least the <literal>v-app</literal> style class."
msgstr "它必须至少带有 <literal>v-app</literal> 样式."

#. Tag: listitem
#: chapter-advanced.xml:401
#, no-c-format
msgid ""
"it should have a nested <literal>&lt;div&gt;</literal> element with "
"<literal>v-app-loading</literal> style class. This is a placeholder for the "
"loading indicator that is displayed while the UI is being loaded."
msgstr ""
"它应该有一个内嵌的 <literal>&lt;div&gt;</literal> 元素, 带有 <literal>v-app-"
"loading</literal> 样式. 这个是装载中状态指示器的占位元素, UI 装载过程中将会显"
"示这个指示器."

#. Tag: listitem
#: chapter-advanced.xml:406
#, no-c-format
msgid ""
"It should also contain a <literal>&lt;noscript&gt;</literal> element that is "
"shown if the browser does not support JavaScript or it has been disabled. "
"The content of the element should instruct the use to enable JavaScript in "
"the browser."
msgstr ""
"它还需要包含一个 <literal>&lt;noscript&gt;</literal> 元素, 当浏览器不支持 "
"JavaScript 或 JavaScript 被禁用时会显示这个元素. 这个元素的内容应该指导用户去"
"启用浏览器中的 JavaScript 功能."

#. Tag: para
#: chapter-advanced.xml:412
#, no-c-format
msgid ""
"The placeholder element can include style settings, typically a width and "
"height. If the sizes are not defined, the UI will have an undefined size in "
"the particular dimension, which must be in accordance with the sizing of the "
"UI components."
msgstr ""
"这个占位元素可以包含样式设定, 通常用来指定宽度和高度. 如果占位元素的尺寸未定"
"义, UI 在对应的方向上的尺寸也会是未定义尺寸, UI 的尺寸必须与其中的 UI 组件的"
"尺寸一致."

#. Tag: programlisting
#: chapter-advanced.xml:423
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;div style=\"<replaceable>width: 300px; border: 2px "
"solid green;</replaceable>\"\n"
"     id=\"helloworldui\" class=\"v-app\"&gt;\n"
"  &lt;div class=\"v-app-loading\"&gt;&lt;/div&gt;\n"
"  &lt;noscript&gt;<replaceable>You have to enable javascript in your browser "
"to</replaceable>\n"
"            <replaceable>use an application built with Vaadin.</"
"replaceable>&lt;/noscript&gt;\n"
"&lt;/div&gt;"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:428
#, no-c-format
msgid "Initializing the UI"
msgstr "初始化 UI"

#. Tag: para
#: chapter-advanced.xml:430
#, no-c-format
msgid ""
"The UI is loaded by calling the <literal>initApplication()</literal> method "
"for the <literal>vaadin</literal> object defined in the bootstrap script. "
"Before calling it, you should check that the bootstrap script was loaded "
"properly."
msgstr ""
"启动脚本中定义了 <literal>vaadin</literal> 对象, 对这个对象调用 "
"<literal>initApplication()</literal> 方法, 即可装载 UI. 调用这个方法之前, 你"
"应该检查启动脚本有没有正确装载."

#. Tag: programlisting
#: chapter-advanced.xml:437
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;script type=\"text/javascript\"&gt;//&lt;![CDATA[\n"
"  if (!window.vaadin)\n"
"      alert(\"<replaceable>Failed to load the bootstrap JavaScript:</"
"replaceable>\"+\n"
"            \"<replaceable>VAADIN/vaadinBootstrap.js</replaceable>\");"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:439
#, no-c-format
msgid ""
"The <literal>initApplication()</literal> takes two parameters. The first "
"parameter is the UI identifier, exactly as given as the <literal>id</"
"literal> attribute of the placeholder element. The second parameter is an "
"associative map that contains parameters for the UI."
msgstr ""
"<literal>initApplication()</literal> 方法接受两个参数. 第一个参数是 UI 的标识"
"符, 必须与占位符元素的 <literal>id</literal> 属性值完全一致. 第二个参数是一个"
"Map, 其中包含传递给 UI 的参数."

#. Tag: para
#: chapter-advanced.xml:447
#, no-c-format
msgid "The map must contain the following items:"
msgstr "Map 中必须包含以下项目:"

#. Tag: parameter
#: chapter-advanced.xml:453
#, no-c-format
msgid "browserDetailsUrl"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:455
#, no-c-format
msgid ""
"This should be the URL path (relative to the embedding page) to the Vaadin "
"servlet of the UI. It is used by the bootstrap to communicate browser "
"details. A trailing slash may be needed in some cases."
msgstr ""
"这个参数是 UI 的 Vaadin Servlet 的 URL 路径(相对于嵌入 UI 的页面). 它被启动脚"
"本用于传递浏览器的详细信息. 某些情况下可能需要在 URL 末尾带上斜线."

#. Tag: para
#: chapter-advanced.xml:462
#, no-c-format
msgid ""
"Notice that this parameter is not included in the loader page generated by "
"the servlet, because in that case, it can default to the current URL."
msgstr ""
"注意, 在 Servlet 生成的装载页面中不包含这个参数, 因为这种情况下, 它的默认值就"
"是当前 URL."

#. Tag: parameter
#: chapter-advanced.xml:470
#, no-c-format
msgid "serviceUrl"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:472
#, no-c-format
msgid ""
"This is used for server requests after initial loading and should be same as "
"for <parameter>browserDetailsUrl</parameter>. The two parameters are "
"redundant and either may be removed in future."
msgstr ""
"这个参数用于初期装载之后向服务器发送请求, 而且应该与 "
"<parameter>browserDetailsUrl</parameter> 一样. 这两个参数目前是重复的,  将来"
"可能会删除其中一个."

#. Tag: parameter
#: chapter-advanced.xml:482
#, no-c-format
msgid "widgetset"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:483
#, no-c-format
msgid ""
"This should be the exact class name of the widget set for the UI, that is, "
"without the <filename>.gwt.xml</filename> file name extension. If the UI has "
"no custom widget set, you can use the <classname>com.vaadin."
"DefaultWidgetSet</classname>."
msgstr ""
"这个参数应该是 UI 使用的 widget 群的类名, 也就是, 去掉 <filename>.gwt.xml</"
"filename> 扩展名之后的文件名. 如果 UI 没有自定义 widget 群, 你可以使用 "
"<classname>com.vaadin.DefaultWidgetSet</classname>."

#. Tag: parameter
#: chapter-advanced.xml:491
#, no-c-format
msgid "theme"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:492
#, no-c-format
msgid ""
"Name of the theme, such as one of the built-in themes (<literal>reindeer</"
"literal>, <literal>runo</literal>, or <literal>chameleon</literal>) or a "
"custom theme. It must exist under the <filename>VAADIN/themes</filename> "
"folder."
msgstr ""
"Theme 名称, 比如可以是内建 theme 之一 (<literal>reindeer</literal>, "
"<literal>runo</literal>, 或 <literal>chameleon</literal>), 也可以是自定义 "
"theme. Theme 必须存在于 <filename>VAADIN/themes</filename> 目录之下."

#. Tag: parameter
#: chapter-advanced.xml:500
#, no-c-format
msgid "versionInfo"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:501
#, no-c-format
msgid ""
"This parameter is itself an associative map that can contain two parameters: "
"<parameter>vaadinVersion</parameter> contains the version number of the "
"Vaadin version used by the application. The <parameter>applicationVersion</"
"parameter> parameter contains the version of the particular application. The "
"contained parameters are optional, but the <parameter>versionInfo</"
"parameter> parameter itself is not."
msgstr ""
"这个参数自身又是一个 Map, 其中包含两个参数: <parameter>vaadinVersion</"
"parameter> 是应用程序使用的 Vaadin 版本号. <parameter>applicationVersion</"
"parameter> 是应用程序本身的版本号. 这个 Map 内的参数是可选的, 但 "
"<parameter>versionInfo</parameter> 参数自身是必须的."

#. Tag: parameter
#: chapter-advanced.xml:512
#, no-c-format
msgid "vaadinDir"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:513
#, no-c-format
msgid ""
"Relative path to the <filename>VAADIN</filename> directory. It is relative "
"to the URL of the embedding page."
msgstr "<filename>VAADIN</filename> 目录的相对路径. 相对于嵌入 UI 的页面 URL ."

#. Tag: parameter
#: chapter-advanced.xml:519
#, no-c-format
msgid "heartbeatInterval"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:520
#, no-c-format
msgid ""
"The <parameter>hearbeatInterval</parameter> parameter defines the frequency "
"of the keep-alive hearbeat for the UI in seconds, as described in <xref "
"linkend=\"application.lifecycle.ui-expiration\"/>."
msgstr ""
"<parameter>hearbeatInterval</parameter> 参数指定 UI 的 keep-alive 心跳信号发"
"送频度, 单位为秒, 详情请参见 <xref linkend=\"application.lifecycle.ui-"
"expiration\"/>."

#. Tag: parameter
#: chapter-advanced.xml:528
#, no-c-format
msgid "debug"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:529
#, no-c-format
msgid ""
"The parameter defines whether the debug window, as described in <xref "
"linkend=\"advanced.debug\"/>, is enabled."
msgstr ""
"这个参数指定 Debug 窗口是否激活, 详情请参见 <xref linkend=\"advanced.debug\"/"
">."

#. Tag: parameter
#: chapter-advanced.xml:535
#, no-c-format
msgid "standalone"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:536
#, no-c-format
msgid ""
"This parameter should be <parameter>false</parameter> when embedding. "
"<phrase condition=\"web\">The parameter defines whether the UI is rendered "
"on its own in the browser window or in some context. A standalone UI may do "
"things that might interfere with other parts of the page, such as change the "
"page title and request focus when it is loaded. When embedding, the UI is "
"not standalone.</phrase>"
msgstr ""
"嵌入模式下这个参数应该为 <parameter>false</parameter>. <phrase condition="
"\"web\">这个参数指定 UI 是在独有的浏览器窗口中展现, 还是被用于某种上下文环境"
"中. Standalone 模式的 UI 的某些行为可能会干扰页面的其他部分, 比如它可能改变页"
"面标题, 还可能在装载完成后要求聚焦. 嵌入模式下, UI 不是 Standalone 模式.</"
"phrase>"

#. Tag: term
#: chapter-advanced.xml:547
#, no-c-format
msgid ""
"<parameter>authErrMsg</parameter>, <parameter>comErrMsg</parameter>, and "
"<parameter>sessExpMsg</parameter>"
msgstr ""
"<parameter>authErrMsg</parameter>, <parameter>comErrMsg</parameter>, 和 "
"<parameter>sessExpMsg</parameter>"

#. Tag: listitem
#: chapter-advanced.xml:548
#, no-c-format
msgid ""
"These three parameters define the client-side error messages for "
"authentication error, communication error, and session expiration, "
"respectively. The parameters are associative maps themselves and must "
"contain two key-value pairs: <parameter>message</parameter>, which should "
"contain the error text in HTML, and <parameter>caption</parameter>, which "
"should be the error caption."
msgstr ""
"这些参数指定客户端的错误消息, 分别对应于认证错误, 通信错误, session 过期. 这"
"些参数本身都是 Map, 其中必须包含两组值: <parameter>message</parameter>, 指定 "
"HTML 格式的错误信息文本, 以及 <parameter>caption</parameter>, 指定错误信息标"
"题."

#. Tag: programlisting
#: chapter-advanced.xml:564
#, no-c-format
msgid ""
"<?pocket-size 75% ?>  vaadin.initApplication(\"<replaceable>helloworldui</"
"replaceable>\", {\n"
"      \"browserDetailsUrl\": \"<replaceable>helloworld</replaceable>/\",\n"
"      \"serviceUrl\": \"<replaceable>helloworld</replaceable>/\",\n"
"      \"widgetset\": \"<replaceable>com.example.MyWidgetSet</replaceable>"
"\",\n"
"      \"theme\": \"<replaceable>mytheme</replaceable>\",\n"
"      \"versionInfo\": {\"vaadinVersion\": \"<replaceable>7.0.0</replaceable>"
"\"},\n"
"      \"vaadinDir\": \"<replaceable>VAADIN/</replaceable>\",\n"
"      \"heartbeatInterval\": <replaceable>300</replaceable>,\n"
"      \"debug\": <replaceable>true</replaceable>,\n"
"      \"standalone\": false,\n"
"      \"authErrMsg\": {\n"
"          \"message\": \"<replaceable>Take note of any unsaved data, \"+\n"
"                     \"and &lt;u&gt;click here&lt;\\/u&gt; to continue.</"
"replaceable>\",\n"
"          \"caption\": \"Authentication problem\"\n"
"      },\n"
"      \"comErrMsg\": {\n"
"          \"message\": \"<replaceable>Take note of any unsaved data, \"+\n"
"                     \"and &lt;u&gt;click here&lt;\\/u&gt; to continue.</"
"replaceable>\",\n"
"          \"caption\": \"Communication problem\"\n"
"      },\n"
"      \"sessExpMsg\": {\n"
"          \"message\": \"<replaceable>Take note of any unsaved data, \"+\n"
"                     \"and &lt;u&gt;click here&lt;\\/u&gt; to continue.</"
"replaceable>\",\n"
"          \"caption\": \"Session Expired\"\n"
"      }\n"
"  });//]]&gt;\n"
"&lt;/script&gt;"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:566
#, no-c-format
msgid ""
"Notice that many of the parameters are normally deployment parameters, "
"specified in the deployment descriptor, as described in <xref linkend="
"\"application.environment.parameters\"/>."
msgstr ""
"注意, 还有很多参数是通常的部署参数, 在部署描述文件中指定, 详情请参见 <xref "
"linkend=\"application.environment.parameters\"/>."

#. Tag: title
#: chapter-advanced.xml:574
#, no-c-format
msgid "Summary of Div Embedding"
msgstr "关于 Div 嵌入的总结"

#. Tag: para
#: chapter-advanced.xml:576
#, no-c-format
msgid ""
"Below is a complete example of embedding an UI in a <literal>&lt;div&gt;</"
"literal> element."
msgstr "以下是在 <literal>&lt;div&gt;</literal> 元素中嵌入 UI 的完整例子."

#. Tag: programlisting
#: chapter-advanced.xml:581
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n"
"<!DOCTYPE html>\n"
"<html>\n"
"<head>\n"
"  <meta http-equiv=\"Content-Type\"\n"
"        content=\"text/html; charset=UTF-8\" />\n"
"  <meta http-equiv=\"X-UA-Compatible\"\n"
"        content=\"IE=9;chrome=1\" />\n"
"\n"
"  <title>Embedding a Vaadin Application in HTML Page</title>\n"
"  \n"
"  <!-- Set up the favicon from the Vaadin theme -->\n"
"  <link rel=\"shortcut icon\" type=\"image/vnd.microsoft.icon\"\n"
"        href=\"/VAADIN/themes/reindeer/favicon.ico\" />\n"
"  <link rel=\"icon\" type=\"image/vnd.microsoft.icon\"\n"
"           href=\"/VAADIN/themes/reindeer/favicon.ico\" /> \n"
"</head>\n"
"\n"
"<body>\n"
"  <!-- Loads the Vaadin widget set, etc. -->\n"
"  <script type=\"text/javascript\"\n"
"          src=\"VAADIN/vaadinBootstrap.js\"></script>\n"
"\n"
"  <!-- GWT requires an invisible history frame. It is   -->\n"
"  <!-- needed for page/fragment history in the browser. -->\n"
"  <iframe tabindex=\"-1\" id=\"__gwt_historyFrame\"\n"
"          style=\"position: absolute; width: 0; height: 0;\n"
"                 border: 0; overflow: hidden\"\n"
"          src=\"javascript:false\"></iframe>  \n"
"\n"
"  <h1>Embedding a Vaadin UI</h1>\n"
"    \n"
"  <p>This is a static web page that contains an embedded Vaadin\n"
"     application. It's here:</p>\n"
"\n"
"  <!-- So here comes the div element in which the Vaadin -->\n"
"  <!-- application is embedded.                          -->\n"
"  <div style=\"width: 300px; border: 2px solid green;\"\n"
"       id=\"helloworld\" class=\"v-app\">\n"
"\n"
"    <!-- Optional placeholder for the loading indicator -->\n"
"    <div class=\" v-app-loading\"></div>\n"
"\n"
"    <!-- Alternative fallback text -->\n"
"    <noscript>You have to enable javascript in your browser to\n"
"              use an application built with Vaadin.</noscript>\n"
"  </div>\n"
"  \n"
"  <script type=\"text/javascript\">//<![CDATA[\n"
"    if (!window.vaadin)\n"
"        alert(\"Failed to load the bootstrap JavaScript: \"+\n"
"              \"VAADIN/vaadinBootstrap.js\");\n"
"\n"
"    /* The UI Configuration */\n"
"        vaadin.initApplication(\"helloworld\", {\n"
"            \"browserDetailsUrl\": \"helloworld/\",\n"
"            \"serviceUrl\": \"helloworld/\",\n"
"            \"widgetset\": \"com.example.MyWidgetSet\",\n"
"            \"theme\": \"mytheme\",\n"
"            \"versionInfo\": {\"vaadinVersion\": \"7.0.0\"},\n"
"            \"vaadinDir\": \"VAADIN/\",\n"
"            \"heartbeatInterval\": 300,\n"
"            \"debug\": true,\n"
"            \"standalone\": false,\n"
"            \"authErrMsg\": {\n"
"                \"message\": \"Take note of any unsaved data, \"+\n"
"                           \"and <u>click here<\\/u> to continue.\",\n"
"                \"caption\": \"Authentication problem\"\n"
"            },\n"
"            \"comErrMsg\": {\n"
"                \"message\": \"Take note of any unsaved data, \"+\n"
"                           \"and <u>click here<\\/u> to continue.\",\n"
"                \"caption\": \"Communication problem\"\n"
"            },\n"
"            \"sessExpMsg\": {\n"
"                \"message\": \"Take note of any unsaved data, \"+\n"
"                           \"and <u>click here<\\/u> to continue.\",\n"
"                \"caption\": \"Session Expired\"\n"
"            }\n"
"        });//]] >\n"
"  </script>\n"
"  \n"
"  <p>Please view the page source to see how embedding works.</p>\n"
"</body>\n"
"</html>]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:586
#, no-c-format
msgid "Embedding Inside an <literal>iframe</literal> Element"
msgstr "嵌入到 <literal>iframe</literal> 元素中"

#. Tag: para
#: chapter-advanced.xml:588
#, no-c-format
msgid ""
"Embedding a Vaadin UI inside an <literal>&lt;iframe&gt;</literal> element is "
"even easier than the method described above, as it does not require "
"definition of any Vaadin specific definitions."
msgstr ""
"在 <literal>&lt;iframe&gt;</literal> 元素内嵌入 Vaadin UI 比前面将的方法更简"
"单一些, 因为这种方法不必定义任何 Vaadin 相关的参数."

#. Tag: para
#: chapter-advanced.xml:594
#, no-c-format
msgid "You can embed an UI with an element such as the following:"
msgstr "你可以使用以下代码在元素内嵌入 UI:"

#. Tag: programlisting
#: chapter-advanced.xml:598
#, no-c-format
msgid ""
"&lt;iframe src=\"<replaceable>/myapp/myui</replaceable>\"&gt;&lt;/iframe&gt;"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:600
#, no-c-format
msgid ""
"The <literal>&lt;iframe&gt;</literal> elements have several downsides for "
"embedding. One is that their size of is not flexible depending on the "
"content of the frame, but the content must be flexible to accommodate in the "
"frame. You can set the size of an <literal>&lt;iframe&gt;</literal> element "
"with <literal>height</literal> and <literal>width</literal> attributes. "
"Other issues arise from themeing and communication with the frame content "
"and the rest of the page."
msgstr ""
"<literal>&lt;iframe&gt;</literal> 元素用于嵌入 UI 有几个不利的方面. 首先, 它"
"的尺寸无法自动适应 frame 内容的尺寸, 相反, 内容尺寸必须适应 frame 的尺寸. 你"
"可以使用 <literal>height</literal> 和 <literal>width</literal> 属性设置 "
"<literal>&lt;iframe&gt;</literal> 元素的尺寸. 其他问题与 theme 以及 frame 内"
"容和页面其他部分之间的通信有关."

#. Tag: para
#: chapter-advanced.xml:610
#, no-c-format
msgid ""
"Below is a complete example of using the <literal>&lt;iframe&gt;</literal> "
"to embed two applications in a web page."
msgstr ""
"以下是在一个 Web 页面中使用 <literal>&lt;iframe&gt;</literal> 嵌入两个应用程"
"序的完整例子."

#. Tag: programlisting
#: chapter-advanced.xml:615
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[<!DOCTYPE html>\n"
"<html>\n"
"  <head>\n"
"    <title>Embedding in IFrame</title>\n"
"  </head>\n"
"\n"
"  <body style=\"background: #d0ffd0;\">\n"
"    <h1>This is a HTML page</h1>\n"
"    <p>Below are two Vaadin applications embedded inside\n"
"       a table:</p>\n"
"\n"
"    <table align=\"center\" border=\"3\">\n"
"      <tr>\n"
"        <th>The Calculator</th>\n"
"        <th>The Color Picker</th>\n"
"      </tr>\n"
"      <tr valign=\"top\">\n"
"        <td>\n"
"          <iframe src=\"/vaadin-examples/Calc\" height=\"200\"\n"
"                  width=\"150\" frameborder=\"0\"></iframe>\n"
"        </td>\n"
"        <td>\n"
"          <iframe src=\"/vaadin-examples/colorpicker\"\n"
"                  height=\"330\" width=\"400\"\n"
"                  frameborder=\"0\"></iframe>\n"
"        </td>\n"
"      </tr>\n"
"    </table>\n"
"  </body>\n"
"</html>]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:617
#, no-c-format
msgid ""
"The page will look as shown in <xref linkend=\"figure.embedding.iframe\"/> "
"below."
msgstr ""
"这个页面的运行结果, 见 <xref linkend=\"figure.embedding.iframe\"/>(译注: 此处"
"的页面源代码与运行结果截图略有不符)."

#. Tag: title
#: chapter-advanced.xml:623
#, no-c-format
msgid "Vaadin Applications Embedded Inside IFrames"
msgstr "IFrame 内嵌入的 Vaadin 应用程序"

#. Tag: para
#: chapter-advanced.xml:634
#, no-c-format
msgid ""
"You can embed almost anything in an iframe, which essentially acts as a "
"browser window. However, this creates various problems. The iframe must have "
"a fixed size, inheritance of CSS from the embedding page is not possible, "
"and neither is interaction with JavaScript, which makes mashups impossible, "
"and so on. Even bookmarking with URI fragments will not work."
msgstr ""
"在 iframe 内你可以嵌入几乎任何东西, iframe本质上等于一个浏览器窗口. 但是, 这"
"种方式也带来一些问题: iframe 的尺寸必须固定, 从嵌入 UI 的页面继承 CSS 是不可"
"能的, 使用 JavaScript 进行交互也是不可能的, 因此导致不能混合多种内容, 等等等"
"等. 甚至不能使用 URI 片段来保存书签."

#. Tag: para
#: chapter-advanced.xml:642
#, no-c-format
msgid ""
"Note also that websites can forbid iframe embedding by specifying an "
"<literal>X-Frame-Options: SAMEORIGIN</literal> header in the HTTP response."
msgstr ""
"注意网站有可能会在 HTTP 应答中指定一个 <literal>X-Frame-Options: SAMEORIGIN</"
"literal> 头, 禁止嵌入 iframe ."

#. Tag: title
#: chapter-advanced.xml:650
#, no-c-format
msgid "Cross-Site Embedding with the Vaadin XS Add-on"
msgstr "使用 Vaadin XS Add-on 实现跨站嵌入"

#. Tag: emphasis
#: chapter-advanced.xml:655
#, no-c-format
msgid "The XS add-on is currently not available for Vaadin 7."
msgstr "XS add-on 目前还不可用于 Vaadin 7."

#. Tag: para
#: chapter-advanced.xml:658
#, no-c-format
msgid ""
"In the previous sections, we described the two basic methods for embedding "
"Vaadin applications: in a <literal>&lt;div&gt;</literal> element and in an "
"<literal>&lt;iframe&gt;</literal>. One problem with div embedding is that it "
"does not work between different Internet domains, which is a problem if you "
"want to have your website running in one server and your Vaadin application "
"in another. The security model in browsers effectively prevents such cross-"
"site embedding of Ajax applications by enforcing the <emphasis>same origin "
"policy</emphasis> for XmlHttpRequest calls, even if the server is running in "
"the same domain but different port. While iframe is more permissive, "
"allowing embedding almost anything in anywhere, it has many disadvantanges, "
"as described earlier."
msgstr ""
"前面的小节中, 我们介绍了在页面中嵌入 Vaadin 应用程序的两种基本方法 : 使用 "
"<literal>&lt;div&gt;</literal> 元素, 以及使用 <literal>&lt;iframe&gt;</"
"literal> 元素. 使用 div 元素嵌入的一个问题是, 它不能在不同的 Internet 域之间"
"工作, 如果你希望让你的 Web 网站运行在一个服务器上, 而让你的 Vaadin 应用程序运"
"行在另一个服务器上, 那么这就是个问题了. 浏览器的安全模型强制要求 "
"XmlHttpRequest 调用必须遵守 <emphasis>同一来源政策</emphasis>, 这就有效地阻止"
"了 Ajax 应用程序的这种跨站嵌入, 即使 Web 服务器和应用程序服务器运行在同一个域"
"的不同端口上, 也无法工作. iframe 方式则更自由一些, 几乎允许嵌入任何位置的任何"
"内容, 但正如前面介绍过的, 这种方式也有很多不利的方面."

#. Tag: para
#: chapter-advanced.xml:672
#, no-c-format
msgid ""
"The Vaadin XS (Cross-Site) add-on works around the limitation in div "
"embedding by using JSONP-style communication instead of the standard "
"XmlHttpRequests."
msgstr ""
"Vaadin XS (Cross-Site) add-on 解决 div 元素的跨站嵌入问题, 它使用 JSONP 风格"
"的通信, 而不是标准的 XmlHttpRequest."

#. Tag: para
#: chapter-advanced.xml:678
#, no-c-format
msgid "Embedding is done simply with:"
msgstr "嵌入方法很简单:"

#. Tag: programlisting
#: chapter-advanced.xml:682
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[  <script src=\"http://demo.vaadin.com/xsembed/"
"getEmbedJs\"\n"
"          type=\"text/javascript\"></script>]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:684
#, no-c-format
msgid ""
"This includes an automatically generated embedding script in the page, "
"thereby making embedding effortless."
msgstr ""
"以上代码在页面中引入一段自动生成的嵌入脚本, 它可以大大简化我们的嵌入工作."

#. Tag: para
#: chapter-advanced.xml:689
#, no-c-format
msgid ""
"This assumes that the main layout of the application has undefined height. "
"If the height is 100%, you have to wrap it inside an element with a defined "
"height. For example:"
msgstr ""
"以上代码假定有应用程序的主布局高度为未指定. 如果高度为 100%, 你必须将它包装在"
"一个容器元素内, 然后指定容器元素的高度. 比如:"

#. Tag: programlisting
#: chapter-advanced.xml:695
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[ <div style=\"height: 500px;\">\n"
"  <script src=\"http://demo.vaadin.com/xsembed/getEmbedJs\"\n"
"          type=\"text/javascript\"></script>\n"
"</div>]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:697
#, no-c-format
msgid ""
"It is possible to restrict where the application can be embedded by using a "
"whitelist. The add-on also encrypts the client-server communication, which "
"is more important for embedded applications than usual."
msgstr ""
"可以使用白名单来限制应用程序允许被嵌入到哪些位置. 这个 add-on 还会对客户端/服"
"务器端的通信进行加密, 这一点对嵌入式应用程序来说, 比通常应用程序更加重要."

#. Tag: para
#: chapter-advanced.xml:703
#, no-c-format
msgid ""
"You can get the Vaadin XS add-on from Vaadin Directory. It is provided as a "
"Zip package. Download and extract the installation package to a local "
"folder. Instructions for installation and further information is given in "
"the <filename>README.html</filename> file in the package."
msgstr ""
"你可以从 Vaadin Directory 得到 Vaadin XS add-on. 它以 Zip 包的形式提供. 下载"
"并将安装包解开到本地目录. 安装指南及更多详细信息请参见包内的 "
"<filename>README.html</filename> 文件."

#. Tag: para
#: chapter-advanced.xml:710
#, no-c-format
msgid ""
"Some restrictions apply. You can have only one embedded application in one "
"page. Also, some third-party libraries may interfere with the communication. "
"Other notes are given in the README."
msgstr ""
"这个 add-on 也存在一些限制. 在一个页面中只能存在一个内嵌应用程序. 而且, 某些"
"第三方库可能会影响通信. 其他注意事项请参见 README 文件."

#. Tag: title
#: chapter-advanced.xml:726
#, no-c-format
msgid "Debug Mode and Window"
msgstr "Debug 模式和 Debug 窗口"

#. Tag: para
#: chapter-advanced.xml:728
#, no-c-format
msgid ""
"Vaadin applications can be run in two modes: <emphasis>debug mode</emphasis> "
"and <emphasis>production mode</emphasis>. The debug mode, which is on by "
"default, enables a number of built-in debug features for Vaadin developers:"
msgstr ""
"Vaadin 应用程序可以运行在两种模式下: <emphasis>debug 模式</emphasis> 和 "
"<emphasis>生产模式</emphasis>. 默认是 Debug 模式, 激活了很多内建的 debug 功"
"能, 可供 Vaadin 开发者使用:"

#. Tag: listitem
#: chapter-advanced.xml:735
#, no-c-format
msgid "<listitem>Debug Window</listitem>"
msgstr "<listitem>Debug 窗口</listitem>"

#. Tag: listitem
#: chapter-advanced.xml:736
#, no-c-format
msgid "Display debug information in the Debug Window and server console"
msgstr "在 Debug 窗口以及服务器端控制台显示 debug 信息"

#. Tag: listitem
#: chapter-advanced.xml:737
#, no-c-format
msgid "On-the-fly compilation of Sass themes"
msgstr "Sass theme 的即时编译"

#. Tag: title
#: chapter-advanced.xml:741
#, no-c-format
msgid "Enabling the Debug Mode"
msgstr "打开 Debug 模式"

#. Tag: para
#: chapter-advanced.xml:743
#, no-c-format
msgid ""
"The debug mode is enabled and production mode disabled by default in the UI "
"templates created with the Eclipse plugin or the Maven archetypes. The debug "
"mode can be enabled by giving a <parameter>productionMode=false</parameter> "
"parameter to the Vaadin servlet configuration:"
msgstr ""
"使用 Eclipse plugin 或 Maven archetype 创建的 UI 模板中, 默认启用 debug 模"
"式, 而生产模式是禁用的. 也可以在 Vaadin Servlet 配置中指定一个 "
"<parameter>productionMode=false</parameter> 参数来启用 debug 模式:"

#. Tag: programlisting
#: chapter-advanced.xml:751
#, no-c-format
msgid ""
"<?pocket-size 75% ?>@VaadinServletConfiguration(\n"
"            productionMode = <emphasis role=\"bold\">false</emphasis>,\n"
"            ui = <emphasis role=\"bold\">MyprojectUI.class</emphasis>)"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:753
#, no-c-format
msgid ""
"Or with a context parameter in the <filename>web.xml</filename> deployment "
"descriptor:"
msgstr ""
"也可以在部署描述文件 <filename>web.xml</filename> 中指定一个 context 参数:"

#. Tag: programlisting
#: chapter-advanced.xml:758
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;context-param&gt;\n"
"  &lt;description&gt;Vaadin production mode&lt;/description&gt;\n"
"  &lt;param-name&gt;productionMode&lt;/param-name&gt;\n"
"  &lt;param-value&gt;<emphasis role=\"bold\">false</emphasis>&lt;/param-"
"value&gt;\n"
"&lt;/context-param&gt;"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:760
#, no-c-format
msgid ""
"Enabling the production mode disables the debug features, thereby preventing "
"users from easily inspecting the inner workings of the application from the "
"browser."
msgstr ""
"启用生产模式会禁用 debug 功能, 因此可以防止用户从浏览器中轻易地窥测到应用程序"
"的内部工作状况."

#. Tag: title
#: chapter-advanced.xml:768
#, no-c-format
msgid "Opening the Debug Window"
msgstr "打开 Debug 窗口"

#. Tag: para
#: chapter-advanced.xml:770
#, no-c-format
msgid ""
"Running an application in the debug mode enables the client-side Debug "
"Window in the browser. You can open the Debug Window by adding \"<uri>?"
"debug</uri>\" parameter to the URL of the UI, for example, <uri>http://"
"localhost:8080/myapp/?debug</uri>. The Debug Window has buttons for "
"controlling the debugging features and a scrollable log of debug messages."
msgstr ""
"在 debug 模式下运行应用程序, 会激活浏览器中的客户端 Debug 窗口. 你可以在 UI "
"的 URL之后添加一个 \"<uri>?debug</uri>\" 来打开 Debug 窗口, 比如, "
"<uri>http://localhost:8080/myapp/?debug</uri>. Debug 窗口中有一些 debug 功能"
"控制按钮, 还有一个可滚动的日志栏, 用于查看 debug 消息."

#. Tag: title
#: chapter-advanced.xml:780
#, no-c-format
msgid "<title>Debug Window</title>"
msgstr "<title>Debug 窗口</title>"

#. Tag: para
#: chapter-advanced.xml:791
#, no-c-format
msgid ""
"The functionalities are described in detail in the subsequent sections. You "
"can move the window by dragging it from the title bar and resize it from the "
"corners. The <guibutton>Minimize</guibutton> button minimizes the debug "
"window in the corner of the browser window, and the <guibutton>Close</"
"guibutton> button closes it."
msgstr ""
"Debug 窗口的功能会在后续小节中详细介绍. 你可以拖动窗口的标题栏来移动它的位"
"置, 也可以拖拽它的边角来调整大小. <guibutton>Minimize</guibutton> 按钮将 "
"debug 窗口最小化到浏览器窗口之内, <guibutton>Close</guibutton> 按钮关闭 "
"debug 窗口."

#. Tag: para
#: chapter-advanced.xml:799
#, no-c-format
msgid ""
"If you use the Firebug plugin for Firefox or the Developer Tools console in "
"Chrome, the log messages will also be printed to the Firebug console. In "
"such a case, you may want to enable client-side debugging without showing "
"the Debug Window with \"<uri>?debug=quiet</uri>\" in the URL. In the quiet "
"debug mode, log messages will only be printed to the console of the browser "
"debugger."
msgstr ""
"如果你在 Firefox 浏览器中使用 Firebug 插件, 或者在 Chrome 浏览器中使用 "
"Developer Tools 控制台, 那么日志消息也会打印到 Firebug 或 Chrome 的控制台中. "
"这时, 你可能希望允许客户端调试, 但不要显示 Debug 窗口, 你可以在 URL 末尾添加 "
"\"<uri>?debug=quiet</uri>\" 参数来实现这一点. 在 quiet debug 模式下, 日志信息"
"只会输出到浏览器调试器的控制台中."

#. Tag: title
#: chapter-advanced.xml:810 chapter-advanced.xml:819
#, no-c-format
msgid "Debug Message Log"
msgstr "Debug 日志"

#. Tag: para
#: chapter-advanced.xml:812
#, no-c-format
msgid ""
"The debug message log displays client-side debug messages, with time counter "
"in milliseconds. The control buttons allow you to clear the log, reset the "
"timer, and lock scrolling."
msgstr ""
"debug 日志信息用于显示客户端 debug 信息, 还包含毫秒单位的计时器. 界面上有一些"
"控制按钮, 可用于清除日志, 重置计时器, 或锁定滚动."

#. Tag: title
#: chapter-advanced.xml:831
#, no-c-format
msgid "Logging to Debug Window"
msgstr "向 Debug 窗口输出日志"

#. Tag: para
#: chapter-advanced.xml:833
#, no-c-format
msgid ""
"You can take advantage of the debug mode when developing client-side "
"components, by using the standard Java <classname>Logger</classname> to "
"write messages to the log. The messages will be written to the debug window "
"and Firebug console. No messages are written if the debug window is not open "
"or if the application is running in production mode."
msgstr ""
"开发客户端组件时, debug 模式的日志功能可以为你带来很大的便利. 你可以使用标准"
"的 Java <classname>Logger</classname> 向输出日志, 日志信息也会被写入到 debug "
"窗口以及 Firebug 控制台. debug 窗口未打开时, 或应用程序运行于生产模式时, 不会"
"有任何消息输出."

#. Tag: title
#: chapter-advanced.xml:846 chapter-advanced.xml:856
#, no-c-format
msgid "General Information"
msgstr "一般信息"

#. Tag: para
#: chapter-advanced.xml:848
#, no-c-format
msgid ""
"The <guilabel>General information about the application(s)</guilabel> tab "
"displays various information about the UI, such as version numbers of the "
"client and servlet engine, and the theme. If they do not match, you may need "
"to compile the widget set or theme."
msgstr ""
"<guilabel>应用程序一般信息</guilabel> tab 显示 UI 的各种信息, 比如客户端引"
"擎, Servlet 引擎以及 theme 的版本号. 如果这些版本不匹配, 你可能需要编译 "
"widget 群或 theme."

#. Tag: title
#: chapter-advanced.xml:869
#, no-c-format
msgid "Inspecting Component Hierarchy"
msgstr "查看组件层级关系"

#. Tag: para
#: chapter-advanced.xml:871
#, no-c-format
msgid ""
"The <guilabel>Component Hierarchy</guilabel> tab has several sub-modes that "
"allow debugging the component tree in various ways."
msgstr ""
"<guilabel>Component Hierarchy</guilabel> tab 有几个不同的子模式, 可以通过不同"
"的方式调试组件树."

#. Tag: title
#: chapter-advanced.xml:877 chapter-advanced.xml:890
#, no-c-format
msgid "Connector Hierarchy Tree"
msgstr "连接器的层级关系树"

#. Tag: para
#: chapter-advanced.xml:879
#, no-c-format
msgid ""
"The <guibutton>Show the connector hierarchy tree</guibutton> button displays "
"the client-side connector hierarchy. As explained in <xref linkend=\"gwt\"/"
">, client-side widgets are managed by connectors that handle communication "
"with the server-side component counterparts. The connector hierarchy "
"therefore corresponds with the server-side component tree, but the client-"
"side widget tree and HTML DOM tree have more complexity."
msgstr ""
"<guibutton>Show the connector hierarchy tree</guibutton> 按钮可以显示客户端连"
"接器层级关系. 客户端 widget 由连接器管理, 它负责处理与服务器端对应组件的通"
"信, 详情请参见 <xref linkend=\"gwt\"/>. 因此连接器的层级对应到服务器端的组件"
"树, 但客户端 widget 树和 HTML DOM 树比服务器端组件树要更复杂."

#. Tag: para
#: chapter-advanced.xml:901
#, no-c-format
msgid "Clicking on a connector highlights the widget in the UI."
msgstr "点击一个连接器会将 UI 中对应的 widget 高亮显示."

#. Tag: title
#: chapter-advanced.xml:907
#, no-c-format
msgid "Inspecting a Component"
msgstr "查看组件信息"

#. Tag: para
#: chapter-advanced.xml:909
#, no-c-format
msgid ""
"The <guibutton>Select a component in the page to inspect it</guibutton> "
"button lets you select a component in the UI by clicking it and display its "
"client-side properties."
msgstr ""
"<guibutton>Select a component in the page to inspect it</guibutton> 按钮允许"
"你选择 UI 中的一个组件, 你可以点击这个组件, 并显示它的客户端属性."

#. Tag: para
#: chapter-advanced.xml:915
#, no-c-format
msgid ""
"To view the HTML structure and CSS styles in more detail, you can use "
"Firebug in Firefox, or the Developer Tools in Chrome, as described in <xref "
"linkend=\"getting-started.environment.firefox\"/>. Firefox also has a built-"
"in feature for inspecting HTML and CSS."
msgstr ""
"要查看 HTML 结构和 CSS 样式的更详细信息, 你可以使用 Firefox 中的 Firebug, 或 "
"Chrome 中的 Developer Tools, 详情请参见 <xref linkend=\"getting-started."
"environment.firefox\"/>. Firefox 也有内建的功能可以查看 HTML 和 CSS."

#. Tag: title
#: chapter-advanced.xml:924
#, no-c-format
msgid "Analyzing Layout Problems"
msgstr "分析布局问题"

#. Tag: para
#: chapter-advanced.xml:926
#, no-c-format
msgid ""
"The <guilabel>Check layouts for potential problems</guilabel> button "
"analyzes the currently visible UI and makes a report of possible layout "
"related problems. All detected layout problems are displayed in the log and "
"also printed to the console."
msgstr ""
"<guilabel>Check layouts for potential problems</guilabel> 按钮可以分析目前可"
"见的 UI, 并生成一份布局中可能存在的问题的报告. 检测出来的所有布局问题会显示在"
"日志中, 也会输出到控制台."

#. Tag: title
#: chapter-advanced.xml:934
#, no-c-format
msgid "Debug Window Showing the Result of Layout Analysis."
msgstr "Debug 窗口中显示的布局分析结果."

#. Tag: para
#: chapter-advanced.xml:945
#, no-c-format
msgid ""
"Clicking on a reported problem highlights the component with the problem in "
"the UI."
msgstr "点击报告中的问题, 可以将 UI 中对应的组件高亮显示."

#. Tag: para
#: chapter-advanced.xml:950
#, no-c-format
msgid ""
"The most common layout problem is caused by placing a component that has a "
"relative size inside a container (layout) that has undefined size in the "
"particular direction (height or width). For example, adding a "
"<classname>Button</classname> with 100% width inside a "
"<classname>VerticalLayout</classname> with undefined width. In such a case, "
"the error would look as shown in <xref linkend=\"figure.advanced.debug."
"hierarchy.analyze\"/>."
msgstr ""
"造成布局问题的最常见原因是: 将一个某方向(高度或宽度)为相对尺寸的组件, 放置在"
"一个未指定尺寸的容器(布局)之内. 比如, 将一个 100% 宽度的 <classname>Button</"
"classname> 放置在一个未指定宽度的 <classname>VerticalLayout</classname> 之"
"内. 这种情况下, 布局错误的结果见 <xref linkend=\"figure.advanced.debug."
"hierarchy.analyze\"/>."

#. Tag: para
#: chapter-advanced.xml:960
#, no-c-format
msgid ""
"<classname>CustomLayout</classname> components can not be analyzed in the "
"same way as other layouts. For custom layouts, the button analyzes all "
"contained relative-sized components and checks if any relative dimension is "
"calculated to zero so that the component will be invisible. The error log "
"will display a warning for each of these invisible components. It would not "
"be meaningful to emphasize the component itself as it is not visible, so "
"when you select such an error, the parent layout of the component is "
"emphasized if possible."
msgstr ""
"<classname>CustomLayout</classname> 组件不可以象其他布局一样进行分析. 对于自"
"定义布局, 布局分析按钮会分析它包含的所有相对尺寸组件, 并检查是否有某个相对尺"
"寸被计算为 0, 以至于组件不可见. 错误日志中会对每个这样的不可见组件显示一条警"
"告信息. 高亮显示这些组件是没有意义的, 因为它已经处于不可见状态了, 因此当你选"
"中这样一条错误信息时, 如果可能的话, 会高亮显示组件的父布局."

#. Tag: title
#: chapter-advanced.xml:973
#, no-c-format
msgid "Displaying Used Connectors"
msgstr "显示使用的连接器"

#. Tag: para
#: chapter-advanced.xml:975
#, no-c-format
msgid ""
"The last button, <guibutton>Show used connectors and how to optimize widget "
"set</guibutton>, displays a list of all currently visible connectors. It "
"also generates a connector bundle loader factory, which you can use to "
"optimize the widget set so that it only contains the widgets actually used "
"in the UI. Note, however, that it only lists the connectors visible in the "
"current UI state, and you usually have more connectors than that."
msgstr ""
"最后一个按钮是, <guibutton>Show used connectors and how to optimize widget "
"set</guibutton>, 它会列出目前所有可见的连接器. 它还会产生一个连接器群的加载器"
"工厂, 你可以用来定制 widget 群, 使其中只包含目前 UI 中真实使用到的 widget. 注"
"意, 这个按钮只会列出目前 UI 状态下可见的连接器, 实际存在的连接器通常会比显示"
"的要多."

#. Tag: title
#: chapter-advanced.xml:988
#, no-c-format
msgid "Communication Log"
msgstr "通信 Log"

#. Tag: para
#: chapter-advanced.xml:990
#, no-c-format
msgid ""
"The <guilabel>Communication</guilabel> tab displays all server requests. You "
"can unfold the requests to view defails, such as the connectors involved. "
"Clicking on a connector highlights the corresponding element in the UI."
msgstr ""
"<guilabel>Communication</guilabel> tab 显示搜有的服务器请求. 你可以展开这些请"
"求,来查看它的细节, 比如使用了哪个连接器, 等等. 点击连接器会高亮显示 UI 中对应"
"的元素."

#. Tag: para
#: chapter-advanced.xml:997
#, no-c-format
msgid ""
"You can use Firebug or Developer Tools in Firefox or Chrome, respectively, "
"to get more detailed information about the requests and responses."
msgstr ""
"你可以使用 Firefox 中的 Firebug 或 Chrome 中的 Developer Tools, 来查看请求和"
"应答的更详细信息."

#. Tag: title
#: chapter-advanced.xml:1004
#, no-c-format
msgid "Debug Modes"
msgstr "Debug 模式"

#. Tag: para
#: chapter-advanced.xml:1006
#, no-c-format
msgid ""
"The <guilabel>Menu</guilabel> tab in the window opens a sub-menu to select "
"various settings. Here you can also launch the GWT SuperDevMode, as "
"described in <xref linkend=\"clientside.debugging\"/>."
msgstr ""
"窗口中的 <guilabel>Menu</guilabel> tab 打开一个子菜单, 可以在这里选择很多设置."
"在这个菜单中你还可以启动 GWT SuperDevMode, 详情请参见 <xref linkend=\"clientside.debugging\"/>."

#. Tag: title
#: chapter-advanced.xml:1015
#, no-c-format
msgid "Request Handlers"
msgstr "请求处理器(Request Handler)"

#. Tag: para
#: chapter-advanced.xml:1017
#, no-c-format
msgid ""
"Request handlers are useful for catching request parameters or generating "
"dynamic content, such as HTML, images, PDF, or other content. You can "
"provide HTTP content easily also with stream resources, as described in "
"<xref linkend=\"application.resources.stream\"/>. The stream resources, "
"however, are only usable from within a Vaadin application, such as in an "
"<classname>Image</classname> component. Request handlers allow responding to "
"HTTP requests made with the application URL, including GET or POST "
"parameters. You could also use a separate servlet to generate dynamic "
"content, but a request handler is associated with the Vaadin session and it "
"can easily access all the session data."
msgstr ""
"请求处理器是一种便利的工具, 可以用于捕捉请求参数或生成动态内容, 比如 HTML, 图"
"像, PDF, 或其他内容. 你可以便利地提供 HTTP 内容, 也可以提供流资源, 详情请参"
"见 <xref linkend=\"application.resources.stream\"/>. 但流资源只能用于 Vaadin "
"应用程序之内, 比如 <classname>Image</classname> 组件内. 请求处理器允许对发送"
"给应用程序 URL 的 HTTP 请求进行应答, 可处理 GET 或 POST 参数. 你也可以使用独"
"立的 Servlet 来产生动态内容, 但请求处理器是与 Vaadin Session 关联的, 而且它可"
"以方便地访问所有的 Session 数据."

#. Tag: para
#: chapter-advanced.xml:1030
#, no-c-format
msgid ""
"To handle requests, you need to implement the <interfacename>RequestHandler</"
"interfacename> interface. The <methodname>handleRequest()</methodname> "
"method gets the session, request, and response objects as parameters."
msgstr ""
"要相应一个请求, 你需要实现 <interfacename>RequestHandler</interfacename> 接"
"口. <methodname>handleRequest()</methodname> 方法的参数是 session, request, "
"以及 response 对象."

#. Tag: para
#: chapter-advanced.xml:1037
#, no-c-format
msgid ""
"If the handler writes a response, it must return <literal>true</literal>. "
"This stops running other possible request handlers. Otherwise, it should "
"return <literal>false</literal> so that another handler could return a "
"response. Eventually, if no other handler writes a response, a UI will be "
"created and initialized."
msgstr ""
"如果请求处理器输出了应答, 它必须返回 <literal>true</literal>. 这个返回值会阻"
"止 Vaadin 继续执行其他可能存在的请求处理器. 否则, 应该返回 <literal>false</"
"literal>, 此时其他请求处理器就可以继续执行, 并返回 HTTP 应答. 最终, 如果没有"
"任何一个请求处理器返回了应答, 这是会创建并初始化一个 UI."

#. Tag: para
#: chapter-advanced.xml:1045
#, no-c-format
msgid ""
"In the following example, we catch requests for a sub-path in the URL for "
"the servlet and write a plain text response. The servlet path consists of "
"the context path and the servlet (sub-)path. Any additional path is passed "
"to the request handler in the <parameter>pathInfo</parameter> of the "
"request. For example, if the full path is <filename>/myapp/myui/rhexample</"
"filename>, the path info will be <filename>/rhexample</filename>. Also, "
"request parameters are available."
msgstr ""
"下面的例子中, 我们捕捉发送到 Servlet URL 之下的子路径的一个请求, 并返回一个纯"
"文本应答. Servlet 路径由 context 路径和 Servlet (子)路径组成. 此外的任何附加"
"路径都会被传递给请求处理器, 成为 request 对象的 <parameter>pathInfo</"
"parameter> 属性. 比如, 假定全路径是 <filename>/myapp/myui/rhexample</"
"filename>, 此时 pathInfo 将是 <filename>/rhexample</filename>. 此外, 请求参数"
"也是允许的."

#. Tag: programlisting
#: chapter-advanced.xml:1055
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[VaadinSession.getCurrent().addRequestHandler(\n"
"        new RequestHandler() {\n"
"    @Override\n"
"    public boolean handleRequest(VaadinSession session,\n"
"                                 VaadinRequest request,\n"
"                                 VaadinResponse response)\n"
"            throws IOException {\n"
"        if (\"/rhexample\".equals(request.getPathInfo())) {\n"
"            response.setContentType(\"text/plain\");\n"
"            response.getWriter().append(\n"
"                \"Here's some dynamically generated content.\\n\"+\n"
"                \"Time: \" + (new Date()).toString());\n"
"            return true; // We wrote a response\n"
"        } else\n"
"            return false; // No response was written\n"
"    }\n"
"});\n"
"\n"
"// Find out the base bath for the servlet\n"
"String servletPath = VaadinServlet.getCurrent()\n"
"    .getServletContext().getContextPath() + VaadinServletService \n"
"    .getCurrentServletRequest().getServletPath();\n"
"        \n"
"// Display the page in a popup window\n"
"Link open = new Link(\"Click to Show the Page\",\n"
"    new ExternalResource(servletPath + \"/rhexample\"),\n"
"    \"_blank\", 500, 350, BorderStyle.DEFAULT);\n"
"layout.addComponent(open);]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:1059
#, no-c-format
msgid "Shortcut Keys"
msgstr "快捷键"

#. Tag: para
#: chapter-advanced.xml:1061
#, no-c-format
msgid ""
"Vaadin provides simple ways for defining shortcut keys for field components "
"and a default button, and a lower-level generic shortcut key binding API "
"based on actions."
msgstr ""
"Vaadin 提供了为 Field 组件和默认按钮定义快捷键的便利方法, 还提供了基于动作"
"(Action)的快捷键绑定通用低阶 API."

#. Tag: title
#: chapter-advanced.xml:1068
#, no-c-format
msgid "Shortcut Keys for Default Buttons"
msgstr "默认按钮的快捷键"

#. Tag: para
#: chapter-advanced.xml:1070
#, no-c-format
msgid ""
"You can add or set a <emphasis>click shortcut</emphasis> to a button to set "
"it as \"default\" button; pressing the defined key, typically <keycap>Enter</"
"keycap>, in any component in the window causes a click event for the button."
msgstr ""
"你可以向按钮添加或设定一个 <emphasis>点击快捷键</emphasis>, 通过这种方法可以"
"将这个按钮设置为 \"默认\" 按钮; 在窗口内的任何组件上, 按下这个预定义的快捷"
"键, 通常是 <keycap>Enter</keycap> 键, 都会触发对象按钮的点击事件."

#. Tag: para
#: chapter-advanced.xml:1077
#, no-c-format
msgid ""
"You can define a click shortcut with the <methodname>setClickShortcut()</"
"methodname> shorthand method:"
msgstr ""
"定义点击快捷键可以使用 <methodname>setClickShortcut()</methodname> 方法:"

#. Tag: programlisting
#: chapter-advanced.xml:1082
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an OK button and set it as the default "
"button\n"
"Button ok = new Button(\"OK\");\n"
"ok.setClickShortcut(KeyCode.ENTER);\n"
"ok.addStyleName(Reindeer.BUTTON_DEFAULT);]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1084
#, no-c-format
msgid ""
"The <literal>BUTTON_DEFAULT</literal> style name highlights a button to show "
"the default button status; usually with a bolder font than usual, depending "
"on the theme. The result can be seen in <xref linkend=\"figure.advanced."
"shortcuts.defaultbutton\"/>."
msgstr ""
"<literal>BUTTON_DEFAULT</literal> 样式名会将按钮高亮显示, 表示这个按钮目前是"
"默认按钮; 此时字体通常会更粗一些, 具体如何由 theme 觉得. 运行结果见 <xref "
"linkend=\"figure.advanced.shortcuts.defaultbutton\"/>."

#. Tag: title
#: chapter-advanced.xml:1092
#, no-c-format
msgid "Default Button with Click Shortcut"
msgstr "设置了点击快捷键的默认按钮"

#. Tag: title
#: chapter-advanced.xml:1105
#, no-c-format
msgid "Field Focus Shortcuts"
msgstr "控制 Field 的焦点快捷键"

#. Tag: para
#: chapter-advanced.xml:1107
#, no-c-format
msgid ""
"You can define a shortcut key that sets the focus to a field component (any "
"component that inherits <classname>AbstractField</classname>) by adding a "
"<classname>FocusShortcut</classname> as a shortcut listener to the field. ."
msgstr ""
"你可以定义一个让 Field 组件(继承自 <classname>AbstractField</classname> 的组"
"件)获得焦点的快捷键, 方法是向 Field 添加一个 <classname>FocusShortcut</"
"classname> 作为快捷键的监听器."

#. Tag: para
#: chapter-advanced.xml:1114
#, no-c-format
msgid ""
"The constructor of the <classname>FocusShortcut</classname> takes the field "
"component as its first parameter, followed by the key code, and an optional "
"list of modifier keys, as listed in <xref linkend=\"advanced.shortcuts."
"keycodes\"/>."
msgstr ""
"<classname>FocusShortcut</classname> 的构造函数第一个参数为 Field 组件, 第二"
"个参数是快捷键代码, 第三个参数可选, 是修饰键列表, 详情请参见 <xref linkend="
"\"advanced.shortcuts.keycodes\"/>."

#. Tag: programlisting
#: chapter-advanced.xml:1122
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// A field with Alt+N bound to it\n"
"TextField name = new TextField(\"Name (Alt+N)\");\n"
"name.addShortcutListener(\n"
"        new AbstractField.FocusShortcut(name, KeyCode.N,\n"
"                                        ModifierKey.ALT));\n"
"layout.addComponent(name);]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1124
#, no-c-format
msgid ""
"You can also specify the shortcut by a shorthand notation, where the "
"shortcut key is indicated with an ampersand (<literal>&amp;</literal>)."
msgstr "你也可以使用更简短的注"
"解来指定快捷键, 快捷键以<literal>&amp;</literal>符号来标记."

#. Tag: programlisting
#: chapter-advanced.xml:1131
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// A field with Alt+A bound to it, using "
"shorthand notation\n"
"TextField address = new TextField(\"Address (Alt+A)\");\n"
"address.addShortcutListener(\n"
"        new AbstractField.FocusShortcut(address, \"&Address\"));]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1133
#, no-c-format
msgid ""
"This is especially useful for internationalization, so that you can "
"determine the shortcut key from the localized string."
msgstr "这种方式对国际化特别有用, 因为可以从翻译过的文字中自动检测出快捷键."

#. Tag: title
#: chapter-advanced.xml:1140
#, no-c-format
msgid "Generic Shortcut Actions"
msgstr "通用的快捷键 Action"

#. Tag: para
#: chapter-advanced.xml:1142
#, no-c-format
msgid ""
"Shortcut keys can be defined as <emphasis>actions</emphasis> using the "
"<classname>ShortcutAction</classname> class. It extends the generic "
"<classname>Action</classname> class that is used for example in "
"<classname>Tree</classname> and <classname>Table</classname> for context "
"menus. Currently, the only classes that accept <classname>ShortcutAction</"
"classname>s are <classname>Window</classname> and <classname>Panel</"
"classname>."
msgstr ""
"可以使用 <classname>ShortcutAction</classname> 类, 以 <emphasis>动作</"
"emphasis> 的形式来定义快捷键. 这个类继承了共通基类 <classname>Action</"
"classname>, 我们在 <classname>Tree</classname> 和 <classname>Table</"
"classname> 的上下文菜单例子程序中使用过 Action 类. 目前, 唯一能够接受 "
"<classname>ShortcutAction</classname> 的类是 <classname>Window</classname> "
"和 <classname>Panel</classname>."

#. Tag: para
#: chapter-advanced.xml:1152
#, no-c-format
msgid ""
"To handle key presses, you need to define an action handler by implementing "
"the <classname>Handler</classname> interface. The interface has two methods "
"that you need to implement: <methodname>getActions()</methodname> and "
"<methodname>handleAction()</methodname>."
msgstr ""
"为了处理键盘按下事件, 你需要实现 <classname>Handler</classname> 接口来定义一"
"个动作处理器. 这个接口有两个方法需要实现: <methodname>getActions()</"
"methodname> 和 <methodname>handleAction()</methodname>."

#. Tag: para
#: chapter-advanced.xml:1160
#, no-c-format
msgid ""
"The <methodname>getActions()</methodname> method must return an array of "
"<classname>Action</classname> objects for the component, specified with the "
"second parameter for the method, the <parameter>sender</parameter> of an "
"action. For a keyboard shortcut, you use a <classname>ShortcutAction</"
"classname>. The implementation of the method could be following:"
msgstr ""
"<methodname>getActions()</methodname> 方法必须针对组件返回一个 "
"<classname>Action</classname> 对象数组, 对象组件通过方法的第二个参数来指定, "
"也就是动作的 <parameter>sender</parameter>. 对于键盘快捷键, 你可以使用 "
"<classname>ShortcutAction</classname>. 这个方法的实现示例如下:"

#. Tag: programlisting
#: chapter-advanced.xml:1169
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have the unmodified Enter key cause an "
"event\n"
"Action action_ok = new ShortcutAction(\"Default key\",\n"
"        ShortcutAction.KeyCode.ENTER, null);\n"
"\n"
"// Have the C key modified with Alt cause an event\n"
"Action action_cancel = new ShortcutAction(\"Alt+C\",\n"
"        ShortcutAction.KeyCode.C,\n"
"        new int[] { ShortcutAction.ModifierKey.ALT });\n"
"\n"
"Action[] actions = new Action[] {action_cancel, action_ok};\n"
"\n"
"public Action[] getActions(Object target, Object sender) {\n"
"    if (sender == myPanel)\n"
"        return actions;\n"
"\n"
"    return null;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1171
#, no-c-format
msgid ""
"The returned <classname>Action</classname> array may be static or you can "
"create it dynamically for different senders according to your needs."
msgstr ""
"返回的 <classname>Action</classname> 数组必须是 static 的, 你也可以针对不同"
"的 sender 按照你的需要动态创建不同的结果."

#. Tag: para
#: chapter-advanced.xml:1176
#, no-c-format
msgid ""
"The constructor of <classname>ShortcutAction</classname> takes a symbolic "
"caption for the action; this is largely irrelevant for shortcut actions in "
"their current implementation, but might be used later if implementors use "
"them both in menus and as shortcut actions. The second parameter is the key "
"code and the third a list of modifier keys, which are listed in <xref "
"linkend=\"advanced.shortcuts.keycodes\"/>."
msgstr ""
"<classname>ShortcutAction</classname> 的构造函数第一个参数是 action 的一个符"
"号化的标题; 在目前的实现中, 这个标题与 Shortcut Action 关系不大, 但将来可能会"
"被同时用在菜单和 Shortcut Action 中. 第二个参数是键码(key code), 第三个参数是"
"修饰键列表, 详情请参见 <xref linkend=\"advanced.shortcuts.keycodes\"/>."

#. Tag: para
#: chapter-advanced.xml:1185
#, no-c-format
msgid ""
"The following example demonstrates the definition of a default button for a "
"user interface, as well as a normal shortcut key, <keycombo><keycap>Alt</"
"keycap><keycap>C</keycap></keycombo> for clicking the <guibutton>Cancel</"
"guibutton> button."
msgstr ""
"下例演示如何在 UI 中定义一个默认按钮, 以及一个通常的快捷键, 使用 "
"<keycombo><keycap>Alt</keycap><keycap>C</keycap></keycombo> 作为 "
"<guibutton>Cancel</guibutton> 按钮的快捷键."

#. Tag: programlisting
#: chapter-advanced.xml:1192
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class DefaultButtonExample extends "
"CustomComponent\n"
"                                  implements Handler {\n"
"    // Define and create user interface components\n"
"    Panel panel = new Panel(\"Login\");\n"
"    FormLayout formlayout = new FormLayout();\n"
"    TextField username = new TextField(\"Username\");\n"
"    TextField password = new TextField(\"Password\");\n"
"    HorizontalLayout buttons = new HorizontalLayout();\n"
"\n"
"    // Create buttons and define their listener methods.\n"
"    Button ok = new Button(\"OK\", this, \"okHandler\");\n"
"    Button cancel = new Button(\"Cancel\", this, \"cancelHandler\");\n"
"\n"
"    // Have the unmodified Enter key cause an event\n"
"    Action action_ok = new ShortcutAction(\"Default key\",\n"
"            ShortcutAction.KeyCode.ENTER, null);\n"
"\n"
"    // Have the C key modified with Alt cause an event\n"
"    Action action_cancel = new ShortcutAction(\"Alt+C\",\n"
"            ShortcutAction.KeyCode.C,\n"
"            new int[] { ShortcutAction.ModifierKey.ALT });\n"
"\n"
"    public DefaultButtonExample() {\n"
"        // Set up the user interface\n"
"        setCompositionRoot(panel);\n"
"        panel.addComponent(formlayout);\n"
"        formlayout.addComponent(username);\n"
"        formlayout.addComponent(password);\n"
"        formlayout.addComponent(buttons);\n"
"        buttons.addComponent(ok);\n"
"        buttons.addComponent(cancel);\n"
"\n"
"        // Set focus to username\n"
"        username.focus();\n"
"\n"
"        // Set this object as the action handler\n"
"        panel.addActionHandler(this);\n"
"    }\n"
"\n"
"    /**\n"
"     * Retrieve actions for a specific component. This method\n"
"     * will be called for each object that has a handler; in\n"
"     * this example just for login panel. The returned action\n"
"     * list might as well be static list.\n"
"     */\n"
"    public Action[] getActions(Object target, Object sender) {\n"
"        System.out.println(\"getActions()\");\n"
"        return new Action[] { action_ok, action_cancel };\n"
"    }\n"
"\n"
"    /**\n"
"     * Handle actions received from keyboard. This simply directs\n"
"     * the actions to the same listener methods that are called\n"
"     * with ButtonClick events.\n"
"     */\n"
"    public void handleAction(Action action, Object sender,\n"
"                             Object target) {\n"
"        if (action == action_ok) {\n"
"            okHandler();\n"
"        }\n"
"        if (action == action_cancel) {\n"
"            cancelHandler();\n"
"        }\n"
"    }\n"
"\n"
"    public void okHandler() {\n"
"        // Do something: report the click\n"
"        formlayout.addComponent(new Label(\"OK clicked. \"\n"
"                + \"User=\" + username.getValue() + \", password=\"\n"
"                + password.getValue()));\n"
"    }\n"
"\n"
"    public void cancelHandler() {\n"
"        // Do something: report the click\n"
"        formlayout.addComponent(new Label(\"Cancel clicked. User=\"\n"
"                + username.getValue() + \", password=\"\n"
"                + password.getValue()));\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1194
#, no-c-format
msgid ""
"Notice that the keyboard actions can currently be attached only to "
"<classname>Panel</classname>s and <classname>Window</classname>s. This can "
"cause problems if you have components that require a certain key. For "
"example, multi-line <classname>TextField</classname> requires the "
"<keycap>Enter</keycap> key. There is currently no way to filter the shortcut "
"actions out while the focus is inside some specific component, so you need "
"to avoid such conflicts."
msgstr ""
"注意, 键盘动作目前只能绑定到 <classname>Panel</classname> 和 "
"<classname>Window</classname>. 如果你的组件本身要求使用某个键, 就会发生冲突. "
"比如, 多行的 <classname>TextField</classname> 需要使用 <keycap>Enter</"
"keycap> 键. 当某个特定组件获得焦点时, 目前没有办法可以将快捷键过滤出来, 因此"
"你需要注意避免这类冲突."

#. Tag: title
#: chapter-advanced.xml:1206
#, no-c-format
msgid "Supported Key Codes and Modifier Keys"
msgstr "对键码(Key Code)和修饰键(Modifier Key)的支持"

#. Tag: para
#: chapter-advanced.xml:1208
#, no-c-format
msgid ""
"The shortcut key definitions require a key code to identify the pressed key "
"and modifier keys, such as Shift, Alt, or Ctrl, to specify a key combination."
msgstr ""
"快捷键的定义需要一个键码, 用来指定按下的键和修饰键, 比如 Shift, Alt, 或 Ctrl."

#. Tag: para
#: chapter-advanced.xml:1214
#, no-c-format
msgid ""
"The key codes are defined in the <classname>ShortcutAction.KeyCode</"
"classname> interface and are:"
msgstr "键码定义在 <classname>ShortcutAction.KeyCode</classname> 接口中, 如下:"

#. Tag: term
#: chapter-advanced.xml:1221
#, no-c-format
msgid "Keys <parameter>A</parameter> to <parameter>Z</parameter>"
msgstr "<parameter>A</parameter> 到 <parameter>Z</parameter> 键"

#. Tag: listitem
#: chapter-advanced.xml:1222
#, no-c-format
msgid "Normal letter keys"
msgstr "通常的字母键"

#. Tag: term
#: chapter-advanced.xml:1225
#, no-c-format
msgid "<parameter>F1</parameter> to <parameter>F12</parameter>"
msgstr "<parameter>F1</parameter> 到 <parameter>F12</parameter>"

#. Tag: para
#: chapter-advanced.xml:1227
#, no-c-format
msgid "Function keys"
msgstr "功能键"

#. Tag: term
#: chapter-advanced.xml:1231
#, no-c-format
msgid ""
"<parameter>BACKSPACE</parameter>, <parameter>DELETE</parameter>, "
"<parameter>ENTER</parameter>, <parameter>ESCAPE</parameter>, "
"<parameter>INSERT</parameter>, <parameter>TAB</parameter>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1233
#, no-c-format
msgid "Control keys"
msgstr "控制键"

#. Tag: term
#: chapter-advanced.xml:1237
#, no-c-format
msgid "<parameter>NUM0</parameter> to <parameter>NUM9</parameter>"
msgstr "<parameter>NUM0</parameter> 到 <parameter>NUM9</parameter>"

#. Tag: para
#: chapter-advanced.xml:1239
#, no-c-format
msgid "Number pad keys"
msgstr "右侧小键盘上的数字键"

#. Tag: term
#: chapter-advanced.xml:1243
#, no-c-format
msgid ""
"<parameter>ARROW_DOWN</parameter>, <parameter>ARROW_UP</parameter>, "
"<parameter>ARROW_LEFT</parameter>, <parameter>ARROW_RIGHT</parameter>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1245
#, no-c-format
msgid "Arrow keys"
msgstr "方向键"

#. Tag: term
#: chapter-advanced.xml:1249
#, no-c-format
msgid ""
"<parameter>HOME</parameter>, <parameter>END</parameter>, <parameter>PAGE_UP</"
"parameter>, <parameter>PAGE_DOWN</parameter>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1251
#, no-c-format
msgid "Other movement keys"
msgstr "其他移动键"

#. Tag: para
#: chapter-advanced.xml:1256
#, no-c-format
msgid ""
"Modifier keys are defined in <classname>ShortcutAction.ModifierKey</"
"classname> and are:"
msgstr ""
"修饰键定义在 <classname>ShortcutAction.ModifierKey</classname> 中, 如下:"

#. Tag: parameter
#: chapter-advanced.xml:1263
#, no-c-format
msgid "ModifierKey.ALT"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:1264
#, no-c-format
msgid "Alt key"
msgstr "Alt 键"

#. Tag: parameter
#: chapter-advanced.xml:1267
#, no-c-format
msgid "ModifierKey.CTRL"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:1268
#, no-c-format
msgid "Ctrl key"
msgstr "Ctrl 键"

#. Tag: parameter
#: chapter-advanced.xml:1271
#, no-c-format
msgid "ModifierKey.SHIFT"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:1272
#, no-c-format
msgid "Shift key"
msgstr "Shift 键"

#. Tag: para
#: chapter-advanced.xml:1276
#, no-c-format
msgid ""
"All constructors and methods accepting modifier keys take them as a variable "
"argument list following the key code, separated with commas. For example, "
"the following defines a <keycombo><keycap>Ctrl</keycap><keycap>Shift</"
"keycap><keycap>N</keycap></keycombo> key combination for a shortcut."
msgstr ""
"所有构造函数或方法, 如果接受修饰键为参数, 那么这个修饰键参数会出现在键码参数"
"之后, 并且是以逗号分隔的变长参数列表. 比如, 下例定义了一个 "
"<keycombo><keycap>Ctrl</keycap><keycap>Shift</keycap><keycap>N</keycap></"
"keycombo> 的按键组合."

#. Tag: programlisting
#: chapter-advanced.xml:1284
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[TextField name = new TextField(\"Name (Ctrl"
"+Shift+N)\");\n"
"name.addShortcutListener(\n"
"        new AbstractField.FocusShortcut(name, KeyCode.N,\n"
"                                        ModifierKey.CTRL,\n"
"                                        ModifierKey.SHIFT));]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:1287
#, no-c-format
msgid "Supported Key Combinations"
msgstr "支持的快捷键组合"

#. Tag: para
#: chapter-advanced.xml:1289
#, no-c-format
msgid ""
"The actual possible key combinations vary greatly between browsers, as most "
"browsers have a number of built-in shortcut keys, which can not be used in "
"web applications. For example, Mozilla Firefox allows binding almost any key "
"combination, while Opera does not even allow binding Alt shortcuts. Other "
"browsers are generally in between these two. Also, the operating system can "
"reserve some key combinations and some computer manufacturers define their "
"own system key combinations."
msgstr ""
"实际可用的键盘组合在不同的浏览器中可能会有很大区别, 因为大多数浏览器都有大量"
"的内建快捷键, 这些浏览器自用的快捷键就不能在 Web 应用程序中使用了. 比如, "
"Mozilla Firefox 几乎允许绑定任意的按键组合, 而 Opera 甚至连 Alt 键都不允许使"
"用. 其他浏览器大多处于这两种极端情况之间. 此外, 操作系统也可能保留某些按键组"
"合, 某些计算机制造厂商也预定义了他们自己的系统按键组合."

#. Tag: title
#: chapter-advanced.xml:1303
#, no-c-format
msgid "Printing"
msgstr "打印"

#. Tag: primary
#: chapter-advanced.xml:1306
#, no-c-format
msgid "printing"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1309
#, no-c-format
msgid ""
"Vaadin does not have any special support for printing. There are two basic "
"ways to print - in a printer controlled by the application server or by the "
"user from the web browser. Printing in the application server is largely "
"independent of the UI, you just have to take care that printing commands do "
"not block server requests, possibly by running the print commands in another "
"thread."
msgstr ""
"Vaadin 对于打印没有任何特别支持. 打印有两种基本方式 - 使用应用程序服务器端控"
"制的打印机, 或者由用户在 Web 浏览器中打印. 应用程序服务器端的打印工作与 UI 几"
"乎无关, 你只需要控制好打印命令, 使它不要阻塞服务器请求, 这一点可以通过使用独"
"立线程运行打印命令来实现."

#. Tag: methodname
#: chapter-advanced.xml:1320 chapter-advanced.xml:1324
#, no-c-format
msgid "print()"
msgstr ""

#. Tag: primary
#: chapter-advanced.xml:1323 chapter-advanced.xml:1344
#, no-c-format
msgid "JavaScript"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1325
#, no-c-format
msgid ""
"For client-side printing, most browsers support printing the web page. You "
"can either print the current or a special print page that you open. The page "
"can be styled for printing with special CSS rules, and you can hide unwanted "
"elements. You can also print other than Vaadin UI content, such as HTML or "
"PDF."
msgstr ""
"对于客户端的打印, 大多数浏览器都支持 Web 页面的打印功能. 你可以打印当前页面, "
"也可以打印某个特别的打印页面. 页面可以使用特别的 CSS 规则来控制打印时的样式, "
"在打印时你可以隐藏不希望出现的元素. 除 Vaadin UI 外, 你还可以打印其他内容, 比"
"如 HTML 或 PDF."

#. Tag: title
#: chapter-advanced.xml:1335
#, no-c-format
msgid "Printing the Browser Window"
msgstr "打印浏览器窗口"

#. Tag: para
#: chapter-advanced.xml:1337
#, no-c-format
msgid ""
"Vaadin does not have special support for launching the printing in browser, "
"but you can easily use the JavaScript <methodname>print()</methodname> "
"method that opens the print window of the browser."
msgstr ""
"在浏览器中启动打印机, Vaadin 没有提供特别的支持, 但你可以通过 JavaScript "
"<methodname>print()</methodname> 方法很简单地实现, 这个方法会打开浏览器的打印"
"窗口."

#. Tag: methodname
#: chapter-advanced.xml:1344
#, no-c-format
msgid "execute()"
msgstr ""

#. Tag: programlisting
#: chapter-advanced.xml:1347
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Button print = new Button(\"Print This Page"
"\");\n"
"print.addClickListener(new Button.ClickListener() {\n"
"    public void buttonClick(ClickEvent event) {\n"
"        // Print the current page\n"
"        JavaScript.getCurrent().execute(\"print();\");\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1349
#, no-c-format
msgid ""
"The button in the above example would print the current page, including the "
"button itself. You can hide such elements in CSS, as well as otherwise style "
"the page for printing. Style definitions for printing are defined inside a "
"<literal>@media print {}</literal> block in CSS."
msgstr ""
"上例中的按钮会打印当前页面, 包括按钮本身. 你可以使用 CSS 来隐藏这类元素, 也可"
"以针对打印版进行专门的样式控制. 专门针对打印的样式定义需要包括在 CSS 的 "
"<literal>@media print {}</literal> 之内."

#. Tag: title
#: chapter-advanced.xml:1358
#, no-c-format
msgid "Opening a Print Window"
msgstr "打开打印窗口"

#. Tag: para
#: chapter-advanced.xml:1360
#, no-c-format
msgid ""
"You can open a browser window with a special UI for print content and "
"automatically launch printing the content."
msgstr ""
"你可以打开一个浏览器窗口, 其中内容是一个专用于打印内容的 UI, 并且自动启动打印"
"动作."

#. Tag: programlisting
#: chapter-advanced.xml:1366
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public static class PrintUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        // Have some content to print\n"
"        setContent(new Label(\n"
"            \"<h1>Here's some dynamic content</h1>\\n\" +\n"
"            \"<p>This is to be printed.</p>\",\n"
"            ContentMode.HTML));\n"
"        \n"
"        // Print automatically when the window opens\n"
"        JavaScript.getCurrent().execute(\n"
"            \"setTimeout(function() {\" +\n"
"            \"  print(); self.close();}, 0);\");\n"
"    }\n"
"}\n"
"...\n"
"\n"
"// Create an opener extension\n"
"BrowserWindowOpener opener =\n"
"        new BrowserWindowOpener(PrintUI.class);\n"
"opener.setFeatures(\"height=200,width=400,resizable\");\n"
"    \n"
"// A button to open the printer-friendly page.\n"
"Button print = new Button(\"Click to Print\");\n"
"opener.extend(print);]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1368
#, no-c-format
msgid ""
"How the browser opens the window, as an actual (popup) window or just a tab, "
"depends on the browser. After printing, we automatically close the window "
"with JavaScript <methodname>close()</methodname> call."
msgstr ""
"浏览器如何打开窗口, 是作为真实的(弹出)窗口, 还是作为一个 tab, 由浏览器决定. "
"打印完成后, 我们调用 JavaScript 的 <methodname>close()</methodname> 方法来自动关闭窗"
"口."

#. Tag: title
#: chapter-advanced.xml:1381
#, no-c-format
msgid "Printing PDF"
msgstr "打印 PDF"

#. Tag: primary
#: chapter-advanced.xml:1384
#, no-c-format
msgid "<primary>PDF</primary>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1384
#, no-c-format
msgid ""
"To print content as PDF, you need to provide the downloadable content as a "
"static or a dynamic resource, such as a <classname>StreamResource</"
"classname>."
msgstr ""
"为了以 PDF 形式打印内容, 你需要提供可下载的 PDF 内容, 这个内容可以是静态的也"
"可以是动态生成的, 比如 <classname>StreamResource</classname> 形式."

#. Tag: para
#: chapter-advanced.xml:1391
#, no-c-format
msgid ""
"You can let the user open the resource using a <classname>Link</classname> "
"component, or some other component with a <classname>PopupWindowOpener</"
"classname> extension. When such a link or opener is clicked, the browser "
"opens the PDF in the browser, in an external viewer (such as Adobe Reader), "
"or lets the user save the document."
msgstr ""
"你可以使用 <classname>Link</classname> 来让用户打开这个资源, 也可以使用与 "
"<classname>PopupWindowOpener</classname> 绑定的其他组件. 当这个 Link 或 "
"PopupWindowOpener 被点击之后, 浏览器会在浏览器内部打开 PDF, 或在外部阅读器(比"
"如 Adobe Reader)中打开 PDF, 或者让用户将文档保存为本地文件."

#. Tag: para
#: chapter-advanced.xml:1400
#, no-c-format
msgid ""
"It is crucial to notice that clicking a <classname>Link</classname> or a "
"<classname>PopupWindowOpener</classname> is a client-side operation. If you "
"get the content of the dynamic PDF from the same UI state, you can not have "
"the link or opener enabled, as then clicking it would not get the current UI "
"content. Instead, you have to create the resource object before the link or "
"opener are clicked. This usually requires a two-step operation, or having "
"the print operation available in another view."
msgstr ""
"有一个重要问题需要注意, 点击 <classname>Link</classname> 或 "
"<classname>PopupWindowOpener</classname> 是发生在客户端的操作. 如果你通过某"
"个 UI 状态创建出动态 PDF 内容, 这之前你无法使 Link 或 Opener 有效, 因为点击它"
"不能得到当前 UI 的内容. 相反, 你必须在 Link 或 Opener 被点击之前就创建资源对"
"象. 这种方案通常需要两步操作, 或者需要将打印操作放在另外的视图中."

#. Tag: programlisting
#: chapter-advanced.xml:1411
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// A user interface for a (trivial) data model "
"from which\n"
"// the PDF is generated.\n"
"final TextField name = new TextField(\"Name\");\n"
"name.setValue(\"Slartibartfast\");\n"
"\n"
"// This has to be clicked first to create the stream resource\n"
"final Button ok = new Button(\"OK\");\n"
"\n"
"// This actually opens the stream resource\n"
"final Button print = new Button(\"Open PDF\");\n"
"print.setEnabled(false);\n"
"\n"
"ok.addClickListener(new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        // Create the PDF source and pass the data model to it\n"
"        StreamSource source =\n"
"            new MyPdfSource((String) name.getValue());\n"
"        \n"
"        // Create the stream resource and give it a file name\n"
"        String filename = \"pdf_printing_example.pdf\";\n"
"        StreamResource resource =\n"
"                new StreamResource(source, filename);\n"
"        \n"
"        // These settings are not usually necessary. MIME type\n"
"        // is detected automatically from the file name, but\n"
"        // setting it explicitly may be necessary if the file\n"
"        // suffix is not \".pdf\".\n"
"        resource.setMIMEType(\"application/pdf\");\n"
"        resource.getStream().setParameter(\n"
"                \"Content-Disposition\",\n"
"                \"attachment; filename=\"+filename);\n"
"\n"
"        // Extend the print button with an opener\n"
"        // for the PDF resource\n"
"        BrowserWindowOpener opener =\n"
"                new BrowserWindowOpener(resource);\n"
"        opener.extend(print);\n"
"      \n"
"        name.setEnabled(false);\n"
"        ok.setEnabled(false);\n"
"        print.setEnabled(true);\n"
"    }\n"
"});\n"
"\n"
"layout.addComponent(name);\n"
"layout.addComponent(ok);\n"
"layout.addComponent(print);]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:1419
#, no-c-format
msgid "Google App Engine Integration"
msgstr "与 Google App Engine 的集成"

#. Tag: emphasis
#: chapter-advanced.xml:1422
#, no-c-format
msgid "This section is not yet fully updated to Vaadin 7."
msgstr "本节内容还没有针对 Vaadin 7 版本更新完毕."

#. Tag: para
#: chapter-advanced.xml:1425
#, no-c-format
msgid ""
"Vaadin includes support to run Vaadin applications in the Google App Engine "
"(GAE). The most essential requirement for GAE is the ability to serialize "
"the application state. Vaadin applications are serializable through the "
"<classname>java.io.Serializable</classname> interface."
msgstr ""
"针对 Vaadin 应用程序 在 Google App Engine (GAE) 中的运行, Vaadin 提供了支持. "
"GAE 中运行的最重要的要求是能够将应用程序状态序列化保存. Vaadin 应用程序通过 "
"<classname>java.io.Serializable</classname> 接口实现序列化功能."

#. Tag: para
#: chapter-advanced.xml:1432
#, no-c-format
msgid ""
"To run as a GAE application, an application must use "
"<classname>GAEVaadinServlet</classname> instead of <classname>VaadinServlet</"
"classname>, and of course implement the <classname>java.io.Serializable</"
"classname> interface for all persistent classes. You also need to enable "
"session support in <filename>appengine-web.xml</filename> with:"
msgstr ""
"要作为 GAE 应用程序运行, 应用程序必须使用 <classname>GAEVaadinServlet</"
"classname> 而不是 <classname>VaadinServlet</classname>, 而且对所有的持久化类"
"都需要实现 <classname>java.io.Serializable</classname> 接口. 你还需要在 "
"<filename>appengine-web.xml</filename> 中允许 session:"

#. Tag: programlisting
#: chapter-advanced.xml:1441
#, no-c-format
msgid "<![CDATA[<sessions-enabled>true</sessions-enabled>]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1443
#, no-c-format
msgid ""
"The Vaadin Project wizard can create the configuration files needed for GAE "
"deployment. See <xref linkend=\"getting-started.first-project.creation\"/>. "
"When the Google App Engine deployment configuration is selected, the wizard "
"will create the project structure following the GAE Servlet convention "
"instead of the regular Servlet convention. The main differences are:"
msgstr ""
"Vaadin 工程向导可以创建 GAE 部署需要的配置文件. 详情请参见 <xref linkend="
"\"getting-started.first-project.creation\"/>. 当选择 Google App Engine 部署配"
"置时, 向导会按照 GAE Servlet  规约来创建工程结构, 而不是使用通常的 Servlet 规"
"约. 主要区别是:"

#. Tag: listitem
#: chapter-advanced.xml:1452
#, no-c-format
msgid "Source directory: <filename>src/main/java</filename>"
msgstr "源代码目录: <filename>src/main/java</filename>"

#. Tag: listitem
#: chapter-advanced.xml:1453
#, no-c-format
msgid "Output directory: <filename>war/WEB-INF/classes</filename>"
msgstr "输出目录: <filename>war/WEB-INF/classes</filename>"

#. Tag: listitem
#: chapter-advanced.xml:1454
#, no-c-format
msgid "Content directory: <filename>war</filename>"
msgstr "Web 内容目录: <filename>war</filename>"

#. Tag: title
#: chapter-advanced.xml:1458
#, no-c-format
msgid "Rules and Limitations"
msgstr "规则与限制"

#. Tag: para
#: chapter-advanced.xml:1460
#, no-c-format
msgid ""
"Running Vaadin applications in Google App Engine has the following rules and "
"limitations:"
msgstr "在 Google App Engine 中运行 Vaadin 应用程序存在以下规则和限制:"

#. Tag: para
#: chapter-advanced.xml:1466
#, no-c-format
msgid ""
"Avoid using the session for storage, usual App Engine limitations apply (no "
"synchronization, that is, it is unreliable)."
msgstr ""
"不要使用 session 作为数据存储的目的, 通常的 App Engine 限制也适用于这个问题"
"(session 不同步, 也就是说, 是不可靠的)."

#. Tag: para
#: chapter-advanced.xml:1470
#, no-c-format
msgid ""
"Vaadin uses memcache for mutex, the key is of the form <parameter>_vmutex&lt;"
"sessionid&gt;</parameter>."
msgstr ""
"Vaadin 在互斥锁(mutex)中使用 memcache, 其中键值的形式是 "
"<parameter>_vmutex&lt;sessionid&gt;</parameter>."

#. Tag: para
#: chapter-advanced.xml:1473
#, no-c-format
msgid ""
"The Vaadin <classname>WebApplicationContext</classname> class is serialized "
"separately into memcache and datastore; the memcache key is "
"<parameter>_vac&lt;sessionid&gt;</parameter> and the datastore entity kind "
"is <parameter>_vac</parameter> with identifiers of the type "
"<parameter>_vac&lt;sessionid&gt;</parameter>."
msgstr ""
"Vaadin <classname>WebApplicationContext</classname> 类会被分别序列化进入 "
"memcache 和 datastore 中; memcache 中键值是 <parameter>_vac&lt;sessionid&gt;"
"</parameter>, datastore 中的 entity kind 是 <parameter>_vac</parameter>, ID "
"类型是 <parameter>_vac&lt;sessionid&gt;</parameter>."

#. Tag: para
#: chapter-advanced.xml:1479
#, no-c-format
msgid ""
"<emphasis>Do not</emphasis> update the application state when serving an "
"<classname>ConnectorResource</classname> (such as <classname>ClassResource</"
"classname>.<methodname>getStream()</methodname>)."
msgstr ""
"向客户端提供 <classname>ConnectorResource</classname>时 (比如 "
"<classname>ClassResource</classname>.<methodname>getStream()</methodname>), "
"<emphasis>不要</emphasis> 更新应用程序状态."

#. Tag: para
#: chapter-advanced.xml:1483
#, no-c-format
msgid ""
"<emphasis>Avoid</emphasis> (or be very careful when) updating application "
"state in a <classname>TransactionListener</classname> - it is called even "
"when the application is not locked and won't be serialized (such as with "
"<classname>ConnectorResource</classname>), and changes can therefore be lost "
"(it should be safe to update things that can be safely discarded later, that "
"is, valid only for the current request)."
msgstr ""
"在 <classname>TransactionListener</classname> 之内 <emphasis>不要</emphasis> "
"更新应用程序状态(如果一定要做, 需要特别小心) - 即使在应用程序未被锁定, 不会被"
"序列化的时刻(比如使用 <classname>ConnectorResource</classname> 时)这个监听器"
"也会被调用, 因此对应用程序状态的变更可能会丢失(对于那些可以丢弃的信息, 也就是"
"说, 只对当前请求有效的那些信息, 是可以更新的)."

#. Tag: para
#: chapter-advanced.xml:1491
#, no-c-format
msgid ""
"The application remains locked during uploads - a progress bar is not "
"possible."
msgstr "上传文件时, 应用程序会保持锁死 - 进度条是不可用的."

#. Tag: title
#: chapter-advanced.xml:1498
#, no-c-format
msgid "Common Security Issues"
msgstr "共通的安全问题"

#. Tag: title
#: chapter-advanced.xml:1501
#, no-c-format
msgid "Sanitizing User Input to Prevent Cross-Site Scripting"
msgstr "处理用户输入内容, 防止跨站脚本攻击"

#. Tag: para
#: chapter-advanced.xml:1503
#, no-c-format
msgid ""
"You can put raw HTML content in many components, such as the "
"<classname>Label</classname> and <classname>CustomLayout</classname>, as "
"well as in tooltips and notifications. In such cases, you should make sure "
"that if the content has any possibility to come from user input, you must "
"make sure that the content is safe before displaying it. Otherwise, a "
"malicious user can easily make a <link xlink:href=\"http://en.wikipedia.org/"
"wiki/Cross-site_scripting\">cross-site scripting attack</link> by injecting "
"offensive JavaScript code in such components. See other sources for more "
"information about cross-site scripting."
msgstr ""
"在很多组件内都可以使用原生的 HTML 内容, 比如在 <classname>Label</classname> "
"和 <classname>CustomLayout</classname> 内, 以及在 tooltip 和通知信息内. 这种"
"情况下, 如果内容有可能来自用户输入的话, 在显示这些内容之前你必须确保内容是安"
"全的. 否则, 恶意用户可以很容易地在这类组件中注入攻击性的 JavaScript 脚本, 发"
"起 <link xlink:href=\"http://en.wikipedia.org/wiki/Cross-site_scripting\">跨"
"站脚本攻击</link>. 关于跨站脚本攻击的更多介绍, 请阅读其他相关文档."

#. Tag: para
#: chapter-advanced.xml:1516
#, no-c-format
msgid ""
"Offensive code can easily be injected with <literal>&lt;script&gt;</literal> "
"markup or in tag attributes as events, such as <parameter>onLoad</"
"parameter>. Cross-site scripting vulnerabilities are browser dependent, "
"depending on the situations in which different browsers execute scripting "
"markup."
msgstr ""
"可以很容易地注入攻击代码, 方法是使用 <literal>&lt;script&gt;</literal> 标记, "
"或者使用其他 tag 的事件属性, 比如 <parameter>onLoad</parameter> 属性. 跨站脚"
"本漏洞与浏览器相关, 取决于各种不同浏览器执行脚本时的具体情况."

#. Tag: para
#: chapter-advanced.xml:1525
#, no-c-format
msgid ""
"Therefore, if the content created by one user is shown to other users, the "
"content must be sanitized. There is no generic way to sanitize user input, "
"as different applications can allow different kinds of input. Pruning "
"(X)HTML tags out is somewhat simple, but some applications may need to allow "
"(X)HTML content. It is therefore the responsibility of the application to "
"sanitize the input."
msgstr ""
"因此, 如果需要将一个用户创建的内容显示给其他用户, 内容首先要进行安全处理. 对"
"用户输入内容的安全处理并不存在一个通用的方法, 因为不同的应用程序可能会允许不"
"同的输入内容. 删去所有的 (X)HTML tag 是最简便的方法, 但某些应用程序会需要允许"
"使用 (X)HTML 内容. 因此, 应用程序必须按照各自的需求来对内容进行安全处理."

#. Tag: para
#: chapter-advanced.xml:1534
#, no-c-format
msgid ""
"Character encoding can make sanitization more difficult, as offensive tags "
"can be encoded so that they are not recognized by a sanitizer. This can be "
"done, for example, with HTML character entities and with variable-width "
"encodings such as UTF-8 or various CJK encodings, by abusing multiple "
"representations of a character. Most trivially, you could input <literal>&lt;"
"</literal> and <literal>&gt;</literal> with <literal>&amp;lt;</literal> and "
"<literal>&amp;gt;</literal>, respectively. The input could also be malformed "
"and the sanitizer must be able to interpret it exactly as the browser would, "
"and different browsers can interpret malformed HTML and variable-width "
"character encodings differently."
msgstr ""
"字符编码问题会使得内容的安全处理变得更加困难, 因为攻击性 tag 可能是被编码过"
"的, 因此安全处理程序可能无法识别它们. 比如, 攻击者可以利用 HTML 字符实体"
"(character entity), 使用变宽字符集, 比如 UTF-8 或各种 CJK 字符集, 通过同一个"
"字符的多种表达方式来欺骗安全处理程序. 最简单的例子, 你可以使用 <literal>&amp;"
"lt;</literal> 和 <literal>&amp;gt;</literal> 来输入 <literal>&lt;</literal> "
"和 <literal>&gt;</literal>. 输入内容还可以是格式不正确的, 安全处理程序必须有"
"能力使用与浏览器完全相同的方式来解释这段输入, 而不同的浏览器对格式不正确的 "
"HTML 以及变宽字符集编码的解释有可能很不相同."

#. Tag: para
#: chapter-advanced.xml:1548
#, no-c-format
msgid ""
"Notice that the problem applies also to user input from a "
"<classname>RichTextArea</classname> is transmitted as HTML from the browser "
"to server-side and is not sanitized. As the entire purpose of the "
"<classname>RichTextArea</classname> component is to allow input of formatted "
"text, you can not just remove all HTML tags. Also many attributes, such as "
"<parameter>style</parameter>, should pass through the sanitization."
msgstr ""
"注意, 这个问题对于 <classname>RichTextArea</classname> 的输入也是有效的, 它的"
"内容以 HTML 形式从浏览器传送到服务器端, 而且是未经过安全处理的. 由于 "
"<classname>RichTextArea</classname> 组件的目的本身就是为了允许输入格式化的文"
"本, 所以你不能简单地删除所有的 HTML tag. 此外还有很多 tag 属性, 比如 "
"<parameter>style</parameter>, 在安全处理过程中也应该保留下来."

#. Tag: title
#: chapter-advanced.xml:1563
#, no-c-format
msgid "Navigating in an Application"
msgstr "应用程序内的导航跳转"

#. Tag: para
#: chapter-advanced.xml:1565
#, no-c-format
msgid ""
"Plain Vaadin applications do not have normal web page navigation as they "
"usually run on a single page, as all Ajax applications do. Quite commonly, "
"however, applications have different views between which the user should be "
"able to navigate. The <classname>Navigator</classname> in Vaadin can be used "
"for most cases of navigation. Views managed by the navigator automatically "
"get a distinct URI fragment, which can be used to be able to bookmark the "
"views and their states and to go back and forward in the browser history."
msgstr ""
"简单的 Vaadin 应用程序不存在 Web 页面跳转的问题, 因为它们象所有的 Ajax 应用程"
"序一样, 通常只运行在一个页面内. 但是, 很多情况下, 应用程序也可能带有多个视"
"图, 用户应该能在这些视图之间导航跳转. Vaadin 中的 <classname>Navigator</"
"classname> 可以用来解决大多数这类跳转导航问题. 导航器管理下的多个视图会自动获"
"得不同的 URI 片段, 这些 URI 片段可以用来作为视图及其状态的书签, 还可以在浏览"
"器的历史记录中向前或向后跳转."

#. Tag: title
#: chapter-advanced.xml:1576
#, no-c-format
msgid "Setting Up for Navigation"
msgstr "导航设置"

#. Tag: para
#: chapter-advanced.xml:1578
#, no-c-format
msgid ""
"The <classname>Navigator</classname> class manages a collection of "
"<emphasis>views</emphasis> that implement the <interfacename>View</"
"interfacename> interface. The views can be either registered beforehand or "
"acquired from a <emphasis>view provider</emphasis>. When registering, the "
"views must have a name identifier and be added to a navigator with "
"<methodname>addView()</methodname>. You can register new views at any point. "
"Once registered, you can navigate to them with <methodname>navigateTo()</"
"methodname>."
msgstr ""
"<classname>Navigator</classname> 类管理多个 <emphasis>视图</emphasis>, 这些视"
"图需要实现 <interfacename>View</interfacename> 接口. 视图可以预先注册, 也可以"
"通过 <emphasis>视图提供者</emphasis> 来获得. 注册时, 视图必须拥有一个名称标识"
"符, 然后使用 <methodname>addView()</methodname> 方法加入到导航器中. 你可以在"
"任何时刻注册新的视图. 一旦注册完成, 你就可以使用 <methodname>navigateTo()</"
"methodname> 方法在视图中导航跳转."

#. Tag: para
#: chapter-advanced.xml:1590
#, no-c-format
msgid ""
"<classname>Navigator</classname> manages navigation in a component "
"container, which can be either a <interfacename>ComponentContainer</"
"interfacename> (most layouts) or a <interfacename>SingleComponentContainer</"
"interfacename> (<classname>UI</classname>, <classname>Panel</classname>, or "
"<classname>Window</classname>). The component container is managed through a "
"<interfacename>ViewDisplay</interfacename>. Two view displays are defined: "
"<classname>ComponentContainerViewDisplay</classname> and "
"<classname>SingleComponentContainerViewDisplay</classname>, for the "
"respective component container types. Normally, you can let the navigator "
"create the view display internally, as we do in the example below, but you "
"can also create it yourself to customize it."
msgstr ""
"<classname>Navigator</classname> 使用组件容器来管理导航跳转, 容器可以是 "
"<interfacename>ComponentContainer</interfacename> (大多数布局组件是 "
"ComponentContainer) 或 <interfacename>SingleComponentContainer</"
"interfacename> (<classname>UI</classname>, <classname>Panel</classname>, 或 "
"<classname>Window</classname> 是 SingleComponentContainer). 组件容器通过 "
"<interfacename>ViewDisplay</interfacename> 来管理. ViewDisplay 有两种: "
"<classname>ComponentContainerViewDisplay</classname> 和 "
"<classname>SingleComponentContainerViewDisplay</classname>, 分别对应于前面的"
"两种组件容器类型. 通常, 你可以让导航器来创建内部的 ViewDisplay, 下例中我们就"
"是这样做的, 但你也可以自己创建它, 以便对它进行定制."

#. Tag: para
#: chapter-advanced.xml:1605
#, no-c-format
msgid ""
"Let us consider the following UI with two views: start and main. Here, we "
"define their names with enums to be typesafe. We manage the navigation with "
"the UI class itself, which is a <interfacename>SingleComponentContainer</"
"interfacename>."
msgstr ""
"我们来看看下面的 UI, 其中包含两个视图: 开始视图和主视图. 这里, 我们使用 enum "
"来定义它们的名称, 以便保证类型安全. 我们使用 UI 类自身来管理导航跳转, 这里的 "
"UI 类是一个 <interfacename>SingleComponentContainer</interfacename>."

#. Tag: programlisting
#: chapter-advanced.xml:1613
#, no-c-format
msgid ""
"<![CDATA[public class NavigatorUI extends UI {\n"
"    Navigator navigator;\n"
"    protected static final String MAINVIEW = \"main\";\n"
"\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        getPage().setTitle(\"Navigation Example\");\n"
"        \n"
"        // Create a navigator to control the views\n"
"        navigator = new Navigator(this, this);\n"
"        \n"
"        // Create and register the views\n"
"        navigator.addView(\"\", new StartView());\n"
"        navigator.addView(MAINVIEW, new MainView());\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1615
#, no-c-format
msgid ""
"The <classname>Navigator</classname> automatically sets the URI fragment of "
"the application URL. It also registers a "
"<interfacename>URIFragmentChangedListener</interfacename> in the page "
"<phrase condition=\"web\">(see <xref linkend=\"advanced.urifu\"/>)</phrase> "
"to show the view identified by the URI fragment if entered or navigated to "
"in the browser. This also enables browser navigation history in the "
"application."
msgstr ""
"<classname>Navigator</classname> 自动设定应用程序 URL 的 URI 片段. 它还会在页"
"面中注册一个 <interfacename>URIFragmentChangedListener</interfacename> "
"<phrase condition=\"web\">(详情请参见 <xref linkend=\"advanced.urifu\"/>)</"
"phrase>, 当用户手动输入某个地址时, 或者在浏览器内发生跳转时, 这个 "
"URIFragmentChangedListener 用来显示 URI 片段对应的视图. 这个功能也允许在应用"
"程序内记录下浏览器的浏览历史."

#. Tag: title
#: chapter-advanced.xml:1625
#, no-c-format
msgid "View Providers"
msgstr "视图提供者(View Provider)"

#. Tag: para
#: chapter-advanced.xml:1627
#, no-c-format
msgid ""
"You can create new views dynamically using a <emphasis>view provider</"
"emphasis> that implements the <interfacename>ViewProvider</interfacename> "
"interface. A provider is registered in <classname>Navigator</classname> with "
"<methodname>addProvider()</methodname>."
msgstr ""
"你可以使用 <emphasis>视图提供者</emphasis> 来动态创建新的视图, 视图提供者需要"
"实现 <interfacename>ViewProvider</interfacename> 接口. 视图提供者通过 "
"<methodname>addProvider()</methodname> 方法注册到 <classname>Navigator</"
"classname> 中."

#. Tag: para
#: chapter-advanced.xml:1635
#, no-c-format
msgid ""
"The <methodname>ClassBasedViewProvider</methodname> is a view provider that "
"can dynamically create new instances of a specified view class based on the "
"view name."
msgstr ""
"<methodname>ClassBasedViewProvider</methodname> 是一个视图提供者, 它可以根据"
"视图名称, 动态地创建某个预先指定的视图类的新实例."

#. Tag: para
#: chapter-advanced.xml:1641
#, no-c-format
msgid ""
"The <methodname>StaticViewProvider</methodname> returns an existing view "
"instance based on the view name. The <methodname>addView()</methodname> in "
"<classname>Navigator</classname> is actually just a shorthand for creating a "
"static view provider for each registered view."
msgstr ""
"<methodname>StaticViewProvider</methodname> 根据视图名称返回一个既有的视图实"
"例. <classname>Navigator</classname> 中的 <methodname>addView()</methodname> "
"方法实际上只是一个便捷方法, 其中的内容是为注册的每一个视图创建一个 "
"StaticViewProvider."

#. Tag: title
#: chapter-advanced.xml:1651
#, no-c-format
msgid "View Change Listeners"
msgstr "视图变化监听器"

#. Tag: para
#: chapter-advanced.xml:1653
#, no-c-format
msgid ""
"You can handle view changes also by implementing a "
"<interfacename>ViewChangeListener</interfacename> and adding it to a "
"<classname>Navigator</classname>. When a view change occurs, a listener "
"receives a <classname>ViewChangeEvent</classname> object, which has "
"references to the old and the activated view, the name of the activated "
"view, as well as the fragment parameters."
msgstr ""
"实现 <interfacename>ViewChangeListener</interfacename> 接口, 并将它添加到 "
"<classname>Navigator</classname> 中, 这样就可以处理视图的变化事件了. 当试图发"
"生变化时, 监听器会收到一个 <classname>ViewChangeEvent</classname> 对象, 其中"
"的信息包含旧视图和目前活动视图, 目前活动视图的名称, 以及 URI 片段参数."

#. Tag: title
#: chapter-advanced.xml:1665
#, no-c-format
msgid "Implementing a View"
msgstr "实现 View"

#. Tag: para
#: chapter-advanced.xml:1667
#, no-c-format
msgid ""
"Views can be any objects that implement the <interfacename>View</"
"interfacename> interface. When the <methodname>navigateTo()</methodname> is "
"called for the navigator, or the application is opened with the URI fragment "
"associated with the view, the navigator switches to the view and calls its "
"<methodname>enter()</methodname> method."
msgstr ""
"视图可以是实现了 <interfacename>View</interfacename> 接口的任何对象. 当导航器"
"的 <methodname>navigateTo()</methodname> 方法被调用时, 或者使用与视图关联的 "
"URI 片段来打开应用程序时, 导航器会切换到这个视图, 并调用它的 "
"<methodname>enter()</methodname> 方法."

#. Tag: para
#: chapter-advanced.xml:1676
#, no-c-format
msgid ""
"To continue with the example, consider the following simple start view that "
"just lets the user to navigate to the main view. It only pops up a "
"notification when the user navigates to it and displays the navigation "
"button."
msgstr ""
"继续前面的例子, 我们的开始视图很简单, 它只用来让用户跳转到主视图. 当用户跳转"
"到开始视图时, 它只会弹出一个通知信息, 并显示一个导航跳转按钮."

#. Tag: programlisting
#: chapter-advanced.xml:1684
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/** A start view for navigating to the main "
"view */\n"
"public class StartView extends VerticalLayout implements View {\n"
"    public StartView() {\n"
"        setSizeFull();\n"
"\n"
"        Button button = new Button(\"Go to Main View\",\n"
"                new Button.ClickListener() {\n"
"            @Override\n"
"            public void buttonClick(ClickEvent event) {\n"
"                navigator.navigateTo(MAINVIEW);\n"
"            }\n"
"        });\n"
"        addComponent(button);\n"
"        setComponentAlignment(button, Alignment.MIDDLE_CENTER);\n"
"    }        \n"
"        \n"
"    @Override\n"
"    public void enter(ViewChangeEvent event) {\n"
"        Notification.show(\"Welcome to the Animal Farm\");\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1686
#, no-c-format
msgid ""
"You can initialize the view content in the constructor, as was done in the "
"example above, or in the <methodname>enter()</methodname> method. The "
"advantage with the latter method is that the view is attached to the view "
"container as well as to the UI at that time, which is not the case in the "
"constructor."
msgstr ""
"如上例所示, 你可以在构造函数中初始化视图的内容, 或者也可以在 "
"<methodname>enter()</methodname> 方法中初始化. 后一种方法的优点是, 视图只有在"
"关联到视图容器时才会同时关联到 UI, 而在使用构造函数的方案中并不是如此."

#. Tag: title
#: chapter-advanced.xml:1696
#, no-c-format
msgid "Handling URI Fragment Path"
msgstr "处理 URI 片段路径"

#. Tag: para
#: chapter-advanced.xml:1698
#, no-c-format
msgid ""
"URI fragment part of a URL is the part after a hash <literal>#</literal> "
"character. Is used for within-UI URLs, because it is the only part of the "
"URL that can be changed with JavaScript from within a page without reloading "
"the page. The URLs with URI fragments can be used for hyperlinking and "
"bookmarking, as well as browser history, just like any other URLs. In "
"addition, an exclamation mark <literal>#!</literal> after the hash marks "
"that the page is a stateful AJAX page, which can be crawled by search "
"engines. Crawling requires that the application also responds to special "
"URLs to get the searchable content. URI fragments are managed by "
"<classname>Page</classname>, which provides a low-level API."
msgstr ""
"URL 中的 URI 片段是指 <literal>#</literal> 字符以后的部分. 它用来表达 UI 内部"
"的 URL, 因为在 URL 中, 只有这一部分可以通过页面内的 JavaScript 来改变, 而同时"
"又不会导致页面重装载. 带 URI 片段的 URL 与其他 URL 一样, 可以用在超链接和浏览"
"器书签中, 也可以用于浏览器访问履历. 此外, <literal>#!</literal> 符号表示页面"
"是一个有状态的 AJAX 页面, 可以被搜索引擎抓取. 搜索引擎抓取页面时要求针对\"可"
"搜索内容\"的 URL, 应用程序也能正常应答. URI 片段由 <classname>Page</"
"classname> 管理, 它负责提供相关的低阶 API."

#. Tag: para
#: chapter-advanced.xml:1711
#, no-c-format
msgid ""
"URI fragments can be used with <classname>Navigator</classname> in two ways: "
"for navigating to a view and to a state within a view. The URI fragment "
"accepted by <methodname>navigateTo()</methodname> can have the view name at "
"the root, followed by fragment parameters after a slash (\"<literal>/</"
"literal>\"). These parameters are passed to the <methodname>enter()</"
"methodname> method in the <interfacename>View</interfacename>."
msgstr ""
"在 <classname>Navigator</classname> 中使用 URI 片段有两种方式: 跳转到某个视"
"图, 或者跳转到视图内的某个状态. <methodname>navigateTo()</methodname> 方法接"
"受的 URI 片段, 最前端是视图名称, 再一个斜线(\"<literal>/</literal>\")之后可以"
"附带片段参数. 这些参数会被传递给 <interfacename>View</interfacename> 的 "
"<methodname>enter()</methodname> 方法."

#. Tag: para
#: chapter-advanced.xml:1721
#, no-c-format
msgid "In the following example, we implement within-view navigation."
msgstr "下例中, 我们实现视图内部的导航条转."

#. Tag: programlisting
#: chapter-advanced.xml:1726
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/** Main view with a menu */\n"
"public class MainView extends VerticalLayout implements View {\n"
"    Panel panel;\n"
"\n"
"    // Menu navigation button listener\n"
"    class ButtonListener implements Button.ClickListener {\n"
"\n"
"        String menuitem;\n"
"        public ButtonListener(String menuitem) {\n"
"            this.menuitem = menuitem;\n"
"        }\n"
"\n"
"        @Override\n"
"        public void buttonClick(ClickEvent event) {\n"
"            // Navigate to a specific state\n"
"            navigator.navigateTo(MAINVIEW + \"/\" + menuitem);\n"
"        }\n"
"    }\n"
"\n"
"    public MainView() {\n"
"        setSizeFull();\n"
"        \n"
"        // Layout with menu on left and view area on right\n"
"        HorizontalLayout hLayout = new HorizontalLayout();\n"
"        hLayout.setSizeFull();\n"
"\n"
"        // Have a menu on the left side of the screen\n"
"        Panel menu = new Panel(\"List of Equals\");\n"
"        menu.setHeight(\"100%\");\n"
"        menu.setWidth(null);\n"
"        VerticalLayout menuContent = new VerticalLayout();\n"
"        menuContent.addComponent(new Button(\"Pig\",\n"
"                  new ButtonListener(\"pig\")));\n"
"        menuContent.addComponent(new Button(\"Cat\",\n"
"                  new ButtonListener(\"cat\")));\n"
"        menuContent.addComponent(new Button(\"Dog\",      \n"
"                  new ButtonListener(\"dog\")));\n"
"        menuContent.addComponent(new Button(\"Reindeer\",\n"
"                  new ButtonListener(\"reindeer\")));\n"
"        menuContent.addComponent(new Button(\"Penguin\",\n"
"                  new ButtonListener(\"penguin\")));\n"
"        menuContent.addComponent(new Button(\"Sheep\",\n"
"                  new ButtonListener(\"sheep\")));\n"
"        menuContent.setWidth(null);\n"
"        menuContent.setMargin(true);\n"
"        menu.setContent(menuContent);\n"
"        hLayout.addComponent(menu);\n"
"\n"
"        // A panel that contains a content area on right\n"
"        panel = new Panel(\"An Equal\");\n"
"        panel.setSizeFull();\n"
"        hLayout.addComponent(panel);\n"
"        hLayout.setExpandRatio(panel, 1.0f);\n"
"\n"
"        addComponent(hLayout);\n"
"        setExpandRatio(hLayout, 1.0f);\n"
"        \n"
"        // Allow going back to the start\n"
"        Button logout = new Button(\"Logout\",\n"
"                   new Button.ClickListener() {\n"
"            @Override\n"
"            public void buttonClick(ClickEvent event) {\n"
"                navigator.navigateTo(\"\");\n"
"            }\n"
"        });\n"
"        addComponent(logout);\n"
"    }        \n"
"    \n"
"    @Override\n"
"    public void enter(ViewChangeEvent event) {\n"
"        VerticalLayout panelContent = new VerticalLayout();\n"
"        panelContent.setSizeFull();\n"
"        panelContent.setMargin(true);\n"
"        panel.setContent(panelContent); // Also clears\n"
"\n"
"        if (event.getParameters() == null\n"
"            || event.getParameters().isEmpty()) {\n"
"            panelContent.addComponent(\n"
"                new Label(\"Nothing to see here, \" +\n"
"                          \"just pass along.\"));\n"
"            return;\n"
"        }\n"
"\n"
"        // Display the fragment parameters\n"
"        Label watching = new Label(\n"
"            \"You are currently watching a \" +\n"
"            event.getParameters());\n"
"        watching.setSizeUndefined();\n"
"        panelContent.addComponent(watching);\n"
"        panelContent.setComponentAlignment(watching,\n"
"            Alignment.MIDDLE_CENTER);\n"
"        \n"
"        // Some other content\n"
"        Embedded pic = new Embedded(null,\n"
"            new ThemeResource(\"img/\" + event.getParameters() +\n"
"                              \"-128px.png\"));\n"
"        panelContent.addComponent(pic);\n"
"        panelContent.setExpandRatio(pic, 1.0f);\n"
"        panelContent.setComponentAlignment(pic,\n"
"                Alignment.MIDDLE_CENTER);\n"
"\n"
"        Label back = new Label(\"And the \" +\n"
"            event.getParameters() + \" is watching you\");\n"
"        back.setSizeUndefined();\n"
"        panelContent.addComponent(back);\n"
"        panelContent.setComponentAlignment(back,\n"
"            Alignment.MIDDLE_CENTER);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1728
#, no-c-format
msgid ""
"The main view is shown in <xref linkend=\"figure.advanced.navigator.mainview"
"\"/>. At this point, the URL would be <literal>http://localhost:8080/myapp#!"
"main/reindeer</literal>."
msgstr ""
"主视图的运行结果见 <xref linkend=\"figure.advanced.navigator.mainview\"/>. 图"
"中显示的状态, 对应的 URL 应该是 <literal>http://localhost:8080/myapp#!main/"
"reindeer</literal>."

#. Tag: title
#: chapter-advanced.xml:1735
#, no-c-format
msgid "Navigator Main View"
msgstr "导航器的主视图"

#. Tag: title
#: chapter-advanced.xml:1746
#, no-c-format
msgid "Advanced Application Architectures"
msgstr "应用程序高级架构"

#. Tag: para
#: chapter-advanced.xml:1748
#, no-c-format
msgid ""
"In this section, we continue from the basic application architectures "
"described in <xref linkend=\"application.architecture\"/> and discuss some "
"of the more advanced patterns that are often used in Vaadin applications."
msgstr ""
"<xref linkend=\"application.architecture\"/> 介绍过关于应用程序架构的基本信"
"息, 本节中我们详细讨论这个问题. 本节还讨论 Vaadin 应用程序经常使用到的一些更"
"高级的设计模式."

#. Tag: title
#: chapter-advanced.xml:1755
#, no-c-format
msgid "Layered Architectures"
msgstr "分层架构"

#. Tag: para
#: chapter-advanced.xml:1757
#, no-c-format
msgid ""
"Layered architectures, where each layer has a clearly distinct "
"responsibility, are probably the most common architectures. Typically, "
"applications follow at least a three-layer architecture:"
msgstr ""
"分层架构可能是最普遍使用的架构, 它的每一层都负责一个清楚的、独立的职责. 通"
"常, 应用程序至少会遵循三层架构原则:"

#. Tag: listitem
#: chapter-advanced.xml:1764
#, no-c-format
msgid "User interface (or presentation) layer"
msgstr "用户界面层(或者叫表现层)"

#. Tag: listitem
#: chapter-advanced.xml:1765
#, no-c-format
msgid "Domain layer"
msgstr "业务层"

#. Tag: listitem
#: chapter-advanced.xml:1766
#, no-c-format
msgid "Data store layer"
msgstr "数据存储层"

#. Tag: para
#: chapter-advanced.xml:1769
#, no-c-format
msgid ""
"Such an architecture starts from a <emphasis>domain model</emphasis>, which "
"defines the data model and the \"business logic\" of the application, "
"typically as POJOs. A user interface is built on top of the domain model, in "
"our context with the Vaadin Framework. The Vaadin user interface could be "
"bound directly to the data model through the Vaadin Data Model, described in "
"<xref linkend=\"datamodel\"/>. Beneath the domain model lies a data store, "
"such as a relational database. The dependencies between the layers are "
"restricted so that a higher layer may depend on a lower one, but never the "
"other way around."
msgstr ""
"这样的架构首先需要一个 <emphasis>业务模型</emphasis>, 其中定义应用程序的数据"
"模型及 \"业务逻辑\", 通常使用 POJO 来实现. 用户界面构建在业务模型之上, 针对我"
"们情况, 用户界面使用 Vaadin Framework 来构建. Vaadin UI 可以通过 Vaadin Data "
"Model 直接绑定到数据模型, 详情请参见 <xref linkend=\"datamodel\"/>. 在业务模"
"型之下存在的是数据存储层, 比如关系型数据库. 各层之间的依赖关系受到严格限制, "
"因此高层可以依赖低层, 但不会出现反方向的依赖."

#. Tag: title
#: chapter-advanced.xml:1782
#, no-c-format
msgid "Three-Layer Architecture"
msgstr "三层架构"

#. Tag: para
#: chapter-advanced.xml:1793
#, no-c-format
msgid ""
"An <emphasis>application layer</emphasis> (or <emphasis>service layer</"
"emphasis>) is often distinguished from the domain layer, offering the domain "
"logic as a service, which can be used by the user interface layer, as well "
"as for other uses. In Java EE development, Enterprise JavaBeans (EJBs) are "
"typically used for building this layer."
msgstr ""
"<emphasis>应用程序层</emphasis> (或者叫 <emphasis>服务层</emphasis>) 常常会从"
"业务层中分离出来, 以服务的形式实现业务逻辑, 它可以被用户界面层使用, 也可以被"
"其他用户使用. 在 Java EE 环境中, 企业 JavaBean (EJB) 通常用来构建这个层."

#. Tag: para
#: chapter-advanced.xml:1801
#, no-c-format
msgid ""
"An <emphasis>infrastructure layer</emphasis> (or <emphasis>data access "
"layer</emphasis>) is often distinguished from the data store layer, with a "
"purpose to abstract the data store. For example, it could involve a "
"persistence solution such as JPA and an EJB container. This layer becomes "
"relevant with Vaadin when binding Vaadin components to data with the "
"JPAContainer, as described in <xref linkend=\"jpacontainer\"/>."
msgstr ""
"<emphasis>基础层</emphasis> (或者叫 <emphasis>数据访问层</emphasis>) 常常从数"
"据存储层中分离出来, 用来实现对数据存储逻辑的抽象. 比如, 它可能用到数据持久化"
"方案, 比如 JPA 和 EJB 容器. 这一层与 Vaadin 的关系主要是, 通过 JPAContainer "
"实现 Vaadin 组件与数据的绑定, 详情请参见 <xref linkend=\"jpacontainer\"/>."

#. Tag: title
#: chapter-advanced.xml:1812 chapter-advanced.xml:1826
#, no-c-format
msgid "Model-View-Presenter Pattern"
msgstr "模型(Model)-视图(View)-展现者(Presenter) 模式"

#. Tag: para
#: chapter-advanced.xml:1814
#, no-c-format
msgid ""
"The Model-View-Presenter (MVP) pattern is one of the most common patterns in "
"developing large applications with Vaadin. It is similar to the older Model-"
"View-Controller (MVC) pattern, which is not as meaningful in Vaadin "
"development. Instead of an implementation-aware controller, there is an "
"implementation-agnostic presenter that operates the view through an "
"interface. The view does not interact directly with the model. This isolates "
"the view implementation better than in MVC and allows easier unit testing of "
"the presenter and model."
msgstr ""
"在使用 Vaadin 开发大型应用程序时, 模型(Model)-视图(View)-展现者(Presenter) "
"(MVP)模式是最常见的模式之一. 它类似于旧的 模型(Model)-视图(View)-控制器"
"(Controller) (MVC) 模式, MVC 模式在 Vaadin 开发中意义不大. 我们不使用与实现相"
"关的控制器, 而是使用与实现无关的展现者, 它负责通过接口来操纵视图. 视图不直接"
"与模型发生交互. 这种设计比 MVC 模式更好地隔离了视图的实现, 而且可以更简单地实"
"现对展现者和模型的单元测试."

#. Tag: para
#: chapter-advanced.xml:1837
#, no-c-format
msgid ""
"illustrates the MVP pattern with a simple calculator. The domain model is "
"realized in the <classname>Calculator</classname> class, which includes a "
"data model and some model logic operations. The "
"<classname>CalculatorViewImpl</classname> is a Vaadin implementation of the "
"view, defined in the <interfacename>CalculatorView</interfacename> "
"interface. The <classname>CalculatorPresenter</classname> handles the user "
"interface logic. User interaction events received in the view are translated "
"into implementation-independent events for the presenter to handle (the view "
"implementation could also just call the presenter)."
msgstr ""
"使用一个简单的计算器展示了 MVP 模式. 业务模型由 <classname>Calculator</"
"classname> 类实现, 其中包含数据模型和一些业务逻辑. "
"<classname>CalculatorViewImpl</classname> 是使用 Vaadin 实现的视图, 视图由 "
"<interfacename>CalculatorView</interfacename> 接口定义. "
"<classname>CalculatorPresenter</classname> 类负责处理 UI 逻辑. 视图中接受到"
"的 UI 事件被翻译为与实现无关的事件, 并交给展现者去处理(视图的实现类可以简单地"
"调用展现者)."

#. Tag: para
#: chapter-advanced.xml:1850
#, no-c-format
msgid ""
"Let us first look how the model and view are bound together by the presenter "
"in the following example:"
msgstr "我们首先来看看下例, 其中模型和视图通过展现者绑定在一起:"

#. Tag: programlisting
#: chapter-advanced.xml:1855
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[\n"
"// Create the model and the Vaadin view implementation\n"
"CalculatorModel    model = new CalculatorModel();\n"
"CalculatorViewImpl view  = new CalculatorViewImpl();\n"
"    \n"
"// The presenter binds the model and view together\n"
"new CalculatorPresenter(model, view);\n"
"    \n"
"// The view implementation is a Vaadin component\n"
"layout.addComponent(view);]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1857
#, no-c-format
msgid ""
"You could add the view anywhere in a Vaadin application, as it is a "
"composite component."
msgstr ""
"你可以将这个视图添加到 Vaadin 应用程序中的任何位置, 因为它是一个复合组件."

#. Tag: title
#: chapter-advanced.xml:1863
#, no-c-format
msgid "The Model"
msgstr "模型"

#. Tag: para
#: chapter-advanced.xml:1865
#, no-c-format
msgid ""
"Our business model is quite simple, with one value and a number of "
"operations for manipulating it."
msgstr "我们的业务模型非常简单, 其中只有一个值, 和对这个值的一系列操作."

#. Tag: programlisting
#: chapter-advanced.xml:1870
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/** The model **/\n"
"class CalculatorModel {\n"
"    private double value = 0.0;\n"
"    \n"
"    public void clear() {\n"
"        value = 0.0;\n"
"    }\n"
"\n"
"    public void add(double arg) {\n"
"        value += arg;\n"
"    }\n"
"\n"
"    public void multiply(double arg) {\n"
"        value *= arg;\n"
"    }\n"
"\n"
"    public void divide(double arg) {\n"
"        if (arg != 0.0)\n"
"            value /= arg;\n"
"    }\n"
"    \n"
"    public double getValue() {\n"
"        return value;\n"
"    }\n"
"    \n"
"    public void setValue(double value) {\n"
"        this.value = value;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:1874
#, no-c-format
msgid "The View"
msgstr "视图"

#. Tag: para
#: chapter-advanced.xml:1876
#, no-c-format
msgid ""
"The purpose of the view in MVP is to display data and receive user "
"interaction. It relays the user interaction to the presenter in an fashion "
"that is independent of the view implementation, that is, no Vaadin events. "
"It is defined as a UI framework interface that can have multiple "
"implementations."
msgstr ""
"MVP 模式中视图的目的是用来显示数据, 并接受用户的操作. 它依赖于用户对展现者的"
"操作, 这种操作与具体的视图实现无关, 也就是说, 展现者中不使用 Vaadin 事件. 这"
"样设计的目的是允许 UI 接口可以有多种不同的实现."

#. Tag: programlisting
#: chapter-advanced.xml:1884
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[interface CalculatorView {\n"
"    public void setDisplay(double value);\n"
"\n"
"    interface CalculatorViewListener {\n"
"        void buttonClick(char operation);\n"
"    }\n"
"    public void addListener(CalculatorViewListener listener);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1886
#, no-c-format
msgid ""
"The are design alternatives for the view. It could receive the listener in "
"its constructor, or it could just know the presenter. Here, we forward "
"button clicks as an implementation-independent event."
msgstr ""
"对于视图的设计可以有几种选择. 它可以在构造函数中接受监听器, 或者它可以直接知"
"道展现者. 这里, 我们将按钮的点击作为一个与实现无关的事件转发出去."

#. Tag: para
#: chapter-advanced.xml:1893
#, no-c-format
msgid ""
"As we are using Vaadin, we make a Vaadin implementation of the interface as "
"follows:"
msgstr "由于我们在使用 Vaadin, 我们使用 Vaadin 来实现上面的接口, 如下:"

#. Tag: programlisting
#: chapter-advanced.xml:1898
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class CalculatorViewImpl extends "
"CustomComponent\n"
"        implements CalculatorView, ClickListener {\n"
"    private Label display = new Label(\"0.0\");\n"
"\n"
"    public CalculatorViewImpl() {\n"
"        GridLayout layout  = new GridLayout(4, 5);\n"
"\n"
"        // Create a result label that spans over all\n"
"        // the 4 columns in the first row\n"
"        layout.addComponent(display, 0, 0, 3, 0);\n"
"    \n"
"        // The operations for the calculator in the order\n"
"        // they appear on the screen (left to right, top\n"
"        // to bottom)\n"
"        String[] operations = new String[] {\n"
"            \"7\", \"8\", \"9\", \"/\", \"4\", \"5\", \"6\",\n"
"            \"*\", \"1\", \"2\", \"3\", \"-\", \"0\", \"=\", \"C\", \"+"
"\" };\n"
"\n"
"        // Add buttons and have them send click events\n"
"        // to this class\n"
"        for (String caption: operations)\n"
"            layout.addComponent(new Button(caption, this));\n"
"\n"
"        setCompositionRoot(layout);\n"
"    }\n"
"    \n"
"    public void setDisplay(double value) {\n"
"        display.setValue(Double.toString(value));\n"
"    }\n"
"\n"
"    /* Only the presenter registers one listener... */\n"
"    List<CalculatorViewListener> listeners =\n"
"            new ArrayList<CalculatorViewListener>();\n"
"\n"
"    public void addListener(CalculatorViewListener listener) {\n"
"        listeners.add(listener);\n"
"    }\n"
"\n"
"    /** Relay button clicks to the presenter with an\n"
"     *  implementation-independent event */\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        for (CalculatorViewListener listener: listeners)\n"
"            listener.buttonClick(event.getButton()\n"
"                                 .getCaption().charAt(0));\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:1902
#, no-c-format
msgid "The Presenter"
msgstr "展现者"

#. Tag: para
#: chapter-advanced.xml:1904
#, no-c-format
msgid ""
"The presenter in MVP is a middle-man that handles all user interaction "
"logic, but in an implementation-independent way, so that it doesn't actually "
"know anything about Vaadin. It shows data in the view and receives user "
"interaction back from it."
msgstr ""
"MVP 中的展现者是一个中间人, 它负责所有的用户交互逻辑, 但使用一种与实现无关的"
"方式, 因此它实际上并不意识到 Vaadin 的存在. 它负责在视图中显示数据, 并负责从"
"视图中接受用户的交互."

#. Tag: programlisting
#: chapter-advanced.xml:1911
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class CalculatorPresenter\n"
"        implements CalculatorView.CalculatorViewListener {\n"
"    CalculatorModel model;\n"
"    CalculatorView  view;\n"
"\n"
"    private double current = 0.0;\n"
"    private char   lastOperationRequested = 'C';\n"
"    \n"
"    public CalculatorPresenter(CalculatorModel model,\n"
"                               CalculatorView  view) {\n"
"        this.model = model;\n"
"        this.view  = view;\n"
"        \n"
"        view.setDisplay(current);            \n"
"        view.addListener(this);\n"
"    }\n"
"\n"
"    @Override\n"
"    public void buttonClick(char operation) {\n"
"        // Handle digit input\n"
"        if ('0' <= operation && operation <= '9') {\n"
"            current = current * 10\n"
"                    + Double.parseDouble(\"\" + operation);\n"
"            view.setDisplay(current);\n"
"            return;\n"
"        }\n"
"\n"
"        // Execute the previously input operation\n"
"        switch (lastOperationRequested) {\n"
"        case '+':\n"
"            model.add(current);\n"
"            break;\n"
"        case '-':\n"
"            model.add(-current);\n"
"            break;\n"
"        case '/':\n"
"            model.divide(current);\n"
"            break;\n"
"        case '*':\n"
"            model.multiply(current);\n"
"            break;\n"
"        case 'C':\n"
"            model.setValue(current);\n"
"            break;\n"
"        } // '=' is implicit\n"
"\n"
"        lastOperationRequested = operation;\n"
"\n"
"        current = 0.0;\n"
"        if (operation == 'C')\n"
"            model.clear();\n"
"        view.setDisplay(model.getValue());\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1913
#, no-c-format
msgid ""
"In the above example, we held some state information in the presenter. "
"Alternatively, we could have had an intermediate controller between the "
"presenter and the model to handle the low-level button logic."
msgstr ""
"上例中, 我们在展现者中保持了一些状态信息. 如果不使用这种方式的话, 我们也可以"
"在展现者与模型之间使用一个控制器来处理这些底层的按钮逻辑."

#. Tag: title
#: chapter-advanced.xml:1924
#, no-c-format
msgid "Managing URI Fragments"
msgstr "管理 URI 片段"

#. Tag: para
#: chapter-advanced.xml:1926
#, no-c-format
msgid ""
"A major issue in AJAX applications is that as they run in a single web page, "
"bookmarking the application URL (or more generally the <emphasis>URI</"
"emphasis>) can only bookmark the application, not an application state. This "
"is a problem for many applications, such as product catalogs and discussion "
"forums, in which it would be good to provide links to specific products or "
"messages. Consequently, as browsers remember the browsing history by URI, "
"the history and the <guibutton>Back</guibutton> button do not normally work. "
"The solution is to use the <emphasis>fragment identifier</emphasis> part of "
"the URI, which is separated from the primary part (address + path + optional "
"query parameters) of the URI with the hash (#) character. For example:"
msgstr ""
"AJAX 应用程序中的一个主要问题就是它们运行在单一的 Web 页面中, 使用书签记录应"
"用程序 URL (或者更一般地说 <emphasis>URI</emphasis>) 只能记录下应用程序地址, "
"而不是应用程序中的某一个状态. 对很多应用程序来说这是一个问题, 比如对于产品目"
"录和论坛程序, 如果能为某个特定的产品或某个特定的讨论信息记录下独立的地址将会"
"更好一些. 而且, 由于浏览器使用 URI 来记录浏览履历, 浏览履历和 <guibutton>回退"
"</guibutton> 按钮都将无法正常工作. 对这类问题的解决方法是使用 URI 中的 "
"<emphasis>片段标识符</emphasis> 部分, 这个部分与 URI 的主部分(地址 + 路径 + "
"可选的查询参数) 之间通过 # 号分隔开. 比如:"

#. Tag: programlisting
#: chapter-advanced.xml:1940
#, no-c-format
msgid "<?pocket-size 75% ?><![CDATA[http://example.com/path#myfragment]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1942
#, no-c-format
msgid ""
"The exact syntax of the fragment identifier part is defined in RFC 3986 "
"(Internet standard STD 66) that defines the URI syntax. A fragment may only "
"contain the regular URI <emphasis>path characters</emphasis> (see the "
"standard) and additionally the slash and the question mark."
msgstr ""
"片段标识符部分的语法由 RFC 3986 标准定义(Internet 标准 STD 66) , 这个标准定义"
"了整个  URI 的语法. 片段可以只包含通常的 URI <emphasis>路径字符</emphasis> "
"(具体请参见上述标准), 以及斜线和问号."

#. Tag: para
#: chapter-advanced.xml:1949
#, no-c-format
msgid ""
"Vaadin offers two ways to enable the use of URI fragments: the high-level "
"<classname>Navigator</classname> utility described in <xref linkend="
"\"advanced.navigator\"/> and the low-level API described here."
msgstr ""
"Vaadin 提供了两种方式来使用 URI 片段: 一种是高阶的 <classname>Navigator</"
"classname> 类, 详情请参见 <xref linkend=\"advanced.navigator\"/> , 另一种是低"
"阶 API, 本节讨论这种低阶 API."

#. Tag: title
#: chapter-advanced.xml:1956
#, no-c-format
msgid "Setting the URI Fragment"
msgstr "设置 URI 片段"

#. Tag: para
#: chapter-advanced.xml:1958
#, no-c-format
msgid ""
"You can set the current fragment identifier with the "
"<methodname>setUriFragment()</methodname> method in the <classname>Page</"
"classname> object."
msgstr ""
"你可以在 <classname>Page</classname>对象中使用 <methodname>setUriFragment()</"
"methodname> 方法, 设置当前片段标识符."

#. Tag: programlisting
#: chapter-advanced.xml:1964
#, no-c-format
msgid "<![CDATA[Page.getCurrent().setUriFragment(\"mars\");]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1966
#, no-c-format
msgid ""
"Setting the URI fragment causes an <interfacename>UriFragmentChangeEvent</"
"interfacename>, which is processed in the same server request. As with UI "
"rendering, the URI fragment is changed in the browser after the currently "
"processed server request returns the response."
msgstr ""
"设置 URI 片段会导致一个 <interfacename>UriFragmentChangeEvent</"
"interfacename> 事件, 这个事件会在当前的服务器请求中处理.  当前处理中的服务请"
"求返回应答之后, 通过 UI 的描绘处理,  URI 片段会反映到浏览器中."

#. Tag: para
#: chapter-advanced.xml:1974
#, no-c-format
msgid ""
"Prefixing the fragment identifier with an exclamation mark enables the web "
"crawler support described in <xref linkend=\"advanced.urifu.crawling\"/>."
msgstr ""
"在片段标识符之前使用感叹号前缀, 可以允许 Web 爬虫抓取, 详情请参见 <xref "
"linkend=\"advanced.urifu.crawling\"/>."

#. Tag: title
#: chapter-advanced.xml:1981
#, no-c-format
msgid "Reading the URI Fragment"
msgstr "读取 URI 片段"

#. Tag: para
#: chapter-advanced.xml:1983
#, no-c-format
msgid ""
"The current URI fragment can be acquired with the "
"<methodname>getUriFragment()</methodname> method from the current "
"<classname>Page</classname> object. The fragment is known when the "
"<methodname>init()</methodname> method of the UI is called."
msgstr ""
"当前 URI 片段可以使用当前 <classname>Page</classname>对象的 "
"<methodname>getUriFragment()</methodname> 方法取得. 当 UI 的 "
"<methodname>init()</methodname> 方法被调用时, 片段信息就是可知的了."

#. Tag: programlisting
#: chapter-advanced.xml:1991
#, no-c-format
msgid ""
"<![CDATA[// Read initial URI fragment to create UI content\n"
"String fragment = getPage().getUriFragment();\n"
"enter(fragment);]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:1993
#, no-c-format
msgid ""
"To enable reusing the same code when the URI fragment is changed, as "
"described next, it is usually best to build the relevant part of the UI in a "
"separate method. In the above example, we called an <methodname>enter()</"
"methodname> method, in a way that is similar to handling view changes with "
"<classname>Navigator</classname>."
msgstr ""
"为了在 URI 片段变更时重用代码, 详情见下文, 通常最好的办法是在一个独立的方法中"
"构建 UI 中的相关部分. 上面的例子中, 我们调用了 <methodname>enter()</"
"methodname> 方法, 这种方式类似于使用 <classname>Navigator</classname> 来处理"
"视图变更时的做法."

#. Tag: title
#: chapter-advanced.xml:2003
#, no-c-format
msgid "Listening for URI Fragment Changes"
msgstr "监听 URI 片段的变更"

#. Tag: para
#: chapter-advanced.xml:2005
#, no-c-format
msgid ""
"After the UI has been initialized, changes in the URI fragment can be "
"handled with a <interfacename>UriFragmentChangeListener</interfacename>. The "
"listeners are called when the URI fragment changes, but not when the UI is "
"initialized, where the current fragment is available from the page object as "
"described earlier."
msgstr ""
"UI 初始化完成后, URI 片段的变化可以使用 "
"<interfacename>UriFragmentChangeListener</interfacename> 来处理. 这个监听器会"
"在 URI 片段发生变化时被调用, 但在 UI 初始化时不会. 如前文所述, UI 初始化时是"
"可以通过 page 对象得到当前 URI 片段的."

#. Tag: para
#: chapter-advanced.xml:2013
#, no-c-format
msgid ""
"For example, we could define the listener as follows in the "
"<methodname>init()</methodname> method of a UI class:"
msgstr ""
"比如, 我们可以在 UI 类的 <methodname>init()</methodname> 方法中定义一个监听"
"器, 如下:"

#. Tag: programlisting
#: chapter-advanced.xml:2019
#, no-c-format
msgid ""
"<![CDATA[public class MyUI extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        getPage().addUriFragmentChangedListener(\n"
"               new UriFragmentChangedListener() {\n"
"           public void uriFragmentChanged(\n"
"                   UriFragmentChangedEvent source) {\n"
"               enter(source.getUriFragment());\n"
"            }\n"
"        });\n"
"\n"
"        // Read the initial URI fragment\n"
"        enter(getPage().getUriFragment());\n"
"    }\n"
"\n"
"    void enter(String fragment) {\n"
"        ... initialize the UI ...\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2021
#, no-c-format
msgid ""
"shows an application that allows specifying the menu selection with a URI "
"fragment and correspondingly sets the fragment when the user selects a menu "
"item."
msgstr ""
"展示了一个应用程序, 它可以使用 URI 片段来指定菜单的选中项, 也可以在用户选择一"
"个菜单项时设置对应的 URI 片段."

#. Tag: title
#: chapter-advanced.xml:2028
#, no-c-format
msgid "Application State Management with URI Fragment Utility"
msgstr "使用 URI 片段来管理应用程序状态"

#. Tag: title
#: chapter-advanced.xml:2041
#, no-c-format
msgid "Supporting Web Crawling"
msgstr "支持 Web 爬虫"

#. Tag: para
#: chapter-advanced.xml:2043
#, no-c-format
msgid ""
"Stateful AJAX applications can not normally be crawled by a search engine, "
"as they run in a single page and a crawler can not navigate the states even "
"if URI fragments are enabled. The Google search engine and crawler <link "
"xlink:href=\"http://googlewebmastercentral.blogspot.fi/2009/10/proposal-for-"
"making-ajax-crawlable.html\">support a convention</link> where the fragment "
"identifiers are prefixed with exclamation mark, such as <literal>#!"
"myfragment</literal>. The servlet needs to have a separate searchable "
"content page accessible with the same URL, but with a "
"<literal>_escaped_fragment_</literal> parameter. For example, for <literal>/"
"myapp/myui#!myfragment</literal> it would be <literal>/myapp/myui?"
"_escaped_fragment_=myfragment</literal>."
msgstr ""
"有状态的 AJAX 应用程序通常不能被搜索引擎抓取, 因为它们运行在单一页面中, 而即"
"使使用了 URI 片段, Web 爬虫也不能在应用程序的各个状态之间跳转 . Google 搜索引"
"擎和爬虫 <link xlink:href=\"http://googlewebmastercentral.blogspot."
"fi/2009/10/proposal-for-making-ajax-crawlable.html\">支持一种规约</link>, 其"
"中的片段标识符以感叹号为前缀, 比如 <literal>#!myfragment</literal>. Servlet "
"需要有一个单独的可搜索的内容页面, 这个页面使用相同的 URL 来访问, 但带一个 "
"<literal>_escaped_fragment_</literal> 参数. 比如, 对于 <literal>/myapp/myui#!"
"myfragment</literal>, 可搜索页面的 URL 应该是 <literal>/myapp/myui?"
"_escaped_fragment_=myfragment</literal>."

#. Tag: para
#: chapter-advanced.xml:2057
#, no-c-format
msgid ""
"You can provide the crawl content by overriding the <methodname>service()</"
"methodname> method in a custom servlet class. For regular requests, you "
"should call the super implementation in the <classname>VaadinServlet</"
"classname> class."
msgstr ""
"你可以使用自定义的 Servlet 类, 覆盖 <methodname>service()</methodname> 方法来"
"提供可搜索的页面内容. 对于通常的请求, 你应该调用基类 "
"<classname>VaadinServlet</classname> 的实现."

#. Tag: programlisting
#: chapter-advanced.xml:2065
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyCustomServlet extends "
"VaadinServlet\n"
"    @Override\n"
"    protected void service(HttpServletRequest request,\n"
"                           HttpServletResponse response)\n"
"            throws ServletException, IOException {\n"
"        String fragment = request\n"
"            .getParameter(\"_escaped_fragment_\");\n"
"        if (fragment != null) {\n"
"            response.setContentType(\"text/html\");\n"
"            Writer writer = response.getWriter();\n"
"            writer.append(\"<html><body>\"+\n"
"                \"<p>Here is some crawlable \"+\n"
"                \"content about \" + fragment + \"</p>\");\n"
"            \n"
"            // A list of all crawlable pages\n"
"            String items[] = {\"mercury\", \"venus\",\n"
"                              \"earth\", \"mars\"};\n"
"            writer.append(\"<p>Index of all content:</p><ul>\");\n"
"            for (String item: items) {\n"
"                String url = request.getContextPath() +\n"
"                    request.getServletPath() +\n"
"                    request.getPathInfo() + \"#!\" + item;\n"
"                writer.append(\"<li><a href='\" + url + \"'>\" +\n"
"                              item + \"</a></li>\");\n"
"            }\n"
"            writer.append(\"</ul></body>\");\n"
"        } else\n"
"            super.service(request, response);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2067
#, no-c-format
msgid ""
"The crawlable content does not need to be human readable. It can provide an "
"index of links to other application states, as we did in the example above. "
"The links should use the \"<literal>#!</literal>\" notation, but can not be "
"relative to avoid having the <literal>_escaped_fragment_</literal> parameter."
msgstr ""
"可被搜索引擎抓取的内容不需要是可供人类阅读的. 它可以包含一些索引链接, 指向应"
"用程序的其他各种状态, 如我们在上例中所作的那样. 这些链接应该使用 "
"\"<literal>#!</literal>\" 标注, 但不应该是相对路径, 这样才能避免在链接中出现 "
"<literal>_escaped_fragment_</literal> 参数."

#. Tag: para
#: chapter-advanced.xml:2075
#, no-c-format
msgid ""
"You need to use the custom servlet class in the <filename>web.xml</filename> "
"deployment descriptor instead of the normal <classname>VaadinServlet</"
"classname> class, as described in <xref linkend=\"application.environment."
"web-xml\"/>."
msgstr ""
"你应该在部署描述文件 <filename>web.xml</filename> 中使用这个自定义的 "
"Servlet, 而不是通常的 <classname>VaadinServlet</classname> 类, 详情请参见 "
"<xref linkend=\"application.environment.web-xml\"/>."

#. Tag: title
#: chapter-advanced.xml:2248
#, no-c-format
msgid "<title>Drag and Drop</title>"
msgstr "<title>拖放</title>"

#. Tag: primary
#: chapter-advanced.xml:2251 chapter-advanced.xml:2516
#, no-c-format
msgid "<primary>Drag and Drop</primary>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2254
#, no-c-format
msgid ""
"Dragging an object from one location to another by grabbing it with mouse, "
"holding the mouse button pressed, and then releasing the button to \"drop\" "
"it to the other location is a common way to move, copy, or associate "
"objects. For example, most operating systems allow dragging and dropping "
"files between folders or dragging a document on a program to open it. In "
"Vaadin, it is possible to drag and drop components and parts of certain "
"components."
msgstr ""
"在一个对象上按下鼠标, 并保持鼠标键按住不放, 可以将这个对象从一个位置拖动到另"
"一个位置, 然后在目标位置上放开鼠标按钮, 可以将这个对象 \"放\" 到另一个位置"
"上. 这种拖放操作是一种常用的方式, 可用来移动, 复制, 或关联对象. 比如, 大多数"
"操作系统允许在文件夹之间拖放文件, 也支持拖动一个文档到程序上来打开这个文档. "
"在 Vaadin 中支持组件的拖放, 对于某些组件还可以拖放其中的一部分."

#. Tag: para
#: chapter-advanced.xml:2263
#, no-c-format
msgid ""
"Dragged objects, or <emphasis>transferables</emphasis>, are essentially data "
"objects. You can drag and drop rows in <classname>Table</classname> and "
"nodes in <classname>Tree</classname> components, either within or between "
"the components. You can also drag entire components by wrapping them inside "
"<classname>DragAndDropWrapper</classname>."
msgstr ""
"被拖动的对象, 或者叫 <emphasis>可传送对象</emphasis>, 本质上是数据对象. 你可"
"以在 <classname>Table</classname> 组件内拖放行, 可以在 <classname>Tree</"
"classname> 组件中拖放节点, 这两种拖动都可以发生在组件之内, 也可以在组件之间. "
"你也可以将整个组件包在 <classname>DragAndDropWrapper</classname> 之内, 然后就"
"可以拖动这个组件."

#. Tag: para
#: chapter-advanced.xml:2271
#, no-c-format
msgid ""
"Dragging starts from a <emphasis>drag source</emphasis>, which defines the "
"transferable. Transferables implement the <classname>Transferable</"
"classname> interfaces. For trees and tables, which are bound to "
"<classname>Container</classname> data sources, a node or row transferable is "
"a reference to an <classname>Item</classname> in the Vaadin Data Model. "
"Dragged components are referenced with a <classname>WrapperTransferable</"
"classname>. Starting dragging does not require any client-server "
"communication, you only need to enable dragging. All drag and drop logic "
"occurs in two operations: determining (<emphasis>accepting</emphasis>) where "
"dropping is allowed and actually dropping. Drops can be done on a "
"<emphasis>drop target</emphasis>, which implements the "
"<classname>DropTarget</classname> interface. Three components implement the "
"interface: <classname>Tree</classname>, <classname>Table</classname>, and "
"<classname>DragAndDropWrapper</classname>. These accept and drop operations "
"need to be provided in a <emphasis>drop handler</emphasis>. Essentially all "
"you need to do to enable drag and drop is to enable dragging in the drag "
"source and implement the <methodname>getAcceptCriterion()</methodname> and "
"<methodname>drop()</methodname> methods in the <classname>DropHandler</"
"classname> interface."
msgstr ""
"拖动操作从 <emphasis>拖放源</emphasis> 开始, 拖放源定义了可传送数据. 可传送数"
"据需要实现 <classname>Transferable</classname> 接口. 对于绑定到 "
"<classname>Container</classname> 数据源的 Tree 和 Table, 对应于节点或者行的可"
"传送数据, 就是Vaadin Data Model 中的一个 <classname>Item</classname>. 被拖放"
"的组件对应于一个 <classname>WrapperTransferable</classname> 对象. 拖动开始操"
"作不需要客户端到服务器的任何通信, 你只需要允许拖动就可以了. 拖和放的全部逻辑"
"包括两个步骤: 判定哪些位置可以允许放下拖动中的对象(属于称为 <emphasis>接受"
"(accepting)</emphasis>), 以及实际的放下动作. 放的动作可以放声在 <emphasis>拖"
"放目标</emphasis> 中, 拖放目标需要实现 <classname>DropTarget</classname> 接"
"口. 有三个组件实现了这个接口: <classname>Tree</classname>, <classname>Table</"
"classname>, 以及 <classname>DragAndDropWrapper</classname>. 接受动作"
"(accepting)和放下动作(drop)需要通过 <emphasis>drop 处理器</emphasis> 来实现. "
"本质上来说, 对于拖放动作你所需要做的就是: 在拖放源中允许拖动, 并实现 "
"<classname>DropHandler</classname> 接口中的 "
"<methodname>getAcceptCriterion()</methodname> 和 <methodname>drop()</"
"methodname> 方法."

#. Tag: para
#: chapter-advanced.xml:2294
#, no-c-format
msgid ""
"The client-server architecture of Vaadin causes special requirements for the "
"drag and drop functionality. The logic for determining where a dragged "
"object can be dropped, that is, <emphasis>accepting</emphasis> a drop, "
"should normally be done on the client-side, in the browser. Server "
"communications are too slow to have much of such logic on the server-side. "
"The drag and drop feature therefore offers a number of ways to avoid the "
"server communications to ensure a good user experience."
msgstr ""
"Vaadin 的客户端/服务器端架构导致了拖放功能的一个问题. 对一个拖动中的对象, 它"
"可以在哪些区域放下的判定处理, 也就是, <emphasis>接受(accepting)</emphasis> 一"
"个放下动作, 一般应该在客户端(也就是在浏览器内)完成. 与服务器的通信太慢, 因此"
"这类判定无法在服务器端完成. 因此, 拖放功能提供了很多手段来避免发生服务器通"
"信, 以便提供更流畅的用户体验."

#. Tag: title
#: chapter-advanced.xml:2305
#, no-c-format
msgid "Handling Drops"
msgstr "处理拖放"

#. Tag: para
#: chapter-advanced.xml:2307
#, no-c-format
msgid ""
"Most of the user-defined drag and drop logic occurs in a <emphasis>drop "
"handler</emphasis>, which is provided by implementing the "
"<methodname>drop()</methodname> method in the <classname>DropHandler</"
"classname> interface. A closely related definition is the drop accept "
"criterion, which is defined in the <methodname>getAcceptCriterion()</"
"methodname> method in the same interface. It is described in <xref linkend="
"\"advanced.dragndrop.acceptcriteria\"/> later."
msgstr ""
"大多数用户定义的拖放逻辑发生在 <emphasis>drop 处理器中</emphasis>, 主要是实"
"现 <classname>DropHandler</classname> 接口的 <methodname>drop()</methodname> "
"方法. 另一个紧密相关的问题是 drop 动作的接受判定, 这个处理定义在同一个接口的 "
"<methodname>getAcceptCriterion()</methodname> 方法中. 这个问题在后面的 <xref "
"linkend=\"advanced.dragndrop.acceptcriteria\"/> 中详细介绍."

#. Tag: para
#: chapter-advanced.xml:2318
#, no-c-format
msgid ""
"The <methodname>drop()</methodname> method gets a "
"<classname>DragAndDropEvent</classname> as its parameters. The event object "
"provides references to two important object: <classname>Transferable</"
"classname> and <classname>TargetDetails</classname>."
msgstr ""
"<methodname>drop()</methodname> 方法收到的参数是 "
"<classname>DragAndDropEvent</classname>. 通过这个事件对象可以得到两个重要的对"
"象: <classname>Transferable</classname> 和 <classname>TargetDetails</"
"classname>."

#. Tag: para
#: chapter-advanced.xml:2326
#, no-c-format
msgid ""
"A <classname>Transferable</classname> contains a reference to the object "
"(component or data item) that is being dragged. A tree or table item is "
"represented as a <classname>TreeTransferable</classname> or "
"<classname>TableTransferable</classname> object, which carries the item "
"identifier of the dragged tree or table item. These special transferables, "
"which are bound to some data in a container, are "
"<classname>DataBoundTransferable</classname>. Dragged components are "
"represented as <classname>WrapperTransferable</classname> objects, as the "
"components are wrapped in a <classname>DragAndDropWrapper</classname>."
msgstr ""
"<classname>Transferable</classname> 中包含正在拖动中的对象(组件或数据项目)信"
"息. Tree 或 Table 中的项目分别表现为 <classname>TreeTransferable</classname> "
"或 <classname>TableTransferable</classname> 对象, 其中包含正在被拖动中的 "
"Tree 或 Table 项目的 ID. 这些特定的可传送对象是 "
"<classname>DataBoundTransferable</classname> 类, 它绑定到容器中的某些数据. 被"
"拖动的组件表现为 <classname>WrapperTransferable</classname> 对象, 叫这个名称"
"是因为组件被包装在 <classname>DragAndDropWrapper</classname> 之内."

#. Tag: para
#: chapter-advanced.xml:2338
#, no-c-format
msgid ""
"The <classname>TargetDetails</classname> object provides information about "
"the exact location where the transferable object is being dropped. The exact "
"class of the details object depends on the drop target and you need to cast "
"it to the proper subclass to get more detailed information. If the target is "
"selection component, essentially a tree or a table, the "
"<classname>AbstractSelectTargetDetails</classname> object tells the item on "
"which the drop is being made. For trees, the <classname>TreeTargetDetails</"
"classname> gives some more details. For wrapped components, the information "
"is provided in a <classname>WrapperDropDetails</classname> object. In "
"addition to the target item or component, the details objects provide a "
"<emphasis>drop location</emphasis>. For selection components, the location "
"can be obtained with the <methodname>getDropLocation()</methodname> and for "
"wrapped components with <methodname>verticalDropLocation()</methodname> and "
"<methodname>horizontalDropLocation()</methodname>. The locations are "
"specified as either <classname>VerticalDropLocation</classname> or "
"<classname>HorizontalDropLocation</classname> objects. The drop location "
"objects specify whether the transferable is being dropped above, below, or "
"directly on (at the middle of) a component or item."
msgstr ""
"<classname>TargetDetails</classname> 对象中的信息是可传输对象被放下的确切位"
"置. Detail 对象的具体类型由 drop 目标决定, 你需要将它转换为正确的类型才可以得"
"到更多详细信息. 如果目标是一个选择组件, 也就是 Tree 或 Table, "
"<classname>AbstractSelectTargetDetails</classname> 对象可以告诉我们推动对象被"
"放在哪个数据项目之上. 对于 Tree, <classname>TreeTargetDetails</classname> 还"
"给出了更多的信息. 对于被封装的组件, 这些信息由 "
"<classname>WrapperDropDetails</classname> 对象给出. 除拖放的目标项目或目标组"
"件外, Detail 对象还提供 <emphasis>drop 位置</emphasis> 信息. 对于选择组件, 位"
"置可以通过 <methodname>getDropLocation()</methodname> 方法得到, 对于封装的组"
"件, 可以通过 <methodname>verticalDropLocation()</methodname> 和 "
"<methodname>horizontalDropLocation()</methodname> 方法得到. 位置信息表现为 "
"<classname>VerticalDropLocation</classname> 或 "
"<classname>HorizontalDropLocation</classname> 对象. drop 位置对象还指明可传输"
"对象被放在组件或数据项目的上方, 下方, 还是正好在其内部."

#. Tag: para
#: chapter-advanced.xml:2360
#, no-c-format
msgid ""
"Dropping on a <classname>Tree</classname>, <classname>Table</classname>, and "
"a wrapped component is explained further in the following sections."
msgstr ""
"关于将对象拖放到 <classname>Tree</classname>, <classname>Table</classname>, "
"和封装组件之上的问题, 将在后面的小节中讨论."

#. Tag: title
#: chapter-advanced.xml:2367
#, no-c-format
msgid "Dropping Items On a <classname>Tree</classname>"
msgstr "拖放项目到 <classname>Tree</classname> 上"

#. Tag: para
#: chapter-advanced.xml:2369
#, no-c-format
msgid ""
"You can drag items from, to, or within a <classname>Tree</classname>. Making "
"tree a drag source requires simply setting the drag mode with "
"<methodname>setDragMode()</methodname>. <classname>Tree</classname> "
"currently supports only one drag mode, <literal>TreeDragMode.NODE</literal>, "
"which allows dragging single tree nodes. While dragging, the dragged node is "
"referenced with a <classname>TreeTransferable</classname> object, which is a "
"<classname>DataBoundTransferable</classname>. The tree node is identified by "
"the item ID of the container item."
msgstr ""
"你可以从 <classname>Tree</classname> 中拖动数据项目, 也可以拖动到 "
"<classname>Tree</classname> 上, 也可以在 <classname>Tree</classname> 内部拖"
"动. 将 Tree 设置为拖动源只需要简单的使用 <methodname>setDragMode()</"
"methodname> 方法设置拖动模式即可. <classname>Tree</classname> 目前只支持一种"
"拖动模式, <literal>TreeDragMode.NODE</literal>, 这种模式允许拖动单个的节点. "
"拖动时, 被拖动的节点表现为 <classname>TreeTransferable</classname> 对象, 这个"
"类是 <classname>DataBoundTransferable</classname> 的子类. Tree 的节点通过容器"
"中数据项目的 ID 来标识."

#. Tag: para
#: chapter-advanced.xml:2382
#, no-c-format
msgid ""
"When a transferable is dropped on a tree, the drop location is stored in a "
"<classname>TreeTargetDetails</classname> object, which identifies the target "
"location by item ID of the tree node on which the drop is made. You can get "
"the item ID with <methodname>getItemIdOver()</methodname> method in "
"<classname>AbstractSelectTargetDetails</classname>, which the "
"<classname>TreeTargetDetails</classname> inherits. A drop can occur directly "
"on or above or below a node; the exact location is a "
"<classname>VerticalDropLocation</classname>, which you can get with the "
"<methodname>getDropLocation()</methodname> method."
msgstr ""
"当可传送对象拖放到 Tree 上时, drop 位置保存在 <classname>TreeTargetDetails</"
"classname> 对象内, 这个对象标识了 drop 动作发生位置的节点所对应的数据项目 "
"ID. 你可以使用 <classname>AbstractSelectTargetDetails</classname> 类的 "
"<methodname>getItemIdOver()</methodname> 方法得到项目 ID, "
"<classname>TreeTargetDetails</classname> 继承自这个类. drop 动作可以发生在节"
"点上, 也可以在它的上方或下方; 确切的位置信息是一个 "
"<classname>VerticalDropLocation</classname> 对象, 你可以通过 "
"<methodname>getDropLocation()</methodname> 方法得到这个对象."

#. Tag: para
#: chapter-advanced.xml:2394
#, no-c-format
msgid ""
"In the example below, we have a <classname>Tree</classname> and we allow "
"reordering the tree items by drag and drop."
msgstr ""
"下面的例子中, 我们有一个 <classname>Tree</classname> 组件, 我们允许用户通过拖"
"放操作来重新排列其中节点的顺序."

#. Tag: programlisting
#: chapter-advanced.xml:2399
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[final Tree tree = new Tree(\"Inventory\");\n"
"tree.setContainerDataSource(TreeExample.createTreeContent());\n"
"layout.addComponent(tree);\n"
"        \n"
"// Expand all items\n"
"for (Iterator<?> it = tree.rootItemIds().iterator(); it.hasNext();)\n"
"    tree.expandItemsRecursively(it.next());\n"
"        \n"
"// Set the tree in drag source mode\n"
"tree.setDragMode(TreeDragMode.NODE);\n"
"        \n"
"// Allow the tree to receive drag drops and handle them\n"
"tree.setDropHandler(new DropHandler() {\n"
"    public AcceptCriterion getAcceptCriterion() {\n"
"        return AcceptAll.get();\n"
"    }\n"
"\n"
"    public void drop(DragAndDropEvent event) {\n"
"        // Wrapper for the object that is dragged\n"
"        Transferable t = event.getTransferable();\n"
"        \n"
"        // Make sure the drag source is the same tree\n"
"        if (t.getSourceComponent() != tree)\n"
"            return;\n"
"        \n"
"        TreeTargetDetails target = (TreeTargetDetails)\n"
"            event.getTargetDetails();\n"
"\n"
"        // Get ids of the dragged item and the target item\n"
"        Object sourceItemId = t.getData(\"itemId\");\n"
"        Object targetItemId = target.getItemIdOver();\n"
"\n"
"        // On which side of the target the item was dropped \n"
"        VerticalDropLocation location = target.getDropLocation();\n"
"        \n"
"        HierarchicalContainer container = (HierarchicalContainer)\n"
"        tree.getContainerDataSource();\n"
"\n"
"        // Drop right on an item -> make it a child\n"
"        if (location == VerticalDropLocation.MIDDLE)\n"
"            tree.setParent(sourceItemId, targetItemId);\n"
"\n"
"        // Drop at the top of a subtree -> make it previous\n"
"        else if (location == VerticalDropLocation.TOP) {\n"
"            Object parentId = container.getParent(targetItemId);\n"
"            container.setParent(sourceItemId, parentId);\n"
"            container.moveAfterSibling(sourceItemId, targetItemId);\n"
"            container.moveAfterSibling(targetItemId, sourceItemId);\n"
"        }\n"
"        \n"
"        // Drop below another item -> make it next \n"
"        else if (location == VerticalDropLocation.BOTTOM) {\n"
"            Object parentId = container.getParent(targetItemId);\n"
"            container.setParent(sourceItemId, parentId);\n"
"            container.moveAfterSibling(sourceItemId, targetItemId);\n"
"        }\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:2402
#, no-c-format
msgid "Accept Criteria for Trees"
msgstr "对 Tree 进行拖放操作的接受判定"

#. Tag: para
#: chapter-advanced.xml:2404
#, no-c-format
msgid ""
"<classname>Tree</classname> defines some specialized accept criteria for "
"trees."
msgstr "<classname>Tree</classname> 定义了一些特殊的接受判定结果."

#. Tag: term
#: chapter-advanced.xml:2411
#, no-c-format
msgid "<classname>TargetInSubtree</classname> (client-side)"
msgstr "<classname>TargetInSubtree</classname> (客户端)"

#. Tag: listitem
#: chapter-advanced.xml:2412
#, no-c-format
msgid ""
"Accepts if the target item is in the specified sub-tree. The sub-tree is "
"specified by the item ID of the root of the sub-tree in the constructor. The "
"second constructor includes a depth parameter, which specifies how deep from "
"the given root node are drops accepted. Value <literal>-1</literal> means "
"infinite, that is, the entire sub-tree, and is therefore the same as the "
"simpler constructor."
msgstr ""
"如果目标项目是某个特定的子树下的一个节点, 接受拖放. 子树通过它的根节点对应的"
"项目 ID 来指定, 这个项目 ID 在构造函数中指定. 构造函数的另一个版本还包括一个"
"深度参数, 从根节点向下固定深度之内的节点接受拖放. <literal>-1</literal> 代表"
"无限深度, 也就是整个子树都可以接受拖放, 因此效果与第一个构造函数一样."

#. Tag: term
#: chapter-advanced.xml:2423
#, no-c-format
msgid "<classname>TargetItemAllowsChildren</classname> (client-side)"
msgstr "<classname>TargetItemAllowsChildren</classname> (客户端)"

#. Tag: listitem
#: chapter-advanced.xml:2424
#, no-c-format
msgid ""
"Accepts a drop if the tree has <methodname>setChildrenAllowed()</methodname> "
"enabled for the target item. The criterion does not require parameters, so "
"the class is a singleton and can be acquired with <methodname>Tree."
"TargetItemAllowsChildren.get()</methodname>. For example, the following "
"composite criterion accepts drops only on nodes that allow children, but "
"between all nodes:"
msgstr ""
"如果 Tree 对目标数据项目设置了 <methodname>setChildrenAllowed()</"
"methodname>, 则接受拖放动作. 这个判定不需要参数, 因此这个类可以是一个单例"
"(singleton), 并且可以通过 <methodname>Tree.TargetItemAllowsChildren.get()</"
"methodname> 方法取得. 比如, 下例中的复合判定, 允许拖动到各节点之前或之后, 对"
"于拖动到节点之下成为子节点的情况, 则要求对象节点必须允许子节点:"

#. Tag: programlisting
#: chapter-advanced.xml:2433
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[return new Or (Tree.TargetItemAllowsChildren."
"get(), new Not(VerticalLocationIs.MIDDLE));]]>"
msgstr ""

#. Tag: term
#: chapter-advanced.xml:2437
#, no-c-format
msgid "<classname>TreeDropCriterion</classname> (server-side)"
msgstr "<classname>TreeDropCriterion</classname> (服务器端)"

#. Tag: listitem
#: chapter-advanced.xml:2438
#, no-c-format
msgid ""
"Accepts drops on only some items, which as specified by a set of item IDs. "
"You must extend the abstract class and implement the "
"<methodname>getAllowedItemIds()</methodname> to return the set. While the "
"criterion is server-side, it is lazy-loading, so that the list of accepted "
"target nodes is loaded only once from the server for each drag operation. "
"See <xref linkend=\"advanced.dragndrop.acceptcriteria\"/> for an example."
msgstr ""
"只允许拖动到一部分节点上, 这些节点通过一组项目 ID 来指定. 你必须扩展这个抽象"
"类, 并实现 <methodname>getAllowedItemIds()</methodname> 方法来返回这个项目 "
"ID 集合. 由于这个判定发生在服务器端, 它是延迟加载的, 因此对于拖动操作来说, 可"
"接受的目标节点只会从服务器端加载一次. 示例请参见 <xref linkend=\"advanced."
"dragndrop.acceptcriteria\"/>."

#. Tag: para
#: chapter-advanced.xml:2450
#, no-c-format
msgid ""
"In addition, the accept criteria defined in <classname>AbstractSelect</"
"classname> are available for a <classname>Tree</classname>, as listed in "
"<xref linkend=\"advanced.dragndrop.acceptcriteria\"/>."
msgstr ""
"此外, <classname>AbstractSelect</classname> 中定义的接受判定类也可以用于 "
"<classname>Tree</classname>, 详情请参见 <xref linkend=\"advanced.dragndrop."
"acceptcriteria\"/>."

#. Tag: title
#: chapter-advanced.xml:2461
#, no-c-format
msgid "Dropping Items On a <classname>Table</classname>"
msgstr "拖放项目到 <classname>Table</classname> 上"

#. Tag: para
#: chapter-advanced.xml:2463
#, no-c-format
msgid ""
"You can drag items from, to, or within a <classname>Table</classname>. "
"Making table a drag source requires simply setting the drag mode with "
"<methodname>setDragMode()</methodname>. <classname>Table</classname> "
"supports dragging both single rows, with <literal>TableDragMode.ROW</"
"literal>, and multiple rows, with <literal>TableDragMode.MULTIROW</literal>. "
"While dragging, the dragged node or nodes are referenced with a "
"<classname>TreeTransferable</classname> object, which is a "
"<classname>DataBoundTransferable</classname>. Tree nodes are identified by "
"the item IDs of the container items."
msgstr ""
"你可以从 <classname>Table</classname> 中拖放一个数据项目, 也可以拖放到 "
"<classname>Table</classname> 上, 也可以在 <classname>Table</classname> 内部拖"
"放. 将 Table 设置为拖放源只需要简单地使用 <methodname>setDragMode()</"
"methodname> 方法设置拖动模式即可. <classname>Table</classname> 可以使用 "
"<literal>TableDragMode.ROW</literal> 模式拖动单行, 也可以使用 "
"<literal>TableDragMode.MULTIROW</literal> 模式拖动多行. 拖动时, 被拖动的行表"
"现为 <classname>TreeTransferable</classname> 对象, 它继承自  "
"<classname>DataBoundTransferable</classname>. 行通过容器中数据项目的 ID 来标"
"识. (译注: 此处原文有误)"

#. Tag: para
#: chapter-advanced.xml:2477
#, no-c-format
msgid ""
"When a transferable is dropped on a table, the drop location is stored in a "
"<classname>AbstractSelectTargetDetails</classname> object, which identifies "
"the target row by its item ID. You can get the item ID with "
"<methodname>getItemIdOver()</methodname> method. A drop can occur directly "
"on or above or below a row; the exact location is a "
"<classname>VerticalDropLocation</classname>, which you can get with the "
"<methodname>getDropLocation()</methodname> method from the details object."
msgstr ""
"当一个可传输对象被拖放到 Table 上时, drop 位置保存在 "
"<classname>AbstractSelectTargetDetails</classname> 对象中, 它使用数据项目的 "
"ID 来标识拖放的目标行. 你可以通过 <methodname>getItemIdOver()</methodname> 方"
"法得到数据项目. drop 动作可以发生在行上, 也可以在行的上方或下方; 确切的位置"
"是 <classname>VerticalDropLocation</classname> 对象, 可以通过 Detail 对象的 "
"<methodname>getDropLocation()</methodname> 得到这个对象."

#. Tag: title
#: chapter-advanced.xml:2488
#, no-c-format
msgid "Accept Criteria for Tables"
msgstr "对 Table 进行拖放操作的接受判定"

#. Tag: para
#: chapter-advanced.xml:2490
#, no-c-format
msgid ""
"<classname>Table</classname> defines one specialized accept criterion for "
"tables."
msgstr "<classname>Table</classname> 定义了一些特殊的接受判定结果."

#. Tag: term
#: chapter-advanced.xml:2497
#, no-c-format
msgid "<classname>TableDropCriterion</classname> (server-side)"
msgstr "<classname>TableDropCriterion</classname> (服务器端)"

#. Tag: listitem
#: chapter-advanced.xml:2498
#, no-c-format
msgid ""
"Accepts drops only on (or above or below) items that are specified by a set "
"of item IDs. You must extend the abstract class and implement the "
"<methodname>getAllowedItemIds()</methodname> to return the set. While the "
"criterion is server-side, it is lazy-loading, so that the list of accepted "
"target items is loaded only once from the server for each drag operation."
msgstr ""
"只允许拖放到一部分项目上, 这些项目通过一组项目 ID 来指定. 你必须扩展这个抽象"
"类, 实现 <methodname>getAllowedItemIds()</methodname> 方法来返回项目 ID 集"
"合. 由于这个判定发生在服务器端, 它是延迟加载的, 因此对于拖动操作来说, 可接受"
"的目标项目只会从服务器端加载一次."

#. Tag: title
#: chapter-advanced.xml:2513
#, no-c-format
msgid "Accepting Drops"
msgstr "接受拖放"

#. Tag: secondary
#: chapter-advanced.xml:2517
#, no-c-format
msgid "Accept Criteria"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2520
#, no-c-format
msgid ""
"You can not drop the objects you are dragging around just anywhere. Before a "
"drop is possible, the specific drop location on which the mouse hovers must "
"be <emphasis>accepted</emphasis>. Hovering a dragged object over an accepted "
"location displays an <emphasis>accept indicator</emphasis>, which allows the "
"user to position the drop properly. As such checks have to be done all the "
"time when the mouse pointer moves around the drop targets, it is not "
"feasible to send the accept requests to the server-side, so drops on a "
"target are normally accepted by a client-side <emphasis>accept criterion</"
"emphasis>."
msgstr ""
"你不能将拖动中的对象放在任意的位置. 在你放下对象之前, 鼠标目前移动到的位置必"
"须被判定为 <emphasis>接受拖放</emphasis>. 当鼠标抓住一个拖动中的对象经过一个"
"接受拖放的位置时, 会出现 <emphasis>接受拖放指示器</emphasis>, 用户可以通过这"
"个指示器来正确地调整放下对象的位置. 由于这种检查必须在鼠标在拖放目标附近移动"
"时反复执行, 因此不适合向服务器发送请求, 因此 <emphasis>接受判定</emphasis> 通"
"常是在客户端进行的."

#. Tag: para
#: chapter-advanced.xml:2532
#, no-c-format
msgid ""
"A drop handler must define the criterion on the objects which it accepts to "
"be dropped on the target. The criterion needs to be provided in the "
"<classname>getAcceptCriterion()</classname> method of the "
"<classname>DropHandler</classname> interface. A criterion is represented in "
"an <classname>AcceptCriterion</classname> object, which can be a composite "
"of multiple criteria that are evaluated using logical operations. There are "
"two basic types of criteria: <emphasis>client-side</emphasis> and "
"<emphasis>server-side criteria</emphasis>. The various built-in criteria "
"allow accepting drops based on the identity of the source and target "
"components, and on the <emphasis>data flavor</emphasis> of the dragged "
"objects."
msgstr ""
"drop 处理器必须定义接受判定条件(AcceptCriterion), 它负责判定拖动中的对象可以"
"放在哪些对象上. 判定条件需要通过 <classname>DropHandler</classname> 接口的 "
"<classname>getAcceptCriterion()</classname> 方法给出. 判定条件表现为一个 "
"<classname>AcceptCriterion</classname> 对象, 它也可以是多个判定条件通过逻辑运"
"算的组合. 有两种基本的判定条件: <emphasis>客户端判定条件</emphasis> 与 "
"<emphasis>服务器端判定条件</emphasis>. Vaadin 有很多内建的判定条件, 可以实现"
"基于源组件和目标组件是否一致的接受判定, 以及基于被拖动对象 <emphasis>data "
"flavor</emphasis> 的接受判定."

#. Tag: para
#: chapter-advanced.xml:2546
#, no-c-format
msgid ""
"To allow dropping any transferable objects, you can return a universal "
"accept criterion, which you can get with <methodname>AcceptAll.get()</"
"methodname>."
msgstr ""
"要支持任意的可传送数据的拖放, 你可以返回一个接受一切数据的判定条件, 可以使用 "
"<methodname>AcceptAll.get()</methodname> 方法得到这样的判定条件."

#. Tag: programlisting
#: chapter-advanced.xml:2552
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[tree.setDropHandler(new DropHandler() {\n"
"    public AcceptCriterion getAcceptCriterion() {\n"
"        return AcceptAll.get();\n"
"    }\n"
"    ...]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:2555
#, no-c-format
msgid "Client-Side Criteria"
msgstr "客户端判定条件"

#. Tag: para
#: chapter-advanced.xml:2557
#, no-c-format
msgid ""
"The <emphasis>client-side criteria</emphasis>, which inherit the "
"<classname>ClientSideCriterion</classname>, are verified on the client-side, "
"so server requests are not needed for verifying whether each component on "
"which the mouse pointer hovers would accept a certain object."
msgstr ""
"<emphasis>客户端判定条件</emphasis>, 继承自 <classname>ClientSideCriterion</"
"classname>, 运行在客户端, 在鼠标移动时会不断判定各组件能否接受目前拖动中的对"
"象, 但执行判定时不必发送服务器请求."

#. Tag: para
#: chapter-advanced.xml:2564
#, no-c-format
msgid ""
"The following client-side criteria are define in <package>com.vaadin.event."
"dd.acceptcriterion</package>:"
msgstr ""
"<package>com.vaadin.event.dd.acceptcriterion</package> 包内定义了以下客户端判"
"定条件:"

#. Tag: classname
#: chapter-advanced.xml:2571
#, no-c-format
msgid "AcceptAll"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2572
#, no-c-format
msgid "Accepts all transferables and targets."
msgstr "对所有可传输数据和所有目标对象都接受拖放."

#. Tag: classname
#: chapter-advanced.xml:2577
#, no-c-format
msgid "<classname>And</classname>"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2578
#, no-c-format
msgid ""
"Performs the logical AND operation on two or more client-side criteria; "
"accepts the transferable if all the given sub-criteria accept it."
msgstr ""
"在两个或更多客户端判定条件上执行逻辑 AND 操作; 如果所有的子条件都接受, 那么这"
"个复合条件就接受拖放."

#. Tag: classname
#: chapter-advanced.xml:2585
#, no-c-format
msgid "ContainsDataFlavour"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2586
#, no-c-format
msgid "The transferable must contain the defined data flavour."
msgstr "可传输数据必须包含指定的 data flavour."

#. Tag: classname
#: chapter-advanced.xml:2591
#, no-c-format
msgid "<classname>Not</classname>"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2592
#, no-c-format
msgid ""
"Performs the logical NOT operation on a client-side criterion; accepts the "
"transferable if and only if the sub-criterion does not accept it."
msgstr ""
"在一个客户端判定条件上执行一个逻辑 NOT 操作; 只有在子条件不接受时, 这个条件才"
"接受拖放."

#. Tag: classname
#: chapter-advanced.xml:2599
#, no-c-format
msgid "<classname>Or</classname>"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2600
#, no-c-format
msgid ""
"Performs the logical OR operation on two or more client-side criteria; "
"accepts the transferable if any of the given sub-criteria accepts it."
msgstr ""
"在两个或更多客户端判定条件上执行逻辑 OR 操作; 如果任意一个子条件接受, 那么这"
"个复合条件就接受拖放."

#. Tag: classname
#: chapter-advanced.xml:2607
#, no-c-format
msgid "SourceIs"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2608
#, no-c-format
msgid "Accepts all transferables from any of the given source components"
msgstr "如果拖动中的可传输对象来自指定的源组件之一, 那么就接受它"

#. Tag: classname
#: chapter-advanced.xml:2614
#, no-c-format
msgid "SourceIsTarget"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2615
#, no-c-format
msgid ""
"Accepts the transferable only if the source component is the same as the "
"target. This criterion is useful for ensuring that items are dragged only "
"within a tree or a table, and not from outside it."
msgstr ""
"当拖动数据的源组件与目标组件一致时, 接受拖放. 这个判定条件可用于确保数据项目"
"只在同一个 Tree 或 Table 内部拖动, 而不是来自外部."

#. Tag: classname
#: chapter-advanced.xml:2623
#, no-c-format
msgid "TargetDetailIs"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2624
#, no-c-format
msgid ""
"Accepts any transferable if the target detail, such as the item of a tree "
"node or table row, is of the given data flavor and has the given value."
msgstr ""
"当 target detail 对象, 比如 Tree 节点或 Table 行的数据项目, 是某种指定的 "
"data flavor, 并且是某个指定的值时, 接受拖放操作."

#. Tag: para
#: chapter-advanced.xml:2632
#, no-c-format
msgid ""
"In addition, target components such as <classname>Tree</classname> and "
"<classname>Table</classname> define some component-specific client-side "
"accept criteria. See <xref linkend=\"advanced.dragndrop.treedrop\"/> for "
"more details."
msgstr ""
"此外, 目标组件, 比如 <classname>Tree</classname> 和 <classname>Table</"
"classname>, 还定义了一些组件专有的客户端判定条件. 详情请参见 <xref linkend="
"\"advanced.dragndrop.treedrop\"/>."

#. Tag: para
#: chapter-advanced.xml:2639
#, no-c-format
msgid ""
"<classname>AbstractSelect</classname> defines the following criteria for all "
"selection components, including <classname>Tree</classname> and "
"<classname>Table</classname>."
msgstr ""
"<classname>AbstractSelect</classname> 为所有的选择组件, 包括 "
"<classname>Tree</classname> 和 <classname>Table</classname>, 定义了以下判定条"
"件."

#. Tag: classname
#: chapter-advanced.xml:2647
#, no-c-format
msgid "AcceptItem"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2648
#, no-c-format
msgid ""
"Accepts only specific items from a specific selection component. The "
"selection component, which must inherit <classname>AbstractSelect</"
"classname>, is given as the first parameter for the constructor. It is "
"followed by a list of allowed item identifiers in the drag source."
msgstr ""
"只接受某个特定的选择组件中的特定数据项目. 选择组件继承自 "
"<classname>AbstractSelect</classname>, 作为判定条件构造方法的第一个参数指定. "
"第二个参数是拖放源中可接受的项目 ID 列表."

#. Tag: classname
#: chapter-advanced.xml:2657
#, no-c-format
msgid "AcceptItem.ALL"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2658
#, no-c-format
msgid "Accepts all transferables as long as they are items."
msgstr "只要拖动中的可传输对象是数据项目, 就接受拖放."

#. Tag: classname
#: chapter-advanced.xml:2663
#, no-c-format
msgid "TargetItemIs"
msgstr ""

#. Tag: listitem
#: chapter-advanced.xml:2664
#, no-c-format
msgid ""
"Accepts all drops on the specified target items. The constructor requires "
"the target component (<classname>AbstractSelect</classname>) followed by a "
"list of allowed item identifiers."
msgstr ""
"对指定的目标项目, 接受它之上的所有拖放操作. 这个判定条件的构造方法参数是目标"
"组件(<classname>AbstractSelect</classname>), 以及允许拖放的目标项目 ID 列表."

#. Tag: term
#: chapter-advanced.xml:2672
#, no-c-format
msgid ""
"<classname>VerticalLocationIs.MIDDLE</classname>, <classname>TOP</"
"classname>, and <classname>BOTTOM</classname>"
msgstr ""
"<classname>VerticalLocationIs.MIDDLE</classname>, <classname>TOP</"
"classname>, 和 <classname>BOTTOM</classname>"

#. Tag: listitem
#: chapter-advanced.xml:2675
#, no-c-format
msgid ""
"The three static criteria accepts drops on, above, or below an item. For "
"example, you could accept drops only in between items with the following:"
msgstr ""
"这三个静态的判定条件接受在一个数据项目之上, 上方, 或下方的拖放操作. 比如, 你"
"可以使用以下代码, 只接受数据项目之间位置上的拖放:"

#. Tag: programlisting
#: chapter-advanced.xml:2680
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {\n"
"    return new Not(VerticalLocationIs.MIDDLE);\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:2687
#, no-c-format
msgid "Server-Side Criteria"
msgstr "服务器端判定条件"

#. Tag: para
#: chapter-advanced.xml:2689
#, no-c-format
msgid ""
"The <emphasis>server-side criteria</emphasis> are verified on the server-"
"side with the <methodname>accept()</methodname> method of the "
"<classname>ServerSideCriterion</classname> class. This allows fully "
"programmable logic for accepting drops, but the negative side is that it "
"causes a very large amount of server requests. A request is made for every "
"target position on which the pointer hovers. This problem is eased in many "
"cases by the component-specific lazy loading criteria "
"<classname>TableDropCriterion</classname> and <classname>TreeDropCriterion</"
"classname>. They do the server visit once for each drag and drop operation "
"and return all accepted rows or nodes for current <classname>Transferable</"
"classname> at once."
msgstr ""
"<emphasis>服务器端判定条件</emphasis> 运行在服务器端, 通过 "
"<classname>ServerSideCriterion</classname> 类的 <methodname>accept()</"
"methodname> 方法进行判定. 这种方式可以使用程序的全部逻辑功能来实现拖放接受的"
"判定, 但缺点是它导致大量的服务器请求. 每次鼠标到达一个位置都需要发起一次请"
"求. 很多情况下可以使用组件专有的延迟装载判定条件 "
"<classname>TableDropCriterion</classname> 和 <classname>TreeDropCriterion</"
"classname> 来减轻这个问题. 这些判定条件对每个拖放操作只执行一次服务器请求, 并"
"针对目前拖动中的 <classname>Transferable</classname> 对象返回所有可接受的行或"
"节点."

#. Tag: para
#: chapter-advanced.xml:2703
#, no-c-format
msgid ""
"The <methodname>accept()</methodname> method gets the drag event as a "
"parameter so it can perform its logic much like in <methodname>drop()</"
"methodname>."
msgstr ""
"<methodname>accept()</methodname> 方法接受的参数是拖动事件, 因此这个方法的实"
"现可以类似于 <methodname>drop()</methodname> 方法."

#. Tag: programlisting
#: chapter-advanced.xml:2709
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {\n"
"    // Server-side accept criterion that allows drops on any other\n"
"    // location except on nodes that may not have children\n"
"    ServerSideCriterion criterion = new ServerSideCriterion() {\n"
"        public boolean accept(DragAndDropEvent dragEvent) {\n"
"            TreeTargetDetails target = (TreeTargetDetails)\n"
"                dragEvent.getTargetDetails();\n"
"\n"
"            // The tree item on which the load hovers\n"
"            Object targetItemId = target.getItemIdOver();\n"
"\n"
"            // On which side of the target the item is hovered\n"
"            VerticalDropLocation location = target.getDropLocation();\n"
"            if (location == VerticalDropLocation.MIDDLE)\n"
"                if (! tree.areChildrenAllowed(targetItemId))\n"
"                    return false; // Not accepted\n"
"\n"
"            return true; // Accept everything else\n"
"        }\n"
"    };\n"
"    return criterion;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2711
#, no-c-format
msgid ""
"The server-side criteria base class <classname>ServerSideCriterion</"
"classname> provides a generic <methodname>accept()</methodname> method. The "
"more specific <classname>TableDropCriterion</classname> and "
"<classname>TreeDropCriterion</classname> are conveniency extensions that "
"allow definiting allowed drop targets as a set of items. They also provide "
"some optimization by lazy loading, which reduces server communications "
"significantly."
msgstr ""
"服务器端判定条件的基类 <classname>ServerSideCriterion</classname> 提供了一个"
"共通的 <methodname>accept()</methodname> 方法. 更细化的 "
"<classname>TableDropCriterion</classname> 和 <classname>TreeDropCriterion</"
"classname> 类是便于使用的子类, 可以以数据项目集合的形式来指定允许拖放的目标项"
"目. 这些类还提供了延迟加载的优化, 可以显著降低与服务器端的通信数量."

#. Tag: programlisting
#: chapter-advanced.xml:2722
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public AcceptCriterion getAcceptCriterion() {\n"
"    // Server-side accept criterion that allows drops on any\n"
"    // other tree node except on node that may not have children\n"
"    TreeDropCriterion criterion = new TreeDropCriterion() {\n"
"        @Override\n"
"        protected Set<Object> getAllowedItemIds(\n"
"                DragAndDropEvent dragEvent, Tree tree) {\n"
"            HashSet<Object> allowed = new HashSet<Object>();\n"
"            for (Iterator<Object> i =\n"
"                   tree.getItemIds().iterator(); i.hasNext();) {\n"
"                Object itemId = i.next();\n"
"                if (tree.hasChildren(itemId))\n"
"                    allowed.add(itemId);\n"
"            }\n"
"            return allowed;\n"
"        }\n"
"    };\n"
"    return criterion;\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:2727
#, no-c-format
msgid "Accept Indicators"
msgstr "接受指示器"

#. Tag: para
#: chapter-advanced.xml:2729
#, no-c-format
msgid ""
"When a dragged object hovers on a drop target, an <emphasis>accept "
"indicator</emphasis> is displayed to show whether or not the location is "
"accepted. For <parameter>MIDDLE</parameter> location, the indicator is a box "
"around the target (tree node, table row, or component). For vertical drop "
"locations, the accepted locations are shown as horizontal lines, and for "
"horizontal drop locations as vertical lines."
msgstr ""
"当一个被拖动的对象经过 drop 目标上方时, 会显示 <emphasis>接受指示器</"
"emphasis>, 告诉使用者这个位置是否允许拖放. 对于 <parameter>MIDDLE</"
"parameter> 位置, 指示器是目标周边的一个方框 (Tree 的节点, Table 的行, 或组"
"件). 对于垂直 drop 位置, 可接受的位置显示为水平线条, 对于水平 drop 位置, 显示"
"为垂直线条."

#. Tag: para
#: chapter-advanced.xml:2738
#, no-c-format
msgid ""
"For <classname>DragAndDropWrapper</classname> drop targets, you can disable "
"the accept indicators or <emphasis>drag hints</emphasis> with the "
"<parameter>no-vertical-drag-hints</parameter>, <parameter>no-horizontal-drag-"
"hints</parameter>, and <parameter>no-box-drag-hints</parameter> styles. You "
"need to add the styles to the <emphasis>layout that contains</emphasis> the "
"wrapper, not to the wrapper itself."
msgstr ""
"对于拖放目标为 <classname>DragAndDropWrapper</classname> 的情况, 你可以禁止显"
"示接受指示器和 <emphasis>拖放提示(drag hint)</emphasis>, 方法是使用 "
"<parameter>no-vertical-drag-hints</parameter>, <parameter>no-horizontal-drag-"
"hints</parameter>, 和 <parameter>no-box-drag-hints</parameter> 样式. 你需要将"
"这些样式添加到 <emphasis>包含 wrapper 对象的布局组件</emphasis> 上, 而不是添"
"加给 wrapper 对象自身."

#. Tag: programlisting
#: chapter-advanced.xml:2748
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a wrapper\n"
"DragAndDropWrapper wrapper = new DragAndDropWrapper(c);\n"
"layout.addComponent(wrapper);\n"
"\n"
"// Disable the hints\n"
"layout.addStyleName(\"no-vertical-drag-hints\");\n"
"layout.addStyleName(\"no-horizontal-drag-hints\");\n"
"layout.addStyleName(\"no-box-drag-hints\");]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:2757
#, no-c-format
msgid "Dragging Components"
msgstr "拖动组件"

#. Tag: para
#: chapter-advanced.xml:2759
#, no-c-format
msgid ""
"Dragging a component requires wrapping the source component within a "
"<classname>DragAndDropWrapper</classname>. You can then allow dragging by "
"putting the wrapper (and the component) in drag mode with "
"<methodname>setDragStartMode()</methodname>. The method supports two drag "
"modes: <parameter>DragStartMode.WRAPPER</parameter> and "
"<parameter>DragStartMode.COMPONENT</parameter>, which defines whether the "
"entire wrapper is shown as the drag image while dragging or just the wrapped "
"component."
msgstr ""
"拖动组件需要将源组件封装在 <classname>DragAndDropWrapper</classname> 之内. 然"
"后使用 <methodname>setDragStartMode()</methodname>方法将 wrapper (以及组件) "
"设置为拖动模式, 就可以实现拖动功能了. 这个方法支持两种拖动模式: "
"<parameter>DragStartMode.WRAPPER</parameter> 和 <parameter>DragStartMode."
"COMPONENT</parameter>, 这两个模式决定拖动时显示的拖动图像是整个 wrapper, 还是"
"仅仅只是被封装的组件."

#. Tag: programlisting
#: chapter-advanced.xml:2770
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a component to drag\n"
"final Button button = new Button(\"An Absolute Button\");\n"
"\n"
"// Put the component in a D&D wrapper and allow dragging it\n"
"final DragAndDropWrapper buttonWrap = new DragAndDropWrapper(button);\n"
"buttonWrap.setDragStartMode(DragStartMode.COMPONENT);\n"
"\n"
"// Set the wrapper to wrap tightly around the component\n"
"buttonWrap.setSizeUndefined();\n"
"        \n"
"// Add the wrapper, not the component, to the layout\n"
"layout.addComponent(buttonWrap, \"left: 50px; top: 50px;\");]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2772
#, no-c-format
msgid ""
"The default height of <classname>DragAndDropWrapper</classname> is "
"undefined, but the default width is 100%. If you want to ensure that the "
"wrapper fits tightly around the wrapped component, you should call "
"<methodname>setSizeUndefined()</methodname> for the wrapper. Doing so, you "
"should make sure that the wrapped component does not have a relative size, "
"which would cause a paradox."
msgstr ""
"<classname>DragAndDropWrapper</classname> 的高度默认为未指定, 但宽度默认为 "
"100%. 如果你希望确保 wrapper 的尺寸紧密贴近于被封装的组件, 那么你应该对 "
"wrapper 调用 <methodname>setSizeUndefined()</methodname> 方法. 这时, 你应该确"
"保被封装的组件尺寸不是一个相对值, 否则会导致矛盾."

#. Tag: para
#: chapter-advanced.xml:2781
#, no-c-format
msgid ""
"Dragged components are referenced in the <classname>WrapperTransferable</"
"classname>. You can get the reference to the dragged component with "
"<methodname>getDraggedComponent()</methodname>. The method will return "
"<literal>null</literal> if the transferable is not a component. Also HTML 5 "
"drags (see later) are held in wrapper transferables."
msgstr ""
"被拖动的组件使用 <classname>WrapperTransferable</classname> 类来表示. 你可以"
"使用 <methodname>getDraggedComponent()</methodname> 方法得到被拖动的组件. 如"
"果拖动中的可传输对象不是组件, 这个方法将返回 <literal>null</literal>. HTML 5 "
"拖动(详情见后述) 也使用 WrapperTransferable 类来表示."

#. Tag: title
#: chapter-advanced.xml:2793
#, no-c-format
msgid "Dropping on a Component"
msgstr "拖动到组件上"

#. Tag: para
#: chapter-advanced.xml:2795
#, no-c-format
msgid ""
"Drops on a component are enabled by wrapping the component in a "
"<classname>DragAndDropWrapper</classname>. The wrapper is an ordinary "
"component; the constructor takes the wrapped component as a parameter. You "
"just need to define the <classname>DropHandler</classname> for the wrapper "
"with <methodname>setDropHandler()</methodname>."
msgstr ""
"将组件封装在 <classname>DragAndDropWrapper</classname> 之内, 也可以实现向组件"
"的 drop. wrapper 也是一种普通组件; 它的构造函数参数是被封装的组件. 你只需要"
"在 wrapper 上使用 <methodname>setDropHandler()</methodname> 方法来定义 "
"<classname>DropHandler</classname> 即可."

#. Tag: para
#: chapter-advanced.xml:2803
#, no-c-format
msgid ""
"In the following example, we allow moving components in an absolute layout. "
"Details on the drop handler are given later."
msgstr "下例中, 我们允许在绝对布局中移动组件. drop 处理器的细节将在后文中给出."

#. Tag: programlisting
#: chapter-advanced.xml:2808
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// A layout that allows moving its contained "
"components\n"
"// by dragging and dropping them\n"
"final AbsoluteLayout absLayout = new AbsoluteLayout();\n"
"absLayout.setWidth(\"100%\");\n"
"absLayout.setHeight(\"400px\");\n"
"\n"
"... put some (wrapped) components in the layout ...\n"
"\n"
"// Wrap the layout to allow handling drops\n"
"DragAndDropWrapper layoutWrapper =\n"
"        new DragAndDropWrapper(absLayout);\n"
"\n"
"// Handle moving components within the AbsoluteLayout\n"
"layoutWrapper.setDropHandler(new DropHandler() {\n"
"    public AcceptCriterion getAcceptCriterion() {\n"
"        return AcceptAll.get();\n"
"    }\n"
"    \n"
"    public void drop(DragAndDropEvent event) {\n"
"        ...        \n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:2811
#, no-c-format
msgid "Target Details for Wrapped Components"
msgstr "被封装组件的 Target Detail"

#. Tag: para
#: chapter-advanced.xml:2813
#, no-c-format
msgid ""
"The drop handler receives the drop target details in a "
"<classname>WrapperTargetDetails</classname> object, which implements the "
"<classname>TargetDetails</classname> interface."
msgstr ""
"drop 处理器收到一个 <classname>WrapperTargetDetails</classname> 对象, 这个对"
"象实现了 <classname>TargetDetails</classname> 接口, 对象中包含的是 drop 目标"
"的详细信息."

#. Tag: programlisting
#: chapter-advanced.xml:2819
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public void drop(DragAndDropEvent event) {\n"
"    WrapperTransferable t =\n"
"        (WrapperTransferable) event.getTransferable();\n"
"    WrapperTargetDetails details =\n"
"        (WrapperTargetDetails) event.getTargetDetails();]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2821
#, no-c-format
msgid ""
"The wrapper target details include a <classname>MouseEventDetails</"
"classname> object, which you can get with <methodname>getMouseEvent()</"
"methodname>. You can use it to get the mouse coordinates for the position "
"where the mouse button was released and the drag ended. Similarly, you can "
"find out the drag start position from the transferable object (if it is a "
"<classname>WrapperTransferable</classname>) with "
"<methodname>getMouseDownEvent()</methodname>."
msgstr ""
"WrapperTargetDetails 中包含一个 <classname>MouseEventDetails</classname> 对"
"象, 你可以通过 <methodname>getMouseEvent()</methodname> 方法得到它. 你可以通"
"过这个对象得到鼠标按钮放开、拖动结束时的坐标位置. 类似的, 你可以通过可传输对"
"象(如果是 <classname>WrapperTransferable</classname> 对象)使用 "
"<methodname>getMouseDownEvent()</methodname> 方法找出拖动的开始位置."

#. Tag: programlisting
#: chapter-advanced.xml:2832
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Calculate the drag coordinate difference\n"
"int xChange = details.getMouseEvent().getClientX()\n"
"              - t.getMouseDownEvent().getClientX();\n"
"int yChange = details.getMouseEvent().getClientY()\n"
"              - t.getMouseDownEvent().getClientY();\n"
"\n"
"// Move the component in the absolute layout\n"
"ComponentPosition pos =\n"
"    absLayout.getPosition(t.getSourceComponent());\n"
"pos.setLeftValue(pos.getLeftValue() + xChange);\n"
"pos.setTopValue(pos.getTopValue() + yChange);]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2834
#, no-c-format
msgid ""
"You can get the absolute x and y coordinates of the target wrapper with "
"<methodname>getAbsoluteLeft()</methodname> and <methodname>getAbsoluteTop()</"
"methodname>, which allows you to translate the absolute mouse coordinates to "
"coordinates relative to the wrapper. Notice that the coordinates are really "
"the position of the wrapper, not the wrapped component; the wrapper reserves "
"some space for the accept indicators."
msgstr ""
"你可以使用 <methodname>getAbsoluteLeft()</methodname> 和 "
"<methodname>getAbsoluteTop()</methodname> 方法得到目标 wrapper 的 x 和 y 坐标"
"绝对值, 这两个方法可以将鼠标位置的绝对坐标翻译为相对于 wrapper 对象的坐标. 注"
"意, 坐标是相对于 wrapper 的, 而不是相对于被封装的组件的; wrapper 会保留一些空"
"间, 用于显示接受指示器."

#. Tag: para
#: chapter-advanced.xml:2844
#, no-c-format
msgid ""
"The <methodname>verticalDropLocation()</methodname> and "
"<methodname>horizontalDropLocation()</methodname> return the more detailed "
"drop location in the target."
msgstr ""
"<methodname>verticalDropLocation()</methodname> 和 "
"<methodname>horizontalDropLocation()</methodname> 方法可以得到目标对象上的更"
"详细的 drop 位置."

#. Tag: title
#: chapter-advanced.xml:2853
#, no-c-format
msgid "Dragging Files from Outside the Browser"
msgstr "从浏览器之外拖放文件"

#. Tag: para
#: chapter-advanced.xml:2855
#, no-c-format
msgid ""
"The <classname>DragAndDropWrapper</classname> allows dragging files from "
"outside the browser and dropping them on a component wrapped in the wrapper. "
"Dropped files are automatically uploaded to the application and can be "
"acquired from the wrapper with <methodname>getFiles()</methodname>. The "
"files are represented as <classname>Html5File</classname> objects as defined "
"in the inner class. You can define an upload <classname>Receiver</classname> "
"to receive the content of a file to an <classname>OutputStream</classname>."
msgstr ""
"<classname>DragAndDropWrapper</classname> 允许从浏览器之外拖动文件, 并 drop "
"到 wrapper 内封装的组件上. 被拖放的文件会自动上传到应用程序中, 然后可以通过 "
"wrapper 的 <methodname>getFiles()</methodname> 方法得到. 文件以 "
"<classname>Html5File</classname> 对象的形式表达, 这个类定义在inner 类中. 你可"
"以定义一个上传 <classname>Receiver</classname> 来接受文件内容, 并输出到一个 "
"<classname>OutputStream</classname> 中."

#. Tag: para
#: chapter-advanced.xml:2866
#, no-c-format
msgid ""
"Dragging and dropping files to browser is supported in HTML 5 and requires a "
"compatible browser, such as Mozilla Firefox 3.6 or newer."
msgstr ""
"拖放文件到浏览器中是 HTML 5 支持的功能, 因此需要兼容 HTML 5 标准的浏览器, 比"
"如 Mozilla Firefox 3.6 或更高版本."

#. Tag: title
#: chapter-advanced.xml:2876
#, no-c-format
msgid "Logging"
msgstr "日志"

#. Tag: para
#: chapter-advanced.xml:2880
#, no-c-format
msgid ""
"You can do logging in Vaadin application using the standard <package>java."
"util.logging</package> facilities. Configuring logging is as easy as putting "
"a file named <filename>logging.properties</filename> in the default package "
"of your Vaadin application (<filename>src</filename> in an Eclipse project "
"or <filename>src/main/java</filename> or <filename>src/main/resources</"
"filename> in a Maven project). This file is read by the <classname>Logger</"
"classname> class when a new instance of it is initialize."
msgstr ""
"你可以在 Vaadin 应用程序中使用标准的 <package>java.util.logging</package> 功"
"能来输出日志. 配置日志很容易, 只需要将名为 <filename>logging.properties</"
"filename> 的配置文件放在你的 Vaadin 应用程序的默认包之下即可,(也就是 Eclipse "
"工程 的 <filename>src</filename> 目录, Maven 工程的 <filename>src/main/java</"
"filename> 或 <filename>src/main/resources</filename> 目录). 这个文件由 "
"<classname>Logger</classname> 类的新实例创建时负责读取 ."

#. Tag: title
#: chapter-advanced.xml:2892
#, no-c-format
msgid "Logging in Apache Tomcat"
msgstr "在 Apache Tomcat 中输出日志"

#. Tag: para
#: chapter-advanced.xml:2894
#, no-c-format
msgid ""
"For logging Vaadin applications deployed in Apache Tomcat, you do not need "
"to do anything special to log to the same place as Tomcat itself. If you "
"need to write the Vaadin application related messages elsewhere, just add a "
"custom <filename>logging.properties</filename> file to the default package "
"of your Vaadin application."
msgstr ""
"当 Vaadin 应用程序部署到 Apache Tomcat 中时, 你不需要做任何特殊的控制, 就可以"
"将日志输出到 Tomcat 自身日志相同的位置. 如果你需要将 Vaadin 应用程序的日志输"
"出到其他位置, 只需要在你的 Vaadin 应用程序默认包下添加一个自定义的 "
"<filename>logging.properties</filename> 设置文件."

#. Tag: para
#: chapter-advanced.xml:2902
#, no-c-format
msgid ""
"If you would like to pipe the log messages through another logging solution, "
"see <xref linkend=\"advanced.logging.slf4j\"/> below."
msgstr ""
"如果你希望通过其他日志工具来输出日志, 请参见下文的 <xref linkend=\"advanced."
"logging.slf4j\"/>."

#. Tag: title
#: chapter-advanced.xml:2909
#, no-c-format
msgid "Logging in Liferay"
msgstr "在 Liferay 中输出日志"

#. Tag: para
#: chapter-advanced.xml:2911
#, no-c-format
msgid ""
"Liferay mutes logging through <package>java.util.logging</package> by "
"default. In order to enable logging, you need to add a <filename>logging."
"properties</filename> file of your own to the default package of your Vaadin "
"application. This file should define at least one destination where to save "
"the log messages."
msgstr ""
"Liferay 默认关闭了通过 <package>java.util.logging</package> 输出的日志. 为了"
"打开日志, 你需要在你的 Vaadin 应用程序的默认包之下增加一个你自己的 "
"<filename>logging.properties</filename> 配置文件. 这个文件应该定义至少一个日"
"志信息的输出位置."

#. Tag: para
#: chapter-advanced.xml:2919
#, no-c-format
msgid ""
"You can also log through SLF4J, which is used in and bundled with Liferay. "
"Follow the instructions in <xref linkend=\"advanced.logging.slf4j\"/>."
msgstr ""
"你也可以通过 SLF4J 来输出日志, 这个工具也被 Liferay 使用, 并且绑定在 Liferay "
"中. 详情请参见 <xref linkend=\"advanced.logging.slf4j\"/>."

#. Tag: title
#: chapter-advanced.xml:2927
#, no-c-format
msgid "Piping to Log4j using SLF4J"
msgstr "使用 SLF4J 将日志转发给 Log4j"

#. Tag: primary
#: chapter-advanced.xml:2929
#, no-c-format
msgid "Log4j"
msgstr ""

#. Tag: primary
#: chapter-advanced.xml:2930
#, no-c-format
msgid "SLF4J"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2932
#, no-c-format
msgid ""
"Piping output from <package>java.util.logging</package> to Log4j is easy "
"with SLF4J (<link xlink:href=\"http://slf4j.org/\">http://slf4j.org/</"
"link>). The basic way to go about this is to add the SLF4J JAR file as well "
"as the <filename>jul-to-slf4j.jar</filename> file, which implements the "
"bridge from <package>java.util.logging</package>, to SLF4J. You will also "
"need to add a third logging implementation JAR file, that is, "
"<filename>slf4j-log4j12-x.x.x.jar</filename>, to log the actual messages "
"using Log4j. For more info on this, please visit the SLF4J site."
msgstr ""
"使用 SLF4J (<link xlink:href=\"http://slf4j.org/\">http://slf4j.org/</link>) "
"可以很容易地将 <package>java.util.logging</package> 的日志转发给 Log4j. 基本"
"方法是添加 SLF4J JAR 文件, 以及 <filename>jul-to-slf4j.jar</filename> 文件, "
"这个文件中实现了从 <package>java.util.logging</package> 到 SLF4J 的桥接功能. "
"你还需要添加第三方日志实现的 JAR 文件, 也就是, <filename>slf4j-log4j12-x.x.x."
"jar</filename>, 以便使用 Log4j 来输出日志. 关于这个问题的详情, 请参见 SLF4J "
"网站."

#. Tag: para
#: chapter-advanced.xml:2944
#, no-c-format
msgid ""
"In order to get the <package>java.util.logging</package> to SLF4J bridge "
"installed, you need to add the following snippet of code to your "
"<classname>UI</classname> class at the very top:"
msgstr ""
"为了安装从 <package>java.util.logging</package> 到 SLF4J 的桥接, 你需要将以下"
"代码段添加到你的 <classname>UI</classname> 类的最前面:"

#. Tag: programlisting
#: chapter-advanced.xml:2951
#, no-c-format
msgid ""
"<![CDATA[  static {\n"
"    SLF4JBridgeHandler.install();\n"
"  }]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2953
#, no-c-format
msgid ""
"This will make sure that the bridge handler is installed and working before "
"Vaadin starts to process any logging calls."
msgstr ""
"在 Vaadin 开始进行任何日志输出之前, 这段代码将确保桥接功能已安装并正常工作."

#. Tag: title
#: chapter-advanced.xml:2959
#, no-c-format
msgid "Please note!"
msgstr "注意!"

#. Tag: para
#: chapter-advanced.xml:2961
#, no-c-format
msgid ""
"This can seriously impact on the cost of disabled logging statements (60-"
"fold increase) and a measurable impact on enabled log statements (20% "
"overall increase). However, Vaadin doesn't log very much, so the effect on "
"performance will be negligible."
msgstr ""
"这种方法会产生严重的性能问题, 当日志输出禁用时, 日志语句的执行代价增加 60 "
"倍, 当日志输出启用时, 执行代价增加 20%. 但是, Vaadin 输出的日志并不多, 因此性"
"能影响很小, 几乎可以忽略."

#. Tag: title
#: chapter-advanced.xml:2971
#, no-c-format
msgid "Using Logger"
msgstr "使用日志输出器"

#. Tag: para
#: chapter-advanced.xml:2973
#, no-c-format
msgid ""
"You can do logging with a simple pattern where you register a static logger "
"instance in each class that needs logging, and use this logger wherever "
"logging is needed in the class. For example:"
msgstr ""
"你可以使用一种简单的模式来输出日志, 这种模式中你可以在每个需要输出日志的类中"
"注册一个静态的日志输出器实例, 然后在类中需要输出日志的地方使用这个日志输出"
"器. 如下例:"

#. Tag: programlisting
#: chapter-advanced.xml:2979
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyClass {\n"
"  private final static Logger logger =\n"
"          Logger.getLogger(MyClass.class.getName());\n"
"  \n"
"  public void myMethod() {\n"
"    try {\n"
"      // do something that might fail\n"
"    } catch (Exception e) {\n"
"      logger.log(Level.SEVERE, \"FAILED CATASTROPHICALLY!\", e);\n"
"    } \n"
"  }\n"
"}]]>"
msgstr ""

#. Tag: primary
#: chapter-advanced.xml:2982
#, no-c-format
msgid "static"
msgstr ""

#. Tag: primary
#: chapter-advanced.xml:2983
#, no-c-format
msgid "memory leak"
msgstr ""

#. Tag: primary
#: chapter-advanced.xml:2984
#, no-c-format
msgid "PermGen"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:2984
#, no-c-format
msgid ""
"Having a <literal>static</literal> logger instance for each class needing "
"logging saves a bit of memory and time compared to having a logger for every "
"logging class instance. However, it could cause the application to leak "
"PermGen memory with some application servers when redeploying the "
"application. The problem is that the <classname>Logger</classname> may "
"maintain hard references to its instances. As the <classname>Logger</"
"classname> class is loaded with a classloader shared between different web "
"applications, references to classes loaded with a per-application "
"classloader would prevent garbage-collecting the classes after redeploying, "
"hence leaking memory. As the size of the PermGen memory where class object "
"are stored is fixed, the leakage will lead to a server crash after many "
"redeployments. The issue depends on the way how the server manages "
"classloaders, on the hardness of the back-references, and may also be "
"different between Java 6 and 7. So, if you experience PermGen issues, or "
"want to play it on the safe side, you should consider using non-static "
"<classname>Logger</classname> instances."
msgstr ""
"为每个需要输出日志的类保持一个 <literal>静态的</literal> 日志输出器实例, 与在"
"每个需要输出日志的类的实例中保持一个日志输出器相比, 使用静态的日志输出器可以"
"节约极少量的内存和时间. 但是, 在某些应用程序服务器上部署应用程序时, 这种方法"
"有可能会导致应用程序泄漏 PermGen 内存. 这个问题的原因是 <classname>Logger</"
"classname> 类可能会保持它的实例的硬参照. 由于负责装载 <classname>Logger</"
"classname> 类的类装载器在多个不同的 Web 应用程序之间共用, 因此由各应用程序类"
"装载器装载的类的引用, 可能会在应用程序重新部署之后阻止对这些类的垃圾收集, 因"
"此发生内存泄漏(译注: 这段理解不能, 待校). 由于保持类对象的 PermGen 内存的尺寸"
"是固定的, 因此在多次重新部署应用程序之后, 这个内存泄漏会导致服务器崩溃. 这个"
"问题取决于服务器如何管理它的类装载器, 也取决于反向引用的坚固度(译注: 这段理解"
"不能, 待校), 而且可能在 Java 6 和 7 之间也会不同. 因此, 如果你遇到 PermGen 问"
"题, 或者希望你的程序更安全一些, 你应该考虑使用非静态的 <classname>Logger</"
"classname> 实例."

#. Tag: title
#: chapter-advanced.xml:3011
#, no-c-format
msgid "JavaScript Interaction"
msgstr "与 JavaScript 集成"

#. Tag: para
#: chapter-advanced.xml:3013
#, no-c-format
msgid ""
"Vaadin supports two-direction JavaScript calls from and to the server-side. "
"This allows interfacing with JavaScript code without writing client-side "
"integration code."
msgstr ""
"Vaadin 支持双向的 JavaScript 调用, 既可以从服务器端调用 JavaScript, 也可以从 "
"JavaScript 调用服务器端. 使用这种功能就可以与 JavaScript 代码交互, 而不必编写"
"客户端代码."

#. Tag: title
#: chapter-advanced.xml:3020
#, no-c-format
msgid "Calling JavaScript"
msgstr "调用 JavaScript"

#. Tag: para
#: chapter-advanced.xml:3022
#, no-c-format
msgid ""
"You can make JavaScript calls from the server-side with the "
"<methodname>execute()</methodname> method in the <classname>JavaScript</"
"classname> class. You can get a <classname>JavaScript</classname> instance "
"from the current <classname>Page</classname> object with "
"<methodname>getJavaScript()</methodname>."
msgstr ""
"你可以在服务端使用 <classname>JavaScript</classname> 类的 "
"<methodname>execute()</methodname> 方法来执行对 JavaScript 的调用. 首先通过当"
"前 <classname>Page</classname> 对象的 <methodname>getJavaScript()</"
"methodname> 方法得到 <classname>JavaScript</classname> 实例."

#. Tag: programlisting
#: chapter-advanced.xml:3033
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Execute JavaScript in the currently "
"processed page\n"
"Page.getCurrent().getJavaScript().execute(\"alert('Hello')\");]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3035
#, no-c-format
msgid ""
"The <classname>JavaScript</classname> class itself has a static shorthand "
"method <methodname>getCurrent()</methodname> to get the instance for the "
"currently processed page."
msgstr ""
"<classname>JavaScript</classname> 类本身有一个静态的便捷方法 "
"<methodname>getCurrent()</methodname>, 可以从当前处理中的页面得到 JavaScript "
"实例."

#. Tag: programlisting
#: chapter-advanced.xml:3041
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Shorthand\n"
"JavaScript.getCurrent().execute(\"alert('Hello')\");]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3043
#, no-c-format
msgid ""
"The JavaScript is executed after the server request that is currently "
"processed returns. If multiple JavaScript calls are made during the "
"processing of the request, they are all executed sequentially after the "
"request is done. Hence, the JavaScript execution does not pause the "
"execution of the server-side application and you can not return values from "
"the JavaScript."
msgstr ""
"当前处理中的服务器请求返回之后, JavaScript 就会被执行. 如果一次请求中多次调用"
"了 JavaScript, 这些调用会在请求结束后顺序执行. 因此, JavaScript 调用不会导致"
"应用程序服务器端的运行暂停, 而且你不能在这种 JavaScript 中返回值."

#. Tag: title
#: chapter-advanced.xml:3054
#, no-c-format
msgid "Handling JavaScript Function Callbacks"
msgstr "处理 JavaScript 函数的回调"

#. Tag: para
#: chapter-advanced.xml:3056
#, no-c-format
msgid ""
"You can make calls with JavaScript from the client-side to the server-side. "
"This requires that you register JavaScript call-back methods from the server-"
"side. You need to implement and register a <classname>JavaScriptFunction</"
"classname> with <methodname>addFunction()</methodname> in the current "
"<classname>JavaScript</classname> object. A function requires a name, with "
"an optional package path, which are given to the <methodname>addFunction()</"
"methodname>. You only need to implement the <methodname>call()</methodname> "
"method to handle calls from the client-side JavaScript."
msgstr ""
"你也可以从客户端的 JavaScript 来调用服务器端. 这个功能要求你在服务器端注册 "
"JavaScript 回调方法. 你需要实现一个 <classname>JavaScriptFunction</"
"classname>, 并使用当前 <classname>JavaScript</classname> 对象的 "
"<methodname>addFunction()</methodname> 方法来注册这个函数. 函数需要有名称, 包"
"路径可选, 这些参数需要传递给 <methodname>addFunction()</methodname> 方法. 你"
"只需要实现 <methodname>call()</methodname> 方法, 就可以处理来自客户端 "
"JavaScript 的调用."

#. Tag: programlisting
#: chapter-advanced.xml:3069
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[\n"
"JavaScript.getCurrent().addFunction(\"com.example.foo.myfunc\",\n"
"                                    new JavaScriptFunction() {\n"
"    @Override\n"
"    public void call(JSONArray arguments) throws JSONException {\n"
"        Notification.show(\"Received call\");\n"
"    }\n"
"});\n"
"\n"
"Link link = new Link(\"Send Message\", new ExternalResource(\n"
"        \"javascript:com.example.foo.myfunc()\"));]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3071
#, no-c-format
msgid ""
"Parameters passed to the JavaScript method on the client-side are provided "
"in a <classname>JSONArray</classname> passed to the <methodname>call()</"
"methodname> method. The parameter values can be acquired with the "
"<methodname>get()</methodname> method by the index of the parameter, or any "
"of the type-casting getters. The getter must match the type of the passed "
"parameter, or a <classname>JSONException</classname> is thrown."
msgstr ""
"客户端传递给 JavaScript 方法的参数, 会以 <classname>JSONArray</classname> 的"
"形式传递给服务器端的 <methodname>call()</methodname> 方法. 参数值可以使用 "
"<methodname>get()</methodname> 方法取得, 这个方法的参数是希望取得的 "
"JavaScript 参数下标, 也可以使用带类型转换的 get 方法. 这些 get 方法必须与实际"
"传递的参数的类型一致, 否则会抛出 <classname>JSONException</classname> 例外."

#. Tag: programlisting
#: chapter-advanced.xml:3081
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[JavaScript.getCurrent().addFunction(\"com."
"example.foo.myfunc\",\n"
"                                    new JavaScriptFunction() {\n"
"    @Override\n"
"    public void call(JSONArray arguments) throws JSONException {\n"
"        try {\n"
"            String message = arguments.getString(0);\n"
"            int    value   = arguments.getInt(1);\n"
"            Notification.show(\"Message: \" + message +\n"
"                              \", value: \" + value);\n"
"        } catch (JSONException e) {\n"
"            Notification.show(\"Error: \" + e.getMessage());\n"
"        }\n"
"    }\n"
"});\n"
"        \n"
"Link link = new Link(\"Send Message\", new ExternalResource(\n"
"  \"javascript:com.example.foo.myfunc(prompt('Message'), 42)\"));]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3083
#, no-c-format
msgid ""
"The function callback mechanism is the same as the RPC mechanism used with "
"JavaScript component integration, as described in <xref linkend=\"gwt."
"javascript.rpc\"/>."
msgstr ""
"这里的函数回调机制, 与 JavaScript 组件集成中使用的 RPC 机制是一样的, 详情请参"
"见<xref linkend=\"gwt.javascript.rpc\"/>."

#. Tag: title
#: chapter-advanced.xml:3092
#, no-c-format
msgid "Accessing Session-Global Data"
msgstr "访问 Session 全局数据"

#. Tag: emphasis
#: chapter-advanced.xml:3095
#, no-c-format
msgid ""
"This section is mostly up-to-date with Vaadin 7, but has some information "
"which still needs to be updated."
msgstr "本节大部分内容已按照 Vaadin 7 进行了更新, 但少量信息还需要修改."

#. Tag: para
#: chapter-advanced.xml:3099
#, no-c-format
msgid ""
"Applications typically need to access some objects from practically all user "
"interface code, such as a user object, a business data model, or a database "
"connection. This data is typically initialized and managed in the UI class "
"of the application, or in the session or servlet."
msgstr ""
"应用程序通常会需要使用一些全局对象, 比如用户信息, 业务数据模型, 或数据库连"
"接. 创建并管理这些数据的通常是应用程序的 UI 类, 或者是 Session 或 Servlet."

#. Tag: para
#: chapter-advanced.xml:3106
#, no-c-format
msgid "For example, you could hold it in the UI class as follows:"
msgstr "比如, 你的 UI 类可以是这样:"

#. Tag: programlisting
#: chapter-advanced.xml:3110
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyUI extends UI {\n"
"    UserData userData;\n"
"\n"
"    public void init() {\n"
"        userData = new UserData();\n"
"    }\n"
"\n"
"    public UserData getUserData() {\n"
"        return userData;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3112
#, no-c-format
msgid ""
"Vaadin offers two ways to access the UI object: with <methodname>getUI()</"
"methodname> method from any component and the global <methodname>UI."
"getCurrent()</methodname> method."
msgstr ""
"Vaadin 提供了两种方式访问 UI 对象: 通过任何组件, 使用它的 "
"<methodname>getUI()</methodname> 方法, 以及使用全局方法 <methodname>UI."
"getCurrent()</methodname>."

#. Tag: para
#: chapter-advanced.xml:3118
#, no-c-format
msgid "The <methodname>getUI()</methodname> works as follows:"
msgstr "<methodname>getUI()</methodname> 方法的用法如下:"

#. Tag: programlisting
#: chapter-advanced.xml:3122
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[data = ((MyUI)component.getUI())."
"getUserData();]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3124
#, no-c-format
msgid ""
"This does not, however work in many cases, because it requires that the "
"components are attached to the UI. That is not the case most of the time "
"when the UI is still being built, such as in constructors."
msgstr ""
"但是这种方式在大多数情况下是无用的, 因为它需要组件绑定到 UI 上. 在 UI 的创建"
"过程中, 比如在构造方法中, 就无法满足这个要求了."

#. Tag: programlisting
#: chapter-advanced.xml:3130
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {\n"
"    public MyComponent() {\n"
"        // This fails with NullPointerException\n"
"        Label label = new Label(\"Country: \" +\n"
"            getApplication().getLocale().getCountry());\n"
"\n"
"        setCompositionRoot(label);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3133
#, no-c-format
msgid ""
"The global access methods for the currently served servlet, session, and UI "
"allow an easy way to access the data:"
msgstr "通过取得当前 Servlet, Session, UI 的全局方法, 可以十分便利地得到数据:"

#. Tag: programlisting
#: chapter-advanced.xml:3138
#, no-c-format
msgid "<![CDATA[data = ((MyUI) UI.getCurrent()).getUserData();]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:3141
#, no-c-format
msgid "The Problem"
msgstr "问题"

#. Tag: para
#: chapter-advanced.xml:3143
#, no-c-format
msgid ""
"The basic problem in accessing session-global data is that the "
"<methodname>getUI()</methodname> method works only after the component has "
"been attached to the application. Before that, it returns <parameter>null</"
"parameter>. This is the case in constructors of components, such as a "
"<classname>CustomComponent</classname>:"
msgstr ""
"访问 Session 全局数据的基本问题是 <methodname>getUI()</methodname> 方法只能在"
"组件绑定到应用程序之后才可以工作. 在此之前, 这个方法只会返回 "
"<parameter>null</parameter>. 在组件的构造方法中就会如此, 比如在 "
"<classname>CustomComponent</classname> 的构造方法中:"

#. Tag: para
#: chapter-advanced.xml:3151
#, no-c-format
msgid ""
"Using a static variable or a singleton implemented with such to give a "
"global access to user session data is not possible, because static variables "
"are global in the entire web application, not just the user session. This "
"can be handy for communicating data between the concurrent sessions, but "
"creates a problem within a session."
msgstr ""
"使用静态变量, 或使用单子实现来访问用户 Session 数据是不可能的, 因为静态变量是"
"在整个 Web 应用程序范围内唯一的, 而不仅仅是在当前用户 Session 中唯一. 这种方"
"案在并发的多个 session 之间共享数据是有用的, 但为了在 session 内共享数据就不"
"可行了."

#. Tag: para
#: chapter-advanced.xml:3159
#, no-c-format
msgid ""
"The data would be shared by all users and be reinitialized every time a new "
"user opens the application."
msgstr ""
"这类数据会被所有的用户共享, 而且每次新用户打开应用程序时都会重新初始化这些数"
"据."

#. Tag: title
#: chapter-advanced.xml:3166
#, no-c-format
msgid "Overview of Solutions"
msgstr "解决方案概要"

#. Tag: para
#: chapter-advanced.xml:3168
#, no-c-format
msgid ""
"To get the application object or any other global data, you have the "
"following solutions:"
msgstr "为了取得 application 对象或其他全局数据, 有以下几种解决方案:"

#. Tag: para
#: chapter-advanced.xml:3175
#, no-c-format
msgid "Pass a reference to the global data as a parameter"
msgstr "将全局数据的引用作为参数传递"

#. Tag: para
#: chapter-advanced.xml:3180
#, no-c-format
msgid "Initialize components in <methodname>attach()</methodname> method"
msgstr "在 <methodname>attach()</methodname> 方法内初始化组件"

#. Tag: para
#: chapter-advanced.xml:3185
#, no-c-format
msgid ""
"Initialize components in the <methodname>enter()</methodname> method of the "
"navigation view (if using navigation)"
msgstr ""
"(如果使用视图导航的话)在视图导航跳转的 <methodname>enter()</methodname> 方法"
"内初始化组件"

#. Tag: para
#: chapter-advanced.xml:3191
#, no-c-format
msgid ""
"Store a reference to global data using the <emphasis>ThreadLocal Pattern</"
"emphasis>"
msgstr "使用 <emphasis>ThreadLocal 模式</emphasis> 保存全局数据"

#. Tag: para
#: chapter-advanced.xml:3197
#, no-c-format
msgid "Each solution is described in the following sections."
msgstr "上述各种解决方案会在以下各节分别解释."

#. Tag: title
#: chapter-advanced.xml:3203
#, no-c-format
msgid "Passing References Around"
msgstr "传递对象引用"

#. Tag: para
#: chapter-advanced.xml:3205
#, no-c-format
msgid ""
"You can pass references to objects as parameters. This is the normal way in "
"object-oriented programming."
msgstr "你可以将对象的引用作为参数来传递. 这是面向对象编程中的常见方式."

#. Tag: programlisting
#: chapter-advanced.xml:3210
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyApplication extends Application {\n"
"    UserData userData;\n"
"\n"
"    public void init() {\n"
"        Window mainWindow = new Window(\"My Window\");\n"
"        setMainWindow(mainWindow);\n"
"\n"
"        userData = new UserData();\n"
"        \n"
"        mainWindow.addComponent(new MyComponent(this));\n"
"    }\n"
"\n"
"    public UserData getUserData() {\n"
"        return userData;\n"
"    }\n"
"}\n"
"\n"
"class MyComponent extends CustomComponent {\n"
"    public MyComponent(MyApplication app) {\n"
"        Label label = new Label(\"Name: \" +\n"
"            app.getUserData().getName());\n"
"\n"
"        setCompositionRoot(label);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3212
#, no-c-format
msgid ""
"If you need the reference in other methods, you either have to pass it again "
"as a parameter or store it in a member variable."
msgstr ""
"如果在其他方法中需要这些引用, 那么你必须再次把它作为参数传递过去, 或者保存在"
"成员变量中以便其他方法访问."

#. Tag: para
#: chapter-advanced.xml:3217
#, no-c-format
msgid ""
"The problem with this solution is that practically all constructors in the "
"application need to get a reference to the application object, and passing "
"it further around in the classes is another hard task."
msgstr ""
"这个方案的问题是它会导致应用程序中所有构造方法都需要一个 application 参数, 而"
"且在这些类内部还需要将 application 参数继续传递给需要它的方法, 这也是一个很麻"
"烦的任务."

#. Tag: title
#: chapter-advanced.xml:3225
#, no-c-format
msgid "Overriding <methodname>attach()</methodname>"
msgstr "覆盖 <methodname>attach()</methodname> 方法"

#. Tag: para
#: chapter-advanced.xml:3227
#, no-c-format
msgid ""
"The <methodname>attach()</methodname> method is called when the component is "
"attached to the application component through containment hierarchy. The "
"<methodname>getApplication()</methodname> method always works."
msgstr ""
"当组件绑定到应用程序的组件包含层级关系中时, 会调用 <methodname>attach()</"
"methodname> 方法. 这时 <methodname>getApplication()</methodname> 方法是可以使"
"用的."

#. Tag: programlisting
#: chapter-advanced.xml:3234
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyComponent extends CustomComponent {\n"
"    public MyComponent() {\n"
"        // Must set a dummy root in constructor\n"
"        setCompositionRoot(new Label(\"\"));\n"
"    }\n"
"\n"
"    @Override\n"
"    public void attach() {    \n"
"        Label label = new Label(\"Name: \" +\n"
"            ((MyApplication)component.getApplication())\n"
"                .getUserData().getName());\n"
"\n"
"        setCompositionRoot(label);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3236
#, no-c-format
msgid ""
"While this solution works, it is slightly messy. You may need to do some "
"initialization in the constructor, but any construction requiring the global "
"data must be done in the <methodname>attach()</methodname> method. "
"Especially, <classname>CustomComponent</classname> requires that the "
"<methodname>setCompositionRoot()</methodname> method is called in the "
"constructor. If you can't create the actual composition root component in "
"the constructor, you need to use a temporary dummy root, as is done in the "
"example above."
msgstr ""
"这种方案虽然可以工作, 但略为混乱. 你有可能会需要在构造方法中进行一些初始化工"
"作, 但如果需要使用全局数据的话, 又必须在 <methodname>attach()</methodname> 方"
"法内执行. 尤其是, <classname>CustomComponent</classname> 需要在构造方法中调"
"用 <methodname>setCompositionRoot()</methodname> 方法. 如果你在构造方法中无法"
"创建实际的根组件, 你就必须使用一个临时性的 dummy 根组件, 如上例所示."

#. Tag: para
#: chapter-advanced.xml:3247
#, no-c-format
msgid ""
"Using <methodname>getApplication()</methodname> also needs casting if you "
"want to use methods defined in your application class."
msgstr ""
"如果你希望访问你的 application 类中定义的方法, 那么使用 "
"<methodname>getApplication()</methodname> 得到的 application 对象还需要进行类"
"型转换."

#. Tag: title
#: chapter-advanced.xml:3254
#, no-c-format
msgid "ThreadLocal Pattern"
msgstr "ThreadLocal 模式"

#. Tag: primary
#: chapter-advanced.xml:3256
#, no-c-format
msgid "ThreadLocal pattern"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3258
#, no-c-format
msgid ""
"Vaadin uses the ThreadLocal pattern for allowing global access to the "
"<classname>&uiclass;</classname>, and <classname>Page</classname> objects of "
"the currently processed server request with a static "
"<methodname>getCurrent()</methodname> method in all the respective classes. "
"This section explains why the pattern is used in Vaadin and how it works. "
"You may also need to reimplement the pattern for some purpose."
msgstr ""
"Vaadin 使用 ThreadLocal 模式来实现当前服务器请求的 <classname>&uiclass;</"
"classname>, 和 <classname>Page</classname> 对象的全局访问, 通过各类的 "
"<methodname>getCurrent()</methodname> 静态方法就可以得到这些对象. 本节介绍 "
"Vaadin 为什么使用这种模式, 以及它的工作原理. 为了达到某种特定的目的, 你可能会"
"需要重新实现这种模式."

#. Tag: para
#: chapter-advanced.xml:3269
#, no-c-format
msgid ""
"The ThreadLocal pattern gives a solution to the global access problem by "
"solving two sub-problems of static variables."
msgstr ""
"ThreadLocal 模式为了解决全局数据的访问问题, 将其分解为与静态变量相关的两个子"
"问题来分别解决."

#. Tag: para
#: chapter-advanced.xml:3274
#, no-c-format
msgid ""
"As the first problem, assume that the servlet container processes requests "
"for many users (sessions) sequentially. If a static variable is set in a "
"request belonging one user, it could be read or re-set by the next incoming "
"request belonging to another user. This can be solved by setting the global "
"reference at the beginning of each HTTP request to point to data of the "
"current user, as illustrated in Figure <xref linkend=\"figure.advanced."
"global.threadlocal.sequentiality\" xrefstyle=\"select:labelnumber\"/>."
msgstr ""
"第一个子问题是, 假定 Servlet 容器对多个用户(session)的请求顺序地处理. 如果在"
"属于某个用户的一个请求之内设置了静态变量, 这个变量可能会被属于另一个用户的下"
"一个请求读取, 或者重新设置. 解决这个问题的方法是, 在每个 HTTP 请求的开始处, "
"将全局引用设置为指向当期用户的数据, 参见 <xref linkend=\"figure.advanced."
"global.threadlocal.sequentiality\" xrefstyle=\"select:labelnumber\"/>."

#. Tag: title
#: chapter-advanced.xml:3286
#, no-c-format
msgid ""
"Switching a static (or ThreadLocal) reference during sequential processing "
"of requests"
msgstr "在顺序处理的多个请求中切换静态(或者 ThreadLocal) 的对象引用"

#. Tag: para
#: chapter-advanced.xml:3310
#, no-c-format
msgid ""
"The second problem is that servlet containers typically do thread pooling "
"with multiple worker threads that process requests. Therefore, setting a "
"static reference would change it in all threads running concurrently, "
"possibly just when another thread is processing a request for another user. "
"The solution is to store the reference in a thread-local variable instead of "
"a static. You can do so by using the <classname>ThreadLocal</classname> "
"class in Java for the switch reference."
msgstr ""
"第二个子问题是 Servlet 容器通常会使用线程池中的多个工作线程来并发地处理多个请"
"求. 因此, 设置静态引用, 会使得它在并发执行的所有线程之内都被改变, 此时可能恰"
"好另一个线程正在处理属于另一个用户的请求. 这个问题的解决方案是使用 thread-"
"local 变量来保存数据引用, 而不是使用静态变量. 因此你可以使用 Java 的 "
"<classname>ThreadLocal</classname> 类来切换数据引用."

#. Tag: title
#: chapter-advanced.xml:3321
#, no-c-format
msgid ""
"Switching <classname>ThreadLocal</classname> references during concurrent "
"processing of requests"
msgstr "在并发处理多个请求时切换 <classname>ThreadLocal</classname> 引用"

#. Tag: title
#: chapter-advanced.xml:3379
#, no-c-format
msgid "Server Push"
msgstr "服务器端 PUSH"

#. Tag: para
#: chapter-advanced.xml:3381
#, no-c-format
msgid ""
"When you need to update a UI from another UI, possibly of another user, or "
"from a background thread running in the server, you usually want to have the "
"update show immediately, not when the browser happens to make the next "
"server request. For this purpose, you can use <emphasis>server push</"
"emphasis> that sends the data to the browser immediately. Push is based on a "
"client-server connection, usually a WebSocket connection, that the client "
"establishes and the server can then use to send updates to the client."
msgstr ""
"如果你需要从一个 UI 来更新另一个 UI(可能属于另一个用户), 或者通过服务器端运行"
"的背景线程来更新 UI, 你通常会希望这个更新动作立即发生, 而不是一直等到浏览器"
"(不知何年何月.....)发起下一次请求时才有机会完成更新. 为了达到这个目的, 你可以"
"使用 <emphasis>服务器端PUSH</emphasis> 功能, 即时发送数据到浏览器端. PUSH 的"
"基础是客户端和服务器端之间的连接, 通常使用 WebSocket 连接, 由客户端负责创建这"
"个连接, 服务器端可以使用这个连接将更新信息发送给客户端."

#. Tag: para
#: chapter-advanced.xml:3391
#, no-c-format
msgid ""
"The server-client communication is done by default with a WebSocket "
"connection if the browser and the server support it. If not, Vaadin will "
"fall back to a method supported by the browser. Vaadin Push uses a custom "
"build of the <link xlink:href=\"https://github.com/Atmosphere/atmosphere"
"\">Atmosphere framework</link> for client-server communication."
msgstr ""
"服务器端与客户端的通信默认使用 WebSocket 连接, 但前提是浏览器和服务器都要支"
"持 WebSocket. 如果不支持, Vaadin 会使用浏览器能够支持的替代方案. Vaadin PUSH "
"功能的客户端与服务器端通信, 使用一个定制编译版的 <link xlink:href=\"https://"
"github.com/Atmosphere/atmosphere\">Atmosphere framework</link>."

#. Tag: title
#: chapter-advanced.xml:3400
#, no-c-format
msgid "Installing the Push Support"
msgstr "安装 PUSH 功能"

#. Tag: para
#: chapter-advanced.xml:3402
#, no-c-format
msgid ""
"The server push support in Vaadin requires the separate Vaadin Push library. "
"It is included in the installation package as <filename>vaadin-push.jar</"
"filename>."
msgstr ""
"Vaadin 所支持的服务器端 PUSH 需要单独的 Vaadin PUSH 库. 这个库包含在安装包"
"中, 文件名是 <filename>vaadin-push.jar</filename>."

#. Tag: title
#: chapter-advanced.xml:3409
#, no-c-format
msgid "Retrieving with Ivy"
msgstr "通过 Ivy 取得 PUSH 库"

#. Tag: para
#: chapter-advanced.xml:3411
#, no-c-format
msgid ""
"With Ivy, you can get it with the following declaration in the <filename>ivy."
"xml</filename>:"
msgstr ""
"使用 Ivy 时, 你可以使用 <filename>ivy.xml</filename> 中的以下声明来得到 PUSH "
"库:"

#. Tag: programlisting
#: chapter-advanced.xml:3416
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[<dependency org=\"com.vaadin\" name=\"vaadin-"
"push\"\n"
"            rev=\"&vaadin.version;\" conf=\"default->default\"/>]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3418
#, no-c-format
msgid ""
"In some servers, you may need to exlude a <literal>sl4j</literal> dependency "
"as follows:"
msgstr "在某些服务器中, 你可能需要除去对 <literal>sl4j</literal> 的依赖, 如下:"

#. Tag: programlisting
#: chapter-advanced.xml:3423
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[<dependency org=\"com.vaadin\" name=\"vaadin-"
"push\"\n"
"            rev=\"&vaadin.version;\" conf=\"default->default\">\n"
"    <exclude org=\"org.slf4j\" name=\"slf4j-api\"/>\n"
"</dependency>]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3425
#, no-c-format
msgid ""
"Pay note that the Atmosphere library is a bundle, so if you retrieve the "
"libraries with Ant, for example, you need to retrieve <literal>type=\"jar,"
"bundle\"</literal>."
msgstr ""
"注意, Atmosphere 库是以 bundle 形式提供的, 所以如果你使用 Ant, 你需要以 "
"<literal>type=\"jar,bundle\"</literal> 的方式来取得这个库."

#. Tag: title
#: chapter-advanced.xml:3433
#, no-c-format
msgid "Retrieving with Maven"
msgstr "使用 Maven 取得 PUSH 库"

#. Tag: para
#: chapter-advanced.xml:3435
#, no-c-format
msgid ""
"In Maven, you can get the push library with the following dependency in the "
"POM:"
msgstr "在 Maven 中, 你可以在 POM 中使用以下依赖关系来得到 PUSH 库:"

#. Tag: programlisting
#: chapter-advanced.xml:3440
#, no-c-format
msgid ""
"<![CDATA[<dependency>\n"
"    <groupId>com.vaadin</groupId>\n"
"    <artifactId>vaadin-push</artifactId>\n"
"    <version>${vaadin.version}</version>\n"
"</dependency>]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:3445
#, no-c-format
msgid "Enabling Push for a UI"
msgstr "对一个 UI 允许 PUSH 功能"

#. Tag: para
#: chapter-advanced.xml:3447
#, no-c-format
msgid ""
"To enable server push, you need to define the push mode either in the "
"deployment descriptor or with the <classname>@Push</classname> annotation "
"for the UI."
msgstr ""
"要激活服务器端 PUSH 功能, 你需要定义 PUSH 模式, 可以使用描述符来定义, 也可以"
"在 UI 类上使用 <classname>@Push</classname> 注解."

#. Tag: title
#: chapter-advanced.xml:3454
#, no-c-format
msgid "Push Modes"
msgstr "PUSH 模式"

#. Tag: para
#: chapter-advanced.xml:3456
#, no-c-format
msgid ""
"You can use server push in two modes: <literal>automatic</literal> and "
"<literal>manual</literal>. The automatic mode pushes changes to the browser "
"automatically after access() finishes. With the manual mode, you can do the "
"push explicitly with <methodname>push()</methodname>, which allows more "
"flexibility."
msgstr ""
"服务器端 PUSH 的模式有两种: <literal>自动</literal> 模式和 <literal>manual</"
"literal> 模式. 自动模式会在 access() 结束后将更新内容自动PUSH 到浏览器端. 手"
"动模式下, 你可以使用 <methodname>push()</methodname> 方法显式地进行 PUSH, 这"
"种方法的灵活性更高一些."

#. Tag: title
#: chapter-advanced.xml:3466
#, no-c-format
msgid "The <classname>@Push</classname> annotation"
msgstr "<classname>@Push</classname> 注解"

#. Tag: para
#: chapter-advanced.xml:3468
#, no-c-format
msgid ""
"You can enable server push for a UI with the <classname>@Push</classname> "
"annotation as follows. It defaults to automatic mode (<parameter>PushMode."
"AUTOMATIC</parameter>)."
msgstr ""
"如下例所示, 你可以使用 <classname>@Push</classname>注解, 对一个 UI 激活服务器"
"端 PUSH功能. 这个注解默认是自动模式(<parameter>PushMode.AUTOMATIC</"
"parameter>)."

#. Tag: programlisting
#: chapter-advanced.xml:3474
#, no-c-format
msgid ""
"<![CDATA[@Push\n"
"public class PushyUI extends UI {]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3476
#, no-c-format
msgid ""
"To enable manual mode, you need to give the <parameter>PushMode.MANUAL</"
"parameter> parameter as follows:"
msgstr ""
"要使用手动模式, 你需要使用 <parameter>PushMode.MANUAL</parameter> 参数, 如下"
"例:"

#. Tag: programlisting
#: chapter-advanced.xml:3481
#, no-c-format
msgid ""
"<![CDATA[@Push(PushMode.MANUAL)\n"
"public class PushyUI extends UI {]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:3485
#, no-c-format
msgid "Servlet Configuration"
msgstr "Servlet 配置"

#. Tag: para
#: chapter-advanced.xml:3487
#, no-c-format
msgid ""
"You can enable the server push and define the push mode also in the servlet "
"configuration with the <parameter>pushmode</parameter> parameter for the "
"servlet in the <filename>web.xml</filename> deployment descriptor. If you "
"use a Servlet 3.0 compatible server, you also want to enable asynchronous "
"processing with the <literal>async-supported</literal> parameter. Note the "
"use of Servlet 3.0 schema in the deployment descriptor."
msgstr ""
"通过 Servlet 配置也可以启用服务器端 PUSH 功能, 并设置 PUSH 模式, 方法是在部署"
"描述文件 <filename>web.xml</filename> 中为 Servlet 指定 <parameter>pushmode</"
"parameter> 参数. 如果使用兼容 Servlet 3.0 规范的服务器, 你还可以使用 "
"<literal>async-supported</literal> 参数来启用异步处理 . 注意, 需要在部署描述"
"文件中使用 Servlet 3.0 的 schema."

#. Tag: programlisting
#: chapter-advanced.xml:3498
#, no-c-format
msgid ""
"<?pocket-size 70% ?>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n"
"&lt;web-app\n"
"  id=\"WebApp_ID\" version=\"<emphasis role=\"bold\">3.0</emphasis>\"\n"
"  xmlns=\"<emphasis role=\"bold\">http://java.sun.com/xml/ns/javaee</"
"emphasis>\"\n"
"  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \n"
"  xsi:schemaLocation=\"<emphasis role=\"bold\">http://java.sun.com/xml/ns/"
"javaee\n"
"      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd</emphasis>\"&gt;\n"
"  &lt;servlet&gt;\n"
"    &lt;servlet-name&gt;Pushy UI&lt;/servlet-name&gt;\n"
"    &lt;servlet-class&gt;\n"
"        com.vaadin.server.VaadinServlet&lt;/servlet-class&gt;\n"
"\n"
"    &lt;init-param&gt;\n"
"        &lt;param-name&gt;UI&lt;/param-name&gt;\n"
"        &lt;param-value&gt;<emphasis role=\"bold\">com.example.my.PushyUI</"
"emphasis>&lt;/param-value&gt;\n"
"    &lt;/init-param&gt;\n"
"\n"
"    &lt;!-- Enable server push --&gt;\n"
"    &lt;init-param&gt;\n"
"      &lt;param-name&gt;pushmode&lt;/param-name&gt;\n"
"      &lt;param-value&gt;<emphasis role=\"bold\">automatic</emphasis>&lt;/"
"param-value&gt;\n"
"    &lt;/init-param&gt;\n"
"    &lt;async-supported&gt;<emphasis role=\"bold\">true</emphasis>&lt;/async-"
"supported&gt;\n"
"  &lt;/servlet&gt;\n"
"&lt;/web-app&gt;"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:3502
#, no-c-format
msgid "Accessing UI from Another Thread"
msgstr "在其他线程中访问 UI"

#. Tag: para
#: chapter-advanced.xml:3504
#, no-c-format
msgid ""
"Making changes to a <classname>UI</classname> object from another thread and "
"pushing them to the browser requires locking the user session when accessing "
"the UI. Otherwise, the UI update done from another thread could conflict "
"with a regular event-driven update and cause either data corruption or "
"deadlocks. Because of this, you may only access an UI using the "
"<methodname>access()</methodname> method, which locks the session to prevent "
"conflicts. It takes a <interfacename>Runnable</interfacename> which it "
"executes as its parameter."
msgstr ""
"在其他线程中变更 <classname>UI</classname> 对象, 并将这些变更 PUSH 到浏览器"
"端, 这个操作需要在访问 UI 时对用户 session 加锁. 否则, 在其他线程中对 UI 的变"
"更会与通常的事件驱动的 UI 更新发生冲突, 结果导致数据丢失, 或死锁. 由于这个问"
"题, 你只能使用 <methodname>access()</methodname> 方法来访问 UI, 这个方法会锁"
"住 session, 防止前面所说的冲突. 这个方法的参数是一个 "
"<interfacename>Runnable</interfacename>, 并在方法内部执行它."

#. Tag: programlisting
#: chapter-advanced.xml:3519
#, no-c-format
msgid ""
"<![CDATA[ui.access(new Runnable() {\n"
"    @Override\n"
"    public void run() {\n"
"        series.add(new DataSeriesItem(x, y));\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3521
#, no-c-format
msgid ""
"In Java 8, where a parameterless lambda expression creates a runnable, you "
"could simply write:"
msgstr "在 Java 8 中, 无参数的 lambda 表达式可会创建一个 Runnable, 所以代码可以简化为:"

#. Tag: programlisting
#: chapter-advanced.xml:3526
#, no-c-format
msgid ""
"<![CDATA[ui.access(() ->\n"
"        series.add(new DataSeriesItem(x, y)));]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3528
#, no-c-format
msgid ""
"If the push mode is <literal>manual</literal>, you need to push the pending "
"UI changes to the browser explicitly with the <methodname>push()</"
"methodname> method."
msgstr ""
"如果 PUSH 模式是 <literal>手动</literal> 模式, 你需要使用 "
"<methodname>push()</methodname> 方法, 显式地将 UI 的变更 PUSH 到浏览器端."

#. Tag: programlisting
#: chapter-advanced.xml:3534
#, no-c-format
msgid ""
"<![CDATA[ui.access(new Runnable() {\n"
"    @Override\n"
"    public void run() {\n"
"        series.add(new DataSeriesItem(x, y));\n"
"        ui.push();\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3537
#, no-c-format
msgid ""
"Below is a complete example of a case where we make UI changes from another "
"thread."
msgstr "下面是一个完整的例子, 我们在另一个线程中对 UI 进行更新."

#. Tag: programlisting
#: chapter-advanced.xml:3543
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class PushyUI extends UI {\n"
"    Chart chart = new Chart(ChartType.AREASPLINE);\n"
"    DataSeries series = new DataSeries();\n"
"    \n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        chart.setSizeFull();\n"
"        setContent(chart);\n"
"        \n"
"        // Prepare the data display\n"
"        Configuration conf = chart.getConfiguration();\n"
"        conf.setTitle(\"Hot New Data\");\n"
"        conf.setSeries(series);\n"
"        \n"
"        // Start the data feed thread\n"
"        new FeederThread().start();\n"
"    }\n"
"    \n"
"    class FeederThread extends Thread {\n"
"        int count = 0;\n"
"        \n"
"        @Override\n"
"        public void run() {\n"
"            try {\n"
"                // Update the data for a while\n"
"                while (count < 100) {\n"
"                    Thread.sleep(1000);\n"
"                \n"
"                    access(new Runnable() {\n"
"                        @Override\n"
"                        public void run() {\n"
"                            double y = Math.random();\n"
"                            series.add(\n"
"                                new DataSeriesItem(count++, y),\n"
"                                true, count > 10);\n"
"                        }\n"
"                    });\n"
"                }\n"
"\n"
"                // Inform that we have stopped running\n"
"                access(new Runnable() {\n"
"                    @Override\n"
"                    public void run() {\n"
"                        setContent(new Label(\"Done!\"));\n"
"                    }\n"
"                });\n"
"            } catch (InterruptedException e) {\n"
"                e.printStackTrace();\n"
"            }\n"
"        }\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3545
#, no-c-format
msgid ""
"When sharing data between UIs or user sessions, you need to consider the "
"message-passing mechanism more carefully, as explained next."
msgstr ""
"当在多个 UI 实例(也就是多个用户 Session)之间共享数据时, 你需要更加小心地考虑"
"消息传递机制, 详情见下一节."

#. Tag: title
#: chapter-advanced.xml:3552
#, no-c-format
msgid "Broadcasting to Other Users"
msgstr "向其他用户发送广播"

#. Tag: para
#: chapter-advanced.xml:3554
#, no-c-format
msgid ""
"Broadcasting messages to be pushed to UIs in other user sessions requires "
"having some sort of message-passing mechanism that sends the messages to all "
"UIs that register as recipients. As processing server requests for different "
"UIs is done concurrently in different threads of the application server, "
"locking the threads properly is very important to avoid deadlock situations."
msgstr ""
"将需要 PUSH 的消息广播到属于其他用户 session 的 UI 中去, 这样的任务需要使用某"
"种消息传递机制, 来将消息发送给所有注册为消息接收者的 UI. 由于不同 UI 的服务器"
"请求, 是在应用程序服务器中的不同线程中并发处理的, 因此为了避免死锁, 需要对这"
"些线程正确地加锁."

#. Tag: title
#: chapter-advanced.xml:3564
#, no-c-format
msgid "The Broadcaster"
msgstr "广播器"

#. Tag: para
#: chapter-advanced.xml:3566
#, no-c-format
msgid ""
"The standard pattern for sending messages to other users is to use a "
"<emphasis>broadcaster</emphasis> singleton that registers the UIs and "
"broadcasts messages to them safely. To avoid deadlocks, it is recommended "
"that the messages should be sent through a message queue in a separate "
"thread. Using a Java <classname>ExecutorService</classname> running in a "
"single thread is usually the easiest and safest way."
msgstr ""
"发送消息到其他用户的标准模式是使用 <emphasis>广播器(broadcaster)</emphasis> "
"单体, 它负责注册 UI, 并向 UI 安全地广播消息. 为了避免死锁, 建议在独立的线程中"
"使用消息队列来发送消息. 通常最简单最安全的方法是, 使用一个运行在单线程内的 "
"Java <classname>ExecutorService</classname>."

#. Tag: programlisting
#: chapter-advanced.xml:3577
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class Broadcaster implements "
"Serializable {\n"
"    static ExecutorService executorService =\n"
"        Executors.newSingleThreadExecutor();\n"
"\n"
"    public interface BroadcastListener {\n"
"        void receiveBroadcast(String message);\n"
"    }\n"
"    \n"
"    private static LinkedList<BroadcastListener> listeners =\n"
"        new LinkedList<BroadcastListener>();\n"
"    \n"
"    public static synchronized void register(\n"
"            BroadcastListener listener) {\n"
"        listeners.add(listener);\n"
"    }\n"
"    \n"
"    public static synchronized void unregister(\n"
"            BroadcastListener listener) {\n"
"        listeners.remove(listener);\n"
"    }\n"
"    \n"
"    public static synchronized void broadcast(\n"
"            final String message) {\n"
"        for (final BroadcastListener listener: listeners)\n"
"            executorService.execute(new Runnable() {\n"
"                @Override\n"
"                public void run() {\n"
"                    listener.receiveBroadcast(message);\n"
"                }\n"
"            });\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-advanced.xml:3579
#, no-c-format
msgid ""
"In Java 8, you could use lambda expressions for the listeners instead of the "
"interface, and a parameterless expression to create the runnable:"
msgstr "在 Java 8 中, 你可以使用 lambda 表达式代替接口来作为事件监听器, 还可以使用无参数的 lambda 表达式 来创建 Runnable:"

#. Tag: programlisting
#: chapter-advanced.xml:3585
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[for (final Consumer<String> listener: "
"listeners)\n"
"    executorService.execute(() ->\n"
"            listener.accept(message));]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:3589
#, no-c-format
msgid "Receiving Broadcasts"
msgstr "接收广播"

#. Tag: para
#: chapter-advanced.xml:3591
#, no-c-format
msgid ""
"The receivers need to implement the receiver interface and register to the "
"broadcaster to receive the broadcasts. A listener should be unregistered "
"when the UI expires. When updating the UI in a receiver, it should be done "
"safely as described earlier, by executing the update through the "
"<methodname>access()</methodname> method of the UI."
msgstr ""
"广播消息的接收者需要实现 receiver 接口, 并将自己注册到广播器中, 才能接收到广"
"播消息. UI 过期时, 监听器需要取消注册. 在消息接收者中更新  UI 时, 必须象前文"
"介绍过的那样安全地实现更新, 更新动作必须通过 UI 的 <methodname>access()</"
"methodname> 方法来完成."

#. Tag: programlisting
#: chapter-advanced.xml:3600
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[@Push\n"
"public class PushAroundUI extends UI\n"
"       implements Broadcaster.BroadcastListener {\n"
"    \n"
"    VerticalLayout messages = new VerticalLayout();\n"
"\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        ... build the UI ...\n"
"        \n"
"        // Register to receive broadcasts\n"
"        Broadcaster.register(this);\n"
"    }\n"
"\n"
"    // Must also unregister when the UI expires    \n"
"    @Override\n"
"    public void detach() {\n"
"        Broadcaster.unregister(this);\n"
"        super.detach();\n"
"    }\n"
"\n"
"    @Override\n"
"    public void receiveBroadcast(final String message) {\n"
"        // Must lock the session to execute logic safely\n"
"        access(new Runnable() {\n"
"            @Override\n"
"            public void run() {\n"
"                // Show it somehow\n"
"                messages.addComponent(new Label(message));\n"
"            }\n"
"        });\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-advanced.xml:3604
#, no-c-format
msgid "Sending Broadcasts"
msgstr "发送广播消息"

#. Tag: para
#: chapter-advanced.xml:3606
#, no-c-format
msgid ""
"To send broadcasts with a broadcaster singleton, such as the one described "
"above, you would only need to call the <methodname>broadcast()</methodname> "
"method as follows."
msgstr ""
"为了使用上面介绍的广播器单子来发送广播消息, 你只需要调用 "
"<methodname>broadcast()</methodname> 方法, 如下."

#. Tag: programlisting
#: chapter-advanced.xml:3613
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[final TextField input = new TextField();\n"
"sendBar.addComponent(input);\n"
"\n"
"Button send = new Button(\"Send\");\n"
"send.addClickListener(new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        // Broadcast the message\n"
"        Broadcaster.broadcast(input.getValue());\n"
"        \n"
"        input.setValue(\"\");\n"
"    }\n"
"});]]>"
msgstr ""

