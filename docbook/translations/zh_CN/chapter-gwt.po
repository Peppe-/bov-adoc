# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-11-07 16:28+0000\n"
"PO-Revision-Date: 2014-11-08 01:28+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-gwt.xml:11
#, no-c-format
msgid "Integrating with the Server-Side"
msgstr "与客户端集成"

#. Tag: primary
#: chapter-gwt.xml:14
#, no-c-format
msgid "Google Web Toolkit"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:15
#, no-c-format
msgid "<secondary>widgets</secondary>"
msgstr ""

#. Tag: primary
#: chapter-gwt.xml:17
#, no-c-format
msgid "<primary>widgets</primary>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:19
#, no-c-format
msgid ""
"This chapter describes how you can integrate client-side widgets or "
"JavaScript components with a server-side component. The client-side "
"implementations of all standard server-side components in Vaadin use the "
"same client-side interfaces and patterns."
msgstr ""
"本章将介绍如何实现客户端 widget 或 JavaScript 组件与服务器端组件的集成. "
"Vaadin 中的所有服务器端标准组件, 其客户端实现都使用相同的客户端接口和模式."

#. Tag: title
#: chapter-gwt.xml:27
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-gwt.xml:29
#, no-c-format
msgid ""
"Vaadin components consist of two parts: a server-side and a client-side "
"component. The latter are also called <emphasis>widgets</emphasis> in Google "
"Web Toolkit (GWT) parlance. A Vaadin application uses the API of the server-"
"side component, which is rendered as a client-side widget in the browser. As "
"on the server-side, the client-side widgets form a hierarchy of layout "
"widgets and regular widgets as the leaves."
msgstr ""
"Vaadin 组件由两部分组成: 服务器端组件, 以及客户端组件. 在 Google Web Toolkit "
"(GWT) 术语中, 客户端组件又被称为 <emphasis>widget</emphasis>. Vaadin 应用程序"
"使用服务器端组件的 API, 服务器端组件最终在浏览器中显示为客户端 widget. 与服务"
"器端一样, 客户端 widget 构成一个布局 widget 的层级树, 其他通常 widget 则是这"
"个层级树上的最末端叶节点."

#. Tag: title
#: chapter-gwt.xml:39
#, no-c-format
msgid "Integration of Client-Side Widgets"
msgstr "客户端 Widget 的集成"

#. Tag: para
#: chapter-gwt.xml:50
#, no-c-format
msgid ""
"The communication between a client-side widget and a server-side component "
"is managed with a <emphasis>connector</emphasis> that handles syncronizing "
"the widget state and events to and from the server-side."
msgstr ""
"客户端 widget 与服务器端组件之间的通信由 <emphasis>连接器(connector)</"
"emphasis> 管理, 连接器负责在客户端与服务器端之间维护 widget 状态与事件的双向"
"同步."

#. Tag: primary
#: chapter-gwt.xml:55
#, no-c-format
msgid "connector"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:58
#, no-c-format
msgid ""
"When rendering the user interface, a client-side connector and a widget are "
"created for each server-side component. The mapping from a component to a "
"connector is defined in the connector class with a <literal>@Connect</"
"literal> annotation, and the widget is created by the connector class."
msgstr ""
"展现 UI 时, 会为每个服务器端组件创建对应的客户端连接器(connector)和客户端 "
"widget. 组件与连接器的映射关系, 通过 connector 类中的 <literal>@Connect</"
"literal> 注解来定义, widget 则由 connector 类负责创建."

#. Tag: primary
#: chapter-gwt.xml:64
#, no-c-format
msgid "@Connect"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:67
#, no-c-format
msgid ""
"The state of a server-side component is synchronized automatically to the "
"client-side widget using a <emphasis>shared state</emphasis> object. A "
"shared state object implements the <interfacename>ComponentState</"
"interfacename> interface and it is used both in the server-side and the "
"client-side component. On the client-side, a connector always has access to "
"its state instance, as well to the state of its parent component state and "
"the states of its children."
msgstr ""
"服务器端组件的状态信息, 会使用 <emphasis>共享的状态信息</emphasis> 对象自动同"
"步到客户端 widget 中. 共享的状态信息对象实现了 "
"<interfacename>ComponentState</interfacename> 接口, 并在服务端组件与客户端组"
"件中同时使用. 在客户端, 连接器始终可以访问到它的状态对象, 以及它的父组件和子"
"组件状态."

#. Tag: primary
#: chapter-gwt.xml:76
#, no-c-format
msgid "state object"
msgstr ""

#. Tag: classname
#: chapter-gwt.xml:77
#, no-c-format
msgid "ComponentState"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:80
#, no-c-format
msgid ""
"The state sharing assumes that state is defined with standard Java types, "
"such as primitive and boxed primitive types, <classname>String</classname>, "
"arrays, and certain collections (<classname>List</classname>, "
"<classname>Set</classname>, and <classname>Map</classname>) of the supported "
"types. Also the Vaadin <classname>Connector</classname> and some special "
"internal types can be shared."
msgstr ""
"这种状态信息共享方案假定状态信息中使用的是 Java 标准数据类型, 比如基本数据类"
"型(int, float 等)或基本数据类型的封装类(Integer, Float 等), "
"<classname>String</classname>, 数组, 以及由这些类型数据组成的几种集合类型 "
"(<classname>List</classname>, <classname>Set</classname>, 和 <classname>Map</"
"classname>). 除此之外, Vaadin 的 <classname>Connector</classname> 类和其他几"
"种特别的内部类型也可以作为共享状态信息."

#. Tag: para
#: chapter-gwt.xml:89
#, no-c-format
msgid ""
"In addition to state, both server- and client-side can make remote procedure "
"calls (RPC) to the other side. RPC is used foremost for event notifications. "
"For example, when a client-side connector of a button receives a click, it "
"sends the event to the server-side using RPC."
msgstr ""
"除共享状态信息之外, 服务端与客户端还可以向另一端发起远程过程调用(RPC, remote "
"procedure call). RPC 最初用于事件通知. 比如, 当一个按钮的客户端连接器收到一个"
"点击事件, 它会使用 RPC 将这个事件发送给服务器端."

#. Tag: title
#: chapter-gwt.xml:97
#, no-c-format
msgid "Project Structure"
msgstr "工程结构"

#. Tag: para
#: chapter-gwt.xml:99
#, no-c-format
msgid ""
"Widget set compilation, as described in <xref linkend=\"clientside.module\"/"
">, requires using a special project structure, where the client-side classes "
"are located under a <filename>client</filename> package under the package of "
"the module descriptor. Any static resources, such as stylesheets and images, "
"should be located under a <filename>public</filename> folder (not Java "
"package). The source for the server-side component may be located anywhere, "
"except not in the client-side package."
msgstr ""
"Widget set 的编译(详情请参见 <xref linkend=\"clientside.module\"/>), 需要使用"
"一种特定的工程结构, 客户端类放在模块描述文件所在包之下的 <filename>client</"
"filename> 包中. 所有的静态资源, 比如样式表和图片文件, 应该放在 "
"<filename>public</filename> 文件夹(注意, 不是 Java 包)中. 服务器端组件的源代"
"码可以放在客户端代码包之外的任何位置."

#. Tag: para
#: chapter-gwt.xml:110
#, no-c-format
msgid ""
"The basic project structure is illustrated in <xref linkend=\"figure.gwt."
"overview.project\"/>."
msgstr "基本的工程结构参见 <xref linkend=\"figure.gwt.overview.project\"/>."

#. Tag: title
#: chapter-gwt.xml:115
#, no-c-format
msgid "Basic Widget Integration Project Structure"
msgstr "Widget 集成工程的基本结构"

#. Tag: para
#: chapter-gwt.xml:126
#, no-c-format
msgid ""
"The Eclipse wizard, described in <xref linkend=\"gwt.eclipse\"/>, creates a "
"widget integration skeleton with the above structure."
msgstr ""
"Eclipse 向导(详情请参见 <xref linkend=\"gwt.eclipse\"/>), 会帮助你创建 "
"widget 集成工程的框架代码, 结构与上图一样."

#. Tag: title
#: chapter-gwt.xml:133
#, no-c-format
msgid "Integrating JavaScript Components"
msgstr "JavaScript 组件的集成"

#. Tag: para
#: chapter-gwt.xml:135
#, no-c-format
msgid ""
"In addition to the GWT widget integration, Vaadin offers a simplified way to "
"integrate pure JavaScript components. The JavaScript connector code is "
"published from the server-side. As the JavaScript integration does not "
"involve GWT programming, no widget set compilation is needed."
msgstr ""
"除 GWT widget 集成之外, Vaadin 还提供了简单的方法来集成纯 JavaScript 的组件. "
"JavaScript 连接器代码由服务器端发布. 由于 JavaScript 集成与 GWT 无关, 因此不"
"需要编译 widget set."

#. Tag: primary
#: chapter-gwt.xml:141
#, no-c-format
msgid "JavaScript"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:147
#, no-c-format
msgid "Starting It Simple With Eclipse"
msgstr "使用 Eclipse 简化工作"

#. Tag: primary
#: chapter-gwt.xml:150
#, no-c-format
msgid "Eclipse"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:151
#, no-c-format
msgid "widget development"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:154
#, no-c-format
msgid ""
"Let us first take the easy way and create a simple component with Eclipse. "
"While you can develop new widgets with any IDE or even without, you may find "
"Eclipse and the Vaadin Plugin for it useful, as it automates all the basic "
"routines of widget development, most importantly the creation of new widgets."
msgstr ""
"我们首先介绍使用 Eclipse 进行客户端集成的简单方式, 并创建一个简单的组件. 你当"
"然可以使用任意的 IDE 来开发新 widget, 甚至可以不使用 IDE, 但你会发现使用 "
"Eclipse 和 Vaadin Plugin 是非常便利的, 因为它们可以帮助你自动完成 widget 开发"
"中的所有基本工作, 其中最重要的就是创建新 widget."

#. Tag: title
#: chapter-gwt.xml:162
#, no-c-format
msgid "Creating a Widget"
msgstr "创建 Widget"

#. Tag: para
#: chapter-gwt.xml:166
#, no-c-format
msgid ""
"Right-click the project in the Project Explorer and select "
"<menuchoice><guimenu>New</guimenu><guimenuitem>Other...</guimenuitem></"
"menuchoice>."
msgstr ""
"在工程上点击鼠标右键, 然后选择菜单项 <menuchoice><guimenu>New</"
"guimenu><guimenuitem>Other...</guimenuitem></menuchoice>."

#. Tag: para
#: chapter-gwt.xml:172
#, no-c-format
msgid ""
"In the wizard selection, select <menuchoice><guimenu>Vaadin</"
"guimenu><guimenuitem>Vaadin Widget</guimenuitem></menuchoice> and click "
"<guibutton>Next</guibutton>."
msgstr ""
"在向导选择窗口中, 选择 <menuchoice><guimenu>Vaadin</"
"guimenu><guimenuitem>Vaadin Widget</guimenuitem></menuchoice>, 然后点击 "
"<guibutton>Next</guibutton> 按钮."

#. Tag: para
#: chapter-gwt.xml:191
#, no-c-format
msgid ""
"In the <guilabel>New Component Wizard</guilabel>, make the following "
"settings."
msgstr "在 <guilabel>New Component Wizard</guilabel> 窗口中, 进行以下设定."

#. Tag: guilabel
#: chapter-gwt.xml:206
#, no-c-format
msgid "Source folder"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:208
#, no-c-format
msgid ""
"The root folder of the entire source tree. The default value is the default "
"source tree of your project, and you should normally leave it unchanged "
"unless you have a different project structure."
msgstr ""
"指定整个源代码树的根目录. 默认值是你的工程的默认源代码树目录, 通常不要修改这"
"个值, 除非你的工程结构与一般结构不同."

#. Tag: guilabel
#: chapter-gwt.xml:217
#, no-c-format
msgid "Package"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:219
#, no-c-format
msgid ""
"The parent package under which the new server-side component should be "
"created. If the project does not already have a widget set, one is created "
"under this package in the <package>widgetset</package> subpackage. The "
"subpackage will contain the <filename>.gwt.xml</filename> descriptor that "
"defines the widget set and the new widget stub under the <package>widgetset."
"client</package> subpackage."
msgstr ""
"新建的服务器端组件所属的父包. 如果工程中不存在已有的 widget set, 那么会在这个"
"包之下的 <package>widgetset</package> 子包内创建新的 widget set. 子包中会包"
"含 <filename>.gwt.xml</filename> 描述文件, 负责定义 widget set, 在 "
"<package>widgetset.client</package> 子包中还会包含 widget 的根(stub)代码."

#. Tag: guilabel
#: chapter-gwt.xml:232
#, no-c-format
msgid "Name"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:234
#, no-c-format
msgid ""
"The class name of the new <emphasis>server-side component</emphasis>. The "
"name of the client-side widget stub will be the same but with \"-"
"<classname>Widget</classname>\" suffix, for example, "
"<classname>MyComponentWidget</classname>. You can rename the classes "
"afterwards."
msgstr ""
"新建 <emphasis>服务器端组件</emphasis> 的类名. 客户端 widget 的根代码将会使用"
"相同的名称, 但加上 \"-<classname>Widget</classname>\" 后缀, 比如, "
"<classname>MyComponentWidget</classname>. 你可以在将来修改类名."

#. Tag: guilabel
#: chapter-gwt.xml:245
#, no-c-format
msgid "Superclass"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:247
#, no-c-format
msgid ""
"The superclass of the server-side component. It is "
"<classname>AbstractComponent</classname> by default, but <classname>com."
"vaadin.ui.AbstractField</classname> or <classname>com.vaadin.ui."
"AbstractSelect</classname> are other commonly used superclasses. If you are "
"extending an existing component, you should select it as the superclass. You "
"can easily change the superclass later."
msgstr ""
"服务器端组件的父类. 默认值是 <classname>AbstractComponent</classname> 类, 但 "
"<classname>com.vaadin.ui.AbstractField</classname> 或 <classname>com.vaadin."
"ui.AbstractSelect</classname> 也是常用的父类. 如果你从一个已有的组件继承, 你"
"应该选择这个组件作为父类. 这个父类也可以在将来修改."

#. Tag: guilabel
#: chapter-gwt.xml:260
#, no-c-format
msgid "Template"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:262
#, no-c-format
msgid ""
"Select which template to use. The default is <guilabel>Full fledged</"
"guilabel>, which creates the server-side component, the client-side widget, "
"the connector, a shared state object, and an RPC object. The "
"<guilabel>Connector only</guilabel> leaves the shared state and RPC objects "
"out."
msgstr ""
"选择使用哪个模板. 默认值是 <guilabel>Full fledged</guilabel>, 这个模板会创建"
"服务器端组件, 客户端 widget, 连接器, 共享的状态对象, 以及 RPC 对象. "
"<guilabel>Connector only</guilabel> 选项可以指定不创建共享的状态对象和 RPC 对"
"象."

#. Tag: para
#: chapter-gwt.xml:274
#, no-c-format
msgid ""
"Finally, click <guibutton>Finish</guibutton> to create the new component."
msgstr "最后, 点击 <guibutton>Finish</guibutton> 按钮, 创建新组件."

#. Tag: para
#: chapter-gwt.xml:280
#, no-c-format
msgid "The wizard will:"
msgstr "向导将会帮助你:"

#. Tag: para
#: chapter-gwt.xml:286
#, no-c-format
msgid "Create a server-side component stub in the base package"
msgstr "在基础包(base package)中创建服务器端组件的根代码"

#. Tag: para
#: chapter-gwt.xml:290
#, no-c-format
msgid ""
"If the project does not already have a widget set, the wizard creates a GWT "
"module descriptor file (<filename>.gwt.xml</filename>) in the base package "
"and modifies the servlet class or the <filename>web.xml</filename> "
"deployment descriptor to specify the widget set class name parameter for the "
"application"
msgstr ""
"如果工程中不存在已有的 widget set, 向导会在基础包中创建一个 GWT 模块描述文件"
"(<filename>.gwt.xml</filename>), 并修改 servlet 类, 或修改 <filename>web."
"xml</filename> 部署描述文件,  为应用程序指定 widget set 类名参数"

#. Tag: para
#: chapter-gwt.xml:301
#, no-c-format
msgid ""
"Create a client-side widget stub (along with the connector and shared state "
"and RPC stubs) in the <filename>client.componentname</filename> package "
"under the base package"
msgstr ""
"在基础包之下的 <filename>client.componentname</filename> 包中, 创建客户端 "
"widget 根代码(以及连接器, 共享的状态对象, 以及 RPC 根代码)"

#. Tag: para
#: chapter-gwt.xml:308
#, no-c-format
msgid ""
"The structure of the server-side component and the client-side widget, and "
"the serialization of component state between them, is explained in the "
"subsequent sections of this chapter."
msgstr ""
"关于服务器端组件和客户端 widget 的结构, 以及组件状态在服务器端与客户端之间的"
"序列化传递, 将在本章后续小节中讲解."

#. Tag: para
#: chapter-gwt.xml:314
#, no-c-format
msgid ""
"To compile the widget set, click the <guibutton>Compile widget set</"
"guibutton> button in the Eclipse toolbar. See <xref linkend=\"gwt.eclipse."
"compiling\"/> for details. After the compilation finishes, you should be "
"able to run your application as before, but using the new widget set. The "
"compilation result is written under the <filename>WebContent/VAADIN/"
"widgetsets</filename> folder. When you need to recompile the widget set in "
"Eclipse, see <xref linkend=\"gwt.eclipse.compiling\"/>. For detailed "
"information on compiling widget sets, see <xref linkend=\"clientside."
"compiling\"/>."
msgstr ""
"要编译 widget set, 可以点击 Eclipse 工具条上的 <guibutton>Compile widget "
"set</guibutton> 按钮. 详情请参见 <xref linkend=\"gwt.eclipse.compiling\"/>. "
"编译完成后, 你就可以运行你的应用程序了, 方法与以前一样, 但这次是使用新的 "
"widget set. 编译结果写入到 <filename>WebContent/VAADIN/widgetsets</filename> "
"文件夹下. 如果你需要在 Eclipse 中重编译 widget set, 请参见 <xref linkend="
"\"gwt.eclipse.compiling\"/>. 关于 widget set 编译的详情, 请参见 <xref "
"linkend=\"clientside.compiling\"/>."

#. Tag: para
#: chapter-gwt.xml:326
#, no-c-format
msgid ""
"The following setting is inserted in the <filename>web.xml</filename> "
"deployment descriptor to enable the widget set:"
msgstr ""
"为了使用 widget set, 需要在 <filename>web.xml</filename> 部署描述文件中插入以"
"下设定内容:"

#. Tag: programlisting
#: chapter-gwt.xml:331
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;init-param&gt;\n"
"    &lt;description&gt;Application widgetset&lt;/description&gt;\n"
"    &lt;param-name&gt;widgetset&lt;/param-name&gt;\n"
"    &lt;param-value&gt;<emphasis mode=\"bold\">com.example.myproject."
"widgetset.MyprojectApplicationWidgetset</emphasis>&lt;/param-value&gt;\n"
"&lt;/init-param&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:333
#, no-c-format
msgid ""
"You can refactor the package structure if you find need for it, but GWT "
"compiler requires that the client-side code <emphasis>must</emphasis> always "
"be stored under a package named \"<filename>client</filename>\" or a package "
"defined with a <literal>source</literal> element in the widget set "
"descriptor."
msgstr ""
"如果有需要, 你随时可以修改包结构, 但 GWT 编译器要求客户端代码所在的包 "
"<emphasis>必须</emphasis> 名为 \"<filename>client</filename>\", 或者是 "
"widget set 描述文件中 <literal>source</literal> 元素定义的包."

#. Tag: title
#: chapter-gwt.xml:343
#, no-c-format
msgid "Compiling the Widget Set"
msgstr "编译 Widget Set"

#. Tag: para
#: chapter-gwt.xml:345
#, no-c-format
msgid ""
"After you edit a widget, you need to compile the widget set. The Vaadin "
"Plugin for Eclipse automatically suggests to compile the widget set in "
"various situations, such as when you save a client-side source file. If this "
"gets annoying, you can disable the automatic recompilation in the Vaadin "
"category in project settings, by selecting the <guilabel>Suspend automatic "
"widgetset builds</guilabel> option."
msgstr ""
"编辑过 widget 之后, 你需要编译 widget set. Vaadin Plugin for Eclipse 在很多情"
"况下会自动提示你编译 widget set, 比如当你保存了客户端源代码文件之后. 如果这个"
"自动提示对你造成了干扰, 你可以在工程设置的 Vaadin 分组中选中 "
"<guilabel>Suspend automatic widgetset builds</guilabel> 选项, 禁用自动重编译"
"选项."

#. Tag: para
#: chapter-gwt.xml:354
#, no-c-format
msgid ""
"You can compile the widget set manually by clicking the <guibutton>Compile "
"widgetset</guibutton> button in the Eclipse toolbar, shown in <xref linkend="
"\"figure.gwt.eclipse.compiling.toolbar\"/>, while the project is open and "
"selected. If the project has multiple widget set definition files, you need "
"to select the one to compile in the Project Explorer."
msgstr ""
"你可以点击 Eclipse 工具条中的 <guibutton>Compile widgetset</guibutton> 按钮来"
"手工编译 widget set. 打开并选中工程后, 这个按钮如 <xref linkend=\"figure.gwt."
"eclipse.compiling.toolbar\"/> 所示. 如果工程中存在多个 widget set 定义文件, "
"你需要在 Project Explorer 选中需要编译的对象."

#. Tag: title
#: chapter-gwt.xml:364
#, no-c-format
msgid "The <guibutton>Compile Widgetset</guibutton> Button in Eclipse Toolbar"
msgstr "Eclipse 工具条中的 <guibutton>Compile Widgetset</guibutton> 按钮"

#. Tag: para
#: chapter-gwt.xml:375
#, no-c-format
msgid ""
"The compilation progress is shown in the <guilabel>Console</guilabel> panel "
"in Eclipse, illustrated in <xref linkend=\"figure.gwt.eclipse.compiling\"/>. "
"You should note especially the list of widget sets found in the class path."
msgstr ""
"编译进度会显示在 Eclipse 的 <guilabel>Console</guilabel> 面板中, 参见 <xref "
"linkend=\"figure.gwt.eclipse.compiling\"/>. 你需要特别注意类路径中找到的 "
"widget set 列表."

#. Tag: title
#: chapter-gwt.xml:383
#, no-c-format
msgid "Compiling a Widget Set"
msgstr "Widget Set 编译时的输出"

#. Tag: para
#: chapter-gwt.xml:394
#, no-c-format
msgid ""
"The compilation output is written under the <filename>WebContent/VAADIN/"
"widgetsets</filename> folder, in a widget set specific folder."
msgstr ""
"编译的输出路径是 <filename>WebContent/VAADIN/widgetsets</filename> 文件夹下"
"的 widget set 对应文件夹."

#. Tag: para
#: chapter-gwt.xml:400
#, no-c-format
msgid ""
"You can speed up the compilation significantly by compiling the widget set "
"only for your browser during development. The generated <filename>.gwt.xml</"
"filename> descriptor stub includes a disabled element that specifies the "
"target browser. See <xref linkend=\"gwt.module.compilation-limiting\"/> for "
"more details on setting the <literal>user-agent</literal> property."
msgstr ""
"在开发阶段, 你可以只为你的浏览器编译 widget set, 这样可以显著提高编译速度. 生"
"成的 <filename>.gwt.xml</filename> 描述文件的根代码中包含了一个被禁用的元素, "
"这个元素指定编译的目标浏览器. 关于 <literal>user-agent</literal> 属性的设置, "
"详情请参见 <xref linkend=\"gwt.module.compilation-limiting\"/>."

#. Tag: para
#: chapter-gwt.xml:409
#, no-c-format
msgid ""
"For more information on compiling widget sets, see <xref linkend="
"\"clientside.compiling\"/>. Should you compile a widget set outside Eclipse, "
"you need to refresh the project by selecting it in <guilabel>Project "
"Explorer</guilabel> and pressing <keycap>F5</keycap>."
msgstr ""
"关于 widget set 的更多详细信息, 请参见 <xref linkend=\"clientside.compiling"
"\"/>. 如果你在 Eclipse 环境之外编译了 widget set, 你需要在 <guilabel>Project "
"Explorer</guilabel> 中选中工程, 然后按下 <keycap>F5</keycap> 键来刷新工程信"
"息."

#. Tag: title
#: chapter-gwt.xml:422
#, no-c-format
msgid "Creating a Server-Side Component"
msgstr "创建服务器端组件"

#. Tag: para
#: chapter-gwt.xml:424
#, no-c-format
msgid ""
"Typical server-side Vaadin applications use server-side components that are "
"rendered on the client-side using their counterpart widgets. A server-side "
"component must manage state synchronization between the widget on the client-"
"side, in addition to any server-side logic."
msgstr ""
"通常的服务器端 Vaadin 应用程序使用服务器端组件, 服务器端组件在客户端使用对应"
"的 widget 来展现. 服务器端组件除了实现它的服务器端逻辑之外, 还需要管理服务器"
"端与客户端之间的状态同步问题."

#. Tag: title
#: chapter-gwt.xml:432 chapter-gwt.xml:1553
#, no-c-format
msgid "Basic Server-Side Component"
msgstr "基本的服务器端组件"

#. Tag: para
#: chapter-gwt.xml:434
#, no-c-format
msgid ""
"The component state is usually managed by a <emphasis>shared state</"
"emphasis>, described later in <xref linkend=\"gwt.shared-state\"/>."
msgstr ""
"组件状态通常使用 <emphasis>共享的状态对象</emphasis> 来管理, 这个问题将在后面"
"的 <xref linkend=\"gwt.shared-state\"/> 中详细介绍."

#. Tag: programlisting
#: chapter-gwt.xml:439
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyComponent extends "
"AbstractComponent {\n"
"    public MyComponent() {\n"
"        getState().setText(\"This is MyComponent\");\n"
"    }\n"
"\n"
"    @Override\n"
"    protected MyComponentState getState() {\n"
"        return (MyComponentState) super.getState();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:448
#, no-c-format
msgid "Integrating the Two Sides with a Connector"
msgstr "使用连接器实现客户端与服务器端的集成"

#. Tag: para
#: chapter-gwt.xml:450
#, no-c-format
msgid ""
"A client-side widget is integrated with a server-side component with a "
"<emphasis>connector</emphasis>. A connector is a client-side class that "
"communicates changes to the widget state and events to the server-side."
msgstr ""
"客户端 widget 与服务器端组件的集成是通过 <emphasis>连接器(connector)</"
"emphasis> 实现的. 连接器是一个客户端类, 它负责将服务器端的状态变更发送到客户"
"端 widget, 并将客户端事件发送到服务器端."

#. Tag: para
#: chapter-gwt.xml:456
#, no-c-format
msgid ""
"A connector normally gets the state of the server-side component by the "
"<emphasis>shared state</emphasis>, described later in <xref linkend=\"gwt."
"shared-state\"/>."
msgstr ""
"连接器通常使用 <emphasis>共享的状态对象</emphasis> 来得到服务器端组件的状态, "
"这个问题将在后面的 <xref linkend=\"gwt.shared-state\"/> 中详细介绍."

#. Tag: title
#: chapter-gwt.xml:463
#, no-c-format
msgid "A Basic Connector"
msgstr "一个基本的连接器"

#. Tag: para
#: chapter-gwt.xml:465
#, no-c-format
msgid ""
"The basic tasks of a connector is to hook up to the widget and handle events "
"from user interaction and changes received from the server. A connector also "
"has a number of routine infrastructure methods which need to be implemented."
msgstr ""
"连接器的基本任务是挂接在 widget 上, 处理用户操作导致的事件, 以及从服务器端收"
"到的状态变更. 此外, 连接器还需要实现一些底层基本方法."

#. Tag: programlisting
#: chapter-gwt.xml:472
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Connect(MyComponent.class)\n"
"public class MyComponentConnector\n"
"        extends AbstractComponentConnector {\n"
"\n"
"    @Override\n"
"    public MyComponentWidget getWidget() {\n"
"        return (MyComponentWidget) super.getWidget();\n"
"    }\n"
"\n"
"    @Override\n"
"    public MyComponentState getState() {\n"
"        return (MyComponentState) super.getState();\n"
"    }\n"
"\n"
"    @Override\n"
"    public void onStateChanged(StateChangeEvent stateChangeEvent)\n"
"    {\n"
"        super.onStateChanged(stateChangeEvent);\n"
"        \n"
"        // Do something useful\n"
"        final String text = getState().text;\n"
"        getWidget().setText(text);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:474
#, no-c-format
msgid ""
"Here, we handled state change with the crude <methodname>onStateChanged()</"
"methodname> method that is called when any of the state properties is "
"changed. A finer and simpler handling is achieved by using the "
"<classname>@OnStateChange</classname> annotation on a handler method for "
"each property, or by <classname>@DelegateToWidget</classname> on a shared "
"state property, as described later in <xref linkend=\"gwt.shared-state\"/>."
msgstr ""
"这里, 我们使用一个很粗糙的 <methodname>onStateChanged()</methodname> 方法来处"
"理状态变更, 当组件状态的任何属性发生变化时, 这个方法都会被调用. 更好更简单的"
"方案是为每一个属性实现一个处理方法, 并使用 <classname>@OnStateChange</"
"classname> 来注解这些方法, 或者在共享的状态对象的属性上使用 "
"<classname>@DelegateToWidget</classname> 方法, 这种方案将在后面的 <xref "
"linkend=\"gwt.shared-state\"/> 中介绍."

#. Tag: title
#: chapter-gwt.xml:486
#, no-c-format
msgid "Communication with the Server-Side"
msgstr "与服务器端通信"

#. Tag: para
#: chapter-gwt.xml:488
#, no-c-format
msgid ""
"The main task of a connector is to communicate user interaction with the "
"widget to the server-side and receive state changes from the server-side and "
"relay them to the widget."
msgstr ""
"连接器的主要任务是, 将用户在 widget 上的操作发送给服务器端, 以及从服务器端接"
"受状态变更并转发给 widget."

#. Tag: para
#: chapter-gwt.xml:494
#, no-c-format
msgid ""
"Server-to-client communication is normally done using a <emphasis>shared "
"state</emphasis>, as described in <xref linkend=\"gwt.shared-state\"/>, as "
"well as RPC calls. The serialization of the state data is handled completely "
"transparently. <phrase condition=\"web\">Once the client-side engine "
"receives the changes from the server, it reacts to them by creating and "
"notifying connectors that in turn manage widgets. This is described in <xref "
"linkend=\"gwt.advanced.phases\"/> in more detail.</phrase>"
msgstr ""
"服务器端到客户端的通信通常需要使用 <emphasis>共享的状态对象</emphasis>, 详情"
"请参见 <xref linkend=\"gwt.shared-state\"/>, 此外还需要使用 RPC 调用. 状态数"
"据的序列化会完全透明地处理, 开发者不必关心. <phrase condition=\"web\">当客户"
"端引擎从服务器端收到状态变更时, 它会创建并通知负责管理 widget 的连接器. 详情"
"请参见 <xref linkend=\"gwt.advanced.phases\"/>.</phrase>"

#. Tag: para
#: chapter-gwt.xml:504
#, no-c-format
msgid ""
"For client-to-server communication, a connector can make remote procedure "
"calls (RPC) to the server-side. Also, the server-side component can make RPC "
"calls to the connector. For a thorough description of the RPC mechanism, "
"refer to <xref linkend=\"gwt.rpc\"/>."
msgstr ""
"为实现客户端到服务器端的通信, 连接器可以向服务器端发起远程过程调用(RPC). 而"
"且, 服务器端组件也可以向连接器发起 RPC 调用. 关于 RPC 机制的详细介绍, 请参见 "
"<xref linkend=\"gwt.rpc\"/>."

#. Tag: title
#: chapter-gwt.xml:514
#, no-c-format
msgid "Shared State"
msgstr "状态信息共享"

#. Tag: para
#: chapter-gwt.xml:516
#, no-c-format
msgid ""
"The basic communication from a server-side component to its the client-side "
"widget counterpart is handled using a <emphasis>shared state</emphasis>. The "
"shared state is serialized transparently. It should be considered read-only "
"on the client-side, as it is not serialized back to the server-side."
msgstr ""
"从服务器端组件到它对应的客户端 widget 的基本通信是使用 <emphasis>共享的状态信"
"息</emphasis> 实现的. 共享的状态信息的序列化处理会透明地实现. 在客户端, 共享"
"的状态信息应该被看作是只读的, 因为它不会被序列化后传回到服务器端."

#. Tag: para
#: chapter-gwt.xml:523
#, no-c-format
msgid ""
"A shared state object simply needs to extend the <classname>ComponentState</"
"classname>. The member variables should normally be declared as public."
msgstr ""
"共享的状态对象只需要简单地继承 <classname>ComponentState</classname> 类. 状态"
"对象的成员变量通常应该声明为 public 成员."

#. Tag: programlisting
#: chapter-gwt.xml:529
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyComponentState extends "
"ComponentState {\n"
"    public String text;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:531
#, no-c-format
msgid ""
"A shared state should never contain any logic. If the members have private "
"visibility for some reason, you can also use public setters and getters, in "
"which case the property must not be public."
msgstr ""
"共享的状态对象中不应该包含任何逻辑处理代码. 如果因为某种原因, 成员变量可见度"
"为 private, 你可以使用 public 的 setter 和 getter 方法, 这时属性本身不可以为 "
"public."

#. Tag: title
#: chapter-gwt.xml:538
#, no-c-format
msgid "Accessing Shared State on Server-Side"
msgstr "在服务器端访问共享的状态信息"

#. Tag: para
#: chapter-gwt.xml:540
#, no-c-format
msgid ""
"A server-side component can access the shared state with the "
"<methodname>getState()</methodname> method. It is required that you override "
"the base implementation with one that returns the shared state object cast "
"to the proper type, as follows:"
msgstr ""
"服务器端组件可以使用 <methodname>getState()</methodname> 方法来访问共享的状态"
"对象. 你需要重载基类中的这个方法, 在新的实现中应该将共享的状态对象转换为正确"
"的类型, 然后再返回转换后的结果, 如下:"

#. Tag: programlisting
#: chapter-gwt.xml:547 chapter-gwt.xml:568
#, no-c-format
msgid ""
"<![CDATA[@Override\n"
"public MyComponentState getState() {\n"
"    return (MyComponentState) super.getState();\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:549
#, no-c-format
msgid ""
"You can then use the <methodname>getState()</methodname> to access the "
"shared state object with the proper type."
msgstr ""
"然后你就可以使用 <methodname>getState()</methodname> 方法, 得到正确类型的共享"
"状态信息."

#. Tag: programlisting
#: chapter-gwt.xml:554
#, no-c-format
msgid ""
"<![CDATA[public MyComponent() {\n"
"    getState().setText(\"This is the initial state\");\n"
"    ....\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:559
#, no-c-format
msgid "Handing Shared State in a Connector"
msgstr "在连接器中管理共享的状态信息"

#. Tag: para
#: chapter-gwt.xml:561
#, no-c-format
msgid ""
"A connector can access a shared state with the <methodname>getState()</"
"methodname> method. The access should be read-only. It is required that you "
"override the base implementation with one that returns the proper shared "
"state type, as follows:"
msgstr ""
"连接器可以使用 <methodname>getState()</methodname> 方法访问共享的状态信息. 但"
"这种访问必须是只读的. 你需要重载父类的这个方法, 在新的实现中为共享状态信息返"
"回正确的数据类型, 如下:"

#. Tag: para
#: chapter-gwt.xml:570
#, no-c-format
msgid ""
"State changes made on the server-side are communicated transparently to the "
"client-side. When a state change occurs, the <methodname>onStateChanged()</"
"methodname> method in the connector is called. You should should always call "
"the superclass method before anything else to handle changes to common "
"component properties."
msgstr ""
"由服务器端导致的状态变化会被透明地发送到客户端. 当发生状态变化时,  连接器中"
"的 <methodname>onStateChanged()</methodname> 方法会被调用. 在你执行任何变更处"
"理之前, 首先应该调用父类的方法, 以便实现组件共通属性的变更处理."

#. Tag: programlisting
#: chapter-gwt.xml:578
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Override\n"
"public void onStateChanged(StateChangeEvent stateChangeEvent) {\n"
"    super.onStateChanged(stateChangeEvent);\n"
"                \n"
"    // Copy the state properties to the widget properties\n"
"    final String text = getState().getText();\n"
"    getWidget().setText(text);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:580
#, no-c-format
msgid ""
"The crude <methodname>onStateChanged()</methodname> method is called when "
"any of the state properties is changed, allowing you to have even complex "
"logic in how you manipulate the widget according to the state changes. In "
"most cases, however, you can handle the property changes more easily and "
"also more efficiently by using instead the <classname>@OnStateChange</"
"classname> annotation on the handler methods for each property, as described "
"next in <xref linkend=\"gwt.shared-state.onstatechange\"/>, or by delegating "
"the property value directly to the widget, as described in <xref linkend="
"\"gwt.shared-state.delegatetowidget\"/>."
msgstr ""
"上例中的 <methodname>onStateChanged()</methodname> 方法很粗糙, 状态信息中的任"
"何属性发生变更时, 这个方法都会被调用, 因此你可以实现很复杂的逻辑, 根据不同的"
"状态变化来操纵 widget. 但是大多数情况下, 你可以用更简单而且更有效率的方式来处"
"理属性变更, 方法是为每个属性实现单独的变更处理方法, 并对这些方法使用 "
"<classname>@OnStateChange</classname> 注解, 这种方案的详情将在后面的 <xref "
"linkend=\"gwt.shared-state.onstatechange\"/> 中介绍, 或者你也可以直接将属性值"
"转发给 widget, 详情请参见 <xref linkend=\"gwt.shared-state.delegatetowidget"
"\"/>."

#. Tag: para
#: chapter-gwt.xml:593
#, no-c-format
msgid ""
"The processing phases of state changes are described in more detail in <xref "
"linkend=\"gwt.advanced.phases\"/>."
msgstr ""
"状态信息变更的处理过程分为几个阶段, 详情请参见 <xref linkend=\"gwt.advanced."
"phases\"/>."

#. Tag: title
#: chapter-gwt.xml:600
#, no-c-format
msgid ""
"Handling Property State Changes with <classname>@OnStateChange</classname>"
msgstr "使用 <classname>@OnStateChange</classname> 处理属性状态的变更"

#. Tag: para
#: chapter-gwt.xml:602
#, no-c-format
msgid ""
"The <classname>@OnStateChange</classname> annotation can be used to mark a "
"connector method that handles state change on a particular property, given "
"as parameter for the annotation. In addition to higher clarity, this avoids "
"handling all property changes if a state change occurs in only one or some "
"of them. However, if a state change can occur in multiple properties, you "
"can only use this technique if the properties do not have interaction that "
"prevents handling them separately in arbitrary order."
msgstr ""
"<classname>@OnStateChange</classname> 注解可以用来标识连接器的一个方法, 将它"
"指定为状态信息中一个属性的变更处理方法, 对象属性可以通过注解的参数来指定. 除"
"了代码更加清晰之外, 这种方法还有一个优点, 当状态信息中变更的属性仅有一个或一"
"部分时, 可以不必在处理方法中维护所有的属性. 但是, 如果状态信息的多个属性都可"
"以发生变更, 那么只有属性之间不存在相互影响, 各个属性的变更处理代码不存在执行"
"顺序的要求时, 你才可以使用这种方案."

#. Tag: para
#: chapter-gwt.xml:612
#, no-c-format
msgid ""
"We can replace the <methodname>onStateChange()</methodname> method in the "
"earlier connector example with the following:"
msgstr ""
"我们可以将前面的连接器示例代码中的 <methodname>onStateChange()</methodname> "
"方法替换为以下代码:"

#. Tag: programlisting
#: chapter-gwt.xml:617
#, no-c-format
msgid ""
"<![CDATA[@OnStateChange(\"text\")\n"
"void updateText() {\n"
"    getWidget().setText(getState().text);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:619
#, no-c-format
msgid ""
"If the shared state property and the widget property have same name and do "
"not require any type conversion, as is the case in the above example, you "
"could simplify this even further by using the <classname>@DelegateToWidget</"
"classname> annotation for the shared state property, as described in <xref "
"linkend=\"gwt.shared-state.delegatetowidget\"/>."
msgstr ""
"如果在共享的状态信息与 widget 中, 属性名称相同, 而且不需要任何类型转换, (前面"
"的例子正是这种情况), 这时可以采用更加简单的方案, 也就是为状态信息的属性使用 "
"<classname>@DelegateToWidget</classname> 注解, 详情请参见 <xref linkend="
"\"gwt.shared-state.delegatetowidget\"/>."

#. Tag: title
#: chapter-gwt.xml:630
#, no-c-format
msgid "Delegating State Properties to Widget"
msgstr "将状态属性转发给 Widget"

#. Tag: para
#: chapter-gwt.xml:632
#, no-c-format
msgid ""
"The <classname>@DelegateToWidget</classname> annotation for a shared state "
"property defines automatic delegation of the property value to the "
"corresponding widget property of the same name and type, by calling the "
"respective setter for the property in the widget."
msgstr ""
"在状态信息的属性上使用 <classname>@DelegateToWidget</classname> 注解, 可以将"
"状态信息的属性值自动转发到同名同类型的 widget 属性上, Vaadin 会对 widget 调用"
"这个属性对应的 setter 方法."

#. Tag: programlisting
#: chapter-gwt.xml:639
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyComponentState extends "
"AbstractComponentState {\n"
"    @DelegateToWidget\n"
"    public String text;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:641
#, no-c-format
msgid ""
"This is equivalent to handling the state change in the connector, as done in "
"the example in <xref linkend=\"gwt.shared-state.onstatechange\"/>."
msgstr ""
"上面的代码等价于在连接器内处理状态的变更, 参见 <xref linkend=\"gwt.shared-"
"state.onstatechange\"/> 中的示例代码."

#. Tag: para
#: chapter-gwt.xml:646
#, no-c-format
msgid ""
"If you want to delegate a shared state property to a widget property of "
"another name, you can give the property name as a string parameter for the "
"annotation."
msgstr ""
"如果你希望将状态信息的属性转发给 widget 的不同名称的属性, 你可以使用注解的字"
"符串参数来指定属性名称."

#. Tag: programlisting
#: chapter-gwt.xml:652
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyComponentState extends "
"AbstractComponentState {\n"
"    @DelegateToWidget(\"description\")\n"
"    public String text;\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:657
#, no-c-format
msgid "Referring to Components in Shared State"
msgstr "在共享的状态信息中参照组件"

#. Tag: para
#: chapter-gwt.xml:659
#, no-c-format
msgid ""
"While you can pass any regular Java objects through a shared state, "
"referring to another component requires special handling because on the "
"server-side you can only refer to a server-side component, while on the "
"client-side you only have widgets. References to components can be made by "
"referring to their connectors (all server-side components implement the "
"<interfacename>Connector</interfacename> interface)."
msgstr ""
"虽然你可以通过共享的状态信息来传递任何常规的 Java 对象, 但如果要参照另一个组"
"件则需要特别的处理, 因为在服务器端你只能参照一个服务器端组件, 而在客户端你只"
"能得到 widget. 对组件的参照可以通过参照它们的连接器来实现(所有的服务器端组件"
"都实现了 <interfacename>Connector</interfacename> 方法)."

#. Tag: programlisting
#: chapter-gwt.xml:668
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyComponentState extends "
"ComponentState {\n"
"    public Connector otherComponent;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:670
#, no-c-format
msgid "You could then access the component on the server-side as follows:"
msgstr "然后, 在服务器端你应该使用以下方法访问组件:"

#. Tag: programlisting
#: chapter-gwt.xml:674
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyComponent {\n"
"    public void MyComponent(Component otherComponent) {\n"
"        getState().otherComponent = otherComponent;\n"
"    }\n"
"\n"
"    public Component getOtherComponent() {\n"
"        return (Component)getState().otherComponent;\n"
"    }\n"
"\n"
"    // And the cast method\n"
"    @Override\n"
"    public MyComponentState getState() {\n"
"        return (MyComponentState) super.getState();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:676
#, no-c-format
msgid ""
"On the client-side, you should cast it in a similar fashion to a "
"<classname>ComponentConnector</classname>, or possibly to the specific "
"connector type if it is known."
msgstr ""
"在客户端, 你应该使用类似的方法, 将参照的组件转换为 "
"<classname>ComponentConnector</classname>, 如果你确定地知道连接器类型, 也可以"
"转换为更确定的类型."

#. Tag: title
#: chapter-gwt.xml:684
#, no-c-format
msgid "Sharing Resources"
msgstr "共享资源"

#. Tag: para
#: chapter-gwt.xml:686
#, no-c-format
msgid ""
"Resources, which commonly are references to icons or other images, are "
"another case of objects that require special handling. A "
"<interfacename>Resource</interfacename> object exists only on the server-"
"side and on the client-side you have an URL to the resource. You need to use "
"the <methodname>setResource()</methodname> and <methodname>getResource()</"
"methodname> on the server-side to access a resource, which is serialized to "
"the client-side separately."
msgstr ""
"资源, (通常是图标或其他图片), 是另一种需要特别处理的情况. "
"<interfacename>Resource</interfacename> 对象只存在于服务器端, 在客户端你只能"
"得到资源的 URL. 在服务器端你需要使用 <methodname>setResource()</methodname> "
"和 <methodname>getResource()</methodname> 方法来访问资源, 资源会被独立地序列"
"化传送到客户端."

#. Tag: para
#: chapter-gwt.xml:696
#, no-c-format
msgid "Let us begin with the server-side API:"
msgstr "我们先来看看服务器端 API:"

#. Tag: programlisting
#: chapter-gwt.xml:700
#, no-c-format
msgid ""
"<![CDATA[public class MyComponent extends AbstractComponent {\n"
"    ...\n"
"\n"
"    public void setMyIcon(Resource myIcon) {\n"
"        setResource(\"myIcon\", myIcon);\n"
"    }\n"
"\n"
"    public Resource getMyIcon() {\n"
"        return getResource(\"myIcon\");\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:702
#, no-c-format
msgid ""
"On the client-side, you can then get the URL of the resource with "
"<methodname>getResourceUrl()</methodname>."
msgstr ""
"然后, 在客户端你可以使用 <methodname>getResourceUrl()</methodname>方法得到资"
"源的 URL."

#. Tag: programlisting
#: chapter-gwt.xml:707
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Override\n"
"public void onStateChanged(StateChangeEvent stateChangeEvent) {\n"
"    super.onStateChanged(stateChangeEvent);\n"
"    ...\n"
"        \n"
"    // Get the resource URL for the icon\n"
"    getWidget().setMyIcon(getResourceUrl(\"myIcon\"));\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:709
#, no-c-format
msgid "The widget could then use the URL, for example, as follows:"
msgstr "然后 widget 就可以使用 URL, 如下:"

#. Tag: programlisting
#: chapter-gwt.xml:713
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyWidget extends Label {\n"
"    ...\n"
"    \n"
"    Element imgElement = null;\n"
"    \n"
"    public void setMyIcon(String url) {\n"
"        if (imgElement == null) {\n"
"            imgElement = DOM.createImg();\n"
"            getElement().appendChild(imgElement);\n"
"        }\n"
"        \n"
"        DOM.setElementAttribute(imgElement, \"src\", url);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:719
#, no-c-format
msgid "RPC Calls Between Client- and Server-Side"
msgstr "客户端与服务器端之间的 RPC 调用"

#. Tag: para
#: chapter-gwt.xml:721
#, no-c-format
msgid ""
"Vaadin supports making Remote Procedure Calls (RPC) between a server-side "
"component and its client-side widget counterpart. RPC calls are normally "
"used for communicating stateless events, such as button clicks or other user "
"interaction, in contrast to changing the shared state. Either party can make "
"an RPC call to the other side. When a client-side widget makes a call, a "
"server request is made. Calls made from the server-side to the client-side "
"are communicated in the response of the server request during which the call "
"was made."
msgstr ""
"Vaadin 支持在服务器端组件和对应的客户端 widget 之间进行远程过程调用(Remote "
"Procedure Call, RPC). 与共享状态信息的变更不同, RPC 调用通常用于传递无状态的"
"事件, 比如按钮的点击, 或其他用户操作事件. 服务器端和客户端都可以向另一端发起 "
"RPC 调用. 当客户端 widget 发起调用时, 会产生向服务器的请求. 由服务器端向客户"
"端发起的调用, 会作为这段代码所属的请求的应答的一部分传递给客户端.(译注: 服务"
"器端代码通常不会主动执行, 它需要由客户端的一次请求来触发, 因此服务器端向客户"
"端发起的调用, 也属于客户端的某个请求所触发的代码的一部分. 服务器端向客户端发"
"起的调用, 会作为这个请求的应答内容的一部分, 传递给客户端.)"

#. Tag: para
#: chapter-gwt.xml:732
#, no-c-format
msgid ""
"If you use Eclipse and enable the \"Full-Fledged\" widget in the New Vaadin "
"Widget wizard, it automatically creates a component with an RPC stub."
msgstr ""
"如果你使用 Eclipse, 并且在 New Vaadin Widget 向导中选择了 \"Full-Fledged\" "
"widget, 那么向导会自动创建组件的 RPC 根代码(stub)."

#. Tag: title
#: chapter-gwt.xml:738
#, no-c-format
msgid "RPC Calls to the Server-Side"
msgstr "对服务器端的 RPC 调用"

#. Tag: para
#: chapter-gwt.xml:740
#, no-c-format
msgid ""
"RPC calls from the client-side to the server-side are made through an RPC "
"interface that extends the <interfacename>ServerRpc</interfacename> "
"interface. A server RPC interface simply defines any methods that can be "
"called through the interface."
msgstr ""
"从客户端向服务器端发起的 RPC 调用使用 RPC 接口来实现, RPC 接口继承自 "
"<interfacename>ServerRpc</interfacename> 接口. 在 Server RPC 接口中, 只简单地"
"定义通过这个接口可以调用的方法."

#. Tag: para
#: chapter-gwt.xml:747
#, no-c-format
msgid "For example:"
msgstr "比如:"

#. Tag: programlisting
#: chapter-gwt.xml:751
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public interface MyComponentServerRpc extends "
"ServerRpc {\n"
"    public void clicked(String buttonName);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:753
#, no-c-format
msgid ""
"The above example defines a single <methodname>clicks()</methodname> RPC "
"call, which takes a <classname>MouseEventDetails</classname> object as the "
"parameter."
msgstr ""
"上例定义了一个 <methodname>clicks()</methodname> RPC 调用, 参数是一个 "
"<classname>MouseEventDetails</classname> 对象."

#. Tag: para
#: chapter-gwt.xml:759
#, no-c-format
msgid ""
"You can pass the most common standard Java types, such as primitive and "
"boxed primitive types, <classname>String</classname>, and arrays and some "
"collections (<classname>List</classname>, <classname>Set</classname>, and "
"<classname>Map</classname>) of the supported types. Also the Vaadin "
"<classname>Connector</classname> and some special internal types can be "
"passed."
msgstr ""
"在 RPC 调用中可以传递大多数标准 Java 类型, 比如基本数据类型(int, float 等)及"
"对应的封装类(Integer, Float 等), <classname>String</classname>, 数组, 以及以"
"上类型构成的一部分集合类型(<classname>List</classname>, <classname>Set</"
"classname>, 和 <classname>Map</classname>). 此外, Vaadin <classname>连接器</"
"classname> 和一些特殊的内部类型也可以使用."

#. Tag: para
#: chapter-gwt.xml:768
#, no-c-format
msgid ""
"An RPC method must return void - the widget set compiler should complain if "
"it doesn't."
msgstr "RPC 方法返回值必须为 void - 否则 widget set 编译器会提示错误."

#. Tag: title
#: chapter-gwt.xml:774
#, no-c-format
msgid "Making a Call"
msgstr "发起调用"

#. Tag: para
#: chapter-gwt.xml:776
#, no-c-format
msgid ""
"Before making a call, you need to instantiate the server RPC object with "
"<methodname>RpcProxy.create()</methodname>. After that, you can make calls "
"through the server RPC interface that you defined, for example as follows:"
msgstr ""
"在发起调用之前, 你需要使用 <methodname>RpcProxy.create()</methodname> 方法来"
"初始化 Server RPC 对象. 然后, 就可以通过你定义的 Server RPC 接口来进行调用, "
"比如:"

#. Tag: programlisting
#: chapter-gwt.xml:783
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Connect(MyComponent.class)\n"
"public class MyComponentConnector\n"
"       extends AbstractComponentConnector {\n"
"\n"
"    public MyComponentConnector() {\n"
"        getWidget().addClickHandler(new ClickHandler() {\n"
"            public void onClick(ClickEvent event) {\n"
"                final MouseEventDetails mouseDetails =\n"
"                     MouseEventDetailsBuilder\n"
"                         .buildMouseEventDetails(\n"
"                                 event.getNativeEvent(),\n"
"                                 getWidget().getElement());\n"
"                MyComponentServerRpc rpc =\n"
"                    getRpcProxy(MyComponentServerRpc.class);\n"
"\n"
"                // Make the call\n"
"                rpc.clicked(mouseDetails.getButtonName());\n"
"            }\n"
"        });\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:787
#, no-c-format
msgid "Handling a Call"
msgstr "处理调用"

#. Tag: para
#: chapter-gwt.xml:789
#, no-c-format
msgid ""
"RPC calls are handled in a server-side implementation of the server RPC "
"interface. The call and its parameters are serialized and passed to the "
"server in an RPC request transparently."
msgstr ""
"RPC 调用由 Server RPC 接口的服务器端实现类来处理. 在一次 RPC 请求中, 调用及参"
"数会被序列化, 然后传递给服务器, 这些处理是透明的, 开发者不必关心."

#. Tag: programlisting
#: chapter-gwt.xml:795
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyComponent extends "
"AbstractComponent {\n"
"    private MyComponentServerRpc rpc =\n"
"    new MyComponentServerRpc() {\n"
"        private int clickCount = 0;\n"
"        \n"
"        public void clicked(String buttonName) {\n"
"            Notification.show(\"Clicked \" + buttonName);\n"
"        }\n"
"    };\n"
"\n"
"    public MyComponent() {\n"
"        ...\n"
"        registerRpc(rpc);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:801
#, no-c-format
msgid "Component and &uiclass; Extensions"
msgstr "组件与 &uiclass; 扩展"

#. Tag: para
#: chapter-gwt.xml:803
#, no-c-format
msgid ""
"Adding features to existing components by extending them by inheritance "
"creates a problem when you want to combine such features. For example, one "
"add-on could add spell-check to a <classname>TextField</classname>, while "
"another could add client-side validation. Combining such add-on features "
"would be difficult if not impossible. You might also want to add a feature "
"to several or even to all components, but extending all of them by "
"inheritance is not really an option. Vaadin includes a component plug-in "
"mechanism for these purposes. Such plug-ins are simply called "
"<emphasis>extensions</emphasis>."
msgstr ""
"为了给已有的组件添加新的功能, 我们可以选择继承这个组件类, 但带来的问题是不能"
"便利地组合各种不同的功能. 比如, 某个 add-on 可以为 <classname>TextField</"
"classname> 添加拼写检查功能, 另一个 add-on 可以添加客户端校验功能. 想要将这"
"些 add-on 的功能组合起来, 是非常困难的, 有时甚至是不可能的. 有时你可能希望将"
"某个功能添加给几个组件, 甚至所有的组件, 但以类继承的方式来扩展所有这些组件的"
"功能绝对不是一个好的方案. Vaadin 中包含一种组件插件机制来解决这个问题. 这种插"
"件机制就叫做 <emphasis>扩展(Extension)</emphasis>."

#. Tag: para
#: chapter-gwt.xml:814
#, no-c-format
msgid ""
"Also a &ui; can be extended in a similar fashion. In fact, some Vaadin "
"features such as the JavaScript execution are UI extensions."
msgstr ""
"&ui; 也可以使用类似的方式来扩展. Vaadin 的某些功能, 比如 JavaScript 执行功"
"能, 事实上就是 UI 扩展."

#. Tag: para
#: chapter-gwt.xml:819
#, no-c-format
msgid ""
"Implementing an extension requires defining a server-side extension class "
"and a client-side connector. An extension can have a shared state with the "
"connector and use RPC, just like a component could."
msgstr ""
"实现一个扩展需要定义一个服务器端扩展类, 以及一个客户端连接器. 和组件一样, 扩"
"展与连接器可以带有共享的状态信息, 也可以使用 RPC."

#. Tag: title
#: chapter-gwt.xml:826
#, no-c-format
msgid "Server-Side Extension API"
msgstr "服务器端扩展 API"

#. Tag: para
#: chapter-gwt.xml:828
#, no-c-format
msgid ""
"The server-side API for an extension consists of class that extends (in the "
"Java sense) the <classname>AbstractExtension</classname> class. It typically "
"has an <emphasis>extend()</emphasis> method, a constructor, or a static "
"helper method that takes the extended component or &ui; as a parameter and "
"passes it to <emphasis>super.extend()</emphasis>."
msgstr ""
"对于一个扩展来说, 服务器端 API 包括继承自 <classname>AbstractExtension</"
"classname> 的类. 这个类通常有一个 <emphasis>extend()</emphasis> 方法, 一个构"
"造方法(或一个静态的帮助方法), 接受的参数是被扩展的组件或 &ui; 这些参数会被传"
"递给 <emphasis>super.extend()</emphasis>."

#. Tag: para
#: chapter-gwt.xml:836
#, no-c-format
msgid ""
"For example, let us have a trivial example with an extension that takes no "
"special parameters, and illustrates the three alternative APIs:"
msgstr "我们来看看下面的示例程序, 它演示了三种不同的 API:"

#. Tag: programlisting
#: chapter-gwt.xml:841
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class CapsLockWarning extends "
"AbstractExtension {\n"
"    // You could pass it in the constructor\n"
"    public CapsLockWarning(PasswordField field) {\n"
"        super.extend(field);\n"
"    }\n"
"\n"
"    // Or in an extend() method\n"
"    public void extend(PasswordField field) {\n"
"        super.extend(field);\n"
"    }\n"
"\n"
"    // Or with a static helper\n"
"    public static addTo(PasswordField field) {\n"
"        new CapsLockWarning().extend(field);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:843
#, no-c-format
msgid "The extension could then be added to a component as follows:"
msgstr "这个扩展可以使用以下方式添加到组件上:"

#. Tag: programlisting
#: chapter-gwt.xml:847
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[PasswordField password = new "
"PasswordField(\"Give it\");\n"
"\n"
"// Use the constructor\n"
"new CapsLockWarning(password);\n"
"\n"
"// ... or with the extend() method\n"
"new CapsLockWarning().extend(password);\n"
"\n"
"// ... or with the static helper\n"
"CapsLockWarning.addTo(password);\n"
"\n"
"layout.addComponent(password);]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:849
#, no-c-format
msgid ""
"Adding a feature in such a \"reverse\" way is a bit unusual in the Vaadin "
"API, but allows type safety for extensions, as the method can limit the "
"target type to which the extension can be applied, and whether it is a "
"regular component or a &ui;."
msgstr ""
"使用这种 \"反转\" 的方式来添加新功能在 Vaadin API 中显得稍微有些怪异, 但这种"
"方式可以实现扩展的类型安全, 因为扩展类中的方法可以限定这个扩展可以使用的目标"
"类型, 还可以限定扩展目标是通常的组件还是 &ui;."

#. Tag: title
#: chapter-gwt.xml:858
#, no-c-format
msgid "Extension Connectors"
msgstr "扩展的连接器"

#. Tag: para
#: chapter-gwt.xml:860
#, no-c-format
msgid ""
"An extension does not have a corresponding widget on the client-side, but "
"only an extension connector that extends the "
"<classname>AbstractExtensionConnector</classname> class. The server-side "
"extension class is specified with a <literal>@Connect</literal> annotation, "
"just like in component connectors."
msgstr ""
"对于扩展来说, 在客户端不存在对应的 widget, 只有一个扩展连接器, 继承自 "
"<classname>AbstractExtensionConnector</classname> 类. 和组件的连接器一样, 扩"
"展连接器使用 <literal>@Connect</literal> 注解来标记对应的服务器端扩展类."

#. Tag: para
#: chapter-gwt.xml:868
#, no-c-format
msgid ""
"An extension connector needs to implement the <methodname>extend()</"
"methodname> method, which allows hooking to the extended component. The "
"normal extension mechanism is to modify the extended component as needed and "
"add event handlers to it to handle user interaction. An extension connector "
"can share a state with the server-side extension as well as make RPC calls, "
"just like with components."
msgstr ""
"扩展的连接器需要实现 <methodname>extend()</methodname> 方法, 这个方法负责挂接"
"到目标组件上. 实现扩展的一般机制是根据需要修改目标组件, 并向组件追加事件处理"
"器来响应用户操作. 与组件一样, 扩展的连接器可以与服务器端扩展类共享状态信息, "
"也可以发起 RPC 调用."

#. Tag: para
#: chapter-gwt.xml:877
#, no-c-format
msgid ""
"In the following example, we implement a \"Caps Lock warning\" extension. It "
"listens for changes in Caps Lock state and displays a floating warning "
"element over the extended component if the Caps Lock is on."
msgstr ""
"下面的示例中, 我们实现一个 \"Caps Lock 警告\" 扩展. 它监听 Caps Lock 键的状态"
"变化, 如果 Caps Lock 键被打开, 则在目标组件上显示一个浮动的警告信息."

#. Tag: programlisting
#: chapter-gwt.xml:883
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Connect(CapsLockWarning.class)\n"
"public class CapsLockWarningConnector\n"
"        extends AbstractExtensionConnector {\n"
"\n"
"    @Override\n"
"    protected void extend(ServerConnector target) {\n"
"        // Get the extended widget\n"
"        final Widget pw =\n"
"                ((ComponentConnector) target).getWidget();\n"
"\n"
"        // Preparations for the added feature\n"
"        final VOverlay warning = new VOverlay();\n"
"        warning.setOwner(pw);\n"
"        warning.add(new HTML(\"Caps Lock is enabled!\"));\n"
"\n"
"        // Add an event handler\n"
"        pw.addDomHandler(new KeyPressHandler() {\n"
"            public void onKeyPress(KeyPressEvent event) {\n"
"                if (isEnabled() && isCapsLockOn(event)) {\n"
"                    warning.showRelativeTo(passwordWidget);\n"
"                } else {\n"
"                    warning.hide();\n"
"                }\n"
"            }\n"
"        }, KeyPressEvent.getType());\n"
"    }\n"
"\n"
"    private boolean isCapsLockOn(KeyPressEvent e) {\n"
"        return e.isShiftKeyDown() ^\n"
"               Character.isUpperCase(e.getCharCode());\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:885
#, no-c-format
msgid ""
"The <methodname>extend()</methodname> method gets the connector of the "
"extended component as the parameter, in the above example a "
"<classname>PasswordFieldConnector</classname>. It can access the widget with "
"the <methodname>getWidget()</methodname>."
msgstr ""
"<methodname>extend()</methodname> 方法得到的参数是目标组件的连接器, 在上例中"
"是一个 <classname>PasswordFieldConnector</classname>. 通过这个连接器的 "
"<methodname>getWidget()</methodname> 方法可以得到组件的 widget."

#. Tag: para
#: chapter-gwt.xml:892
#, no-c-format
msgid ""
"An extension connector needs to be included in a widget set. The class must "
"therefore be defined under the <filename>client</filename> package of a "
"widget set, just like with component connectors."
msgstr ""
"扩展连接器需要包含到 widget set 之内. 因此与组件的连接器一样, 扩展的连接器类"
"需要定义在 widget set 的 <filename>client</filename> 包之下."

#. Tag: title
#: chapter-gwt.xml:901
#, no-c-format
msgid "Styling a Widget"
msgstr "Widget 的样式控制"

#. Tag: para
#: chapter-gwt.xml:903
#, no-c-format
msgid ""
"To make your widget look stylish, you need to style it. There are two basic "
"ways to define CSS styles for a component: in the widget sources and in a "
"theme. A default style should be defined in the widget sources, and "
"different themes can then modify the style."
msgstr ""
"为了让你的 widget 外观漂亮一些, 你需要控制它的样式. 定义组件的 CSS 样式有两种"
"基本方式: 可以在 widget 源代码中定义样式, 也可以在 theme 中定义样式. widget "
"的源代码中应该定义默认样式, 各种 theme 可以对默认样式进行不同的修改."

#. Tag: title
#: chapter-gwt.xml:911
#, no-c-format
msgid "Determining the CSS Class"
msgstr "确定 CSS 样式类"

#. Tag: para
#: chapter-gwt.xml:913
#, no-c-format
msgid ""
"The CSS class of a widget element is normally defined in the widget class "
"and set with <methodname>setStyleName()</methodname>. A widget should set "
"the styles for its sub-elements as it desires."
msgstr ""
"widget 元素的 CSS 类通常在 widget 类中使用 <methodname>setStyleName()</"
"methodname> 方法来设置. widget 还应该根据自己的需求设置子元素的样式."

#. Tag: para
#: chapter-gwt.xml:919
#, no-c-format
msgid ""
"For example, you could style a composite widget with an overall style and "
"with separate styles for the sub-widgets as follows:"
msgstr ""
"比如, 你可以首先为一个组合 widget 设置全体样式, 然后再为各个子 widget 设置各"
"自的样式, 如下:"

#. Tag: programlisting
#: chapter-gwt.xml:924
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyPickerWidget extends "
"ComplexPanel {\n"
"    public static final String CLASSNAME = \"mypicker\";\n"
"\n"
"    private final TextBox textBox = new TextBox();\n"
"    private final PushButton button = new PushButton(\"...\");\n"
"\n"
"    public MyPickerWidget() {\n"
"        setElement(Document.get().createDivElement());\n"
"        setStylePrimaryName(CLASSNAME);\n"
"\n"
"        textBox.setStylePrimaryName(CLASSNAME + \"-field\");\n"
"        button.setStylePrimaryName(CLASSNAME + \"-button\");\n"
"\n"
"        add(textBox, getElement());\n"
"        add(button, getElement());\n"
"\n"
"        button.addClickHandler(new ClickHandler() {\n"
"            public void onClick(ClickEvent event) {\n"
"              Window.alert(\"Calendar picker not yet supported!\");\n"
"            }\n"
"        });\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:926
#, no-c-format
msgid ""
"In addition, all Vaadin components get the <literal>v-widget</literal> "
"class. If it extends an existing Vaadin or GWT widget, it will inherit CSS "
"classes from that as well."
msgstr ""
"除此之外, 所有的 Vaadin 组件都会带有 <literal>v-widget</literal> 样式类. 如果"
"一个 widget 继承已有的 Vaadin 或 GWT widget, 那么它也会继承 widget 父类的 "
"CSS 样式."

#. Tag: title
#: chapter-gwt.xml:934
#, no-c-format
msgid "Default Stylesheet"
msgstr "默认的样式表文件"

#. Tag: para
#: chapter-gwt.xml:936
#, no-c-format
msgid ""
"A client-side module, which is normally a widget set, can include "
"stylesheets. They must be placed under the <filename>public</filename> "
"folder under the folder of the widget set, a described in <xref linkend="
"\"clientside.module.stylesheet\"/>."
msgstr ""
"客户端模块, (通常是widget set), 可以包含样式表文件. 样式表文件必须放在 "
"widget set 所在文件夹下的 <filename>public</filename> 文件夹之下, 详情请参见 "
"<xref linkend=\"clientside.module.stylesheet\"/>."

#. Tag: para
#: chapter-gwt.xml:943
#, no-c-format
msgid "For example, you could style the widget described above as follows:"
msgstr "比如, 对于前面例子中的 widget, 你可以使用下面的样式表文件控制它的样式:"

#. Tag: programlisting
#: chapter-gwt.xml:947
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[.mypicker {\n"
"        white-space: nowrap;\n"
"}\n"
"\n"
".mypicker-button {\n"
"        display: inline-block;\n"
"        border: 1px solid black;\n"
"        padding: 3px;\n"
"        width: 15px;\n"
"        text-align: center;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:949
#, no-c-format
msgid ""
"Notice that some size settings may require more complex handling and "
"calculating the sizes dynamically."
msgstr ""
"注意, 组件的某些尺寸设置, 可能会需要更复杂的控制, 也可能需要动态地计算尺寸."

#. Tag: title
#: chapter-gwt.xml:984
#, no-c-format
msgid "Component Containers"
msgstr "组件容器"

#. Tag: para
#: chapter-gwt.xml:986
#, no-c-format
msgid ""
"Component containers, such as layout components, are a special group of "
"components that require some consideration. In addition to handling state, "
"they need to manage communicating the hierarchy of their contained "
"components to the other side."
msgstr ""
"组件容器, 比如布局组件, 是一组特殊的组件, 需要考虑更多的问题. 除了管理自己的"
"状态之外, 它们还需要在服务器端和客户端之间传递自己内部组件的层级关系状态."

#. Tag: para
#: chapter-gwt.xml:993
#, no-c-format
msgid ""
"The easiest way to implement a component container is extend the "
"<classname>AbstractComponentContainer</classname>, which handles the "
"synchronization of the container server-side components to the client-side."
msgstr ""
"实现组件容器的最简便方法是继承 <classname>AbstractComponentContainer</"
"classname> 类, 这个类会管理组件容器从服务器端到客户端的同步问题."

#. Tag: title
#: chapter-gwt.xml:1022
#, no-c-format
msgid "Advanced Client-Side Topics"
msgstr "客户端的一些高级问题"

#. Tag: para
#: chapter-gwt.xml:1024
#, no-c-format
msgid ""
"In the following, we mention some topics that you may encounter when "
"integrating widgets."
msgstr "下面, 我们讨论在 widget 集成时你可能会遇到的一些问题."

#. Tag: title
#: chapter-gwt.xml:1030
#, no-c-format
msgid "Client-Side Processing Phases"
msgstr "客户端处理的各个阶段"

#. Tag: para
#: chapter-gwt.xml:1032
#, no-c-format
msgid ""
"Vaadin's client-side engine reacts to changes from the server in a number of "
"phases, the order of which can be relevant for a connector. The processing "
"occurs in the <methodname>handleUIDLMessage()</methodname> method in "
"<classname>ApplicationConnection</classname>, but the logic can be quite "
"overwhelming, so we describe the phases in the following summary."
msgstr ""
"当服务器端状态发生变化时, Vaadin 客户端引擎的反应分为几个不同的阶段, 在不同的"
"连接器中, 这些阶段的发生顺序可能会不同. 处理发生在 "
"<classname>ApplicationConnection</classname> 的 "
"<methodname>handleUIDLMessage()</methodname> 方法中, 但处理逻辑非常复杂, 因此"
"我们将各个处理阶段总结如下."

#. Tag: para
#: chapter-gwt.xml:1042
#, no-c-format
msgid ""
"Any dependencies defined by using <classname>@JavaScript</classname> or "
"<classname>@StyleSheet</classname> on the server-side class are loaded. "
"Processing does not continue until the browser confirms that they have been "
"loaded."
msgstr ""
"在服务器端类中可以使用 <classname>@JavaScript</classname> 注解或 "
"<classname>@StyleSheet</classname> 注解来定义的依赖的 JavaScript 或样式表, 这"
"一阶段首先装载这些资源. 直到浏览器确认这些资源装载完毕, 处理才会继续执行."

#. Tag: para
#: chapter-gwt.xml:1052
#, no-c-format
msgid ""
"New connectors are instantiated and <methodname>init()</methodname> is run "
"for each <interfacename>Connector</interfacename>."
msgstr ""
"初始化新的连接器, 并对每个 <interfacename>Connector</interfacename> 执行 "
"<methodname>init()</methodname> 方法."

#. Tag: para
#: chapter-gwt.xml:1060
#, no-c-format
msgid "State objects are updated, but no state change event is fired yet."
msgstr "更新状态对象, 但还不会激发状态变更事件."

#. Tag: para
#: chapter-gwt.xml:1066
#, no-c-format
msgid ""
"The connector hierarchy is updated, but no hierarchy change event is fired "
"yet. <methodname>setParent()</methodname> and <methodname>setChildren()</"
"methodname> are run in this phase."
msgstr ""
"更新连接器层级关系, 但还不会激发层级关系变更事件. 在这个阶段会执行 "
"<methodname>setParent()</methodname> 方法和 <methodname>setChildren()</"
"methodname> 方法."

#. Tag: para
#: chapter-gwt.xml:1074
#, no-c-format
msgid ""
"Hierarchy change events are fired. This means that all state objects and the "
"entire hierarchy are already up to date when this happens. The DOM hierarchy "
"should in theory be up to date after all hierarchy events have been handled, "
"although there are some built-in components that for various reasons do not "
"always live up to this promise."
msgstr ""
"这个阶段会激发层级关系变更事件. 也就是说此时所有的状态对象和完整的层级关系已"
"经更新完毕. 当所有的层级关系变更事件处理完毕之后, 理论上来说 DOM 元素的层级关"
"系应该更新完毕, 但是某些内建组件出于各种理由, 不一定会保证这一点."

#. Tag: para
#: chapter-gwt.xml:1085
#, no-c-format
msgid ""
"Captions are updated, causing <methodname>updateCaption()</methodname> to be "
"invoked on layouts as needed."
msgstr ""
"更新标签, 根据需要会在布局上调用 <methodname>updateCaption()</methodname> 方"
"法."

#. Tag: para
#: chapter-gwt.xml:1093
#, no-c-format
msgid ""
"<classname>@DelegateToWidget</classname> is handled for all changed state "
"objects using the annotation."
msgstr ""
"对于所有使用 <classname>@DelegateToWidget</classname> 注解的状态对象属性, 处"
"理相关的变更."

#. Tag: para
#: chapter-gwt.xml:1100
#, no-c-format
msgid "State change events are fired for all changed state objects."
msgstr "对于有变更的状态对象, 激发状态变更事件."

#. Tag: para
#: chapter-gwt.xml:1106
#, no-c-format
msgid ""
"<methodname>updateFromUIDL()</methodname> is called for legacy connectors."
msgstr ""
"对于旧版本遗留的连接器, 调用 <methodname>updateFromUIDL()</methodname>."

#. Tag: para
#: chapter-gwt.xml:1113
#, no-c-format
msgid "All RPC methods received from the server are invoked."
msgstr "调用从服务器端收到的所有 RPC 方法."

#. Tag: para
#: chapter-gwt.xml:1119
#, no-c-format
msgid ""
"Connectors that are no longer included in the hierarchy are unregistered. "
"This calls <methodname>onUnregister()</methodname> on the "
"<interfacename>Connector</interfacename>."
msgstr ""
"注销不再包含在层级关系中的连接器. 这个过程会调用 <interfacename>Connector</"
"interfacename> 的 <methodname>onUnregister()</methodname> 方法."

#. Tag: para
#: chapter-gwt.xml:1127
#, no-c-format
msgid ""
"The layout phase starts, first checking the sizes and positions of all "
"elements, and then notifying any <interfacename>ElementResizeListener</"
"interfacename>s, as well as calling the appropriate layout method for the "
"connectors that implement either <classname>SimpleManagedLayout</classname> "
"or <classname>DirectionalManagedLayout</classname> interface."
msgstr ""
"从这里开始进入布局管理阶段, 首先检查所有元素的尺寸和位置, 然后向所有的 "
"<interfacename>ElementResizeListener</interfacename> 发送通知, 并对实现 "
"<classname>SimpleManagedLayout</classname> 或 "
"<classname>DirectionalManagedLayout</classname> 接口的连接器, 调用适当的布局"
"方法."

#. Tag: title
#: chapter-gwt.xml:1141
#, no-c-format
msgid "Creating Add-ons"
msgstr "创建 Add-on"

#. Tag: primary
#: chapter-gwt.xml:1144
#, no-c-format
msgid "<primary>add-ons</primary>"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:1145
#, no-c-format
msgid "creating"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1148
#, no-c-format
msgid ""
"Add-ons are the most convenient way to reuse Vaadin code, either "
"commercially or free. Vaadin Directory serves as the store for the add-ons. "
"You can distribute add-ons both as JAR libraries and Zip packages."
msgstr ""
"不论是商业版还是免费版, Add-on 是重用 Vaadin 代码的最便利方法. Vaadin "
"Directory 是 add-on 的下载中心. 你可以使用 JAR 库或 Zip 包形式发布 add-on."

#. Tag: para
#: chapter-gwt.xml:1154
#, no-c-format
msgid "Creating a typical add-on package involves the following tasks:"
msgstr "创建一个通常的 add-on 包, 包括以下几个步骤:"

#. Tag: listitem
#: chapter-gwt.xml:1159
#, no-c-format
msgid "Compile server-side classes"
msgstr "编译服务器端类"

#. Tag: listitem
#: chapter-gwt.xml:1160
#, no-c-format
msgid "Compile JavaDoc (optional)"
msgstr "编译 JavaDoc(可选)"

#. Tag: para
#: chapter-gwt.xml:1162
#, no-c-format
msgid "Build the JAR"
msgstr "Build JAR 文件"

#. Tag: listitem
#: chapter-gwt.xml:1164
#, no-c-format
msgid "Include Vaadin add-on manifest"
msgstr "包含 Vaadin add-on manifest 文件"

#. Tag: listitem
#: chapter-gwt.xml:1165
#, no-c-format
msgid "Include the compiled server-side classes"
msgstr "包含编译后的服务器端类文件"

#. Tag: listitem
#: chapter-gwt.xml:1166
#, no-c-format
msgid "Include the compiled JavaDoc (optional)"
msgstr "包含编译后的 JavaDoc (可选)"

#. Tag: listitem
#: chapter-gwt.xml:1167
#, no-c-format
msgid ""
"Include sources of client-side classes for widget set compilation (optional)"
msgstr "包含客户端类源代码, 以便编译 widget set(可选)"

#. Tag: listitem
#: chapter-gwt.xml:1168
#, no-c-format
msgid "Include any JavaScript dependency libraries (optional)"
msgstr "包含所有依赖的 JavaScript 库(可选)"

#. Tag: listitem
#: chapter-gwt.xml:1169
#, no-c-format
msgid "Exclude any test or demo code in the project"
msgstr "不要包含工程中的所有测试代码或示例代码"

#. Tag: para
#: chapter-gwt.xml:1174
#, no-c-format
msgid ""
"The exact contents depend on the add-on type. Component add-ons often "
"include a widget set, but not always, such as JavaScript components or pure "
"server-side components. You can also have data container and theme add-ons, "
"as well as various tools."
msgstr ""
"具体的内容取决于 add-on 的类型. 组件 add-on 通常包含 widget set, 但也不是永远"
"如此, 比如 JavaScript 组件或纯服务器端组件就没有 widget set. 你也开发数据容"
"器 add-on 和 theme add-on, 以及各种工具 add-on."

#. Tag: para
#: chapter-gwt.xml:1181
#, no-c-format
msgid ""
"It is common to distribute the JavaDoc in a separate JAR, but you can also "
"include it in the same JAR."
msgstr ""
"通常使用独立的 JAR 来发布 JavaDoc, 但也可以将 JavaDoc 包含在同一个 JAR 中."

#. Tag: title
#: chapter-gwt.xml:1187
#, no-c-format
msgid "Exporting Add-on in Eclipse"
msgstr "在 Eclipse 中导出 Add-on"

#. Tag: para
#: chapter-gwt.xml:1189
#, no-c-format
msgid ""
"If you use the Vaadin Plugin for Eclipse for your add-on project, you can "
"simply export the add-on from Eclipse."
msgstr ""
"如果对你的 add-on 工程使用 Vaadin Plugin for Eclipse, 你可以简单地从 Eclipse "
"中导出 add-on."

#. Tag: para
#: chapter-gwt.xml:1196
#, no-c-format
msgid ""
"Select the project and then <menuchoice><guimenu>File</"
"guimenu><guimenuitem>Export</guimenuitem></menuchoice> from the menu"
msgstr ""
"选中工程, 然后在菜单中选择 <menuchoice><guimenu>File</"
"guimenu><guimenuitem>Export</guimenuitem></menuchoice>"

#. Tag: para
#: chapter-gwt.xml:1201
#, no-c-format
msgid ""
"In the export wizard that opens, select <menuchoice><guimenu>Vaadin</"
"guimenu><guimenuitem>Vaadin Add-on Package</guimenuitem></menuchoice>, and "
"click <guibutton>Next</guibutton>"
msgstr ""
"在 export 向导中, 选择 <menuchoice><guimenu>Vaadin</"
"guimenu><guimenuitem>Vaadin Add-on Package</guimenuitem></menuchoice>, 然后点"
"击 <guibutton>Next</guibutton> 按钮"

#. Tag: para
#: chapter-gwt.xml:1206
#, no-c-format
msgid ""
"In the <guilabel>Select the resources to export</guilabel> panel, select the "
"content that should be included in the add-on package. In general, you "
"should include sources in <filename>src</filename> folder (at least for the "
"client-side package), compiled server-side classes, themes in "
"<filename>WebContent/VAADIN/themes</filename>. These are all included "
"automatically. You probably want to leave out any demo or example code."
msgstr ""
"在 <guilabel>Select the resources to export</guilabel> 窗口中, 选择将包含在 "
"add-on 包中的内容. 通常, 应该包含 <filename>src</filename> 文件夹中的源代码 "
"(至少需要客户端包中的源代码), 编译后的服务器端类, <filename>WebContent/"
"VAADIN/themes</filename> 文件夹中的 theme. 这些内容都是自动包含的. 你可能会希"
"望从输出内容中删除示例代码."

#. Tag: title
#: chapter-gwt.xml:1218
#, no-c-format
msgid "Exporting a Vaadin Add-on"
msgstr "导出一个 Vaadin Add-on"

#. Tag: para
#: chapter-gwt.xml:1226
#, no-c-format
msgid ""
"If you are submitting the add-on to Vaadin Directory, the "
"<guilabel>Implementation title</guilabel> should be exactly the name of the "
"add-on in Directory. The name may contain spaces and most other letters. "
"Notice that <emphasis>it is not possible to change the name later</emphasis>."
msgstr ""
"如果你希望将 add-on 发布到 Vaadin Directory, <guilabel>Implementation title</"
"guilabel> 项目中应该输入 add-on 在 Directory 中的名称. 名称中可以包含空白或其"
"他大多数字符. 注意, <emphasis>名称在发布后无法修改</emphasis>."

#. Tag: para
#: chapter-gwt.xml:1234
#, no-c-format
msgid ""
"The <guilabel>Implementation version</guilabel> is the version of your add-"
"on. Typically experimental or beta releases start from 0.1.0, and stable "
"releases from 1.0.0."
msgstr ""
"<guilabel>Implementation version</guilabel> 项目是你的 add-on 的版本号. 通常"
"试验版或 beta 版从 0.1.0 开始, 稳定版从 1.0.0 开始."

#. Tag: para
#: chapter-gwt.xml:1240
#, no-c-format
msgid ""
"The <guilabel>Widgetsets</guilabel> field should list the widget sets "
"included in the add-on, separated by commas. The widget sets should be "
"listed by their class name, that is, without the <filename>.gwt.xml</"
"filename> extension."
msgstr ""
"<guilabel>Widgetsets</guilabel> 项目应该列出 add-on 中包含的所有 widget set, "
"如果有多个, 使用逗号分隔. 列出 widget set 时应该使用类名, 也就是说, 不要带 "
"<filename>.gwt.xml</filename> 扩展名."

#. Tag: para
#: chapter-gwt.xml:1247
#, no-c-format
msgid ""
"The <guilabel>JAR file</guilabel> is the file name of the exported JAR file. "
"It should normally include the version number of the add-on. You should "
"follow the Maven format for the name, such as <filename>myaddon-1.0.0.jar</"
"filename>."
msgstr ""
"<guilabel>JAR file</guilabel> 项目是输出的 JAR 文件名. 通常应该包含 add-on 的"
"版本号. 你应该遵守 Maven 的命名规约, 比如: <filename>myaddon-1.0.0.jar</"
"filename>."

#. Tag: para
#: chapter-gwt.xml:1254
#, no-c-format
msgid "Finally, click <guibutton>Finish</guibutton>."
msgstr "最后, 点击 <guibutton>Finish</guibutton> 按钮."

#. Tag: title
#: chapter-gwt.xml:1262
#, no-c-format
msgid "Building Add-on with Ant"
msgstr "使用 Ant 构建 Add-on"

#. Tag: para
#: chapter-gwt.xml:1264
#, no-c-format
msgid ""
"Building an add-on with Ant is similar to building Vaadin applications. "
"Vaadin libraries and other dependencies are retrieved and included in the "
"classpath using Apache Ivy."
msgstr ""
"使用 Ant 来构建 add-on 的方法与构建 Vaadin 应用程序类似. Vaadin 库及其他依赖"
"的库会通过 Apache Ivy 自动取得, 并包含到类路径中."

#. Tag: para
#: chapter-gwt.xml:1270
#, no-c-format
msgid ""
"In the following, we assume the same structure as in the Eclipse project "
"example. Let us put the build script in the <filename>build</filename> "
"folder under the project. We begin the Ant script as follows:"
msgstr ""
"下面的示例中, 我们假定工程结构与前面的 Eclipse 工程示例相同. 我们将构建脚本放"
"在工程根目录下的 <filename>build</filename> 文件夹中. 我们首先创建以下 Ant 脚"
"本:"

#. Tag: programlisting
#: chapter-gwt.xml:1276
#, no-c-format
msgid ""
"&lt;?xml version=\"1.0\"?&gt;\n"
"\n"
"&lt;project xmlns:ivy=\"antlib:org.apache.ivy.ant\"\n"
"         name=\"<emphasis role=\"bold\">My Own add-on</emphasis>\"\n"
"         basedir=\"..\"\n"
"         default=\"package-jar\"&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1278
#, no-c-format
msgid ""
"The namespace declaration is all you need to do to enable Ivy in Ant 1.6 and "
"later. For earlier Ant versions, please see the Ivy documentation."
msgstr ""
"在 Ant 1.6 或更高版本中使用 Ivy, 只需要声明相关的 namespace 即可. 对于更老的 "
"Ant 版本, 请参见 Ivy 文档."

#. Tag: title
#: chapter-gwt.xml:1284
#, no-c-format
msgid "Configuration and Initialization"
msgstr "配置与初始化"

#. Tag: para
#: chapter-gwt.xml:1286
#, no-c-format
msgid ""
"In the example script, we organize most settings in a <literal>configure</"
"literal> target and then initialize the build in <literal>init</literal> "
"target."
msgstr ""
"在构建脚本示例中, 我们将大多数配置放在 <literal>configure</literal> 目标"
"(target)中, 然后在 <literal>init</literal> 目标中初始化构建环境."

#. Tag: programlisting
#: chapter-gwt.xml:1292
#, no-c-format
msgid ""
"<?pocket-size 65% ?><!-- Update these settings for your project structure --"
">\n"
"&lt;target name=\"configure\"&gt;\n"
"    &lt;!-- Where project source files are located --&gt;\n"
"    &lt;property name=\"src-location\" value=\"<emphasis role=\"bold\">src</"
"emphasis>\" /&gt;\n"
"        \n"
"    &lt;!-- Name of the widget set. --&gt;\n"
"    &lt;property name=\"widgetset\" value=\"<emphasis role=\"bold\">com."
"example.myaddon.widgetset.MyAddonWidgetset</emphasis>\"/&gt;\n"
"\n"
"    &lt;!-- Addon version --&gt;\n"
"    &lt;property name=\"version\" value=\"<emphasis role=\"bold\">0.1.0</"
"emphasis>\"/&gt;\n"
"    \n"
"    &lt;!-- Compilation result directory --&gt;\n"
"    &lt;property name=\"result-dir\" value=\"build/result\"/&gt;\n"
"    \n"
"    &lt;!-- The target name of the built add-on JAR --&gt;\n"
"    &lt;property name=\"target-jar\"\n"
"        value=\"${result-dir}/<emphasis role=\"bold\">myaddon</emphasis>-"
"${version}.jar\"/&gt;\n"
"&lt;/target&gt;\n"
"\n"
"<!-- Initialize build -->\n"
"&lt;target name=\"init\" depends=\"configure\"&gt;\n"
"    &lt;!-- Construct and check classpath --&gt;\n"
"    &lt;path id=\"compile.classpath\"&gt;\n"
"        &lt;pathelement path=\"build/classes\" /&gt;\n"
"        &lt;pathelement path=\"${src-location}\" /&gt;\n"
"        &lt;fileset dir=\"${result-dir}/lib\"&gt;\n"
"            &lt;include name=\"*.jar\"/&gt;\n"
"        &lt;/fileset&gt;\n"
"    &lt;/path&gt;\n"
"\n"
"    &lt;mkdir dir=\"${result-dir}\"/&gt;\n"
"&lt;/target&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1294
#, no-c-format
msgid ""
"You will need to make some configuration also in the <literal>package-jar</"
"literal> target in addition to the <literal>configure</literal> target."
msgstr ""
"除 <literal>configure</literal> 目标之外, 在 <literal>package-jar</literal> "
"目标中也需要进行一些配置."

#. Tag: title
#: chapter-gwt.xml:1302
#, no-c-format
msgid "Compiling the Server-Side"
msgstr "编译服务器端代码"

#. Tag: para
#: chapter-gwt.xml:1304
#, no-c-format
msgid ""
"Compiling the add-on requires the Vaadin libraries and any dependencies. We "
"use Apache Ivy for resolving the dependencies and retrieving the library "
"JARs."
msgstr ""
"编译 add-on 需要使用 Vaadin 库和其他依赖库. 我们使用 Apache Ivy 来解析库之间"
"的依赖关系, 并自动取得这些库的 JAR 文件."

#. Tag: programlisting
#: chapter-gwt.xml:1310
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;!-- Retrieve dependencies with Ivy --&gt;\n"
"&lt;target name=\"resolve\" depends=\"init\"&gt;\n"
"    &lt;ivy:retrieve\n"
"        pattern=\"${result-dir}/lib/[artifact].[ext]\"/&gt;\n"
"&lt;/target&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1312
#, no-c-format
msgid ""
"The <literal>pattern</literal> attribute for the <literal>&lt;retrieve&gt;</"
"literal> task specifies where the dependencies are stored, in the above case "
"in the <filename>build/result/lib</filename> directory."
msgstr ""
"<literal>&lt;retrieve&gt;</literal> 任务(task)的 <literal>pattern</literal> "
"属性指定依赖库取得之后存储在什么位置, 上面的例子中使用的是 <filename>build/"
"result/lib</filename> 目录."

#. Tag: para
#: chapter-gwt.xml:1319
#, no-c-format
msgid "Compiling the server-side classes is then straight-forward:"
msgstr "然后来编译服务器端类, 这个任务非常简单:"

#. Tag: programlisting
#: chapter-gwt.xml:1323
#, no-c-format
msgid ""
"<![CDATA[<!-- Compile server-side -->\n"
"<target name=\"compile-server-side\"\n"
"        depends=\"init, resolve\">\n"
"    <delete dir=\"${result-dir}/classes\"/>\n"
"    <mkdir dir=\"${result-dir}/classes\"/>\n"
"\n"
"    <javac srcdir=\"${src-location}\"\n"
"           destdir=\"${result-dir}/classes\">\n"
"        <classpath>\n"
"            <path refid=\"compile.classpath\"/>\n"
"        </classpath>\n"
"    </javac>\n"
"</target>]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1327
#, no-c-format
msgid "Compiling the JavaDoc"
msgstr "编译 JavaDoc"

#. Tag: para
#: chapter-gwt.xml:1329
#, no-c-format
msgid ""
"You may want to include API documentation for the add-on in the same or in a "
"different JAR file. You can do it as follows, using the configuration we "
"defined earlier. You may want to exclude the client-side classes and any "
"test and demo classes from the JavaDoc, as is done in this example, if they "
"are in the same source tree."
msgstr ""
"你可能会希望将 add-on 的 API 文档包含在同一个或者另一个 JAR 文件中. 你可以使"
"用我们前面定义的配置, 通过以下方法实现. 如果源代码树中包含了客户端类以及测试"
"和示例类, 你可能会希望在 JavaDoc 中排除它们, 下面的示例中就是这样做的."

#. Tag: programlisting
#: chapter-gwt.xml:1337
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;!-- Compile JavaDoc --&gt;\n"
"&lt;target name=\"compile-javadoc\" depends=\"init\"&gt;\n"
"    &lt;delete dir=\"${result-dir}/javadoc\"/&gt;\n"
"    &lt;mkdir dir=\"${result-dir}/javadoc\"/&gt;\n"
"\n"
"    &lt;javadoc destdir=\"${result-dir}/javadoc\"&gt;\n"
"        &lt;sourcefiles&gt;\n"
"            &lt;fileset dir=\"${src-location}\" id=\"src\"&gt;\n"
"                &lt;include name=\"**/*.java\"/&gt;\n"
"                \n"
"                &lt;!-- Excluded stuff from the package --&gt;\n"
"                &lt;exclude name=\"<emphasis role=\"bold\">**/client/**/*</"
"emphasis>\"/&gt;\n"
"                &lt;exclude name=\"<emphasis role=\"bold\">**/demo/**/*</"
"emphasis>\"/&gt;\n"
"                &lt;exclude name=\"<emphasis role=\"bold\">**/MyDemoUI.java</"
"emphasis>\"/&gt;\n"
"            &lt;/fileset&gt;\n"
"        &lt;/sourcefiles&gt;\n"
"        &lt;classpath&gt;\n"
"            &lt;path refid=\"compile.classpath\"/&gt;\n"
"        &lt;/classpath&gt;\n"
"    &lt;/javadoc&gt;\n"
"&lt;/target&gt;"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1341
#, no-c-format
msgid "Packaging the JAR"
msgstr "打包 JAR 文件"

#. Tag: para
#: chapter-gwt.xml:1343
#, no-c-format
msgid "An add-on JAR typically includes the following:"
msgstr "一个 add-on 的 JAR 文件通常包含以下内容:"

#. Tag: listitem
#: chapter-gwt.xml:1348
#, no-c-format
msgid "Vaadin add-on manifest"
msgstr "Vaadin add-on manifest 文件"

#. Tag: listitem
#: chapter-gwt.xml:1349
#, no-c-format
msgid "The compiled server-side classes"
msgstr "编译后的服务器端类文件"

#. Tag: listitem
#: chapter-gwt.xml:1350
#, no-c-format
msgid "The compiled JavaDoc (optional)"
msgstr "编译后的 JavaDoc (可选)"

#. Tag: listitem
#: chapter-gwt.xml:1351
#, no-c-format
msgid "Sources of client-side classes (optional)"
msgstr "客户端类的源代码文件 (可选)"

#. Tag: listitem
#: chapter-gwt.xml:1352
#, no-c-format
msgid "Any JavaScript dependency libraries (optional)"
msgstr "所有依赖的 JavaScript 库 (可选)"

#. Tag: para
#: chapter-gwt.xml:1355
#, no-c-format
msgid ""
"Let us begin crafting the target. The JAR requires the compiled server-side "
"classes and the optional API documentation."
msgstr ""
"我们首先来编写 Ant 的构建目标. JAR 文件需要编译后的服务器端类, 以及 API 文档"
"(可选)."

#. Tag: programlisting
#: chapter-gwt.xml:1360
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<!-- Build the JAR -->\n"
"<target name=\"package-jar\"\n"
"        depends=\"compile-server-side, compile-javadoc\">\n"
"    <jar jarfile=\"${target-jar}\" compress=\"true\">]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1362
#, no-c-format
msgid ""
"First, you need to include a manifest that defines basic information about "
"the add-on. The implementation title must be the exact title of the add-on, "
"as shown in the Vaadin Directory title. The vendor is you. The manifest also "
"includes the license title and file reference for the add-on."
msgstr ""
"第一步, 你需要包含 manifest, 它负责定义 add-on 的基本信息. implementation "
"title 项目必须设置为 add-on 的标题, 和在 Vaadin Directory 中显示的标题一致. "
"vendor 项目是你自己. manifest 中还包括 add-on 的 license title 和 license "
"file 参照地址."

#. Tag: programlisting
#: chapter-gwt.xml:1370
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;!-- Manifest required by Vaadin Directory --&gt;\n"
"&lt;manifest&gt;\n"
"    &lt;attribute name=\"Vaadin-Package-Version\"\n"
"               value=\"1\" /&gt;\n"
"    &lt;attribute name=\"Vaadin-Widgetsets\"\n"
"               value=\"${widgetset}\" /&gt;\n"
"    &lt;attribute name=\"Implementation-Title\"\n"
"               value=\"<emphasis role=\"bold\">My Own Addon</emphasis>\" /"
"&gt;\n"
"    &lt;attribute name=\"Implementation-Version\"\n"
"               value=\"${version}\" /&gt;\n"
"    &lt;attribute name=\"Implementation-Vendor\"\n"
"               value=\"<emphasis role=\"bold\">Me Myself</emphasis>\" /&gt;\n"
"    &lt;attribute name=\"Vaadin-License-Title\"\n"
"               value=\"<emphasis role=\"bold\">Apache2</emphasis>\" /&gt;\n"
"    &lt;attribute name=\"Vaadin-License-File\"\n"
"        value=\"<emphasis role=\"bold\">http://www.apache.org/licenses/"
"LICENSE-2.0</emphasis>\" /&gt;\n"
"&lt;/manifest&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1372
#, no-c-format
msgid ""
"The rest of the <literal>package-jar</literal> target goes as follows. As "
"was done in the JavaDoc compilation, you also need to exclude any test or "
"demo code in the project here. You need to modify at least the emphasized "
"parts for your project."
msgstr ""
"<literal>package-jar</literal> 目标的其余部分如下. 和编译 JavaDoc 时一样, 这"
"里你也需要排除工程中的测试和示例代码. 针对你的工程的具体结构, 你至少需要修改"
"下例中粗体字的部分."

#. Tag: programlisting
#: chapter-gwt.xml:1379
#, no-c-format
msgid ""
"<?pocket-size 65% ?>        &lt;!-- Include built server-side classes --"
"&gt;\n"
"        &lt;fileset dir=\"build/result/classes\"&gt;\n"
"            &lt;patternset&gt;\n"
"                &lt;include name=\"<emphasis role=\"bold\">com/example/"
"myaddon/**/*</emphasis>\"/&gt;\n"
"                &lt;exclude name=\"<emphasis role=\"bold\">**/client/**/*</"
"emphasis>\"/&gt;\n"
"                &lt;exclude name=\"<emphasis role=\"bold\">**/demo/**/*</"
"emphasis>\"/&gt;\n"
"                &lt;exclude name=\"<emphasis role=\"bold\">**/test/**/*</"
"emphasis>\"/&gt;\n"
"                &lt;exclude name=\"<emphasis role=\"bold\">**/MyDemoUI*</"
"emphasis>\"/&gt;\n"
"            &lt;/patternset&gt;\n"
"        &lt;/fileset&gt;\n"
"    \n"
"        &lt;!-- Include widget set sources --&gt;\n"
"        &lt;fileset dir=\"src\"&gt;\n"
"            &lt;patternset&gt;\n"
"                &lt;include name=\"<emphasis role=\"bold\">com/exaple/"
"myaddon/**/*</emphasis>\"/&gt;\n"
"            &lt;/patternset&gt;\n"
"        &lt;/fileset&gt;\n"
"    \n"
"        &lt;!-- Include JavaDoc in the JAR --&gt;\n"
"        &lt;fileset dir=\"${result-dir}/javadoc\"\n"
"                 includes=\"**/*\"/&gt;\n"
"    &lt;/jar&gt;\n"
"&lt;/target&gt;"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1383
#, no-c-format
msgid "You should now be ready to run the build script with Ant."
msgstr "到这里, 你应该可以使用 Ant 来运行构建脚本了."

#. Tag: title
#: chapter-gwt.xml:1391
#, no-c-format
msgid "Migrating from Vaadin 6"
msgstr "从 Vaadin 6 迁移"

#. Tag: primary
#: chapter-gwt.xml:1394
#, no-c-format
msgid "Vaadin 6 Migration"
msgstr ""

#. Tag: secondary
#: chapter-gwt.xml:1395
#, no-c-format
msgid "<secondary>add-ons</secondary>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1398
#, no-c-format
msgid ""
"The client-side architecture was redesigned almost entirely in Vaadin 7. In "
"Vaadin 6, state synchronization was done explicitly by serializing and "
"deserializing the state on the server- and client-side. In Vaadin 7, the "
"serialization is handled automatically by the framework using state objects."
msgstr ""
"在 Vaadin 7 中, 客户端架构几乎完全重新设计过了. 在 Vaadin 6 中, 状态同步是通"
"过在服务器端和客户端显示地序列化/反序列化来实现的. 在 Vaadin 7 中, 序列化是 "
"Vaadin 框架使用状态对象自动处理的."

#. Tag: para
#: chapter-gwt.xml:1405
#, no-c-format
msgid ""
"In Vaadin 6, a server-side component serialized its state to the client-side "
"using the <interfacename>Paintable</interfacename> interface in the client-"
"side and deserialized the state through the <interfacename>VariableOwner</"
"interfacename> interface. In Vaadin 7, these are done through the "
"<interfacename>ClientConnector</interfacename> interface."
msgstr ""
"在 Vaadin 6 中, 服务器端组件会使用客户端的 <interfacename>Paintable</"
"interfacename> 接口, 将它的状态序列化到客户端, 并使用使用 "
"<interfacename>VariableOwner</interfacename> 接口来反序列化状态信息. 在 "
"Vaadin 7 中, 这些工作都使用 <interfacename>ClientConnector</interfacename> 接"
"口来实现."

#. Tag: para
#: chapter-gwt.xml:1413
#, no-c-format
msgid ""
"On the client-side, a widget deserialized its state through the "
"<interfacename>Paintable</interfacename> interface and sent state changes "
"through the <interfacename>ApplicationConnection</interfacename> object. In "
"Vaadin 7, these are replaced with the <interfacename>ServerConnector</"
"interfacename>."
msgstr ""
"在客户端, widget 使用 <interfacename>Paintable</interfacename> 接口反序列化它"
"的状态, 并通过 <interfacename>ApplicationConnection</interfacename> 对象发送"
"状态变更. 在 Vaadin 7 中, 这些工作被 <interfacename>ServerConnector</"
"interfacename> 替代了."

#. Tag: para
#: chapter-gwt.xml:1421
#, no-c-format
msgid ""
"In addition to state synchronization, Vaadin 7 has an RPC mechanism that can "
"be used for communicating events. They are especially useful for events that "
"are not associated with a state change, such as a button click."
msgstr ""
"除状态信息的同步方式之外, Vaadin 7 还有 RPC 机制可用来传送事件. 这种机制对于"
"与状态变更无关的事件尤其有用, 比如按钮的点击事件."

#. Tag: para
#: chapter-gwt.xml:1427
#, no-c-format
msgid ""
"The framework ensures that the connector hierarchy and states are up-to-date "
"when listeners are called."
msgstr "当监听器被调用时, Vaadin 框架会确保连接器层级关系与状态信息都是最新的."

#. Tag: title
#: chapter-gwt.xml:1433
#, no-c-format
msgid "Quick (and Dirty) Migration"
msgstr "快速(而且肮脏)地迁移"

#. Tag: para
#: chapter-gwt.xml:1435
#, no-c-format
msgid ""
"Vaadin 7 has a compatibility layer that allows quick conversion of a widget."
msgstr "Vaadin 7 中带有一个兼容层, 可以用来快速转换一个 widget."

#. Tag: para
#: chapter-gwt.xml:1441
#, no-c-format
msgid ""
"Create a connector class, such as <classname>MyConnector</classname>, that "
"extends <classname>LegacyConnector</classname>. Implement the "
"<methodname>getWidget()</methodname> method."
msgstr ""
"创建一个连接器类, 比如 <classname>MyConnector</classname>, 继承自 "
"<classname>LegacyConnector</classname>. 实现 <methodname>getWidget()</"
"methodname> 方法."

#. Tag: para
#: chapter-gwt.xml:1449
#, no-c-format
msgid ""
"Move the <literal>@ClientWidget(MyWidget.class)</literal> from the server-"
"side component, say <classname>MyComponent</classname>, to the "
"<classname>MyConnector</classname> class and make it "
"<literal>@Connect(MyComponent.class)</literal>."
msgstr ""
"将 <literal>@ClientWidget(MyWidget.class)</literal> 注解, 从服务器端组件, (假"
"定是 <classname>MyComponent</classname>), 移动到 <classname>MyConnector</"
"classname> 类中, 并修改为 <literal>@Connect(MyComponent.class)</literal>."

#. Tag: para
#: chapter-gwt.xml:1457
#, no-c-format
msgid ""
"Have the server-side component implement the <interface>LegacyComponent</"
"interface> interface to enable compatibility handling."
msgstr ""
"让服务器端组件实现 <interface>LegacyComponent</interface> 接口, 以便允许 "
"Vaadin 进行旧版本兼容处理."

#. Tag: para
#: chapter-gwt.xml:1464
#, no-c-format
msgid "Remove any calls to <literal>super.paintContent()</literal>"
msgstr "删除所有对 <literal>super.paintContent()</literal> 的调用"

#. Tag: para
#: chapter-gwt.xml:1469
#, no-c-format
msgid "Update any imports on the client-side"
msgstr "在客户端代码中更新所有的 import 语句"

#. Tag: title
#: chapter-gwt.xml:1480
#, no-c-format
msgid "Integrating JavaScript Components and Extensions"
msgstr "JavaScript 组件与扩展的集成"

#. Tag: primary
#: chapter-gwt.xml:1483
#, no-c-format
msgid "JavaScript integration"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1486
#, no-c-format
msgid ""
"Vaadin allows simplified integration of pure JavaScript components, as well "
"as component and UI extensions. The JavaScript connector code is published "
"from the server-side. As the JavaScript integration does not involve GWT "
"programming, no widget set compilation is needed."
msgstr ""
"除组件和 UI 扩展外, Vaadin 还可以简单地集成纯 JavaScript 组件. JavaScript 连"
"接器代码由服务器端发布. 由于 JavaScript 集成与 GWT 无关, 因此不需要编译 "
"widget set."

#. Tag: title
#: chapter-gwt.xml:1494
#, no-c-format
msgid "Example JavaScript Library"
msgstr "JavaScript 库示例"

#. Tag: para
#: chapter-gwt.xml:1496
#, no-c-format
msgid ""
"There are many kinds of component libraries for JavaScript. In the "
"following, we present a simple library that provides one object-oriented "
"JavaScript component. We use this example later to show how to integrate it "
"with a server-side Vaadin component."
msgstr ""
"JavaScript 组件库有很多类型. 下面的例子中, 我们将演示一个简单的库, 它提供一个"
"面向对象的 JavaScript 组件. 后面我们会使用这个例子来演示如何将它与服务器端 "
"Vaadin 组件集成."

#. Tag: para
#: chapter-gwt.xml:1503
#, no-c-format
msgid ""
"The example library includes a single <classname>MyComponent</classname> "
"component, defined in <filename>mylibrary.js</filename>."
msgstr ""
"例子库中包含一个 <classname>MyComponent</classname> 组件, 定义在 "
"<filename>mylibrary.js</filename> 中."

#. Tag: programlisting
#: chapter-gwt.xml:1508
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Define the namespace\n"
"var mylibrary = mylibrary || {};\n"
"\n"
"mylibrary.MyComponent = function (element) {\n"
"        element.innerHTML =\n"
"                \"<div class='caption'>Hello, world!</div>\" +\n"
"                \"<div class='textinput'>Enter a value: \" +\n"
"                \"<input type='text' name='value'/>\" +\n"
"                \"<input type='button' value='Click'/>\" +\n"
"                \"</div>\";\n"
"\n"
"        // Style it\n"
"        element.style.border = \"thin solid red\";\n"
"        element.style.display = \"inline-block\";\n"
"\n"
"        // Getter and setter for the value property\n"
"        this.getValue = function () {\n"
"                return element.\n"
"                    getElementsByTagName(\"input\")[0].value;\n"
"        };\n"
"        this.setValue = function (value) {\n"
"                element.getElementsByTagName(\"input\")[0].value =\n"
"                    value;\n"
"        };\n"
"\n"
"        // Default implementation of the click handler\n"
"        this.click = function () {\n"
"                alert(\"Error: Must implement click() method\");\n"
"        };\n"
"\n"
"        // Set up button click\n"
"        var button = element.getElementsByTagName(\"input\")[1];\n"
"        var self = this; // Can't use this inside the function\n"
"        button.onclick = function () {\n"
"                self.click();\n"
"        };\n"
"};]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1510
#, no-c-format
msgid ""
"When used in an HTML page, the library would be included with the following "
"definition:"
msgstr "在 HTML 页面中使用时, 应该使用以下语句包含库文件:"

#. Tag: programlisting
#: chapter-gwt.xml:1515
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[<script type=\"text/javascript\"\n"
"        src=\"mylibrary.js\"></script>]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1517
#, no-c-format
msgid "You could then use it anywhere in the HTML document as follows:"
msgstr "然后你就可以在 HTML 文档的任何地方使用这个组件, 如下:"

#. Tag: programlisting
#: chapter-gwt.xml:1521
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[<!-- Placeholder for the component -->    \n"
"<div id=\"foo\"></div>\n"
"    \n"
"<!-- Create the component and bind it to the placeholder -->\n"
"<script type=\"text/javascript\">\n"
"    window.foo = new mylibrary.MyComponent(\n"
"            document.getElementById(\"foo\"));\n"
"    window.foo.click = function () {\n"
"        alert(\"Value is \" + this.getValue());\n"
"    }\n"
"</script>]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1524
#, no-c-format
msgid "A JavaScript Component Example"
msgstr "JavaScript 组件示例"

#. Tag: para
#: chapter-gwt.xml:1532
#, no-c-format
msgid ""
"You could interact with the component with JavaScript for example as follows:"
msgstr "你可以通过 JavaScript 来与这个组件交互, 比如:"

#. Tag: programlisting
#: chapter-gwt.xml:1537
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[<a href=\"javascript:foo.setValue('New "
"value')\">Click here</a>]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1541
#, no-c-format
msgid "A Server-Side API for a JavaScript Component"
msgstr "供 JavaScript 组件使用的服务器端 API"

#. Tag: para
#: chapter-gwt.xml:1543
#, no-c-format
msgid ""
"To begin integrating such a JavaScript component, you would need to sketch a "
"bit how it would be used from a server-side Vaadin application. The "
"component should support writing the value as well as listening for changes "
"to it."
msgstr ""
"为了与这样一个 JavaScript 组件集成, 你首先需要规划一下它在服务器端 Vaadin 应"
"用程序中应该如何使用. 组件应该支持值的写操作, 还要能够监听值的变化."

#. Tag: programlisting
#: chapter-gwt.xml:1550
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[final MyComponent mycomponent = new "
"MyComponent();\n"
"\n"
"// Set the value from server-side\n"
"mycomponent.setValue(\"Server-side value\");\n"
"\n"
"// Process a value input by the user from the client-side\n"
"mycomponent.addValueChangeListener(\n"
"        new MyComponent.ValueChangeListener() {\n"
"    @Override\n"
"    public void valueChange() {\n"
"        Notification.show(\"Value: \" + mycomponent.getValue());\n"
"    }\n"
"});\n"
"\n"
"layout.addComponent(mycomponent);]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1555
#, no-c-format
msgid ""
"A JavaScript component extends the <classname>AbstractJavaScriptComponent</"
"classname>, which handles the shared state and RPC for the component."
msgstr ""
"JavaScript 组件继承自 <classname>AbstractJavaScriptComponent</classname>, 这"
"个类会为组件管理共享的状态对象, 以及 RPC 调用."

#. Tag: programlisting
#: chapter-gwt.xml:1562
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[package com.vaadin.book.examples.client.js;\n"
"\n"
"@JavaScript({\"mylibrary.js\", \"mycomponent-connector.js\"})\n"
"public class MyComponent extends AbstractJavaScriptComponent {\n"
"    public interface ValueChangeListener extends Serializable {\n"
"        void valueChange();\n"
"    }\n"
"    ArrayList<ValueChangeListener> listeners =\n"
"            new ArrayList<ValueChangeListener>();\n"
"    public void addValueChangeListener(\n"
"                   ValueChangeListener listener) {\n"
"        listeners.add(listener);\n"
"    }\n"
"    \n"
"    public void setValue(String value) {\n"
"        getState().value = value;\n"
"    }\n"
"    \n"
"    public String getValue() {\n"
"        return getState().value;\n"
"    }\n"
"\n"
"    @Override\n"
"    protected MyComponentState getState() {\n"
"        return (MyComponentState) super.getState();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1564
#, no-c-format
msgid ""
"Notice later when creating the JavaScript connector that its name must match "
"the package name of this server-side class."
msgstr ""
"注意, 本节后续部分中创建的 JavaScript 连接器, 它的名称必须与这个服务器端类的"
"包名一致."

#. Tag: para
#: chapter-gwt.xml:1569
#, no-c-format
msgid "The shared state of the component is as follows:"
msgstr "组件的共享状态信息如下:"

#. Tag: programlisting
#: chapter-gwt.xml:1573
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyComponentState extends "
"JavaScriptComponentState {\n"
"    public String value;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1575
#, no-c-format
msgid ""
"If the member variables are private, you need to have public setters and "
"getters for them, which you can use in the component."
msgstr ""
"如果成员变量是 private 的, 那么你需要为它定义 public 的 setter 和 getter 方"
"法, 然后在组件中使用这些 public 方法."

#. Tag: title
#: chapter-gwt.xml:1583
#, no-c-format
msgid "Defining a JavaScript Connector"
msgstr "定义一个 JavaScript 连接器"

#. Tag: para
#: chapter-gwt.xml:1585
#, no-c-format
msgid ""
"A JavaScript connector is a function that initializes the JavaScript "
"component and handles communication between the server-side and the "
"JavaScript code."
msgstr ""
"JavaScript 连接器是一个函数, 它负责初始化 JavaScript 组件, 并处理服务器端与 "
"JavaScript  代码之间的通信."

#. Tag: para
#: chapter-gwt.xml:1591
#, no-c-format
msgid ""
"A connector is defined as a connector initializer function that is added to "
"the <literal>window</literal> object. The name of the function must match "
"the server-side class name, with the full package path. Instead of the Java "
"dot notation for the package name, underscores need to be used as separators."
msgstr ""
"连接器定义为一个连接器初始化函数, 这个函数被添加到 <literal>window</literal> "
"对象中. 函数名必须与服务器端类名一致, 其中要包含完整的包路径. 但包名中的分隔"
"符不使用 Java 的点号规约, 而改用下划线作为分隔符."

#. Tag: para
#: chapter-gwt.xml:1599
#, no-c-format
msgid ""
"The Vaadin client-side framework adds a number of methods to the connector "
"function. The <methodname>this.getElement()</methodname> method returns the "
"HTML DOM element of the component. The <methodname>this.getState()</"
"methodname> returns a shared state object with the current state as "
"synchronized from the server-side."
msgstr ""
"Vaadin 客户端框架会向连接器函数添加很多方法. <methodname>this.getElement()</"
"methodname> 方法将返回组件的 HTML DOM 元素. <methodname>this.getState()</"
"methodname> 方法返回共享的状态对象, 其中的状态信息将与服务器端保持同步."

#. Tag: programlisting
#: chapter-gwt.xml:1607
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[window."
"com_vaadin_book_examples_client_js_MyComponent =\n"
"function() {\n"
"    // Create the component\n"
"    var mycomponent =\n"
"        new mylibrary.MyComponent(this.getElement());\n"
"    \n"
"    // Handle changes from the server-side\n"
"    this.onStateChange = function() {\n"
"        mycomponent.setValue(this.getState().value);\n"
"    };\n"
"\n"
"    // Pass user interaction to the server-side\n"
"    var self = this;\n"
"    mycomponent.click = function() {\n"
"        self.onClick(mycomponent.getValue());\n"
"    };\n"
"};]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1609
#, no-c-format
msgid ""
"In the above example, we pass user interaction using the JavaScript RPC "
"mechanism, as described in the next section."
msgstr ""
"上例中, 我们使用 JavaScript RPC 机制来传递用户操作, 详情将在下一节中介绍."

#. Tag: title
#: chapter-gwt.xml:1616
#, no-c-format
msgid "RPC from JavaScript to Server-Side"
msgstr "从 JavaScript 到服务器端的 RPC 调用"

#. Tag: para
#: chapter-gwt.xml:1618
#, no-c-format
msgid ""
"User interaction with the JavaScript component has to be passed to the "
"server-side using an RPC (Remote Procedure Call) mechanism. The JavaScript "
"RPC mechanism is almost equal to regular client-side widgets, as described "
"in <xref linkend=\"gwt.rpc\"/>."
msgstr ""
"用户对 JavaScript 组件的操作必须使用一种 RPC (Remote Procedure Call) 机制传递"
"到服务器端. JavaScript RPC 机制基本上等同于通常的客户端 widget, 详情请参见 "
"<xref linkend=\"gwt.rpc\"/>."

#. Tag: title
#: chapter-gwt.xml:1627
#, no-c-format
msgid "Handling RPC Calls on the Server-Side"
msgstr "在服务器端处理 RPC 调用"

#. Tag: para
#: chapter-gwt.xml:1629
#, no-c-format
msgid ""
"Let us begin with the RPC function registration on the server-side. RPC "
"calls are handled on the server-side in function handlers that implement the "
"<interfacename>JavaScriptFunction</interfacename> interface. A server-side "
"function handler is registered with the <methodname>addFunction()</"
"methodname> method in <classname>AbstractJavaScriptComponent</classname>. "
"The server-side registration actually defines a JavaScript method that is "
"available in the client-side connector object."
msgstr ""
"我们首先来看看服务器端的 RPC 函数注册. RPC 调用在服务器端由函数处理器负责处"
"理, 函数处理器实现 <interfacename>JavaScriptFunction</interfacename> 接口. 服"
"务器端的一个函数处理器使用 <classname>AbstractJavaScriptComponent</"
"classname> 的 <methodname>addFunction()</methodname> 方法来注册. 服务器端的注"
"册实际上会定义一个 JavaScript 方法, 这个方法将供客户端连接器使用."

#. Tag: para
#: chapter-gwt.xml:1641
#, no-c-format
msgid ""
"Continuing from the server-side <classname>MyComponent</classname> example "
"we defined earlier, we add a constructor to it that registers the function."
msgstr ""
"下面继续看我们前面的服务器端 <classname>MyComponent</classname> 示例, 我们现"
"在给它添加一个构造函数, 其中会注册 RPC 函数."

#. Tag: programlisting
#: chapter-gwt.xml:1647
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public MyComponent() {\n"
"    addFunction(\"onClick\", new JavaScriptFunction() {\n"
"        @Override\n"
"        public void call(JSONArray arguments)\n"
"                throws JSONException {\n"
"            getState().setValue(arguments.getString(0));\n"
"            for (ValueChangeListener listener: listeners)\n"
"                listener.valueChange();\n"
"        }\n"
"    });\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-gwt.xml:1651
#, no-c-format
msgid "Making an RPC Call from JavaScript"
msgstr "从 JavaScript 发起 RPC 调用"

#. Tag: para
#: chapter-gwt.xml:1653
#, no-c-format
msgid ""
"An RPC call is made simply by calling the RPC method in the connector. In "
"the constructor function of the JavaScript connector, you could write as "
"follows (the complete connector code was given earlier):"
msgstr ""
"发起一个 RPC 调用只需要简单地调用连接器中的 RPC 方法. 在 JavaScript 连接器的"
"构造函数中, 你可以编写以下代码(完整的连接器代码请参见前面的示例):"

#. Tag: programlisting
#: chapter-gwt.xml:1666
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[window."
"com_vaadin_book_examples_gwt_js_MyComponent =\n"
"    function() {\n"
"        ...\n"
"        var connector = this;\n"
"        mycomponent.click = function() {\n"
"            connector.onClick(mycomponent.getValue());\n"
"        };\n"
"    };]]>"
msgstr ""

#. Tag: para
#: chapter-gwt.xml:1668
#, no-c-format
msgid ""
"Here, the <literal>mycomponent.click</literal> is a function in the example "
"JavaScript library, as described in <xref linkend=\"gwt.javascript.example\"/"
">. The <methodname>onClick()</methodname> is the method we defined on the "
"server-side. We pass a simple string parameter in the call."
msgstr ""
"在这里, <literal>mycomponent.click</literal> 是 JavaScript 示例库中的一个函"
"数, 详情请参见 <xref linkend=\"gwt.javascript.example\"/>. "
"<methodname>onClick()</methodname> 是我们在服务器端定义的方法. 在这个调用中我"
"们传递了一个简单的字符串参数."

#. Tag: para
#: chapter-gwt.xml:1676
#, no-c-format
msgid "You can pass anything that is valid in JSON notation in the parameters."
msgstr "在参数中, 你可以传递 JSON 中合法的任意类型数据."
