# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-11-05 01:01+0000\n"
"PO-Revision-Date: 2014-11-05 10:16+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-datamodel.xml:11
#, no-c-format
msgid "Binding Components to Data"
msgstr "组件与数据绑定"

#. Tag: primary
#: chapter-datamodel.xml:14
#, no-c-format
msgid "<primary>Vaadin Data Model</primary>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:17
#, no-c-format
msgid ""
"This chapter describes the Vaadin Data Model and shows how you can use it to "
"bind components directly to data sources, such as database queries."
msgstr ""
"本章介绍 Vaadin Data Model, 并讲解如何使用它将组件绑定到数据源, 比如一个数据"
"库查询."

#. Tag: title
#: chapter-datamodel.xml:23
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-datamodel.xml:25
#, no-c-format
msgid ""
"The Vaadin Data Model is one of the core concepts of the library. To allow "
"the view (user interface components) to access the data model of an "
"application directly, we have introduced a standard data interface."
msgstr ""
"Vaadin Data Model 是 Vaadin 的核心概念之一. 为了让 view(UI 组件)模块直接访问"
"应用程序的数据模型, 我们引入了一套标准的数据接口."

#. Tag: para
#: chapter-datamodel.xml:31
#, no-c-format
msgid ""
"The model allows binding user interface components directly to the data that "
"they display and possibly allow to edit. There are three nested levels of "
"hierarchy in the data model: <emphasis>property</emphasis>, <emphasis>item</"
"emphasis>, and <emphasis>container</emphasis>. Using a spreadsheet "
"application as an analogy, these would correspond to a cell, a row, and a "
"table, respectively."
msgstr ""
"这个数据模型允许 UI 组件直接绑定到数据上, 然后 UI 组件就可以显示或者编辑这些"
"数据. 数据模型包含三个嵌套层次: <emphasis>属性(property)</emphasis>, "
"<emphasis>项目(item)</emphasis>, 以及 <emphasis>容器(container)</emphasis>. "
"用电子表格应用程序来做类比的话, 这三个层次分别对应于单元格, 行, 表."

#. Tag: title
#: chapter-datamodel.xml:41
#, no-c-format
msgid "<title>Vaadin Data Model</title>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:52
#, no-c-format
msgid ""
"The Data Model is realized as a set of interfaces in the <classname>com."
"vaadin.data</classname> package. The package contains the "
"<classname>Property</classname>, <classname>Item</classname>, and "
"<classname>Container</classname> interfaces, along with a number of more "
"specialized interfaces and classes."
msgstr ""
"数据模型由 <classname>com.vaadin.data</classname> 包内的一组接口构成. 这个包"
"中包含 <classname>Property</classname>, <classname>Item</classname>, 和 "
"<classname>Container</classname> 接口, 以及其他很多特化的接口和类."

#. Tag: para
#: chapter-datamodel.xml:60
#, no-c-format
msgid ""
"Notice that the Data Model does not define data representation, but only "
"interfaces. This leaves the representation fully to the implementation of "
"the containers. The representation can be almost anything, such as a plain "
"old Java object (POJO) structure, a filesystem, or a database query."
msgstr ""
"注意, 数据模型并没有定义数据的表现形式, 只定义了接口. 这种设计将数据的表现方"
"式完全留给容器的具体实现来决定. 数据的表现几乎可以是任何形式, 比如可以是简单 "
"Java 对象(POJO, plain old Java object), 可以是文件系统, 也可是数据库查询."

#. Tag: para
#: chapter-datamodel.xml:67
#, no-c-format
msgid ""
"The Data Model is used heavily in the core user interface components of "
"Vaadin, especially the field components, that is, components that implement "
"the <classname>Field</classname> interface or more typically extend "
"<classname>AbstractField</classname>, which defines many common features. A "
"key feature of all the built-in field components is that they can either "
"maintain their data by themselves or be bound to an external data source. "
"The value of a field is always available through the <classname>Property</"
"classname> interface. As more than one component can be bound to the same "
"data source, it is easy to implement various viewer-editor patterns."
msgstr ""
"数据模型在 Vaadin 的核心 UI 组件中广泛使用, 尤其是 Field 组件中, 也就是实现"
"了 <classname>Field</classname> 接口的组件, 或者更典型地说, 继承自 "
"<classname>AbstractField</classname> 的组件, AbstractField 类中定义了很多共通"
"功能. 内建的 Field 组件的一个关键功能是, 它们既可以自行维护数据, 也可以绑定到"
"外部的数据源. Field 的值总是可以通过 <classname>Property</classname> 接口得"
"到. 由于绑定到同一个数据源的组件可以超过一个, 因此可以很容易实现多阅读者/多编"
"辑者模式."

#. Tag: para
#: chapter-datamodel.xml:80
#, no-c-format
msgid ""
"The relationships of the various interfaces are shown in <xref linkend="
"\"figure.datamodel.overview.relationships\"/>; the value change event and "
"listener interfaces are shown only for the <classname>Property</classname> "
"interface, while the notifier interfaces are omitted altogether."
msgstr ""
"数据模型中各接口的关系, 见 <xref linkend=\"figure.datamodel.overview."
"relationships\"/>; 值变化的事件和监听器接口, 只显示了与 <classname>Property</"
"classname> 接口相关的部分, 省略了通知器接口."

#. Tag: title
#: chapter-datamodel.xml:88
#, no-c-format
msgid "Interface Relationships in Vaadin Data Model"
msgstr "Vaadin Data Model 中各接口的关系"

#. Tag: para
#: chapter-datamodel.xml:99
#, no-c-format
msgid ""
"The Data Model has many important and useful features, such as support for "
"change notification. Especially containers have many helper interfaces, "
"including ones that allow indexing, ordering, sorting, and filtering the "
"data. Also <classname>Field</classname> components provide a number of "
"features involving the data model, such as buffering, validation, and lazy "
"loading."
msgstr ""
"数据模型还有很多重要和有用的功能, 比如支持变更通知. 尤其是, 容器还带有很多辅"
"助接口, 可用于数据的索引, 排序, 过滤. <classname>Field</classname> 组件也提供"
"了很多与数据模型相关的功能, 比如缓冲, 校验, 以及lazy load."

#. Tag: para
#: chapter-datamodel.xml:108
#, no-c-format
msgid ""
"Vaadin provides a number of built-in implementations of the data model "
"interfaces. The built-in implementations are used as the default data models "
"in many field components."
msgstr ""
"Vaadin 对数据模型接口提供了很多内建的实现类. 在很多 Field 组件中, 内建的实现"
"类被用作默认的数据模型."

#. Tag: para
#: chapter-datamodel.xml:114
#, no-c-format
msgid ""
"In addition to the built-in implementations, many data model "
"implementations, such as containers, are available as add-ons, either from "
"the Vaadin Directory or from independent sources. Both commercial and free "
"implementations exist. The JPAContainer, described in <xref linkend="
"\"jpacontainer\"/>, is the most often used conmmercial container add-on. The "
"installation of add-ons is described in <xref linkend=\"addons\"/>. Notice "
"that unlike with most regular add-on components, you do not need to compile "
"a widget set for add-ons that include just data model implementations."
msgstr ""
"出内建的实现外, 还可以通过 add-on 得到很多数据模型的实现, 比如容器, add-on 可"
"以从 Vaadin Directory 得到, 也可以从其他独立的来源得到. 既有商业化的实现, 也"
"有免费的实现. JPAContainer, 参见 <xref linkend=\"jpacontainer\"/>, 是最常用到"
"的商业化容器 add-on.  add-on 的安装请参见 <xref linkend=\"addons\"/>. 注意, "
"与大多数通常的 add-on 组件不同, 对于只包含数据模型实现的 add-on, 你不必为它编"
"译 widget 群."

#. Tag: title
#: chapter-datamodel.xml:127
#, no-c-format
msgid "Properties"
msgstr "属性(Property)"

#. Tag: para
#: chapter-datamodel.xml:129
#, no-c-format
msgid ""
"The <interfacename>Property</interfacename> interface is the base of the "
"Vaadin Data Model. It provides a standardized API for a single data value "
"object that can be read (get) and written (set). A property is always typed, "
"but can optionally support data type conversions. The type of a property can "
"be any Java class. Optionally, properties can provide value change events "
"for following their changes."
msgstr ""
"<interfacename>Property</interfacename> 接口是 Vaadin Data Model 的基础. 它提"
"供了一组标准 API, 用于单个数据值对象的读(get)和写(set). 一个属性永远是固定类"
"型的, 但也可以支持数据类型的转换. 属性的类型可以是任意的 Java 类. 属性还可以"
"向外提供事件, 以便外界追踪值的变化."

#. Tag: para
#: chapter-datamodel.xml:138
#, no-c-format
msgid ""
"You can set the value of a property with <methodname>setValue()</methodname> "
"and read with <methodname>getValue()</methodname>."
msgstr ""
"你可以使用 <methodname>setValue()</methodname> 方法来设置属性的值, 可以通过 "
"<methodname>getValue()</methodname> 方法读取属性值."

#. Tag: para
#: chapter-datamodel.xml:143
#, no-c-format
msgid ""
"In the following, we set and read the property value from a "
"<classname>TextField</classname> component, which implements the "
"<interfacename>Property</interfacename> interface to allow accessing the "
"field value."
msgstr ""
"下例中, 我们通过 <classname>TextField</classname> 组件来读写一个属性的值, 这"
"个组件实现了 <interfacename>Property</interfacename> 接口, 因此可以访问 "
"Field 内的值."

#. Tag: programlisting
#: chapter-datamodel.xml:151
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[final TextField tf = new TextField(\"Name\");\n"
"        \n"
"// Set the value\n"
"tf.setValue(\"The text field value\");\n"
"        \n"
"// When the field value is edited by the user\n"
"tf.addValueChangeListener(\n"
"    new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        // Do something with the new value\n"
"        layout.addComponent(new Label(tf.getValue()));\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:153
#, no-c-format
msgid ""
"Changes in the property value usually fire a <classname>ValueChangeEvent</"
"classname>, which can be handled with a <classname>ValueChangeListener</"
"classname>. The event object provides reference to the property with "
"<methodname>getProperty()</methodname>. Note that its "
"<methodname>getValue()</methodname> method returns the value with "
"<classname>Object</classname> type, so you need to cast it to the proper "
"type."
msgstr ""
"属性值的变更通常会激发一个 <classname>ValueChangeEvent</classname> 事件, 可以"
"使用 <classname>ValueChangeListener</classname> 监听器来处理这个事件. 事件对"
"象通过 <methodname>getProperty()</methodname> 方法提供了指向属性的引用. 注"
"意, <methodname>getValue()</methodname> 方法返回值类型为 <classname>Object</"
"classname>, 因此你需要将它转换为正确的类型."

#. Tag: para
#: chapter-datamodel.xml:163
#, no-c-format
msgid ""
"Properties are in themselves unnamed. They are collected in <emphasis>items</"
"emphasis>, which associate the properties with names: the <emphasis>Property "
"Identifiers</emphasis> or <emphasis>PID</emphasis>s. Items can be further "
"contained in containers and are identified with <emphasis>Item Identifiers</"
"emphasis> or <emphasis>IID</emphasis>s. In the spreadsheet analogy, "
"<emphasis>Property Identifiers</emphasis> would correspond to column names "
"and <emphasis>Item Identifiers</emphasis> to row names. The identifiers can "
"be arbitrary objects, but must implement the <methodname>equals(Object)</"
"methodname> and <methodname>hashCode()</methodname> methods so that they can "
"be used in any standard Java <classname>Collection</classname>."
msgstr ""
"属性内部是没有名称概念的. 它们会被组织在 <emphasis>项目</emphasis> 之内, 在项"
"目的层次上, 属性与名称相关联, 名称就是 <emphasis>属性 ID</emphasis> 或者简称 "
"<emphasis>PID</emphasis>. 项目再被组织在容器中, 项目的标识符称作 <emphasis>项"
"目ID</emphasis> 或者简称 <emphasis>IID</emphasis>. 用电子表格来类比的话, "
"<emphasis>属性ID</emphasis> 对应到列名, <emphasis>项目ID</emphasis> 对应到行"
"名. ID 可以是任意类型的对象, 但必须实现 <methodname>equals(Object)</"
"methodname> 和 <methodname>hashCode()</methodname> 方法, 以便在标准的 Java "
"<classname>Collection</classname> 中存储这些 ID."

#. Tag: para
#: chapter-datamodel.xml:177
#, no-c-format
msgid ""
"The <classname>Property</classname> interface can be utilized either by "
"implementing the interface or by using some of the built-in property "
"implementations. Vaadin includes a <classname>Property</classname> interface "
"implementation for arbitrary function pairs and bean properties, with the "
"<classname>MethodProperty</classname> class, and for simple object "
"properties, with the <classname>ObjectProperty</classname> class, as "
"described later."
msgstr ""
"使用 <classname>Property</classname> 时, 可以直接实现这个接口, 也可以使用内建"
"的实现. Vaadin 包含了一些 <classname>Property</classname> 接口的实现, "
"<classname>MethodProperty</classname> 类, 用于任意函数对和 Bean 属性, "
"<classname>ObjectProperty</classname>类, 用于简单的对象属性, 详情见后文."

#. Tag: para
#: chapter-datamodel.xml:186
#, no-c-format
msgid ""
"In addition to the simple components, selection components provide their "
"current selection as the property value. In single selection mode, the "
"property is a single item identifier, while in multiple selection mode it is "
"a set of item identifiers. See the documentation of the selection components "
"for further details."
msgstr ""
"除简单组件外, 选择组件也将它们的当前选中内容以属性值的形式向外提供. 单选模式"
"下, 属性是单个的项目 ID, 多选模式下, 属性是一组项目 ID 的集合. 详情请参见选择"
"组件的相关文档."

#. Tag: para
#: chapter-datamodel.xml:194
#, no-c-format
msgid ""
"Components that can be bound to a property have an internal default data "
"source object, typically a <classname>ObjectProperty</classname>, which is "
"described later. As all such components are viewers or editors, also "
"described later, so you can rebind a component to any data source with "
"<methodname>setPropertyDataSource()</methodname>."
msgstr ""
"可以绑定到属性上的组件, 带有一个内部的默认数据源对象, 一般是 "
"<classname>ObjectProperty</classname>, 关于这个对象的介绍见后文. 由于这类组件"
"都是查看器或编辑器(详情见后文), 因此你可以使用 "
"<methodname>setPropertyDataSource()</methodname> 方法将组件重绑定到任何的数据"
"源上."

#. Tag: title
#: chapter-datamodel.xml:203
#, no-c-format
msgid "Property Viewers and Editors"
msgstr "属性的查看器和编辑器"

#. Tag: para
#: chapter-datamodel.xml:205
#, no-c-format
msgid ""
"The most important function of the <classname>Property</classname> as well "
"as of the other data model interfaces is to connect classes implementing the "
"interface directly to editor and viewer classes. This means connecting a "
"data source (model) to a user interface component (views) to allow editing "
"or viewing the data model."
msgstr ""
"<classname>Property</classname>(以及其他数据模型接口) 的最重要的功能是, 将数"
"据模型接口的实现类直接连接到编辑器类和查看器类. 也就是说将数据源(模型)与 UI "
"组件(视图)相连, 实现对数据模型的编辑或查看功能."

#. Tag: para
#: chapter-datamodel.xml:213
#, no-c-format
msgid ""
"A property can be bound to a component implementing the <classname>Viewer</"
"classname> interface with <methodname>setPropertyDataSource()</methodname>."
msgstr ""
"属性可以通过 <methodname>setPropertyDataSource()</methodname> 方法绑定到实现"
"了 <classname>Viewer</classname> 接口的组件."

#. Tag: programlisting
#: chapter-datamodel.xml:219
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a data model\n"
"ObjectProperty property =\n"
"    new ObjectProperty(\"Hello\", String.class);\n"
"        \n"
"// Have a component that implements Viewer\n"
"Label viewer = new Label();\n"
"        \n"
"// Bind it to the data\n"
"viewer.setPropertyDataSource(property);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:221
#, no-c-format
msgid ""
"You can use the same method in the <classname>Editor</classname> interface "
"to bind a component that allows editing a particular property type to a "
"property."
msgstr ""
"你也可以使用 <classname>Editor</classname> 接口中的同一个方法, 将某种类型属性"
"的编辑组件绑定到一个属性上."

#. Tag: programlisting
#: chapter-datamodel.xml:227
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a data model\n"
"ObjectProperty property =\n"
"    new ObjectProperty(\"Hello\", String.class);\n"
"        \n"
"// Have a component that implements Viewer\n"
"TextField editor = new TextField(\"Edit Greeting\");\n"
"        \n"
"// Bind it to the data\n"
"editor.setPropertyDataSource(property);\n"
"]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:229
#, no-c-format
msgid ""
"As all field components implement the <classname>Property</classname> "
"interface, you can bind any component implementing the <classname>Viewer</"
"classname> interface to any field, assuming that the viewer is able the view "
"the object type of the field. Continuing from the above example, we can bind "
"a <classname>Label</classname> to the <classname>TextField</classname> value:"
msgstr ""
"由于所有的 Field 组件都实现了 <classname>Property</classname> 接口, 所以你可"
"以将实现 <classname>Viewer</classname> 接口的任何组件绑定到任何的 Field 上, "
"前提是这里的查看器有能力查看 Field 中的数据类型. 继续上面的例子, 我们可以绑定"
"一个 <classname>Label</classname> 组件到 <classname>TextField</classname> 的"
"值上:"

#. Tag: programlisting
#: chapter-datamodel.xml:238
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Label viewer = new Label();\n"
"viewer.setPropertyDataSource(editor);\n"
"\n"
"// The value shown in the viewer is updated immediately\n"
"// after editing the value in the editor (once it\n"
"// loses the focus)\n"
"editor.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:240
#, no-c-format
msgid ""
"If a field has validators, as described in <xref linkend=\"components.fields."
"validation\"/>, the validators are executed before writing the value to the "
"property data source, or by calling the <methodname>validate()</methodname> "
"or <methodname>commit()</methodname> for the field."
msgstr ""
"如果 Field 带有校验器, 参见 <xref linkend=\"components.fields.validation\"/"
">, 校验器的执行会发生在值写入属性数据源之前, 或者在对 Field 调用 "
"<methodname>validate()</methodname> 或 <methodname>commit()</methodname> 方法"
"时."

#. Tag: title
#: chapter-datamodel.xml:250
#, no-c-format
msgid "<classname>ObjectProperty</classname> Implementation"
msgstr "<classname>ObjectProperty</classname> 实现"

#. Tag: para
#: chapter-datamodel.xml:252
#, no-c-format
msgid ""
"The <classname>ObjectProperty</classname> class is a simple implementation "
"of the <classname>Property</classname> interface that allows storing an "
"arbitrary Java object."
msgstr ""
"<classname>ObjectProperty</classname> 类是 <classname>Property</classname> 接"
"口的一个简单实现, 它允许在属性中存储一个任意的 Java 对象."

#. Tag: programlisting
#: chapter-datamodel.xml:258
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a component that implements Viewer "
"interface\n"
"final TextField tf = new TextField(\"Name\");\n"
"        \n"
"// Have a data model with some data\n"
"String myObject = \"Hello\";\n"
"        \n"
"// Wrap it in an ObjectProperty\n"
"ObjectProperty property =\n"
"    new ObjectProperty(myObject, String.class);\n"
"        \n"
"// Bind the property to the component\n"
"tf.setPropertyDataSource(property);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:263
#, no-c-format
msgid "Converting Between Property Type and Representation"
msgstr "在属性类型与表达之间转换"

#. Tag: para
#: chapter-datamodel.xml:265
#, no-c-format
msgid ""
"Fields allow editing a certain type, such as a <classname>String</classname> "
"or <classname>Date</classname>. The bound property, on the other hand, could "
"have some entirely different type. Conversion between a representation "
"edited by the field and the model defined in the property is handler with a "
"converter that implements the <interfacename>Converter</interfacename> "
"interface."
msgstr ""
"Field 用于编辑某个特定类型的数据, 比如 <classname>String</classname> 或 "
"<classname>Date</classname>. 但是与它绑定的属性, 可能包含完全不同的数据类型. "
"在 Field 编辑的数据表达形式, 与属性中定义的数据模型之间, 由转换器来进行数据类"
"型的转换, 转换器需要实现 <interfacename>Converter</interfacename> 接口."

#. Tag: para
#: chapter-datamodel.xml:274
#, no-c-format
msgid ""
"Most common type conversions, such as between string and integer, are "
"handled by the default converters. They are created in a converter factory "
"global in the application."
msgstr ""
"大多数常见类型之间的转换, 比如字符串与整数的转换, 由默认的转换器来处理. 这些"
"转换器由应用程序中的一个全局的转换器工厂负责创建."

#. Tag: title
#: chapter-datamodel.xml:281
#, no-c-format
msgid "Basic Use of Converters"
msgstr "转换器的基本使用"

#. Tag: para
#: chapter-datamodel.xml:283
#, no-c-format
msgid ""
"The <methodname>setConverter(<interfacename>Converter</interfacename>)</"
"methodname> method sets the converter for a field. The method is defined in "
"<classname>AbstractField</classname>."
msgstr ""
"<methodname>setConverter(<interfacename>Converter</interfacename>)</"
"methodname> 方法为 Field 设置转换器. 这个方法定义在 "
"<classname>AbstractField</classname> 类中."

#. Tag: programlisting
#: chapter-datamodel.xml:290
#, no-c-format
msgid ""
"<![CDATA[// Have an integer property\n"
"final ObjectProperty<Integer> property =\n"
"        new ObjectProperty<Integer>(42); \n"
"        \n"
"// Create a TextField, which edits Strings\n"
"final TextField tf = new TextField(\"Name\");\n"
"\n"
"// Use a converter between String and Integer\n"
"tf.setConverter(new StringToIntegerConverter());\n"
"\n"
"// And bind the field\n"
"tf.setPropertyDataSource(property);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:292
#, no-c-format
msgid "The built-in converters are the following:"
msgstr "内建的转换器如下:"

#. Tag: title
#: chapter-datamodel.xml:297
#, no-c-format
msgid "Built-in Converters"
msgstr "内建的转换器"

#. Tag: entry
#: chapter-datamodel.xml:304
#, no-c-format
msgid "Converter"
msgstr "转换器类"

#. Tag: entry
#: chapter-datamodel.xml:305
#, no-c-format
msgid "Representation"
msgstr "组件中的数据表现"

#. Tag: entry
#: chapter-datamodel.xml:306
#, no-c-format
msgid "Model"
msgstr "模型中的数据类型"

#. Tag: classname
#: chapter-datamodel.xml:311
#, no-c-format
msgid "StringToIntegerConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:312 chapter-datamodel.xml:317
#: chapter-datamodel.xml:322 chapter-datamodel.xml:327
#: chapter-datamodel.xml:332
#, no-c-format
msgid "String"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:313
#, no-c-format
msgid "Integer"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:316
#, no-c-format
msgid "StringToDoubleConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:318
#, no-c-format
msgid "Double"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:321
#, no-c-format
msgid "StringToNumberConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:323
#, no-c-format
msgid "Number"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:326
#, no-c-format
msgid "StringToBooleanConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:328
#, no-c-format
msgid "Boolean"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:331
#, no-c-format
msgid "StringToDateConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:333 chapter-datamodel.xml:337
#, no-c-format
msgid "Date"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:336
#, no-c-format
msgid "DateToLongConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:338
#, no-c-format
msgid "Long"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:344
#, no-c-format
msgid ""
"In addition, there is a <classname>ReverseConverter</classname> that takes a "
"converter as a parameter and reverses the conversion direction."
msgstr ""
"除此之外, 还有 <classname>ReverseConverter</classname> 类, 它接受一个转换器作"
"为参数, 然后反转这个转换器的转换方向."

#. Tag: para
#: chapter-datamodel.xml:350
#, no-c-format
msgid ""
"If a converter already exists for a type, the "
"<methodname>setConverter(<interfacename>Class</interfacename>)</methodname> "
"retrieves the converter for the given type from the converter factory, and "
"then sets it for the field. This method is used implicitly when binding "
"field to a property data source."
msgstr ""
"如果对于某个数据类型已经有转换器存在, 那么 "
"<methodname>setConverter(<interfacename>Class</interfacename>)</methodname> "
"方法可以从转换器工厂中得到这个数据类型对应的转换器, 然后再将这个转换器设置到 "
"Field 上. 当绑定 Field 到属性数据源时, 会隐含地使用这个方法."

#. Tag: title
#: chapter-datamodel.xml:360
#, no-c-format
msgid "Implementing a Converter"
msgstr "转换器的实现"

#. Tag: para
#: chapter-datamodel.xml:362
#, no-c-format
msgid ""
"A conversion always occurs between a <emphasis>representation type</"
"emphasis>, edited by the field component, and a <emphasis>model type</"
"emphasis>, that is, the type of the property data source. Converters "
"implement the <interfacename>Converter</interfacename> interface defined in "
"the <package>com.vaadin.data.util.converter</package> package."
msgstr ""
"转换器总是出现在 <emphasis>表现类型</emphasis> 与 <emphasis>数据模型类型</"
"emphasis> 之间, 表现类型就是 Field 组件编辑的类型, 数据模型类型就是属性数据源"
"中的类型. 转换器需要实现 <package>com.vaadin.data.util.converter</package> 包"
"中的 <interfacename>Converter</interfacename> 接口."

#. Tag: para
#: chapter-datamodel.xml:371
#, no-c-format
msgid ""
"For example, let us assume that we have a simple <classname>Complex</"
"classname> type for storing complex values."
msgstr ""
"比如, 假设我们有一个简单的 <classname>Complex</classname> 类型, 用于存储复数"
"值."

#. Tag: programlisting
#: chapter-datamodel.xml:376
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class ComplexConverter\n"
"       implements Converter<String, Complex> {\n"
"    @Override\n"
"    public Complex convertToModel(String value, Locale locale)\n"
"            throws ConversionException {\n"
"        String parts[] =\n"
"            value.replaceAll(\"[\\\\(\\\\)]\", \"\").split(\",\");\n"
"        if (parts.length != 2)\n"
"            throw new ConversionException(\n"
"                    \"Unable to parse String to Complex\");\n"
"        return new Complex(Double.parseDouble(parts[0]),\n"
"                           Double.parseDouble(parts[1]));\n"
"    }\n"
"\n"
"    @Override\n"
"    public String convertToPresentation(Complex value,\n"
"                                        Locale locale)\n"
"            throws ConversionException {\n"
"        return \"(\"+value.getReal()+\",\"+value.getImag()+\")\";\n"
"    }\n"
"\n"
"    @Override\n"
"    public Class<Complex> getModelType() {\n"
"        return Complex.class;\n"
"    }\n"
"\n"
"    @Override\n"
"    public Class<String> getPresentationType() {\n"
"        return String.class;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:378
#, no-c-format
msgid ""
"The conversion methods get the locale for the conversion as a parameter."
msgstr "转换器接受一个语言环境(locale)作为参数, 指定转换时使用的语言环境."

#. Tag: title
#: chapter-datamodel.xml:385
#, no-c-format
msgid "Converter Factory"
msgstr "转换器工厂"

#. Tag: para
#: chapter-datamodel.xml:387
#, no-c-format
msgid ""
"If a field does not directly allow editing a property type, a default "
"converter is attempted to create using an application-global converter "
"factory. If you define your own converters that you wish to include in the "
"converter factory, you need to implement one yourself. While you could "
"implement the <interfacename>ConverterFactory</interfacename> interface, it "
"is usually easier to just extend <classname>DefaultConverterFactory</"
"classname>."
msgstr ""
"如果一个 Field 不能直接编辑属性值的数据类型, 它会尝试使用应用程序全局的转换器"
"工厂来创建一个默认转换器. 如果你定义了自己的转换器, 希望加入到转换器工厂中"
"去, 你需要自己来实现一个转换器工厂. 你可以实现 "
"<interfacename>ConverterFactory</interfacename> 接口, 但更简单的方法是继承 "
"<classname>DefaultConverterFactory</classname> 类."

#. Tag: programlisting
#: chapter-datamodel.xml:397
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyConverterFactory extends "
"DefaultConverterFactory {\n"
"    @Override\n"
"    public <PRESENTATION, MODEL> Converter<PRESENTATION, MODEL>\n"
"            createConverter(Class<PRESENTATION> presentationType,\n"
"                            Class<MODEL> modelType) {\n"
"        // Handle one particular type conversion\n"
"        if (String.class == presentationType &&\n"
"            Complex.class == modelType)\n"
"            return (Converter<PRESENTATION, MODEL>)\n"
"                   new ComplexConverter();\n"
"\n"
"        // Default to the supertype\n"
"        return super.createConverter(presentationType,\n"
"                                     modelType);\n"
"    }\n"
"}\n"
"\n"
"// Use the factory globally in the application\n"
"Application.getCurrentApplication().setConverterFactory(\n"
"        new MyConverterFactory());]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:402
#, no-c-format
msgid "Implementing the <classname>Property</classname> Interface"
msgstr "实现 <classname>Property</classname> 接口"

#. Tag: para
#: chapter-datamodel.xml:404
#, no-c-format
msgid ""
"Implementation of the <classname>Property</classname> interface requires "
"defining setters and getters for the value and the <emphasis>read-only</"
"emphasis> mode. Only a getter is needed for the property type, as the type "
"is often fixed in property implementations."
msgstr ""
"实现 <classname>Property</classname> 接口, 需要为属性值和<emphasis>只读</"
"emphasis>模式分别定义 set 和 get 方法. 对于属性值的数据类型, 只需要 get 方"
"法, 因为对于 Property 的实现类来说, 数据类型通常是固定的."

#. Tag: para
#: chapter-datamodel.xml:411
#, no-c-format
msgid ""
"The following example shows a simple implementation of the "
"<classname>Property</classname> interface:"
msgstr "下例演示 <classname>Property</classname> 接口的一个简单的实现:"

#. Tag: programlisting
#: chapter-datamodel.xml:416
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyProperty implements Property {\n"
"    Integer data     = 0;\n"
"    boolean readOnly = false;\n"
"    \n"
"    // Return the data type of the model\n"
"    public Class<?> getType() {\n"
"        return Integer.class;\n"
"    }\n"
"\n"
"    public Object getValue() {\n"
"        return data;\n"
"    }\n"
"    \n"
"    // Override the default implementation in Object\n"
"    @Override\n"
"    public String toString() {\n"
"        return Integer.toHexString(data);\n"
"    }\n"
"\n"
"    public boolean isReadOnly() {\n"
"        return readOnly;\n"
"    }\n"
"\n"
"    public void setReadOnly(boolean newStatus) {\n"
"        readOnly = newStatus;\n"
"    }\n"
"\n"
"    public void setValue(Object newValue)\n"
"            throws ReadOnlyException, ConversionException {\n"
"        if (readOnly)\n"
"            throw new ReadOnlyException();\n"
"            \n"
"        // Already the same type as the internal representation\n"
"        if (newValue instanceof Integer)\n"
"            data = (Integer) newValue;\n"
"        \n"
"        // Conversion from a string is required\n"
"        else if (newValue instanceof String)\n"
"            try {\n"
"                data = Integer.parseInt((String) newValue, 16);\n"
"            } catch (NumberFormatException e) {\n"
"                throw new ConversionException();\n"
"            }\n"
"        else\n"
"             // Don't know how to convert any other types\n"
"            throw new ConversionException();\n"
"\n"
"        // Reverse decode the hexadecimal value\n"
"    }\n"
"}\n"
"        \n"
"// Instantiate the property and set its data\n"
"MyProperty property = new MyProperty();\n"
"property.setValue(42);\n"
"        \n"
"// Bind it to a component\n"
"final TextField tf = new TextField(\"Name\", property);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:418
#, no-c-format
msgid ""
"The components get the displayed value by the <methodname>toString()</"
"methodname> method, so it is necessary to override it. To allow editing the "
"value, value returned in the <methodname>toString()</methodname> must be in "
"a format that is accepted by the <methodname>setValue()</methodname> method, "
"unless the property is read-only. The <methodname>toString()</methodname> "
"can perform any type conversion necessary to make the internal type a "
"string, and the <methodname>setValue()</methodname> must be able to make a "
"reverse conversion."
msgstr ""
"组件通过 <methodname>toString()</methodname> 方法得到画面上显示的值, 因此我们"
"需要重载这个方法. 为了编辑值, <methodname>toString()</methodname> 方法返回的"
"值, 其格式必须能被 <methodname>setValue()</methodname> 方法接受, 除非属性是只"
"读的. <methodname>toString()</methodname> 方法可以进行任何必要的类型转换, 将"
"内部数据类型转换为字符串, <methodname>setValue()</methodname> 方法则必须进行"
"反向的转换."

#. Tag: para
#: chapter-datamodel.xml:430
#, no-c-format
msgid ""
"The implementation example does not notify about changes in the property "
"value or in the read-only mode. You should normally also implement at least "
"the <classname>Property.ValueChangeNotifier</classname> and "
"<classname>Property.ReadOnlyStatusChangeNotifier</classname>. See the "
"<classname>ObjectProperty</classname> class for an example of the "
"implementation."
msgstr ""
"上面的 Property 实现示例, 没有向外发送属性值和只读模式的变更通知. 通常你至少"
"应该实现 <classname>Property.ValueChangeNotifier</classname> 和 "
"<classname>Property.ReadOnlyStatusChangeNotifier</classname>. 关于这些通知功"
"能的实现方式, 请参考 <classname>ObjectProperty</classname> 类."

#. Tag: title
#: chapter-datamodel.xml:442
#, no-c-format
msgid "Holding properties in Items"
msgstr "在项目(Item)中保存属性(Property)"

#. Tag: para
#: chapter-datamodel.xml:444
#, no-c-format
msgid ""
"The <classname>Item</classname> interface provides access to a set of named "
"properties. Each property is identified by a <emphasis>property identifier</"
"emphasis> (PID) and a reference to such a property can be queried from an "
"<classname>Item</classname> with <methodname>getItemProperty()</methodname> "
"using the identifier."
msgstr ""
"通过 <classname>Item</classname> 接口可以访问一组有名称的属性. 各个属性通过 "
"<emphasis>属性ID</emphasis> (PID) 来区分, 使用 <classname>Item</classname> "
"的 <methodname>getItemProperty()</methodname> 方法, 可以根据 ID 得到对应的属"
"性."

#. Tag: para
#: chapter-datamodel.xml:452
#, no-c-format
msgid ""
"Examples on the use of items include rows in a <classname>Table</classname>, "
"with the properties corresponding to table columns, nodes in a "
"<classname>Tree</classname>, and the the data bound to a <classname>Form</"
"classname>, with item's properties bound to individual form fields."
msgstr ""
"使用项目的例子包括: 1, <classname>Table</classname> 中的行, 其中的属性对应到 "
"Table 的列,  2, <classname>Tree</classname> 中的节点, 3, 以及绑定到 "
"<classname>Form</classname> 的数据, 其中的属性分别绑定到 Form 中各个独立的 "
"Field."

#. Tag: para
#: chapter-datamodel.xml:460
#, no-c-format
msgid ""
"Items are generally equivalent to objects in the object-oriented model, but "
"with the exception that they are configurable and provide an event handling "
"mechanism. The simplest way to utilize <classname>Item</classname> interface "
"is to use existing implementations. Provided utility classes include a "
"configurable property set (<classname>PropertysetItem</classname>) and a "
"bean-to-item adapter (<classname>BeanItem</classname>). Also, a "
"<classname>Form</classname> implements the interface and can therefore be "
"used directly as an item."
msgstr ""
"项目基本上等价于面向对象编程模型中的对象, 区别在于项目是可配置的, 而且提供了"
"事件处理机制. 使用 <classname>Item</classname> 的最简单方法是使用已有的实现"
"类. Vaadin 提供的工具类包括可配置的属性集(<classname>PropertysetItem</"
"classname>) 以及 Bean 到项目的变换器(<classname>BeanItem</classname>). 此外, "
"<classname>Form</classname> 也实现了 Item 接口, 因此可以直接当作项目来使用."

#. Tag: para
#: chapter-datamodel.xml:471
#, no-c-format
msgid ""
"In addition to being used indirectly by many user interface components, "
"items provide the basic data model underlying the <classname>Form</"
"classname> component. In simple cases, forms can even be generated "
"automatically from items. The properties of the item correspond to the "
"fields of the form."
msgstr ""
"除了被很多 UI 组件间接使用之外, 项目也提供了 <classname>Form</classname> 组件"
"之下的基本数据模型. 简单情况下, Form 甚至可以通过项目来自动生成. 项目中的属性"
"与 Form 中的 Field 一一对应."

#. Tag: para
#: chapter-datamodel.xml:478
#, no-c-format
msgid ""
"The <classname>Item</classname> interface defines inner interfaces for "
"maintaining the item property set and listening changes made to it. "
"<classname>PropertySetChangeEvent</classname> events can be emitted by a "
"class implementing the <classname>PropertySetChangeNotifier</classname> "
"interface. They can be received through the "
"<classname>PropertySetChangeListener</classname> interface."
msgstr ""
"<classname>Item</classname> 接口定义了内部接口, 用于维护项目中的属性集合, 以"
"及监听项目的变更事件. 实现了 <classname>PropertySetChangeNotifier</"
"classname> 接口的类可以激发 <classname>PropertySetChangeEvent</classname> 事"
"件. 这个事件可以通过 <classname>PropertySetChangeListener</classname> 接口来"
"接收."

#. Tag: title
#: chapter-datamodel.xml:488
#, no-c-format
msgid "The <classname>PropertysetItem</classname> Implementation"
msgstr "<classname>PropertysetItem</classname> 实现"

#. Tag: para
#: chapter-datamodel.xml:490
#, no-c-format
msgid ""
"The <classname>PropertysetItem</classname> is a generic implementation of "
"the <classname>Item</classname> interface that allows storing properties. "
"The properties are added with <methodname>addItemProperty()</methodname>, "
"which takes a name and the property as parameters."
msgstr ""
"<classname>PropertysetItem</classname> 是 <classname>Item</classname> 接口的"
"一个通用实现, 它可以存储属性. 属性通过 <methodname>addItemProperty()</"
"methodname> 方法加入到项目中, 这个方法接受的参数是属性名和属性对象."

#. Tag: para
#: chapter-datamodel.xml:498
#, no-c-format
msgid ""
"The following example demonstrates a typical case of collecting "
"<classname>ObjectProperty</classname> properties in an item:"
msgstr ""
"下例演示使用 <classname>ObjectProperty</classname> 在项目中存储属性的常见用"
"法:"

#. Tag: programlisting
#: chapter-datamodel.xml:503
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty(\"Zaphod\"));\n"
"item.addItemProperty(\"age\", new ObjectProperty(42));\n"
"        \n"
"// Bind it to a component\n"
"Form form = new Form();\n"
"form.setItemDataSource(item);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:508
#, no-c-format
msgid "Wrapping a Bean in a <classname>BeanItem</classname>"
msgstr "使用 <classname>BeanItem</classname> 包装一个 Bean"

#. Tag: para
#: chapter-datamodel.xml:510
#, no-c-format
msgid ""
"The <classname>BeanItem</classname> implementation of the <classname>Item</"
"classname> interface is a wrapper for Java Bean objects. In fact, only the "
"setters and getters are required while serialization and other bean features "
"are not, so you can wrap almost any POJOs with minimal requirements."
msgstr ""
"<classname>Item</classname> 接口的 <classname>BeanItem</classname> 实现是对 "
"Java Bean 对象的一种包装. 实际上, 只有在序列化时需要用到 set 和 get 方法, "
"Java Bean 的其他功能不是必须的, 因此你可以使用这个类来包装几乎所有的 POJO 对"
"象."

#. Tag: programlisting
#: chapter-datamodel.xml:518
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a bean (or more exactly a POJO)\n"
"class Person {\n"
"    String name;\n"
"    int    age;\n"
"    \n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"    \n"
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
"    \n"
"    public Integer getAge() {\n"
"        return age;\n"
"    }\n"
"    \n"
"    public void setAge(Integer age) {\n"
"        this.age = age.intValue();\n"
"    }\n"
"}\n"
"\n"
"// Create an instance of the bean\n"
"Person bean = new Person();\n"
"        \n"
"// Wrap it in a BeanItem\n"
"BeanItem<Person> item = new BeanItem<Person>(bean);\n"
"        \n"
"// Bind it to a component\n"
"Form form = new Form();\n"
"form.setItemDataSource(item);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:520
#, no-c-format
msgid ""
"You can use the <methodname>getBean()</methodname> method to get a reference "
"to the underlying bean."
msgstr ""
"你可以使用 <methodname>getBean()</methodname> 方法取得项目之下包装的 Bean 对"
"象."

#. Tag: title
#: chapter-datamodel.xml:526
#, no-c-format
msgid "Nested Beans"
msgstr "嵌套 Bean"

#. Tag: para
#: chapter-datamodel.xml:528
#, no-c-format
msgid ""
"You may often have composite classes where one class \"has a\" another "
"class. For example, consider the following <classname>Planet</classname> "
"class which \"has a\" discoverer:"
msgstr ""
"你经常会将多个类组装在一起, 其中一个类 \"拥有\" 其他类. 比如, 考虑下例中的 "
"<classname>Planet</classname> 类, 它\"拥有一个\" 发现者:"

#. Tag: programlisting
#: chapter-datamodel.xml:534
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a bean with two nested beans\n"
"public class Planet implements Serializable {\n"
"    String name;\n"
"    Person discoverer;\n"
"    \n"
"    public Planet(String name, Person discoverer) {\n"
"        this.name = name;\n"
"        this.discoverer = discoverer;\n"
"    }\n"
"\n"
"    ... getters and setters ...\n"
"}\n"
"\n"
"...\n"
"// Create an instance of the bean\n"
"Planet planet = new Planet(\"Uranus\",\n"
"                    new Person(\"William Herschel\", 1738));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:536
#, no-c-format
msgid ""
"When shown in a <classname>Form</classname>, for example, you would want to "
"list the properties of the nested bean along the properties of the composite "
"bean. You can do that by binding the properties of the nested bean "
"individually with a <classname>MethodProperty</classname> or "
"<classname>NestedMethodProperty</classname>. You should usually hide the "
"nested bean from binding as a property by listing only the bound properties "
"in the constructor."
msgstr ""
"在 <classname>Form</classname> 内显示时, 比如, 你希望列出组合 Bean 的属性, 以"
"及嵌套 Bean 的属性. 你可以使用 <classname>MethodProperty</classname> 或 "
"<classname>NestedMethodProperty</classname>来单独绑定嵌套 Bean 的属性. 在绑定"
"组合 Bean 的属性时, 你通常应该将嵌套 Bean 本身排除在外, 方法是在构造方法中只"
"列出需要绑定的属性."

#. Tag: programlisting
#: chapter-datamodel.xml:546
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Wrap it in a BeanItem and hide the nested "
"bean property\n"
"BeanItem<Planet> item = new BeanItem<Planet>(planet,\n"
"        new String[]{\"name\"});\n"
"    \n"
"// Bind the nested properties.\n"
"// Use NestedMethodProperty to bind using dot notation.\n"
"item.addItemProperty(\"discoverername\",\n"
"    new NestedMethodProperty(planet, \"discoverer.name\"));\n"
"    \n"
"// The other way is to use regular MethodProperty.\n"
"item.addItemProperty(\"discovererborn\",\n"
"     new MethodProperty<Person>(planet.getDiscoverer(),\n"
"                                \"born\"));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:548
#, no-c-format
msgid ""
"The difference is that <classname>NestedMethodProperty</classname> does not "
"access the nested bean immediately but only when accessing the property "
"values, while when using <classname>MethodProperty</classname> the nested "
"bean is accessed when creating the method property. The difference is only "
"significant if the nested bean can be null or be changed later."
msgstr ""
"上面两个方法的区别在于, <classname>NestedMethodProperty</classname> 方法不会"
"立即访问嵌套 Bean, 只会在访问属性值时才需要访问到嵌套 Bean, 而使用 "
"<classname>MethodProperty</classname> 方法时, 嵌套 Bean 会在创建 method "
"property 时立即访问. 只有在嵌套 Bean 可能为 null 时, 或者将来可能被变更时, 以"
"上区别才是重要的."

#. Tag: para
#: chapter-datamodel.xml:557
#, no-c-format
msgid ""
"You can use such a bean item for example in a <classname>Form</classname> as "
"follows:"
msgstr ""
"这里创建的 Bean 项目, 举例来说, 可以在 <classname>Form</classname> 中使用, 如"
"下:"

#. Tag: programlisting
#: chapter-datamodel.xml:562
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Bind it to a component\n"
"Form form = new Form();\n"
"form.setItemDataSource(item);\n"
"    \n"
"// Nicer captions\n"
"form.getField(\"discoverername\").setCaption(\"Discoverer\");\n"
"form.getField(\"discovererborn\").setCaption(\"Born\");]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:565
#, no-c-format
msgid "A <classname>Form</classname> with Nested Bean Properties"
msgstr "使用嵌套 Bean 属性的 <classname>Form</classname>"

#. Tag: para
#: chapter-datamodel.xml:573
#, no-c-format
msgid ""
"The <classname>BeanContainer</classname> and <classname>BeanItemContainer</"
"classname> allow easy definition of nested bean properties with "
"<methodname>addNestedContainerProperty()</methodname>, as described in <xref "
"linkend=\"datamodel.container.beancontainer.nestedproperties\"/>."
msgstr ""
"<classname>BeanContainer</classname> 和 <classname>BeanItemContainer</"
"classname> 可以使用 <methodname>addNestedContainerProperty()</methodname> 方"
"法简单地定义嵌套 Bean 属性, 详情请参见 <xref linkend=\"datamodel.container."
"beancontainer.nestedproperties\"/>."

#. Tag: title
#: chapter-datamodel.xml:586
#, no-c-format
msgid "Creating Forms by Binding Fields to Items"
msgstr "通过 Field 与项目的绑定来创建 Form"

#. Tag: emphasis
#: chapter-datamodel.xml:589
#, no-c-format
msgid ""
"Because of pressing release schedules to get this edition to your hands, we "
"were unable to completely update this chapter. Some form handling is still "
"under work, especially form validation."
msgstr ""
"为了尽快完成本书, 我们来不及彻底地更新本章的内容. Form 处理的一些相关内容目前"
"还在编写中, 尤其是 Form 的校验."

#. Tag: para
#: chapter-datamodel.xml:594
#, no-c-format
msgid ""
"Most applications in existence have forms of some sort. Forms contain "
"fields, which you want to bind to a data source, an item in the Vaadin data "
"model. <classname>FieldGroup</classname> provides an easy way to bind fields "
"to the properties of an item. You can use it by first creating a layout with "
"some fields, and then call it to bind the fields to the data source. You can "
"also let the <classname>FieldGroup</classname> create the fields using a "
"field factory. It can also handle commits. Notice that "
"<classname>FieldGroup</classname> is not a user interface component, so you "
"can not add it to a layout."
msgstr ""
"现实中的大多数应用程序都包含某种形式的 Form. Form 中包含 Field, 你会希望将 "
"Field 绑定到数据源上, 也就是 Vaadin 数据模型中的一个项目. "
"<classname>FieldGroup</classname> 提供了一种简便的方式来将 Field 绑定到项目中"
"的属性. 你可以首先绑定创建一个布局, 和一些 Field, 然后使用它将 Field 绑定到数"
"据源. 也可以让 <classname>FieldGroup</classname> 使用 Field 工厂来创建 "
"Field. 它也会处理数据的提交. 注意, <classname>FieldGroup</classname> 不是一"
"个 UI 组件, 因此你不能将它添加到布局中."

#. Tag: title
#: chapter-datamodel.xml:607
#, no-c-format
msgid "Simple Binding"
msgstr "简易绑定"

#. Tag: para
#: chapter-datamodel.xml:610
#, no-c-format
msgid ""
"Let us start with a data model that has an item with a couple of properties. "
"The item could be any item type, as described earlier."
msgstr ""
"让我们从一个数据模型开始, 这个数据模型中包含一个项目, 项目中包含几个属性. 前"
"面我们已经介绍过, 项目可以是任意类型."

#. Tag: programlisting
#: chapter-datamodel.xml:615
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an item\n"
"PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty<String>(\"Zaphod\"));\n"
"item.addItemProperty(\"age\", new ObjectProperty<Integer>(42));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:617
#, no-c-format
msgid ""
"Next, you would design a form for editing the data. The "
"<classname>FormLayout</classname> (<xref linkend=\"layout.formlayout\"/> is "
"ideal for forms, but you could use any other layout as well."
msgstr ""
"下面, 你需要设计一个 Form 来编辑数据. <classname>FormLayout</classname> (参"
"见 <xref linkend=\"layout.formlayout\"/>) 最适合于 Form, 但你也可以使用其他布"
"局."

#. Tag: programlisting
#: chapter-datamodel.xml:623
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have some layout and create the fields\n"
"FormLayout form = new FormLayout();\n"
"\n"
"TextField nameField = new TextField(\"Name\");\n"
"form.addComponent(nameField);\n"
"\n"
"TextField ageField = new TextField(\"Age\");\n"
"form.addComponent(ageField);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:625
#, no-c-format
msgid "Then, we can bind the fields to the data as follows:"
msgstr "然后, 我们可以将 Field 绑定到数据上, 如下:"

#. Tag: programlisting
#: chapter-datamodel.xml:629
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Now create the binder and bind the fields\n"
"FieldGroup binder = new FieldGroup(item);\n"
"binder.bind(nameField, \"name\");\n"
"binder.bind(ageField, \"age\");]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:631
#, no-c-format
msgid ""
"The above way of binding is not different from simply calling "
"<methodname>setPropertyDataSource()</methodname> for the fields. It does, "
"however, register the fields in the field group, which for example enables "
"buffering or validation of the fields using the field group, as described in "
"<xref linkend=\"datamodel.itembinding.buffering\"/>."
msgstr ""
"上面的数据绑定方式与直接调用 Field 的 <methodname>setPropertyDataSource()</"
"methodname> 方法没有区别. 但是, 它会将 Field 注册到 FieldGroup 中, 因此会通"
"过 FieldGroup 来实现针对 Field 的缓冲和校验等功能 , 详情请参见 <xref linkend="
"\"datamodel.itembinding.buffering\"/>."

#. Tag: para
#: chapter-datamodel.xml:639
#, no-c-format
msgid ""
"Next, we consider more practical uses for a <classname>FieldGroup</"
"classname>."
msgstr "下面, 我们来考查一下 <classname>FieldGroup</classname> 更具体的应用."

#. Tag: title
#: chapter-datamodel.xml:648
#, no-c-format
msgid ""
"Using a <interfacename>FieldFactory</interfacename> to Build and Bind Fields"
msgstr "使用 <interfacename>FieldFactory</interfacename> 创建并绑定 Field"

#. Tag: para
#: chapter-datamodel.xml:650
#, no-c-format
msgid ""
"Using the <methodname>buildAndBind()</methodname> methods, "
"<classname>FieldGroup</classname> can create fields for you using a "
"<interfacename>FieldGroupFieldFactory</interfacename>, but you still have to "
"add them to the correct position in your layout."
msgstr ""
"通过 <methodname>buildAndBind()</methodname> 方法, <classname>FieldGroup</"
"classname> 可以使用 <interfacename>FieldGroupFieldFactory</interfacename>为你"
"创建 Field , 但是你仍然需要将这些 Filed 添加到布局内的正确位置上."

#. Tag: programlisting
#: chapter-datamodel.xml:657
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Have some layout\n"
"FormLayout form = new FormLayout();\n"
"        \n"
"// Now create a binder that can also create the fields\n"
"// using the default field factory\n"
"FieldGroup binder = new FieldGroup(item);\n"
"form.addComponent(binder.buildAndBind(\"Name\", \"name\"));\n"
"form.addComponent(binder.buildAndBind(\"Age\", \"age\"));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:661
#, no-c-format
msgid "Binding Member Fields"
msgstr "绑定成员 Field"

#. Tag: para
#: chapter-datamodel.xml:663
#, no-c-format
msgid ""
"The <methodname>bindMemberFields()</methodname> method in "
"<classname>FieldGroup</classname> uses reflection to bind the properties of "
"an item to field components that are member variables of a class. Hence, if "
"you implement a form as a class with the fields stored as member variables, "
"you can use this method to bind them super-easy."
msgstr ""
"<classname>FieldGroup</classname> 中的 <methodname>bindMemberFields()</"
"methodname> 方法使用反射机制来将项目中的属性绑定到类的成员变量的 Field 组件"
"上. 因此, 如果你以类的形式实现一个 Form, 把 Field 作为成员变量保存在类中, 你"
"就可以使用这个方法非常便利地绑定这些 Field."

#. Tag: para
#: chapter-datamodel.xml:671
#, no-c-format
msgid ""
"The item properties are mapped to the members by the property ID and the "
"name of the member variable. If you want to map a property with a different "
"ID to a member, you can use the <literal>@PropertyId</literal> annotation "
"for the member, with the property ID as the parameter."
msgstr ""
"项目属性和成员变量通过属性 ID 和成员变量名来对应. 如果你希望将某个成员变量映"
"射到不同的属性 ID, 你可以对这个成员变量使用 <literal>@PropertyId</literal> 注"
"解, 并将属性 ID 作为这个注解的参数."

#. Tag: para
#: chapter-datamodel.xml:678
#, no-c-format
msgid "For example:"
msgstr "例如:"

#. Tag: programlisting
#: chapter-datamodel.xml:683
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an item\n"
"PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty<String>(\"Zaphod\"));\n"
"item.addItemProperty(\"age\", new ObjectProperty<Integer>(42));\n"
"\n"
"// Define a form as a class that extends some layout\n"
"class MyForm extends FormLayout {\n"
"    // Member that will bind to the \"name\" property\n"
"    TextField name = new TextField(\"Name\");\n"
"    \n"
"    // Member that will bind to the \"age\" property \n"
"    @PropertyId(\"age\")\n"
"    TextField ageField = new TextField(\"Age\");\n"
"    \n"
"    public MyForm() {\n"
"        // Customize the layout a bit\n"
"        setSpacing(true);\n"
"        \n"
"        // Add the fields\n"
"        addComponent(name);\n"
"        addComponent(ageField);\n"
"    }\n"
"}\n"
"        \n"
"// Create one\n"
"MyForm form = new MyForm();\n"
"        \n"
"// Now create a binder that can also creates the fields\n"
"// using the default field factory\n"
"FieldGroup binder = new FieldGroup(item);\n"
"binder.bindMemberFields(form);\n"
"\n"
"// And the form can be used in an higher-level layout\n"
"layout.addComponent(form);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:686
#, no-c-format
msgid "Encapsulating in <classname>CustomComponent</classname>"
msgstr "使用 <classname>CustomComponent</classname> 进行封装"

#. Tag: para
#: chapter-datamodel.xml:688
#, no-c-format
msgid ""
"Using a <classname>CustomComponent</classname> can be better for hiding the "
"implementation details than extending a layout. Also, the use of the "
"<classname>FieldGroup</classname> can be encapsulated in the form class."
msgstr ""
"使用 <classname>CustomComponent</classname> 比继承一个布局要好, 因为可以隐藏"
"内部的实现细节. 此外, <classname>FieldGroup</classname> 的使用也可以封装在 "
"Form 类中."

#. Tag: para
#: chapter-datamodel.xml:694
#, no-c-format
msgid ""
"Consider the following as an alternative for the form implementation "
"presented earlier:"
msgstr "关于我们前面例子中演示的 Form 实现, 考虑一下下面这种替代方案:"

#. Tag: programlisting
#: chapter-datamodel.xml:700
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// A form component that allows editing an "
"item\n"
"class MyForm extends CustomComponent {\n"
"    // Member that will bind to the \"name\" property\n"
"    TextField name = new TextField(\"Name\");\n"
"    \n"
"    // Member that will bind to the \"age\" property \n"
"    @PropertyId(\"age\")\n"
"    TextField ageField = new TextField(\"Age\");\n"
"    \n"
"    public MyForm(Item item) {\n"
"        FormLayout layout = new FormLayout();\n"
"        layout.addComponent(name);\n"
"        layout.addComponent(ageField);\n"
"        \n"
"        // Now use a binder to bind the members\n"
"        FieldGroup binder = new FieldGroup(item);\n"
"        binder.bindMemberFields(this);\n"
"\n"
"        setCompositionRoot(layout);\n"
"    }\n"
"}\n"
"        \n"
"// And the form can be used as a component\n"
"layout.addComponent(new MyForm(item));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:705
#, no-c-format
msgid "Buffering Forms"
msgstr "Form 的缓冲"

#. Tag: para
#: chapter-datamodel.xml:707
#, no-c-format
msgid ""
"Just like for individual fields, as described in <xref linkend=\"components."
"fields.buffering\"/>, a <classname>FieldGroup</classname> can handle "
"buffering the form content so that it is written to the item data source "
"only when <methodname>commit()</methodname> is called for the group. It runs "
"validation for all fields in the group and writes their values to the item "
"data source only if all fields pass the validation. Edits can be discarded, "
"so that the field values are reloaded from the data source, by calling "
"<methodname>discard()</methodname>. Buffering is enabled by default, but can "
"be disabled by calling <methodname>setBuffered(false)</methodname> for the "
"<classname>FieldGroup</classname>."
msgstr ""
"与独立的 Field 一样, 参见 <xref linkend=\"components.fields.buffering\"/>, "
"<classname>FieldGroup</classname> 也可以处理 Form 内容的缓冲, 因此只有在对 "
"FieldGroup 调用 <methodname>commit()</methodname> 方法时, 数据才会写入数据源"
"中. FieldGroup 还会对其中的所有 Field 进行校验, 只有在所有的 Field 都通过校验"
"时, 才会将值写入到数据源中. 调用 <methodname>discard()</methodname> 方法可以"
"取消对数据的编辑, 这时 Field 值会从数据源中重新装载. 缓冲功能默认是有效的, 但"
"可以使用 <classname>FieldGroup</classname> 的 "
"<methodname>setBuffered(false)</methodname> 方法来禁用."

#. Tag: programlisting
#: chapter-datamodel.xml:723
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an item of some sort\n"
"final PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty<String>(\"Q\"));\n"
"item.addItemProperty(\"age\",  new ObjectProperty<Integer>(42));\n"
"\n"
"// Have some layout and create the fields\n"
"Panel form = new Panel(\"Buffered Form\");\n"
"form.setContent(new FormLayout());\n"
"\n"
"// Build and bind the fields using the default field factory\n"
"final FieldGroup binder = new FieldGroup(item);\n"
"form.addComponent(binder.buildAndBind(\"Name\", \"name\"));\n"
"form.addComponent(binder.buildAndBind(\"Age\",  \"age\"));\n"
"\n"
"// Enable buffering (actually enabled by default)\n"
"binder.setBuffered(true);\n"
"        \n"
"// A button to commit the buffer\n"
"form.addComponent(new Button(\"OK\", new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        try {\n"
"            binder.commit();\n"
"            Notification.show(\"Thanks!\");\n"
"        } catch (CommitException e) {\n"
"            Notification.show(\"You fail!\");\n"
"        }\n"
"    }\n"
"}));\n"
"\n"
"// A button to discard the buffer\n"
"form.addComponent(new Button(\"Discard\", new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        binder.discard();\n"
"        Notification.show(\"Discarded!\");\n"
"    }\n"
"}));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:727
#, no-c-format
msgid "Binding Fields to a Bean"
msgstr "将 Field 绑定到 Bean"

#. Tag: para
#: chapter-datamodel.xml:729
#, no-c-format
msgid ""
"The <classname>BeanFieldGroup</classname> makes it easier to bind fields to "
"a bean. It also handles binding to nested beans properties. The build a "
"field bound to a nested bean property, identify the property with dot "
"notation. For example, if a <classname>Person</classname> bean has a "
"<literal>address</literal> property with an <classname>Address</classname> "
"type, which in turn has a <literal>street</literal> property, you could "
"build a field bound to the property with <methodname>buildAndBind(\"Street"
"\", \"address.street\")</methodname>."
msgstr ""
"<classname>BeanFieldGroup</classname> 可以简化 Field 与 Bean 的绑定工作. 它还"
"可以处理嵌套 Bean 属性的绑定. 要创建一个与嵌套 Bean 的属性绑定的 Field, 需要"
"用点号的形式指定属性 ID. 比如, 如果 <classname>Person</classname> Bean 中有一"
"个 <literal>address</literal> 属性, 其类型为 <classname>Address</classname>, "
"这个类中又有一个 <literal>street</literal> 属性, 你可以使用 "
"<methodname>buildAndBind(\"Street\", \"address.street\")</methodname> 方法, "
"创建一个绑定到这个属性上的 Field."

#. Tag: para
#: chapter-datamodel.xml:740
#, no-c-format
msgid ""
"The input to fields bound to a bean can be validated using the Java Bean "
"Validation API, as described in <xref linkend=\"datamodel.itembinding."
"beanvalidation\"/>. The <classname>BeanFieldGroup</classname> automatically "
"adds a <classname>BeanValidator</classname> to every field if a bean "
"validation implementation is included in the classpath."
msgstr ""
"Field 绑定到 Bean 之后, 其中的输入内容可以使用 Java Bean Validation API 来进"
"行校验, 详情请参见<xref linkend=\"datamodel.itembinding.beanvalidation\"/>. "
"如果在当前类路径中存在 Bean 校验器的实现类, <classname>BeanFieldGroup</"
"classname> 会为每一个 Field 自动添加 <classname>BeanValidator</classname>."

#. Tag: title
#: chapter-datamodel.xml:751
#, no-c-format
msgid "Bean Validation"
msgstr "Bean 的校验"

#. Tag: para
#: chapter-datamodel.xml:753
#, no-c-format
msgid ""
"Vaadin allows using the Java Bean Validation API 1.0 (JSR-303) for "
"validating input from fields bound to bean properties before the values are "
"committed to the bean. The validation is done based on annotations on the "
"bean properties, which are used for creating the actual validators "
"automatically. See <xref linkend=\"components.fields.validation\"/> for "
"general information about validation."
msgstr ""
"对于绑定到 Bean 属性的 Field, Vaadin 允许在值写入到 Bean 之前, 使用 Java "
"Bean Validation API 1.0 (JSR-303) 来校验输入内容. 校验基于Bean 属性上的注解来"
"实现, 这些注解用来自动创建实际的校验器. 关于校验, 详情请参见 <xref linkend="
"\"components.fields.validation\"/>."

#. Tag: para
#: chapter-datamodel.xml:762
#, no-c-format
msgid ""
"Using bean validation requires an implementation of the Bean Validation API, "
"such as Hibernate Validator (<filename>hibernate-validator-4.2.0.Final.jar</"
"filename> or later) or Apache Bean Validation. The implementation JAR must "
"be included in the project classpath when using the bean validation, or "
"otherwise an internal error is thrown."
msgstr ""
"使用 Bean 校验功能需要依赖于 Bean Validation API 的实现库, 比如 Hibernate "
"Validator (<filename>hibernate-validator-4.2.0.Final.jar</filename> 或更高版"
"本) 或 Apache Bean Validation. 使用 Bean 校验功能时, 实现库的 JAR 文件必须放"
"在工程的类路径中, 否则将抛出内部错误."

#. Tag: para
#: chapter-datamodel.xml:771
#, no-c-format
msgid ""
"Bean validation is especially useful when persisting entity beans with the "
"Vaadin JPAContainer, described in <xref linkend=\"jpacontainer\"/>."
msgstr ""
"在使用 Vaadin JPAContainer 来管理实体 Bean 的持久化存储时, Bean 校验功能尤其"
"有用, 详情请参见 <xref linkend=\"jpacontainer\"/>."

#. Tag: title
#: chapter-datamodel.xml:777
#, no-c-format
msgid "Annotations"
msgstr "注解"

#. Tag: para
#: chapter-datamodel.xml:779
#, no-c-format
msgid ""
"The validation constraints are defined as annotations. For example, consider "
"the following bean:"
msgstr "校验规则通过注解来定义. 比如, 考虑下面这个 Bean:"

#. Tag: programlisting
#: chapter-datamodel.xml:784
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a bean\n"
"public class Person implements Serializable {\n"
"    @NotNull\n"
"    @javax.validation.constraints.Size(min=2, max=10)\n"
"    String name;\n"
"    \n"
"    @Min(1)\n"
"    @Max(130)\n"
"    int age;\n"
"    \n"
"    // ... setters and getters ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:786
#, no-c-format
msgid ""
"For a complete list of allowed constraints for different data types, please "
"see the <link xlink:href=\"http://docs.oracle.com/javaee/6/tutorial/doc/"
"gircz.html\">Bean Validation API documentation</link>."
msgstr ""
"关于各种数据类型可以使用的校验规约列表, 请参见 <link xlink:href=\"http://"
"docs.oracle.com/javaee/6/tutorial/doc/gircz.html\">Bean Validation API "
"documentation</link>."

#. Tag: title
#: chapter-datamodel.xml:795
#, no-c-format
msgid "Validating the Beans"
msgstr "校验 Bean"

#. Tag: para
#: chapter-datamodel.xml:797
#, no-c-format
msgid ""
"Validating a bean is done with a <classname>BeanValidator</classname>, which "
"you initialize with the name of the bean property it should validate and add "
"it the the editor field."
msgstr ""
"Bean 的校验由 <classname>BeanValidator</classname> 处理, 这个校验器创建时需要"
"指定它负责校验的 Bean 属性名称, 然后需要将它添加到负责编辑数据的 Field."

#. Tag: para
#: chapter-datamodel.xml:803
#, no-c-format
msgid "In the following example, we validate a single unbuffered field:"
msgstr "下例中, 我们对一个单独的、无缓冲的 Field 进行校验:"

#. Tag: programlisting
#: chapter-datamodel.xml:807
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Person bean = new Person(\"Mung bean\", 100);\n"
"BeanItem<Person> item = new BeanItem<Person> (bean);\n"
"    \n"
"// Create an editor bound to a bean field\n"
"TextField firstName = new TextField(\"First Name\",\n"
"        item.getItemProperty(\"name\"));\n"
"    \n"
"// Add the bean validator\n"
"firstName.addValidator(new BeanValidator(Person.class, \"name\"));\n"
"    \n"
"firstName.setImmediate(true);\n"
"layout.addComponent(firstName);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:809
#, no-c-format
msgid ""
"In this case, the validation is done immediately after focus leaves the "
"field. You could do the same for the other field as well."
msgstr ""
"这种情况下, 当焦点离开 Field 时会立即执行校验. 你也可以对其他 Field 进行相同"
"的处理."

#. Tag: para
#: chapter-datamodel.xml:814
#, no-c-format
msgid ""
"Bean validators are automatically created when using a "
"<classname>BeanFieldGroup</classname>."
msgstr "使用 <classname>BeanFieldGroup</classname> 时, 会自动创建 Bean 校验器."

#. Tag: programlisting
#: chapter-datamodel.xml:819
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a bean\n"
"Person bean = new Person(\"Mung bean\", 100);\n"
"        \n"
"// Form for editing the bean\n"
"final BeanFieldGroup<Person> binder =\n"
"        new BeanFieldGroup<Person>(Person.class);\n"
"binder.setItemDataSource(bean);\n"
"layout.addComponent(binder.buildAndBind(\"Name\", \"name\"));\n"
"layout.addComponent(binder.buildAndBind(\"Age\", \"age\"));\n"
"\n"
"// Buffer the form content\n"
"binder.setBuffered(true);\n"
"layout.addComponent(new Button(\"OK\", new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        try {\n"
"            binder.commit();\n"
"        } catch (CommitException e) {\n"
"        }\n"
"    }\n"
"}));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:823
#, no-c-format
msgid "Locale Setting for Bean Validation"
msgstr "Bean 校验中的语言环境(Locale)设定"

#. Tag: para
#: chapter-datamodel.xml:825
#, no-c-format
msgid ""
"The validation error messages are defined in the bean validation "
"implementation, in a <filename>ValidationMessages.properties</filename> "
"file. The message is shown in the language specified with the locale setting "
"for the form. The default language is English, but for example Hibernate "
"Validator contains translations of the messages for a number of languages. "
"If other languages are needed, you need to provide a translation of the "
"properties file."
msgstr ""
"校验失败时的错误消息定义在 Bean 校验实现库的 <filename>ValidationMessages."
"properties</filename> 文件中. 显示的消息内容会与 Form 的语言环境设置保持一"
"致. 默认语言是英语, 但是, Hibernate Validator 也包含了很多语言中的翻译版本. "
"如果需要使用其他语言, 你需要自己提供这个 properties 文件的翻译版."

#. Tag: title
#: chapter-datamodel.xml:840
#, no-c-format
msgid "Collecting Items in Containers"
msgstr "在容器(Container)中保存项目(Item)"

#. Tag: classname
#: chapter-datamodel.xml:843
#, no-c-format
msgid "<classname>Container</classname>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:846
#, no-c-format
msgid ""
"The <classname>Container</classname> interface is the highest containment "
"level of the Vaadin data model, for containing items (rows) which in turn "
"contain properties (columns). Containers can therefore represent tabular "
"data, which can be viewed in a <classname>Table</classname> or some other "
"selection component, as well as hierarchical data."
msgstr ""
"<classname>Container</classname> 接口是 Vaadin 数据模型包含关系中的最高层级, "
"负责包含项目(行), 项目再负责包含属性(列). 因此容器可以表现表格式数据, 这类数"
"据可以通过 <classname>Table</classname> 组件或其他选择组件来查看, 容器也可以"
"表现层级式数据."

#. Tag: para
#: chapter-datamodel.xml:854
#, no-c-format
msgid ""
"The items contained in a container are identified by an <emphasis>item "
"identifier</emphasis> or <emphasis>IID</emphasis>, and the properties by a "
"<emphasis>property identifier</emphasis> or <emphasis>PID</emphasis>."
msgstr ""
"容器内包含的项目通过 <emphasis>项目 ID</emphasis> 简称 <emphasis>IID</"
"emphasis> 来区分, 项目内的属性通过 <emphasis>属性 ID</emphasis> 或者简称 "
"<emphasis>PID</emphasis> 来区分."

#. Tag: title
#: chapter-datamodel.xml:861
#, no-c-format
msgid "Basic Use of Containers"
msgstr "容器的基本使用"

#. Tag: para
#: chapter-datamodel.xml:863
#, no-c-format
msgid ""
"The basic use of containers involves creating one, adding items to it, and "
"binding it as a container data source of a component."
msgstr "容器的基本使用涉及到创建容器, 添加项目, 以及将组件绑定到容器数据源."

#. Tag: title
#: chapter-datamodel.xml:869
#, no-c-format
msgid "Default Containers and Delegation"
msgstr "默认容器和代理"

#. Tag: para
#: chapter-datamodel.xml:871
#, no-c-format
msgid ""
"Before saying anything about creation of containers, it should be noted that "
"all components that can be bound to a container data source are by default "
"bound to a default container. For example, <classname>Table</classname> is "
"bound to a <classname>IndexedContainer</classname>, <classname>Tree</"
"classname> to a <classname>HierarchicalContainer</classname>, and so forth."
msgstr ""
"在我们介绍如何创建容器之前, 应该注意, 所有可以绑定到容器数据源的组件, 都会默"
"认绑定到一个默认容器. 比如, <classname>Table</classname> 绑定到 "
"<classname>IndexedContainer</classname>, <classname>Tree</classname> 绑定到 "
"<classname>HierarchicalContainer</classname>, 等等."

#. Tag: para
#: chapter-datamodel.xml:880
#, no-c-format
msgid ""
"All of the user interface components using containers also implement the "
"relevant container interfaces themselves, so that the access to the "
"underlying data source is delegated through the component."
msgstr ""
"所有使用容器的 UI 组件自身也实现了相关容器接口, 因此可以通过组件的代理来访问"
"底层的数据源."

#. Tag: programlisting
#: chapter-datamodel.xml:886
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create a table with one column\n"
"Table table = new Table(\"My Table\");\n"
"table.addContainerProperty(\"col1\", String.class, null);\n"
"\n"
"// Access items and properties through the component\n"
"table.addItem(\"row1\"); // Create item by explicit ID\n"
"Item item1 = table.getItem(\"row1\");\n"
"Property property1 = item1.getItemProperty(\"col1\");\n"
"property1.setValue(\"some given value\");\n"
"\n"
"// Equivalent access through the container\n"
"Container container = table.getContainerDataSource();\n"
"container.addItem(\"row2\");\n"
"Item item2 = container.getItem(\"row2\");\n"
"Property property2 = item2.getItemProperty(\"col1\");\n"
"property2.setValue(\"another given value\");]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:890
#, no-c-format
msgid "Creating and Binding a Container"
msgstr "容器的创建和绑定"

#. Tag: para
#: chapter-datamodel.xml:892
#, no-c-format
msgid "A container is created and bound to a component as follows:"
msgstr "创建一个容器并绑定到组件的方法如下:"

#. Tag: programlisting
#: chapter-datamodel.xml:896
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[// Create a container of some type\n"
"Container container = new IndexedContainer();\n"
"\n"
"// Initialize the container as required by the container type\n"
"container.addContainerProperty(\"name\", String.class, \"none\");\n"
"container.addContainerProperty(\"volume\", Double.class, 0.0);\n"
"\n"
"... add items ...\n"
"\n"
"// Bind it to a component\n"
"Table table = new Table(\"My Table\");\n"
"table.setContainerDataSource(container);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:898
#, no-c-format
msgid ""
"Most components that can be bound to a container allow passing it also in "
"the constructor, in addition to using <methodname>setContainerDataSource()</"
"methodname>. Creation of the container depends on its type. For some "
"containers, such as the <classname>IndexedContainer</classname>, you need to "
"define the contained properties (columns) as was done above, while some "
"others determine them otherwise. The definition of a property with "
"<methodname>addContainerProperty()</methodname> requires a unique property "
"ID, type, and a default value. You can also give <parameter>null</parameter>."
msgstr ""
"大多数能够绑定到容器的组件, 除了可以使用 "
"<methodname>setContainerDataSource()</methodname> 方法之外, 也允许在构造函数"
"参数中指定容器. 容器的创建方式取决于容器类型. 对某些容器, 比如 "
"<classname>IndexedContainer</classname>, 象上面的例子那样, 你需要定义其中包含"
"的属性(列), 其他容器则会自行判定. 使用 <methodname>addContainerProperty()</"
"methodname> 方法定义属性, 需要指定唯一的属性 ID, 类型, 以及默认值. 你也可以指"
"定默认值为 <parameter>null</parameter>."

#. Tag: para
#: chapter-datamodel.xml:911
#, no-c-format
msgid ""
"Vaadin has a several built-in in-memory container implementations, such as "
"<classname>IndexedContainer</classname> and <classname>BeanItemContainer</"
"classname>, which are easy to use for setting up nonpersistent data "
"storages. For persistent data, either the built-in <classname>SQLContainer</"
"classname> or the <classname>JPAContainer</classname> add-on container can "
"be used."
msgstr ""
"Vaadin 中有几个内建的内存容器实现, 比如 <classname>IndexedContainer</"
"classname> 和 <classname>BeanItemContainer</classname>, 这些实现比较容易使"
"用, 因为不依赖于持久化的数据存储. 对于持久数据, 可以使用内建容器 "
"<classname>SQLContainer</classname>, 也可以使用 add-on 容器 "
"<classname>JPAContainer</classname>."

#. Tag: title
#: chapter-datamodel.xml:922
#, no-c-format
msgid "Adding Items and Accessing Properties"
msgstr "添加项目与访问属性"

#. Tag: para
#: chapter-datamodel.xml:924
#, no-c-format
msgid ""
"Items can be added to a container with the <methodname>addItem()</"
"methodname> method. The parameterless version of the method automatically "
"generates the item ID."
msgstr ""
"可以使用 <methodname>addItem()</methodname> 方法向容器中添加项目. 这个方法的"
"无参数版本会自动生成项目 ID."

#. Tag: programlisting
#: chapter-datamodel.xml:930
#, no-c-format
msgid ""
"<![CDATA[// Create an item\n"
"Object itemId = container.addItem();]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:932
#, no-c-format
msgid ""
"Properties can be requested from container by first requesting an item with "
"<methodname>getItem()</methodname> and then getting the properties from the "
"item with <methodname>getItemProperty()</methodname>."
msgstr ""
"要取得容器中的属性, 可以首先使用 <methodname>getItem()</methodname> 方法得到"
"项目, 然后使用项目的 <methodname>getItemProperty()</methodname> 方法得到属性."

#. Tag: programlisting
#: chapter-datamodel.xml:940
#, no-c-format
msgid ""
"<![CDATA[// Get the item object\n"
"Item item = container.getItem(itemId);\n"
"\n"
"// Access a property in the item\n"
"Property<String> nameProperty =\n"
"        item.getItemProperty(\"name\");\n"
"\n"
"// Do something with the property\n"
"nameProperty.setValue(\"box\");]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:942
#, no-c-format
msgid ""
"You can also get a property directly by the item and property ids with "
"<methodname>getContainerProperty()</methodname>."
msgstr ""
"你也可以使用 <methodname>getContainerProperty()</methodname> 方法, 通过项目 "
"ID 和属性 ID 直接得到属性."

#. Tag: programlisting
#: chapter-datamodel.xml:947
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[container.getContainerProperty(itemId, \"volume"
"\").setValue(5.0);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:951
#, no-c-format
msgid "Adding Items by Given ID"
msgstr "通过指定的 ID 来添加项目"

#. Tag: para
#: chapter-datamodel.xml:953
#, no-c-format
msgid ""
"Some containers, such as <classname>IndexedContainer</classname> and "
"<classname>HierarchicalContainer</classname>, allow adding items by a given "
"ID, which can be any <classname>Object</classname>."
msgstr ""
"某些容器, 比如 <classname>IndexedContainer</classname> 和 "
"<classname>HierarchicalContainer</classname>, 允许使用指定的项目 ID 来添加项"
"目, 项目 ID 可以是任意的 <classname>Object</classname>."

#. Tag: programlisting
#: chapter-datamodel.xml:959
#, no-c-format
msgid ""
"<![CDATA[Item item = container.addItem(\"agivenid\");\n"
"item.getItemProperty(\"name\").setValue(\"barrel\");\n"
"Item.getItemProperty(\"volume\").setValue(119.2);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:961
#, no-c-format
msgid ""
"Notice that the actual item <emphasis>is not</emphasis> given as a parameter "
"to the method, only its ID, as the interface assumes that the container "
"itself creates all the items it contains. Some container implementations can "
"provide methods to add externally created items, and they can even assume "
"that the item ID object is also the item itself. Lazy containers might not "
"create the item immediately, but lazily when it is accessed by its ID."
msgstr ""
"注意, 方法参数中给出的 <emphasis>不是</emphasis> 真实的项目, 而只是项目的 "
"ID, 因为容器接口假定容器本身负责它包含的所有项目. 某些容器的实现类会提供方法"
"来添加外部创建的项目, 它们甚至还可能会假定项目 ID 对象就是项目本身. Lazy 容器"
"可能不会立即创建项目对象, 而是延后到通过项目 ID 访问项目对象时创建."

#. Tag: title
#: chapter-datamodel.xml:974
#, no-c-format
msgid "Container Subinterfaces"
msgstr "容器的下级接口 "

#. Tag: para
#: chapter-datamodel.xml:976
#, no-c-format
msgid ""
"The <classname>Container</classname> interface contains inner interfaces "
"that container implementations can implement to fulfill different features "
"required by components that present container data."
msgstr ""
"<classname>Container</classname> 接口中包含了一些下级接口, 容器的实现类可以实"
"现这些接口, 来实现容器数据的表现组件所需要的各种功能."

#. Tag: interfacename
#: chapter-datamodel.xml:984
#, no-c-format
msgid "Container.Filterable"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:986
#, no-c-format
msgid ""
"Filterable containers allow filtering the contained items by filters, as "
"described in <xref linkend=\"datamodel.container.filtered\"/>."
msgstr ""
"可过滤容器允许使用过滤器来过滤容器内包含的项目, 详情请参见 <xref linkend="
"\"datamodel.container.filtered\"/>."

#. Tag: interfacename
#: chapter-datamodel.xml:994
#, no-c-format
msgid "Container.Hierarchical"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:996
#, no-c-format
msgid ""
"Hierarchical containers allow representing hierarchical relationships "
"between items and are required by the <classname>Tree</classname> and "
"<classname>TreeTable</classname> components. The "
"<classname>HierarchicalContainer</classname> is a built-in in-memory "
"container for hierarchical data, and is used as the default container for "
"the tree components. The <classname>FilesystemContainer</classname> provides "
"access to browsing the content of a file system. Also "
"<classname>JPAContainer</classname> is hierarchical, as described in <xref "
"linkend=\"jpacontainer.usage.hierarchical\"/>."
msgstr ""
"层级容器允许表达项目与项目之间的层级关系, <classname>Tree</classname> 和 "
"<classname>TreeTable</classname> 组件依赖于这个接口. "
"<classname>HierarchicalContainer</classname> 是内建的内存容器, 用于存储层级数"
"据, 也被用作 Tree 组件的默认容器. <classname>FilesystemContainer</classname> "
"可用于访问文件系统的内容. <classname>JPAContainer</classname> 也是层级式的, "
"详情请参见 <xref linkend=\"jpacontainer.usage.hierarchical\"/>."

#. Tag: interfacename
#: chapter-datamodel.xml:1013
#, no-c-format
msgid "Container.Indexed"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1015
#, no-c-format
msgid ""
"An indexed container allows accessing items by an index number, not just "
"their item ID. This feature is required by some components, especially "
"<classname>Table</classname>, which needs to provide lazy access to large "
"containers. The <classname>IndexedContainer</classname> is a basic in-memory "
"implementation, as described in <xref linkend=\"datamodel.container."
"indexedcontainer\"/>."
msgstr ""
"索引容器允许使用索引序号来访问项目, 而不仅仅是使用项目 ID. 某些组件需要这个功"
"能, 尤其是 <classname>Table</classname>, 它需要实现对大容器的 lazy 访问. "
"<classname>IndexedContainer</classname> 是这个接口的基本的内存实现, 详情请参"
"见 <xref linkend=\"datamodel.container.indexedcontainer\"/>."

#. Tag: interfacename
#: chapter-datamodel.xml:1027
#, no-c-format
msgid "Container.Ordered"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1029
#, no-c-format
msgid ""
"An ordered container allows traversing the items in successive order in "
"either direction. Most built-in containers are ordered."
msgstr ""
"有序容器允许在正向或反向上连续地遍历各个项目. 大多数内建容器都是有序的."

#. Tag: interfacename
#: chapter-datamodel.xml:1037
#, no-c-format
msgid "Container.SimpleFilterable"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1039
#, no-c-format
msgid ""
"This interface enables filtering a container by string matching with "
"<methodname>addContainerFilter()</methodname>. The filtering is done by "
"either searching the given string anywhere in a property value, or as its "
"prefix."
msgstr ""
"这个接口允许使用 <methodname>addContainerFilter()</methodname> 方法指定的字符"
"串来过滤容器内容. 过滤方式可以是在属性值内的任何位置搜索指定的字符串, 也可以"
"只搜索字符串前缀."

#. Tag: interfacename
#: chapter-datamodel.xml:1049
#, no-c-format
msgid "Container.Sortable"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1051
#, no-c-format
msgid ""
"A sortable container is required by some components that allow sorting the "
"content, such as <classname>Table</classname>, where the user can click a "
"column header to sort the table by the column. Some other components, such "
"as <classname>Calendar</classname>, may require that the content is sorted "
"to be able to display it properly. Depending on the implementation, sorting "
"can be done only when the <methodname>sort()</methodname> method is called, "
"or the container is automatically kept in order according to the last call "
"of the method."
msgstr ""
"某些允许对内容排序的组件需要使用可排序容器, 比如 <classname>Table</"
"classname>, 当用户点击列头时会按照这一列来排序 Table 内的数据. 某些其他组件, "
"比如 <classname>Calendar</classname>, 可能要求容器内容是以排序过的, 才能保证"
"正确显示. 根据实现类的不同, 可以只在 <methodname>sort()</methodname> 方法被调"
"用时进行排序, 也可能由容器自动保证内容的顺序, 排序方式与 <methodname>sort()</"
"methodname> 方法最后一次被调用时指定的排序方式一致."

#. Tag: para
#: chapter-datamodel.xml:1067
#, no-c-format
msgid "See the API documentation for a detailed description of the interfaces."
msgstr "这些接口的详情, 请参见相应的 API 文档."

#. Tag: classname
#: chapter-datamodel.xml:1073 chapter-datamodel.xml:1359
#, no-c-format
msgid "IndexedContainer"
msgstr "IndexedContainer"

#. Tag: para
#: chapter-datamodel.xml:1075
#, no-c-format
msgid ""
"The <classname>IndexedContainer</classname> is an in-memory container that "
"implements the <interfacename>Indexed</interfacename> interface to allow "
"referencing the items by an index. <classname>IndexedContainer</classname> "
"is used as the default container in most selection components in Vaadin."
msgstr ""
"<classname>IndexedContainer</classname> 是一个内存容器, 实现了 "
"<interfacename>Indexed</interfacename> 接口, 因此可以使用索引序号来访问项目. "
"<classname>IndexedContainer</classname> 在 Vaadin 的大多数选择组件中会被用作"
"默认容器."

#. Tag: para
#: chapter-datamodel.xml:1082
#, no-c-format
msgid ""
"The properties need to be defined with <methodname>addContainerProperty()</"
"methodname>, which takes the property ID, type, and a default value. This "
"must be done before any items are added to the container."
msgstr ""
"属性需要使用 <methodname>addContainerProperty()</methodname> 方法来定义, 这个"
"方法的参数是属性 ID, 类型, 以及默认值. 在向容器添加项目之前, 必须先完成属性定"
"义."

#. Tag: programlisting
#: chapter-datamodel.xml:1089
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create the container\n"
"IndexedContainer container = new IndexedContainer();\n"
"        \n"
"// Define the properties (columns)\n"
"container.addContainerProperty(\"name\", String.class, \"noname\");\n"
"container.addContainerProperty(\"volume\", Double.class, -1.0d);\n"
"\n"
"// Add some items\n"
"Object content[][] = {{\"jar\", 2.0}, {\"bottle\", 0.75},\n"
"                      {\"can\", 1.5}};\n"
"for (Object[] row: content) {\n"
"    Item newItem = container.getItem(container.addItem());\n"
"    newItem.getItemProperty(\"name\").setValue(row[0]);\n"
"    newItem.getItemProperty(\"volume\").setValue(row[1]);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1091
#, no-c-format
msgid ""
"New items are added with <methodname>addItem()</methodname>, which returns "
"the item ID of the new item, or by giving the item ID as a parameter as was "
"described earlier. Note that the <classname>Table</classname> component, "
"which has <classname>IndexedContainer</classname> as its default container, "
"has a conveniency <methodname>addItem()</methodname> method that allows "
"adding items as object vectors containing the property values."
msgstr ""
"新项目使用 <methodname>addItem()</methodname> 方法添加到容器中, 返回值是新项"
"目的 ID, 也可以象前文介绍过的那样, 通过参数指定项目 ID 来添加项目. 注意, "
"<classname>Table</classname> 组件, 使用 <classname>IndexedContainer</"
"classname> 作为它的默认容器, 它有一个名为 <methodname>addItem()</methodname> "
"的方法, 这个方法可以使用对象 vector 来添加项目, vector 内容是项目各个属性的"
"值."

#. Tag: para
#: chapter-datamodel.xml:1101
#, no-c-format
msgid ""
"The container implements the <interfacename>Container.Indexed</"
"interfacename> feature to allow accessing the item IDs by their index "
"number, with <methodname>getIdByIndex()</methodname>, etc. The feature is "
"required mainly for internal purposes of some components, such as "
"<classname>Table</classname>, which uses it to enable lazy transmission of "
"table data to the client-side."
msgstr ""
"实现了 <interfacename>Container.Indexed</interfacename> 功能的容器, 可以使用 "
"<methodname>getIdByIndex()</methodname> 方法, 通过项目的索引序号来访问项目 "
"ID. 索引功能主要是为满足某些组件的内部目的, 比如 <classname>Table</"
"classname> 组件, 它需要使用索引功能来将 Table 数据以 lazy 模式传送到客户端."

#. Tag: classname
#: chapter-datamodel.xml:1113
#, no-c-format
msgid "BeanContainer"
msgstr "BeanContainer"

#. Tag: para
#: chapter-datamodel.xml:1115
#, no-c-format
msgid ""
"The <classname>BeanContainer</classname> is an in-memory container for "
"JavaBean objects. Each contained bean is wrapped inside a "
"<classname>BeanItem</classname> wrapper. The item properties are determined "
"automatically by inspecting the getter and setter methods of the class. This "
"requires that the bean class has public visibility, local classes for "
"example are not allowed. Only beans of the same type can be added to the "
"container."
msgstr ""
"<classname>BeanContainer</classname> 是一个保存 Java Bean 对象的内存容器. 其"
"中包含的每一个 Bean 都被封装在 <classname>BeanItem</classname> 之内. 项目属性"
"通过检查类的 get 方法和 set 方法来自动判定. 因此要求 Bean 类的可见度为 "
"public, local 类是不可使用的. 只有相同类型的 Bean 可以添加到这个容器中."

#. Tag: para
#: chapter-datamodel.xml:1125
#, no-c-format
msgid ""
"The generic has two parameters: a bean type and an item identifier type. The "
"item identifiers can be obtained by defining a custom resolver, using a "
"specific item property for the IDs, or by giving item IDs explicitly. As "
"such, it is more general than the <classname>BeanItemContainer</classname>, "
"which uses the bean object itself as the item identifier, making the use "
"usually simpler. Managing the item IDs makes <classname>BeanContainer</"
"classname> more complex to use, but it is necessary in some cases where the "
"<methodname>equals()</methodname> or <methodname>hashCode()</methodname> "
"methods have been reimplemented in the bean."
msgstr ""
"这个容器的泛型有两个参数: Bean 类型和项目 ID 类型. 项目 ID 可以通过指定一个自"
"定义解析器来获得, 也可以使用特定的项目属性作为 ID, 或者明确给定一个项目 ID. "
"因此, 这个容器比 <classname>BeanItemContainer</classname> 更通用一些, "
"BeanItemContainer 使用 Bean 对象本身作为项目 ID, 但是使用起来更简单一些. 管理"
"项目 ID 使得 <classname>BeanContainer</classname> 的使用更复杂, 但在某些情况"
"下这种工作是必须的, 比如 Bean 的 <methodname>equals()</methodname> 或 "
"<methodname>hashCode()</methodname> 方法被重新实现的情况."

#. Tag: programlisting
#: chapter-datamodel.xml:1139
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a JavaBean\n"
"public class Bean implements Serializable {\n"
"    String name;\n"
"    double energy; // Energy content in kJ/100g\n"
"    \n"
"    public Bean(String name, double energy) {\n"
"        this.name   = name;\n"
"        this.energy = energy;\n"
"    }\n"
"    \n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"    \n"
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
"    \n"
"    public double getEnergy() {\n"
"        return energy;\n"
"    }\n"
"    \n"
"    public void setEnergy(double energy) {\n"
"        this.energy = energy;\n"
"    }\n"
"}\n"
"\n"
"void basic(VerticalLayout layout) {\n"
"    // Create a container for such beans with\n"
"    // strings as item IDs.\n"
"    BeanContainer<String, Bean> beans =\n"
"        new BeanContainer<String, Bean>(Bean.class);\n"
"    \n"
"    // Use the name property as the item ID of the bean\n"
"    beans.setBeanIdProperty(\"name\");\n"
"\n"
"    // Add some beans to it\n"
"    beans.addBean(new Bean(\"Mung bean\",   1452.0));\n"
"    beans.addBean(new Bean(\"Chickpea\",    686.0));\n"
"    beans.addBean(new Bean(\"Lentil\",      1477.0));\n"
"    beans.addBean(new Bean(\"Common bean\", 129.0));\n"
"    beans.addBean(new Bean(\"Soybean\",     1866.0));\n"
"\n"
"    // Bind a table to it\n"
"    Table table = new Table(\"Beans of All Sorts\", beans);\n"
"    layout.addComponent(table);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1141
#, no-c-format
msgid ""
"To use explicit item IDs, use the methods <methodname>addItem(Object, "
"Object)</methodname>, <methodname>addItemAfter(Object, Object, Object)</"
"methodname>, and <methodname>addItemAt(int, Object, Object)</methodname>."
msgstr ""
"如果要明确指定项目 ID, 应该使用 <methodname>addItem(Object, Object)</"
"methodname>, <methodname>addItemAfter(Object, Object, Object)</methodname>, "
"和 <methodname>addItemAt(int, Object, Object)</methodname> 方法."

#. Tag: para
#: chapter-datamodel.xml:1148
#, no-c-format
msgid ""
"It is not possible to add additional properties to the container, except "
"properties in a nested bean."
msgstr "除 Bean 的属性之外, 容器不允许添加额外的属性, 除非是嵌套 Bean 的属性."

#. Tag: title
#: chapter-datamodel.xml:1154
#, no-c-format
msgid "Nested Properties"
msgstr "嵌套属性"

#. Tag: primary
#: chapter-datamodel.xml:1157 chapter-datamodel.xml:1307
#, no-c-format
msgid "nested bean properties"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1160
#, no-c-format
msgid ""
"If you have a nested bean with an 1:1 relationship inside a bean type "
"contained in a <classname>BeanContainer</classname> or "
"<classname>BeanItemContainer</classname>, you can add its properties to the "
"container by specifying them with <methodname>addNestedContainerProperty()</"
"methodname>. The feature is defined at the level of "
"<classname>AbstractBeanContainer</classname>."
msgstr ""
"如果你在 <classname>BeanContainer</classname> 或 "
"<classname>BeanItemContainer</classname> 包含的 Bean 类型之内还有 1:1 关系的"
"嵌套 Bean, 你可以将嵌套 Bean 的属性添加到容器中, 方法是使用 "
"<methodname>addNestedContainerProperty()</methodname> 方法. 这个功能定义在 "
"<classname>AbstractBeanContainer</classname> 基类中."

#. Tag: methodname
#: chapter-datamodel.xml:1168
#, no-c-format
msgid "addNestedContainerProperty()"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1171
#, no-c-format
msgid ""
"As with the bean in a bean container, also a nested bean must have public "
"visibility or otherwise an access exception is thrown. An intermediate "
"reference from a bean in the bean container to a nested bean may have a null "
"value."
msgstr ""
"和 Bean 容器中的 Bean 一样, 嵌套 Bean 的可见度也必须是 public, 否则会抛出访问"
"异常. 从 Bean 容器中的 Bean 到嵌套 Bean 的直接引用, 可以是 null 值."

#. Tag: para
#: chapter-datamodel.xml:1178
#, no-c-format
msgid ""
"For example, let us assume that we have the following two beans with the "
"first one nested inside the second one."
msgstr "比如, 假定我们有下面两个 Bean, 第一个嵌套在第二个之中."

#. Tag: programlisting
#: chapter-datamodel.xml:1184
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[/** Bean to be nested */\n"
"public class EqCoord implements Serializable {\n"
"    double rightAscension; /* In angle hours */\n"
"    double declination;    /* In degrees     */\n"
"\n"
"    ... setters and getters for the properties ...\n"
"}\n"
"\n"
"/** Bean referencing a nested bean */\n"
"public class Star implements Serializable {\n"
"    String  name;\n"
"    EqCoord equatorial; /* Nested bean */\n"
"\n"
"    ... setters and getters for the properties ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1186
#, no-c-format
msgid ""
"After creating the container, you can declare the nested properties by "
"specifying their property identifiers with the "
"<methodname>addNestedContainerProperty()</methodname> in dot notation."
msgstr ""
"创建完容器后, 你可以使用 <methodname>addNestedContainerProperty()</"
"methodname> 方法来声明嵌套属性, 属性 ID 中使用点号分隔."

#. Tag: programlisting
#: chapter-datamodel.xml:1194
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a container for beans\n"
"BeanItemContainer<Star> stars =\n"
"    new BeanItemContainer<Star>(Star.class);\n"
"\n"
"// Declare the nested properties to be used in the container\n"
"stars.addNestedContainerProperty(\"equatorial.rightAscension\");\n"
"stars.addNestedContainerProperty(\"equatorial.declination\");\n"
"\n"
"// Add some items\n"
"stars.addBean(new Star(\"Sirius\",  new EqCoord(6.75, 16.71611)));\n"
"stars.addBean(new Star(\"Polaris\", new EqCoord(2.52, 89.26417)));\n"
"\n"
"// Here the nested bean reference is null\n"
"stars.addBean(new Star(\"Vega\", null));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1196
#, no-c-format
msgid ""
"If you bind such a container to a <classname>Table</classname>, you probably "
"also need to set the column headers. Notice that the entire nested bean "
"itself is still a property in the container and would be displayed in its "
"own column. The <methodname>toString()</methodname> method is used for "
"obtaining the displayed value, which is by default an object reference. You "
"normally do not want this, so you can hide the column with "
"<methodname>setVisibleColumns()</methodname>."
msgstr ""
"如果你将这样一个容器绑定到 <classname>Table</classname> 组件, 你可能还需要设"
"置列头. 注意, 嵌套 Bean 本身仍然是容器中的一个属性, 因此也会显示在它自己的列"
"中. 嵌套 Bean 的 <methodname>toString()</methodname> 方法会被用来取得这个属性"
"的显示值, 它的默认结果是一个对象引用地址. 通常你不会希望这样一个结果, 因此你"
"可以使用 <methodname>setVisibleColumns()</methodname> 方法来隐藏这个列."

#. Tag: methodname
#: chapter-datamodel.xml:1205
#, no-c-format
msgid "setVisibleColumns()"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1209
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Put them in a table\n"
"Table table = new Table(\"Stars\", stars);\n"
"table.setColumnHeader(\"equatorial.rightAscension\", \"RA\");\n"
"table.setColumnHeader(\"equatorial.declination\",    \"Decl\");\n"
"table.setPageLength(table.size());\n"
"\n"
"// Have to set explicitly to hide the \"equatorial\" property\n"
"table.setVisibleColumns(new Object[]{\"name\",\n"
"    \"equatorial.rightAscension\", \"equatorial.declination\"});]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1211
#, no-c-format
msgid ""
"The resulting table is shown in <xref linkend=\"figure.datamodel.container."
"beancontainer.nestedproperties\"/>."
msgstr ""
"Table 的运行结果见 <xref linkend=\"figure.datamodel.container.beancontainer."
"nestedproperties\"/>."

#. Tag: title
#: chapter-datamodel.xml:1217
#, no-c-format
msgid ""
"<classname>Table</classname> Bound to a <classname>BeanContainer</classname> "
"with Nested Properties"
msgstr ""
"使用嵌套属性绑定到 <classname>BeanContainer</classname> 的 <classname>Table</"
"classname> 组件"

#. Tag: para
#: chapter-datamodel.xml:1228
#, no-c-format
msgid ""
"The bean binding in <classname>AbstractBeanContainer</classname> normally "
"uses the <classname>MethodProperty</classname> implementation of the "
"<classname>Property</classname> interface to access the bean properties "
"using the setter and getter methods. For nested properties, the "
"<classname>NestedMethodProperty</classname> implementation is used."
msgstr ""
"绑定到 <classname>AbstractBeanContainer</classname> 的 Bean, 通常使用 "
"<classname>Property</classname> 接口的 <classname>MethodProperty</classname> "
"实现类, 来通过 Bean 的 get 方法和 set 方法访问 Bean 的属性. 对于嵌套属性, 使"
"用的是 <classname>NestedMethodProperty</classname> 实现类."

#. Tag: classname
#: chapter-datamodel.xml:1236
#, no-c-format
msgid "MethodProperty"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1237
#, no-c-format
msgid "NestedMethodProperty"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1244
#, no-c-format
msgid "Defining a Bean ID Resolver"
msgstr "定义一个 Bean ID 解析器"

#. Tag: para
#: chapter-datamodel.xml:1246
#, no-c-format
msgid ""
"If a bean ID resolver is set using <methodname>setBeanIdResolver()</"
"methodname> or <methodname>setBeanIdProperty()</methodname>, the methods "
"<methodname>addBean()</methodname>, <methodname>addBeanAfter()</methodname>, "
"<methodname>addBeanAt()</methodname> and <methodname>addAll()</methodname> "
"can be used to add items to the container. If one of these methods is "
"called, the resolver is used to generate an identifier for the item (must "
"not return <parameter>null</parameter>)."
msgstr ""
"如果使用 <methodname>setBeanIdResolver()</methodname> 或 "
"<methodname>setBeanIdProperty()</methodname> 方法设置了 Bean ID 解析器, 那么"
"就可以使用 <methodname>addBean()</methodname>, <methodname>addBeanAfter()</"
"methodname>, <methodname>addBeanAt()</methodname> 和 <methodname>addAll()</"
"methodname> 方法来向容器添加项目. 如果调用了这些方法之一, Bean ID 解析器会被"
"用来为项目生成 ID(返回的项目必须不是 <parameter>null</parameter>)."

#. Tag: para
#: chapter-datamodel.xml:1259
#, no-c-format
msgid ""
"Note that explicit item identifiers can also be used when a resolver has "
"been set by calling the <methodname>addItem*()</methodname> methods - the "
"resolver is only used when adding beans using the <methodname>addBean*()</"
"methodname> or <methodname>addAll(Collection)</methodname> methods."
msgstr ""
"注意, 即使设置了项目 ID 解析器, 也可以使用明确指定的项目 ID 来调用 "
"<methodname>addItem*()</methodname> 方法 - 项目 ID 解析器只被用在使用 "
"<methodname>addBean*()</methodname> 或 <methodname>addAll(Collection)</"
"methodname> 方法添加 Bean 的场合."

#. Tag: classname
#: chapter-datamodel.xml:1270
#, no-c-format
msgid "BeanItemContainer"
msgstr "BeanItemContainer"

#. Tag: para
#: chapter-datamodel.xml:1272
#, no-c-format
msgid ""
"<classname>BeanItemContainer</classname> is a container for JavaBean objects "
"where each bean is wrapped inside a <classname>BeanItem</classname> wrapper. "
"The item properties are determined automatically by inspecting the getter "
"and setter methods of the class. This requires that the bean class has "
"public visibility, local classes for example are not allowed. Only beans of "
"the same type can be added to the container."
msgstr ""
"<classname>BeanItemContainer</classname> 是一个 Java Bean 对象的容器, 其中的"
"每个 Bean 都封装在 <classname>BeanItem</classname> 之内. 项目属性通过检查类"
"的 get 方法和 set 方法来自动判定. 因此要求 Bean 类的可见度为 public, local 类"
"是不可使用的. 只有相同类型的 Bean 可以添加到这个容器中."

#. Tag: para
#: chapter-datamodel.xml:1282
#, no-c-format
msgid ""
"<classname>BeanItemContainer</classname> is a specialized version of the "
"<classname>BeanContainer</classname> described in <xref linkend=\"datamodel."
"container.beancontainer\"/>. It uses the bean itself as the item identifier, "
"which makes it a bit easier to use than <classname>BeanContainer</classname> "
"in many cases. The latter is, however, needed if the bean has reimplemented "
"the <methodname>equals()</methodname> or <methodname>hashCode()</methodname> "
"methods."
msgstr ""
"<classname>BeanItemContainer</classname> 是 <classname>BeanContainer</"
"classname> 的一个特殊版本, 关于 BeanContainer 请参见 <xref linkend="
"\"datamodel.container.beancontainer\"/>. 这个容器使用 Bean 本身作为项目 ID, "
"因此在很多场合, 它的使用比 <classname>BeanContainer</classname> 要简单一些. "
"但如果 Bean 类重新实现了 <methodname>equals()</methodname> 或 "
"<methodname>hashCode()</methodname> 方法的话, 就需要使用 BeanContainer."

#. Tag: para
#: chapter-datamodel.xml:1293
#, no-c-format
msgid ""
"Let us revisit the example given in <xref linkend=\"datamodel.container."
"beancontainer\"/> using the <classname>BeanItemContainer</classname>."
msgstr ""
"我们再来看看 <xref linkend=\"datamodel.container.beancontainer\"/> 中的例子, "
"现在我们改为使用 <classname>BeanItemContainer</classname>."

#. Tag: programlisting
#: chapter-datamodel.xml:1300
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create a container for the beans\n"
"BeanItemContainer<Bean> beans =\n"
"    new BeanItemContainer<Bean>(Bean.class);\n"
"    \n"
"// Add some beans to it\n"
"beans.addBean(new Bean(\"Mung bean\",   1452.0));\n"
"beans.addBean(new Bean(\"Chickpea\",    686.0));\n"
"beans.addBean(new Bean(\"Lentil\",      1477.0));\n"
"beans.addBean(new Bean(\"Common bean\", 129.0));\n"
"beans.addBean(new Bean(\"Soybean\",     1866.0));\n"
"\n"
"// Bind a table to it\n"
"Table table = new Table(\"Beans of All Sorts\", beans);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1302
#, no-c-format
msgid ""
"It is not possible to add additional properties to a "
"<classname>BeanItemContainer</classname>, except properties in a nested "
"bean, as described in <xref linkend=\"datamodel.container.beancontainer\"/>."
msgstr ""
"除 Bean 的属性之外, <classname>BeanItemContainer</classname> 容器不允许添加额"
"外的属性, 除非是嵌套 Bean 的属性, 关于嵌套属性, 详情请参见 <xref linkend="
"\"datamodel.container.beancontainer\"/>."

#. Tag: title
#: chapter-datamodel.xml:1312
#, no-c-format
msgid "Iterating Over a Container"
msgstr "在容器内遍历"

#. Tag: para
#: chapter-datamodel.xml:1314
#, no-c-format
msgid ""
"As the items in a <classname>Container</classname> are not necessarily "
"indexed, iterating over the items has to be done using an "
"<classname>Iterator</classname>. The <methodname>getItemIds()</methodname> "
"method of <classname>Container</classname> returns a <classname>Collection</"
"classname> of item identifiers over which you can iterate. The following "
"example demonstrates a typical case where you iterate over the values of "
"check boxes in a column of a <classname>Table</classname> component. The "
"context of the example is the example used in <xref linkend=\"components."
"table\"/>."
msgstr ""
"由于 <classname>Container</classname> 内的项目不一定是有索引的, 因此对项目的"
"遍历必须使用 <classname>Iterator</classname>. <classname>Container</"
"classname> 的 <methodname>getItemIds()</methodname> 方法返回一个项目 ID 的 "
"<classname>Collection</classname>, 你可以在这个 Collection 上进行遍历. 下例演"
"示了一种常见的遍历情况, 这里遍历 <classname>Table</classname> 组件的一列中的 "
"CheckBox 的值. 这段示例程序的使用场景, 对应于 <xref linkend=\"components."
"table\"/> 中的示例."

#. Tag: programlisting
#: chapter-datamodel.xml:1326
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Collect the results of the iteration into "
"this string.\n"
"String items = \"\";\n"
"\n"
"// Iterate over the item identifiers of the table.\n"
"for (Iterator i = table.getItemIds().iterator(); i.hasNext();) {\n"
"    // Get the current item identifier, which is an integer.\n"
"    int iid = (Integer) i.next();\n"
"    \n"
"    // Now get the actual item from the table.\n"
"    Item item = table.getItem(iid);\n"
"    \n"
"    // And now we can get to the actual checkbox object.\n"
"    Button button = (Button)\n"
"            (item.getItemProperty(\"ismember\").getValue());\n"
"    \n"
"    // If the checkbox is selected.\n"
"    if ((Boolean)button.getValue() == true) {\n"
"        // Do something with the selected item; collect the\n"
"        // first names in a string.\n"
"        items += item.getItemProperty(\"First Name\")\n"
"                     .getValue() + \" \";\n"
"    }\n"
"}\n"
"\n"
"// Do something with the results; display the selected items.\n"
"layout.addComponent (new Label(\"Selected items: \" + items));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1328
#, no-c-format
msgid ""
"Notice that the <methodname>getItemIds()</methodname> returns an "
"<emphasis>unmodifiable collection</emphasis>, so the <classname>Container</"
"classname> may not be modified during iteration. You can not, for example, "
"remove items from the <classname>Container</classname> during iteration. The "
"modification includes modification in another thread. If the "
"<classname>Container</classname> is modified during iteration, a "
"<classname>ConcurrentModificationException</classname> is thrown and the "
"iterator may be left in an undefined state."
msgstr ""
"注意, <methodname>getItemIds()</methodname> 方法返回的是 <emphasis>不可变更"
"的 Collection</emphasis>, 因此 <classname>Container</classname> 在遍历过程中"
"不可以修改内容. 比如, 你不可以在遍历过程中从 <classname>Container</"
"classname> 内删除项目. 这里所说的修改, 也包括在其他线程内的修改. 如果 "
"<classname>Container</classname> 在遍历过程中被修改, 会抛出 "
"<classname>ConcurrentModificationException</classname> 异常, iterator 会处于"
"一种无效状态."

#. Tag: title
#: chapter-datamodel.xml:1342
#, no-c-format
msgid "<classname>Filterable</classname> Containers"
msgstr "<classname>Filterable</classname> 容器"

#. Tag: primary
#: chapter-datamodel.xml:1345
#, no-c-format
msgid "<primary>Container</primary>"
msgstr ""

#. Tag: secondary
#: chapter-datamodel.xml:1346
#, no-c-format
msgid "Filterable"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1349
#, no-c-format
msgid "<classname>Filter</classname> (in <classname>Container</classname>)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1352
#, no-c-format
msgid ""
"Containers that implement the <classname>Container.Filterable</classname> "
"interface can be filtered. For example, the built-in "
"<classname>IndexedContainer</classname> and the bean item containers "
"implement it. Filtering is typically used for filtering the content of a "
"<classname>Table</classname>."
msgstr ""
"实现了 <classname>Container.Filterable</classname> 接口的容器是可以过滤的. 比"
"如, 内建的 <classname>IndexedContainer</classname> 和 Bean 项目容器都实现了这"
"个接口. 过滤功能通常用于过滤 <classname>Table</classname> 中的内容."

#. Tag: classname
#: chapter-datamodel.xml:1360
#, no-c-format
msgid "Table"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1363
#, no-c-format
msgid ""
"Filters implement the <classname>Filter</classname> interface and you add "
"them to a filterable container with the <methodname>addContainerFilter()</"
"methodname> method. Container items that pass the filter condition are kept "
"and shown in the filterable component."
msgstr ""
"过滤器实现 <classname>Filter</classname> 接口, 你需要使用"
"<methodname>addContainerFilter()</methodname> 方法, 将过滤器添加到一个可过滤"
"的容器中. 容器中的项目, 如果通过了过滤条件, 会被保留并显示在可过滤的组件中."

#. Tag: methodname
#: chapter-datamodel.xml:1369
#, no-c-format
msgid "addContainerFilter()"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1374
#, no-c-format
msgid ""
"<![CDATA[Filter filter = new SimpleStringFilter(\"name\",\n"
"        \"Douglas\", true, false);\n"
"table.addContainerFilter(filter);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1376
#, no-c-format
msgid ""
"If multiple filters are added to a container, they are evaluated using the "
"logical AND operator so that only items that are passed by all the filters "
"are kept."
msgstr ""
"如果容器中添加了多个过滤器, 它们之间会用逻辑 AND 的方式组合起来, 因此只有通过"
"了所有过滤器的项目才会被保留下来."

#. Tag: title
#: chapter-datamodel.xml:1383
#, no-c-format
msgid "Atomic and Composite Filters"
msgstr "原子过滤器与组合过滤器"

#. Tag: para
#: chapter-datamodel.xml:1385
#, no-c-format
msgid ""
"Filters can be classified as <emphasis>atomic</emphasis> and "
"<emphasis>composite</emphasis>. Atomic filters, such as "
"<classname>SimpleStringFilter</classname>, define a single condition, "
"usually for a specific container property. Composite filters make filtering "
"decisions based on the result of one or more other filters. The built-in "
"composite filters implement the logical operators AND, OR, or NOT."
msgstr ""
"过滤器可以分为 <emphasis>原子</emphasis> 和 <emphasis>组合</emphasis> 两类. "
"原子过滤器, 比如 <classname>SimpleStringFilter</classname>, 定义一个单独的过"
"滤条件, 通常应用与一个特定的容器属性. 组合过滤器则根据一个或多个其他过滤器的"
"结果来决定它的过滤结果. 内建的组合过滤器实现了逻辑 AND, OR, 和 NOT 操作."

#. Tag: para
#: chapter-datamodel.xml:1395
#, no-c-format
msgid ""
"For example, the following composite filter would filter out items where the "
"<literal>name</literal> property contains the name \"Douglas\" somewhere "
"<emphasis>or</emphasis> where the <literal>age</literal> property has value "
"less than 42. The properties must have <classname>String</classname> and "
"<classname>Integer</classname> types, respectively."
msgstr ""
"比如, 以下组合过滤器会将 <literal>name</literal> 属性中包含 \"Douglas\" "
"<emphasis>或者</emphasis> <literal>age</literal> 属性值小于 42 的项目排除(译"
"注: 这段说明与示例程序不符). 这两个属性的类型应该分别是 <classname>String</"
"classname> 和 <classname>Integer</classname>."

#. Tag: programlisting
#: chapter-datamodel.xml:1403
#, no-c-format
msgid ""
"<![CDATA[\n"
"filter = new Or(new SimpleStringFilter(\"name\",\n"
"        \"Douglas\", true, false),\n"
"        new Compare.Less(\"age\", 42));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1407
#, no-c-format
msgid "Built-In Filter Types"
msgstr "内建的过滤器类型"

#. Tag: para
#: chapter-datamodel.xml:1409
#, no-c-format
msgid "The built-in filter types are the following:"
msgstr "内建的过滤器类型如下:"

#. Tag: classname
#: chapter-datamodel.xml:1415 chapter-datamodel.xml:1417
#, no-c-format
msgid "SimpleStringFilter"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1418
#, no-c-format
msgid ""
"Passes items where the specified property, that must be of "
"<classname>String</classname> type, contains the given "
"<parameter>filterString</parameter> as a substring. If "
"<parameter>ignoreCase</parameter> is <parameter>true</parameter>, the search "
"is case insensitive. If the <parameter>onlyMatchPrefix</parameter> is "
"<parameter>true</parameter>, the substring may only be in the beginning of "
"the string, otherwise it may be elsewhere as well."
msgstr ""
"项目中某个指定的属性, 类型必须是 <classname>String</classname>, 如果属性值中"
"包含指定的 <parameter>过滤字符串</parameter>, 那么这个项目将通过过滤. 如果 "
"<parameter>ignoreCase</parameter> 参数为 <parameter>true</parameter>, 那么字"
"符串查询是忽略大小写的. 如果 <parameter>onlyMatchPrefix</parameter> 参数为 "
"<parameter>true</parameter>, 那么只会在属性值的前缀部分查找子字符串, 如果这个"
"参数为 <parameter>false</parameter>, 那么子字符串也可以出现在其他位置."

#. Tag: classname
#: chapter-datamodel.xml:1432
#, no-c-format
msgid "IsNull"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1434
#, no-c-format
msgid "<classname>IsNull</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1435
#, no-c-format
msgid ""
"Passes items where the specified property has null value. For in-memory "
"filtering, a simple <literal>==</literal> check is performed. For other "
"containers, the comparison implementation is container dependent, but should "
"correspond to the in-memory null check."
msgstr ""
"项目的指定属性值为 null 时, 这个项目将通过过滤. 对于内存内的过滤, 只执行一个"
"简单的 <literal>==</literal> 判断. 对其他容器, 比较的具体实现方法由各容器分别"
"决定, 但结果应该与内存内的 null 检查逻辑一直."

#. Tag: term
#: chapter-datamodel.xml:1445
#, no-c-format
msgid ""
"<classname>Equal</classname>, <classname>Greater</classname>, "
"<classname>Less</classname>, <classname>GreaterOrEqual</classname>, and "
"<classname>LessOrEqual</classname>"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1451
#, no-c-format
msgid "<classname>Equal</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1452
#, no-c-format
msgid "<classname>Greater</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1453
#, no-c-format
msgid "<classname>Less</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1454
#, no-c-format
msgid "<classname>GreaterOrEqual</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1455
#, no-c-format
msgid "<classname>LessOrEqual</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1456
#, no-c-format
msgid ""
"The comparison filter implementations compare the specified property value "
"to the given constant and pass items for which the comparison result is "
"true. The comparison operators are included in the abstract "
"<classname>Compare</classname> class."
msgstr ""
"比较过滤器将指定的属性的值与指定的常数进行比较, 如果比较结果为 true, 则这个项"
"目将通过过滤. 比较操作包含在 <classname>Compare</classname> 抽象类中."

#. Tag: para
#: chapter-datamodel.xml:1462
#, no-c-format
msgid ""
"For the <classname>Equal</classname> filter, the <methodname>equals()</"
"methodname> method for the property is used in built-in in-memory "
"containers. In other types of containers, the comparison is container "
"dependent and may use, for example, database comparison operations."
msgstr ""
"对于 <classname>Equal</classname> 过滤器, 内建的内存容器会使用属性的 "
"<methodname>equals()</methodname> 方法进行比较. 其他类型的容器, 比较方法由各"
"容器决定, 比如, 可能会使用数据库的比较操作."

#. Tag: para
#: chapter-datamodel.xml:1469
#, no-c-format
msgid ""
"For the other filters, the property value type must implement the "
"<classname>Comparable</classname> interface to work with the built-in in-"
"memory containers. Again for the other types of containers, the comparison "
"is container dependent."
msgstr ""
"对于其他过滤器, 属性值的类型必须实现 <classname>Comparable</classname> 接口, "
"才可以在内建的内存容器中工作. 对其他类型的容器, 比较操作的具体实现由各容器决"
"定."

#. Tag: term
#: chapter-datamodel.xml:1478
#, no-c-format
msgid "<classname>And</classname> and <classname>Or</classname>"
msgstr "<classname>And</classname> 和 <classname>Or</classname>"

#. Tag: primary
#: chapter-datamodel.xml:1480
#, no-c-format
msgid "<classname>And</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1481
#, no-c-format
msgid "<classname>Or</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1482
#, no-c-format
msgid ""
"These logical operator filters are composite filters that combine multiple "
"other filters."
msgstr "这些逻辑操作过滤器是组合过滤器, 可以将多个其他过滤器的结果组合起来."

#. Tag: classname
#: chapter-datamodel.xml:1489
#, no-c-format
msgid "<classname>Not</classname>"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1491
#, no-c-format
msgid "<classname>Not</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1492
#, no-c-format
msgid ""
"The logical unary operator filter negates which items are passed by the "
"filter given as the parameter."
msgstr ""
"这个逻辑非过滤器接受一个过滤器参数, 逻辑非过滤器会将参数中指定的过滤器的结果"
"反转."

#. Tag: title
#: chapter-datamodel.xml:1502
#, no-c-format
msgid "Implementing Custom Filters"
msgstr "实现自定义过滤器"

#. Tag: para
#: chapter-datamodel.xml:1504
#, no-c-format
msgid ""
"A custom filter needs to implement the <classname>Container.Filter</"
"classname> interface."
msgstr "自定义过滤器需要实现 <classname>Container.Filter</classname> 接口."

#. Tag: para
#: chapter-datamodel.xml:1509
#, no-c-format
msgid ""
"A filter can use a single or multiple properties for the filtering logic. "
"The properties used by the filter must be returned with the "
"<methodname>appliesToProperty()</methodname> method. If the filter applies "
"to a user-defined property or properties, it is customary to give the "
"properties as the first argument for the constructor of the filter."
msgstr ""
"过滤器可以在过滤逻辑中使用一个或多个属性. <methodname>appliesToProperty()</"
"methodname> 方法必须判定一个属性是否是过滤器使用到的属性. 如果过滤器适用的目"
"标属性是由使用者指定的, 那么通常的习惯是将这些属性作为过滤器构造函数的第一个"
"参数."

#. Tag: programlisting
#: chapter-datamodel.xml:1519
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyCustomFilter implements Container."
"Filter {\n"
"    protected String propertyId;\n"
"    protected String regex;\n"
"    \n"
"    public MyCustomFilter(String propertyId, String regex) {\n"
"        this.propertyId = propertyId;\n"
"        this.regex      = regex;\n"
"    }\n"
"\n"
"    /** Tells if this filter works on the given property. */\n"
"    @Override\n"
"    public boolean appliesToProperty(Object propertyId) {\n"
"        return propertyId != null &&\n"
"               propertyId.equals(this.propertyId);\n"
"    }]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1521
#, no-c-format
msgid ""
"The actual filtering logic is done in the <methodname>passesFilter()</"
"methodname> method, which simply returns <literal>true</literal> if the item "
"should pass the filter and <literal>false</literal> if it should be filtered "
"out."
msgstr ""
"实际的过滤逻辑在 <methodname>passesFilter()</methodname> 方法中实现, 如果项目"
"应该通过过滤的话, 这个方法返回 <literal>true</literal>, 如果项目应该被排除的"
"话, 这个方法返回 <literal>false</literal>."

#. Tag: programlisting
#: chapter-datamodel.xml:1529
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[    /** Apply the filter on an item to check if "
"it passes. */\n"
"    @Override\n"
"    public boolean passesFilter(Object itemId, Item item)\n"
"            throws UnsupportedOperationException {\n"
"        // Acquire the relevant property from the item object\n"
"        Property p = item.getItemProperty(propertyId);\n"
"        \n"
"        // Should always check validity\n"
"        if (p == null || !p.getType().equals(String.class))\n"
"            return false;\n"
"        String value = (String) p.getValue();\n"
"        \n"
"        // The actual filter logic\n"
"        return value.matches(regex);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1532
#, no-c-format
msgid "You can use such a custom filter just like any other:"
msgstr "你可以使用这个自定义过滤器, 方法与使用其他过滤器一样:"

#. Tag: programlisting
#: chapter-datamodel.xml:1536
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[c.addContainerFilter(\n"
"    new MyCustomFilter(\"Name\", (String) tf.getValue()));]]>"
msgstr ""
