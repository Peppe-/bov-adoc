# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-11-07 20:53+0000\n"
"PO-Revision-Date: 2014-11-14 23:50+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-testbench.xml:11
#, no-c-format
msgid "Vaadin TestBench"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:13
#, no-c-format
msgid ""
"This chapter describes the installation and use of the Vaadin TestBench."
msgstr "本章介绍 Vaadin TestBench 的安装和使用."

#. Tag: title
#: chapter-testbench.xml:18
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-testbench.xml:20
#, no-c-format
msgid ""
"Testing is one of the cornerstones of modern software development. Extending "
"throughout the development process, testing is the thread that binds the "
"product to the requirements. In agile and other iterative development "
"processes, with ever shorter release cycles and continuous integration, the "
"automation of integration, regression, endurance, and acceptance testing is "
"paramount. Further, UI automation may be needed for integration purposes, "
"such as for assistive technologies. The special nature of web applications "
"creates many unique requirements for both testing and UI automation."
msgstr ""
"测试是现代软件开发的基石之一. 测试贯穿软件开发的全过程, 它是联系最终产品与客"
"户需求的纽带. 在敏捷软件开发, 以及其他迭代式开发模式中, 随着发布周期变短, 以"
"及持续集成的引入, 集成的自动化, 回归测试, 压力测试, 验收测试都变得非常重要. "
"此外, 为了集成测试的目的, 以及针对残障人士的辅助技术, 还需要实现 UI 的自动化."
"由于 Web 应用程序存在的特殊性质, 也就对测试和 UI 自动化都提出了一些特殊要求."

#. Tag: para
#: chapter-testbench.xml:31
#, no-c-format
msgid ""
"Vaadin TestBench allows controlling the browser from Java code, as "
"illustrated in <xref linkend=\"figure.testbench.webdriver\"/>. It can open a "
"new browser window to start the application, interact with the UI "
"components, for example, by clicking them, and then get the HTML element "
"values."
msgstr ""
"Vaadin TestBench 可以通过 Java 代码控制浏览器, 见 <xref linkend=\"figure."
"testbench.webdriver\"/>. 它可以打开一个新的浏览器窗口, 启动应用程序, 与 UI 组"
"件进行交互, 比如点击组件, 然后取得 HTML 元素的值."

#. Tag: title
#: chapter-testbench.xml:39
#, no-c-format
msgid "Controlling the Browser with Testbench"
msgstr "使用 Testbench 控制浏览器"

#. Tag: para
#: chapter-testbench.xml:50
#, no-c-format
msgid ""
"Before going further into feature details, you may want to try out Vaadin "
"TestBench yourself. You just need to create a new Vaadin project either with "
"the Eclipse plugin or the Maven archetype. Both create a simple application "
"stub that includes TestBench test cases for testing the UI. You also need to "
"install an evaluation license. For instructions, jump to <xref linkend="
"\"testbench.quickstart\"/> and, after trying it out, come back."
msgstr ""
"在开始讨论更多的功能细节之前, 你可能希望亲自试用一下 Vaadin TestBench. 只需要"
"使用 Eclipse plugin 或 Maven archetype 创建一个新的 Vaadin 工程就可以了. 这两"
"种方法都会创建一个简单的应用程序框架代码, 其中包含 TestBench 的 test case, 可"
"以用来测试 UI. 你还需要安装一个试用许可协议. 具体方法请先阅读 <xref linkend="
"\"testbench.quickstart\"/>, 按照其中的指南动手试验一下, 然后再回到本节."

#. Tag: title
#: chapter-testbench.xml:60
#, no-c-format
msgid "Vaadin TestBench in Software Development"
msgstr "Vaadin TestBench 在软件开发中的地位"

#. Tag: para
#: chapter-testbench.xml:62
#, no-c-format
msgid ""
"Vaadin TestBench can work as the centerpiece of the software development "
"process, for testing the application at all modular levels and in all the "
"phases of the development cycle:"
msgstr ""
"Vaadin TestBench 可以成为整个软件开发过程的中心角色, 它可以在开发周期的每个阶"
"段, 在所有的模块层次上, 对应用程序进行测试:"

#. Tag: para
#: chapter-testbench.xml:69
#, no-c-format
msgid "Automated acceptance tests"
msgstr "自动化的验收测试"

#. Tag: para
#: chapter-testbench.xml:70
#, no-c-format
msgid "Unit tests"
msgstr "单元测试"

#. Tag: para
#: chapter-testbench.xml:71
#, no-c-format
msgid "End-to-end integration tests"
msgstr "端到端(End-to-end)的集成测试"

#. Tag: para
#: chapter-testbench.xml:72
#, no-c-format
msgid "Regression tests"
msgstr "回归测试"

#. Tag: para
#: chapter-testbench.xml:75
#, no-c-format
msgid "Let us look at each of these topics separately."
msgstr "下面我们分别介绍以上各个问题."

#. Tag: para
#: chapter-testbench.xml:79
#, no-c-format
msgid ""
"Any methodological software development, agile or not, is preceded by "
"specification of requirements, which define what the software should "
"actually do. <emphasis>Acceptance tests</emphasis> ensure that the product "
"conforms to the requirements. In agile development, their automation allows "
"continuous tracking of progress towards iteration goals, as well as "
"detecting regressions. The importance of requirements is emphasized in "
"<emphasis>test-driven development</emphasis> (TDD), where tests are written "
"before actual code. In <xref linkend=\"testbench.bdd\"/>, we show how to use "
"Vaadin TestBench for <emphasis>behaviour-driven development</emphasis> "
"(BDD), a form of TDD that concentrates on the formal behavioural "
"specification of requirements."
msgstr ""
"不管是敏捷软件开发, 还是其他的软件开发模式, 首先都需要明确需求规范, 需求规范"
"决定软件应该做什么. <emphasis>验收测试(Acceptance test)</emphasis> 确保产品符"
"合需求规范. 在敏捷软件开发模式中, 自动化的验收测试可以用来持续地追踪最终目标"
"的完成进度, 还可以用来检测是否存在回归故障. 在 <emphasis>测试驱动开发</"
"emphasis> (test-driven development, 简称 TDD)中, 非常强调需求规范的重要性, 在"
"这种开发模式下, 还未编写真实代码之前, 首先就应该编写测试程序. 在 <xref "
"linkend=\"testbench.bdd\"/> 中, 我们介绍如何使用 Vaadin TestBench 来进行 "
"<emphasis>行为驱动开发</emphasis> (behaviour-driven development, 简称 BDD), "
"它是 TDD 的一种形式, 更集中关注需求规范中正式化的行为规范."

#. Tag: para
#: chapter-testbench.xml:93
#, no-c-format
msgid ""
"<emphasis>Unit testing</emphasis> is applied to the smallest scale of "
"software components; in Vaadin applications these are typically individual "
"UI components or view classes. You may also want to generate many different "
"kinds of inputs for the application and check that they produce the desired "
"outputs. For complex composites, such as views, you can use the Page Object "
"Pattern described in <xref linkend=\"testbench.maintainable.pageobject\"/>. "
"The pattern simplifies and modularizes testing by separating low-level "
"details from the more abstract UI logic. In addition to serving the purpose "
"of unit tests, it creates an abstraction layer for higher-level tests, such "
"as acceptance and end-to-end tests."
msgstr ""
"<emphasis>单元测试</emphasis> (Unit testing) 用于测试软件组件中最小的功能单"
"元; 在 Vaadin 应用程序中, 通常是独立的 UI 组件, 或者视图类. 你也可能希望为应"
"用程序生成各种不同的输入, 然后检查对应的输出是否符合预期. 对于复杂的复合组"
"件, 比如视图, 你可以使用页面对象模式(Page Object Pattern), 详情请参见 <xref "
"linkend=\"testbench.maintainable.pageobject\"/>. 这种模式将具体的底层实现细节"
"从抽象的 UI 逻辑中分离出来, 这样就可以使测试更加简化, 更加模块化. 除了用于单"
"元测试之外, 它还创造了一个抽象层, 可以用于高级别的测试, 比如验收测试和端到端"
"测试."

#. Tag: para
#: chapter-testbench.xml:107
#, no-c-format
msgid ""
"<emphasis>Integration tests</emphasis> ensure that software units work "
"together at different levels of modularization. At the broadest level, "
"<emphasis>end-to-end tests</emphasis> extend through the entire application "
"lifecycle from start to finish, going through many or all user stories. The "
"aim is not just to verify the functional requirements for user interaction, "
"but also that data integrity is maintained. For example, in a messaging "
"application, a user would log in, both send and receive messages, and "
"finally log out. Such test workflows could include configuration, "
"registration, interaction between users, administrative tasks, deletion of "
"user accounts, and so forth."
msgstr ""
"<emphasis>集成测试</emphasis> (Integration test) 负责确保软件的多个功能模块单"
"元能够在不同的模块化层次上联合运转. 在最大的层次上, <emphasis>端对端测试</"
"emphasis> (end-to-end test) 贯穿应用程序的整个生命周期, 从开始到结束, 覆盖很"
"多(甚至全部)用户场景(user stories). 测试的目的不仅仅是验证是否达到了用户交互"
"方面的功能需求, 而且还要验证是否保证了数据的完整性. 比如, 在聊天应用程序中, "
"一个用户应该先登录系统, 然后发送和接收消息, 最后退出系统. 这样的测试流程可能"
"包括配置, 注册, 用户间交互, 管理性任务, 删除用户帐号, 等等."

#. Tag: para
#: chapter-testbench.xml:120
#, no-c-format
msgid ""
"In <emphasis>regression testing</emphasis>, you want to ensure that only "
"intended changes occur in the behaviour after modifying the code. There are "
"two lines of defence against such regressions. The primary source of "
"regression tests are the acceptance, unit, and integration tests that "
"validate that the displayed values in the UI's HTML representation are "
"logically correct. Yet, they are not sufficient for detecting visual "
"regressions, for example, because of invalid UI rendering or theme problems. "
"Comparing screenshots to reference images forms a more sensitive layer to "
"detect regressions, at the expense of losing robustness for changes in "
"layout and themeing. The costs of the tradeoff can be minimized by careful "
"application of screenshot comparison only at critical points and by making "
"the analysis of such regressions as easy as possible. As described in <xref "
"linkend=\"testbench.screenshots\"/>, Vaadin TestBench automatically "
"highlights differences in screenshots and allows masking irrelevant areas "
"from image comparison."
msgstr ""
"在 <emphasis>回归测试</emphasis> (regression testing) 中, 你希望能够确保, 在"
"修改了代码之后, 软件的行为只发生我们期待的变化. 有两条防线可以阻止这类回归障"
"碍. 回归测试的主要源代码包括验收测试, 单元测试, 以及集成测试, 负责验证 UI 的 "
"HTML 表现中显示的值逻辑上是正确的. 但是, 这些测试还不足以检测出程序外观表现的"
"回归故障, 比如, 无效的 UI 描绘, 或 theme 问题都会导致外观的不正确. 通过将屏幕"
"截图与参考图片进行比较, 这种方式实现了一种更合理的故障检测能力, 但代价是当布"
"局和 theme 变化时, 会失去测试程序的健壮性. 可以将这种代价降到最低, 方法是将屏"
"幕截图的比较范围局限到最关键的区域, 以及使得对回归障碍的分析尽量简单. 在 "
"<xref linkend=\"testbench.screenshots\"/> 中我们将介绍, Vaadin TestBench 可以"
"自动地将屏幕截图与正确图片之间的差异部分高亮度显示, 还可以在图片比较时遮蔽掉"
"无关区域."

#. Tag: para
#: chapter-testbench.xml:138
#, no-c-format
msgid ""
"You can develop such tests along with your application code, for example "
"with JUnit, which is a widely used Java unit testing framework. You can run "
"the tests as many times as you want in your workstation or in a distributed "
"grid setup."
msgstr ""
"你可以针对你的应用程序代码开发这样的测试程序, 比如可以使用 JUnit, 它是一种广"
"泛使用的 Java 单元测试框架. 你可以在你的工作站中, 或者在一个分布式网格环境"
"中, 按照你的需求任意次地运行这些测试程序."

#. Tag: title
#: chapter-testbench.xml:146
#, no-c-format
msgid "TestBench Workflow"
msgstr "TestBench 的工作流程"

#. Tag: title
#: chapter-testbench.xml:159
#, no-c-format
msgid "Features"
msgstr "功能"

#. Tag: para
#: chapter-testbench.xml:161
#, no-c-format
msgid "The main features of Vaadin TestBench are:"
msgstr "Vaadin TestBench 的主要功能包括:"

#. Tag: para
#: chapter-testbench.xml:167
#, no-c-format
msgid "Control a browser from Java"
msgstr "通过 Java 代码控制浏览器"

#. Tag: para
#: chapter-testbench.xml:170
#, no-c-format
msgid "Generate component selectors in debug window"
msgstr "在调试窗口中生成组件选择器"

#. Tag: para
#: chapter-testbench.xml:173
#, no-c-format
msgid "Validate UI state by assertions and screen capture comparison"
msgstr "通过断言(assertion)和比较屏幕截图来检验 UI 状态"

#. Tag: para
#: chapter-testbench.xml:176
#, no-c-format
msgid "Screen capture comparison with difference highlighting"
msgstr "比较屏幕截图, 并将截图不同的部分高亮度显示"

#. Tag: para
#: chapter-testbench.xml:179
#, no-c-format
msgid "Distributed test grid for running tests"
msgstr "可用来运行测试的分布式测试网格"

#. Tag: para
#: chapter-testbench.xml:182
#, no-c-format
msgid "Integration with unit testing"
msgstr "与单元测试集成"

#. Tag: para
#: chapter-testbench.xml:185
#, no-c-format
msgid "Test with browsers on mobile devices"
msgstr "使用移动设备浏览器进行测试"

#. Tag: para
#: chapter-testbench.xml:189
#, no-c-format
msgid ""
"Execution of tests can be distributed over a grid of test nodes, which "
"speeds up testing. The grid nodes can run different operating systems and "
"have different browsers installed. In a minimal setup, such as for "
"developing the tests, you can use Vaadin TestBench on just a single computer."
msgstr ""
"测试的执行可以分散到多个测试节点组成的网格(grid)上, 这样可以加快测试速度. 网"
"格节点可以混行不同的操作系统, 安装不同的浏览器. 在最小安装环境中, 比如开发测"
"试程序的环境, 你可以在单台计算机上使用 Vaadin TestBench."

#. Tag: title
#: chapter-testbench.xml:199
#, no-c-format
msgid "Based on Selenium"
msgstr "基于 Selenium"

#. Tag: para
#: chapter-testbench.xml:201
#, no-c-format
msgid ""
"Vaadin TestBench is based on the Selenium web browser automation library, "
"especially Selenium WebDriver, which allows you to control browsers straight "
"from Java code."
msgstr ""
"Vaadin TestBench 基于 Selenium Web 浏览器自动化库, 尤其是其中的 Selenium "
"WebDriver, WebDriver 可以通过 Java 代码直接控制浏览器."

#. Tag: para
#: chapter-testbench.xml:207
#, no-c-format
msgid "Selenium is augmented with Vaadin-specific extensions, such as:"
msgstr "Vaadin TestBench 也通过 Vaadin 独有的扩展对 Selenium 进行了扩充, 比如:"

#. Tag: listitem
#: chapter-testbench.xml:212
#, no-c-format
msgid "Proper handling of Ajax-based communications of Vaadin"
msgstr "正确地处理 Vaadin 的基于 AJAX 的通信"

#. Tag: listitem
#: chapter-testbench.xml:213
#, no-c-format
msgid "A high-level, statically typed element query API for Vaadin components"
msgstr ""
"在高级编程模型中, 有一套静态类型的页面元素查询 API, 可用于选择 Vaadin 组件"

#. Tag: listitem
#: chapter-testbench.xml:214
#, no-c-format
msgid "Performance testing of Vaadin applications"
msgstr "Vaadin 应用程序的性能测试"

#. Tag: listitem
#: chapter-testbench.xml:215
#, no-c-format
msgid "Screen capture comparison"
msgstr "屏幕截图的比较"

#. Tag: listitem
#: chapter-testbench.xml:216
#, no-c-format
msgid "Finding HTML elements by a Vaadin selector"
msgstr "使用 Vaadin 选择器查找 HTML 元素"

#. Tag: title
#: chapter-testbench.xml:221
#, no-c-format
msgid "TestBench Components"
msgstr "TestBench 的组件"

#. Tag: para
#: chapter-testbench.xml:223
#, no-c-format
msgid ""
"The TestBench library includes WebDriver, which provides API to control a "
"browser like a user would. This API can be used to build tests, for example, "
"with JUnit. It also includes the grid hub and node servers, which you can "
"use to run tests in a grid configuration."
msgstr ""
"TestBench 库包含 WebDriver, 它提供了 API, 可以象使用者一样控制浏览器. 这些 "
"API 可以用来开发测试程序, 比如, 使用 JUnit 开发单元测试. 它还包括网格 hub 以"
"及节点服务器, 你可以使用它们来在网格环境中运行测试."

#. Tag: para
#: chapter-testbench.xml:230
#, no-c-format
msgid "Vaadin TestBench Library provides the central control logic for:"
msgstr "Vaadin TestBench 库还提供了重要的控制逻辑, 可以用来:"

#. Tag: para
#: chapter-testbench.xml:236
#, no-c-format
msgid "Executing tests with the WebDriver"
msgstr "使用 WebDriver 来运行测试"

#. Tag: para
#: chapter-testbench.xml:241
#, no-c-format
msgid "Additional support for testing Vaadin-based applications"
msgstr "针对测试 Vaadin 应用程序的额外支持"

#. Tag: para
#: chapter-testbench.xml:246
#, no-c-format
msgid "Comparing screen captures with reference images"
msgstr "将屏幕截图与参考图片进行比较"

#. Tag: para
#: chapter-testbench.xml:251
#, no-c-format
msgid "Distributed testing with grid node and hub services"
msgstr "使用网格节点和 hub 服务进行分布式测试"

#. Tag: title
#: chapter-testbench.xml:259
#, no-c-format
msgid "Requirements"
msgstr "需求"

#. Tag: para
#: chapter-testbench.xml:261
#, no-c-format
msgid "Requirements for developing and running tests are:"
msgstr "开发和运行测试程序, 需求如下:"

#. Tag: para
#: chapter-testbench.xml:267
#, no-c-format
msgid "Java JDK 1.6 or newer"
msgstr "Java JDK 1.6 或更高版本"

#. Tag: para
#: chapter-testbench.xml:270
#, no-c-format
msgid "Browsers installed on test nodes as supported by Selenium WebDriver"
msgstr "在测试节点上安装了 Selenium WebDriver 所支持的浏览器"

#. Tag: listitem
#: chapter-testbench.xml:272
#, no-c-format
msgid "<listitem>Google Chrome</listitem>"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:273
#, no-c-format
msgid "<listitem>Internet Explorer</listitem>"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:274
#, no-c-format
msgid "Mozilla Firefox (ESR version recommended)"
msgstr "Mozilla Firefox (推荐使用 ESR 版本)"

#. Tag: listitem
#: chapter-testbench.xml:275
#, no-c-format
msgid "Opera"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:276
#, no-c-format
msgid "Mobile browsers: Android, iPhone"
msgstr "移动设备浏览器: Android, iPhone"

#. Tag: para
#: chapter-testbench.xml:281
#, no-c-format
msgid ""
"A build system, such as Ant or Maven, to automate execution of tests during "
"build process (recommended)"
msgstr "一个构建系统, 比如 Ant 或 Maven, 以便在构建过程中自动化执行测试(推荐)"

#. Tag: para
#: chapter-testbench.xml:288
#, no-c-format
msgid ""
"Note that running tests on an Extended Support Release (ESR) version of "
"Firefox is recommended because of the frequent release cycle of Firefox, "
"which often cause tests to fail. Download an ESR release of Firefox from "
"<link xlink:href=\"http://www.mozilla.org/en-US/firefox/organizations/all."
"html\">http://www.mozilla.org/en-US/firefox/organizations/all.html</link>. "
"Install it alongside your normal Firefox install (do not overwrite)."
msgstr ""
"注意, 推荐在长期支持版(ESR, Extended Support Release)的 Firefox 上运行测试, "
"因为 Firefox 的发布非常频繁, 经常会导致测试失败. 可以在 <link xlink:href="
"\"http://www.mozilla.org/en-US/firefox/organizations/all.html\">http://www."
"mozilla.org/en-US/firefox/organizations/all.html</link> 下载 ESR 版本的 "
"Firefox. 请将 ESR 版与通常版 Firefox 同时安装(不要覆盖)."

#. Tag: para
#: chapter-testbench.xml:297
#, no-c-format
msgid ""
"For Mac OS X, note the issue mentioned in <xref linkend=\"testbench.known-"
"issues.firefox-mac\"/>."
msgstr ""
"对于 Mac OS X, 请注意这里提到的问题: <xref linkend=\"testbench.known-issues."
"firefox-mac\"/>."

#. Tag: title
#: chapter-testbench.xml:304
#, no-c-format
msgid "Continuous Integration Compatibility"
msgstr "与持续集成(Continuous Integration)的兼容"

#. Tag: para
#: chapter-testbench.xml:306
#, no-c-format
msgid ""
"Continuous integration means automatic compilation and testing of "
"applications frequently, typically at least daily, but ideally every time "
"when code changes are committed to the source repository. This practice "
"allows catching integration problems early and finding the changes that "
"first caused them to occur."
msgstr ""
"持续集成意味着对应用程序频繁地自动编译并自动测试, 通常至少一天一次, 理想状况"
"下, 应该在源代码变更被提交到代码库时立即执行. 这种方式可以更早地捕捉到集成问"
"题, 并找出最初导致这些问题的代码变更."

#. Tag: para
#: chapter-testbench.xml:314
#, no-c-format
msgid ""
"You can make unit tests with Vaadin TestBench just like you would do any "
"other Java unit tests, so they work seamlessly with continuous integration "
"systems. Vaadin TestBench is tested to work with at least TeamCity and "
"Hudson/Jenkins build management and continuous integration servers, which "
"all have special support for the JUnit unit testing framework."
msgstr ""
"你可以使用 Vaadin TestBench 来开发单元测试程序, 就像你使用任何其他的 Java 单"
"元测试一样, 因此这些单元测试程序可以与持续集成系统平滑地结合在一起. Vaadin "
"TestBench 已被测试过, 至少可以与 TeamCity 以及 Hudson/Jenkins 构建管理和持续"
"集成服务器共同工作, 这些工具都对 JUnit 单元测试框架有特殊的支持."

#. Tag: title
#: chapter-testbench.xml:323
#, no-c-format
msgid "Continuous Integration Workflow"
msgstr "持续集成(Continuous Integration)的工作流程"

#. Tag: para
#: chapter-testbench.xml:331
#, no-c-format
msgid ""
"illustrates a typical development setup. Both changes to application and "
"test sources are checked in into a source repository, from where the CIS "
"server checks them out, compiles, and deploys the web application to a "
"server. Then, it runs the tests and collects the results."
msgstr ""
"描述了一种典型的开发配置. 应用程序和测试程序的源代码变更都会被 check in 到源"
"代码仓库中, CIS 服务器再从源代码仓库 check out 这些源代码, 编译, 并将 Web 应"
"用程序发布到服务器上. 然后, 它会运行测试程序, 并收集测试结果."

#. Tag: title
#: chapter-testbench.xml:341
#, no-c-format
msgid "Licensing and Trial Period"
msgstr "许可协议以及试用期限"

#. Tag: para
#: chapter-testbench.xml:343
#, no-c-format
msgid ""
"You can download Vaadin TestBench from Vaadin Directory and try it out for a "
"free 30-day trial period, after which you are required to acquire the needed "
"licenses. You can purchase licenses from the Directory. A license for Vaadin "
"TestBench is also included in the Vaadin Pro Account subscription."
msgstr ""
"你可以从 Vaadin Directory 下载 Vaadin TestBench, 并免费试用 30 天, 试用期结束"
"后你需要购买许可. 你可以通过 Vaadin Directory 购买许可. 在 Vaadin Pro 订阅帐"
"号内也包含了 Vaadin TestBench 的许可."

#. Tag: title
#: chapter-testbench.xml:354
#, no-c-format
msgid "Quick Start"
msgstr "快速入门"

#. Tag: para
#: chapter-testbench.xml:356
#, no-c-format
msgid ""
"In the following, we give instructions for getting Vaadin TestBench running "
"in minutes. You can create either a new Eclipse project or a Maven project. "
"Both project types require installing a license key, so we cover that first."
msgstr ""
"下面我们来介绍如何在几分钟之内让 Vaadin TestBench 运行起来. 你可以创建一个新"
"的 Eclipse 工程, 或一个 Maven 工程. 这两种工程类型都需要安装 license key, 所"
"以我们首先来介绍 license key 的安装."

#. Tag: title
#: chapter-testbench.xml:363
#, no-c-format
msgid "Installing License Key"
msgstr "安装 License Key"

#. Tag: para
#: chapter-testbench.xml:365
#, no-c-format
msgid ""
"Before running tests, you need to install a license key. You can purchase "
"Vaadin TestBench or obtain a free trial key from the <link xlink:href="
"\"https://vaadin.com/directory#addon/vaadin-testbench\">Vaadin TestBench "
"download page</link> in Vaadin Directory. You need to register in Vaadin "
"Directory to obtain the key."
msgstr ""
"你需要安装 license key 才能够运行测试程序. 你可以购买 Vaadin TestBench, 也可"
"以从 Vaadin Directory 的 <link xlink:href=\"https://vaadin.com/"
"directory#addon/vaadin-testbench\">Vaadin TestBench 下载页面</link> 得到一个"
"免费试用的 key. 你需要在 Vaadin Directory 中注册才能得到 key."

#. Tag: title
#: chapter-testbench.xml:374
#, no-c-format
msgid "Obtaining License Key from Vaadin Directory"
msgstr "通过 Vaadin Directory 得到 License Key"

#. Tag: para
#: chapter-testbench.xml:382
#, no-c-format
msgid ""
"To install the license key on a development workstation, you can copy and "
"paste it verbatim to a <filename>.vaadin.testbench.developer.license</"
"filename> file in your home directory. For example, in Linux and OS&nbsp;X:"
msgstr ""
"要将 license key 安装到开发工作站上, 你可以将 license key 的文字内容复制并粘"
"贴到你的 home 目录下的 <filename>.vaadin.testbench.developer.license</"
"filename> 文件中. 比如, 在 Linux 和 OS&nbsp;X 环境中:"

#. Tag: screen
#: chapter-testbench.xml:389
#, no-c-format
msgid ""
"<?pocket-size 75% ?><prompt>$</prompt> <command>echo</command> "
"\"<replaceable>L1cen5e-c0de</replaceable>\" > <parameter>~/.vaadin.testbench."
"developer.license</parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:391
#, no-c-format
msgid ""
"You can also pass the key as a system property to the Java application "
"running the tests, usually with a <literal>-D</literal> option on the "
"command-line:"
msgstr ""
"你也可以将 license key 通过系统属性传递给运行测试的 Java 应用程序, 通常可以在"
"命令行中使用 <literal>-D</literal> 选项:"

#. Tag: screen
#: chapter-testbench.xml:397
#, no-c-format
msgid ""
"<?pocket-size 75% ?><prompt>$</prompt> <command>java</command> -"
"D<parameter>vaadin.testbench.developer.license</"
"parameter>=<replaceable>L1cen5e-c0de</replaceable> ..."
msgstr ""

#. Tag: para
#: chapter-testbench.xml:399
#, no-c-format
msgid ""
"How you actually pass the parameter to your test runner depends on the "
"actual test execution environment. Below are listed a few typical "
"environments:"
msgstr ""
"如何将参数传递给你的测试程序的运行器, 取决于实际的测试执行环境. 以下列举了一"
"些典型的环境:"

#. Tag: term
#: chapter-testbench.xml:407
#, no-c-format
msgid "Eclipse IDE"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:409
#, no-c-format
msgid ""
"To install the license key for all projects, select "
"<menuchoice><guimenu>Window</guimenu><guimenuitem>Preferences</guimenuitem></"
"menuchoice> and navigate to the <menuchoice><guimenu>Java</"
"guimenu><guimenuitem>Installed JREs</guimenuitem></menuchoice> section. "
"Select the JRE version that you use for the application and click "
"<guibutton>Edit</guibutton>. In the <guilabel>Default VM arguments</"
"guilabel>, give the <parameter>-D</parameter> expression as shown above."
msgstr ""
"要为所有的工程安装 license key, 请选择菜单项 <menuchoice><guimenu>Window</"
"guimenu><guimenuitem>Preferences</guimenuitem></menuchoice>, 然后找到 "
"<menuchoice><guimenu>Java</guimenu><guimenuitem>Installed JREs</"
"guimenuitem></menuchoice> 部分. 选择你的应用程序所使用的 JRE 版本, 然后点击 "
"<guibutton>Edit</guibutton>. 在 <guilabel>Default VM arguments</guilabel> 项"
"目中, 指定上面介绍的 <parameter>-D</parameter> 表达式."

#. Tag: para
#: chapter-testbench.xml:421
#, no-c-format
msgid ""
"For a single project, create a new JUnit launch configuration in "
"<menuchoice><guimenu>Run</guimenu><guimenuitem>Run configurations</"
"guimenuitem></menuchoice>. Select <guilabel>JUnit</guilabel> and click "
"<guibutton>New launch configuration</guibutton>. If you have already ran "
"JUnit in the project, the launch configuration already exists. Select JUnit "
"4 if not selected automatically. Go to <guilabel>Arguments</guilabel> tab "
"and give the <parameter>-D</parameter> expression in the <guilabel>VM "
"arguments</guilabel> field. Click <guibutton>Run</guibutton> to run the "
"tests immediately or <guibutton>Close</guibutton> to just save the settings."
msgstr ""
"对于单个工程, 可以创建一个新的 JUnit 启动配置, 方法是选择菜单 "
"<menuchoice><guimenu>Run</guimenu><guimenuitem>Run configurations</"
"guimenuitem></menuchoice>. 选择 <guilabel>JUnit</guilabel>, 然后点击 "
"<guibutton>New launch configuration</guibutton>. 如果你已经在这个工程内运行"
"过 JUnit, 那么启动配置应该已经存在. 如果没有自动选中 JUnit 4 的话, 请选择它. "
"进入 <guilabel>Arguments</guilabel> tab 页, 并在 <guilabel>VM arguments</"
"guilabel> 项目中指定 <parameter>-D</parameter> 表达式. 点击 <guibutton>Run</"
"guibutton> 可以立即运行测试程序, 也可以点击 <guibutton>Close</guibutton>, 只"
"保存相关设定."

#. Tag: term
#: chapter-testbench.xml:439
#, no-c-format
msgid "Apache Ant"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:441
#, no-c-format
msgid ""
"If running tests with the <literal>&lt;junit&gt;</literal> task in Apache "
"Ant, as described in <xref linkend=\"testbench.execution.ant\"/>, you can "
"pass the key as follows:"
msgstr ""
"如果使用 Apache Ant 中的 <literal>&lt;junit&gt;</literal> task 来运行测试, "
"(详情请参见 <xref linkend=\"testbench.execution.ant\"/>), 你可以使用以下方法"
"来传递 license key:"

#. Tag: programlisting
#: chapter-testbench.xml:448
#, no-c-format
msgid ""
"<?pocket-size 70% ?>&lt;sysproperty key=\"vaadin.testbench.developer.license"
"\"\n"
"             value=\"<emphasis role=\"bold\">L1cen5e-c0de</emphasis>\"/&gt;"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:450
#, no-c-format
msgid ""
"However, you should never store license keys in a source repository, so if "
"the Ant script is stored in a source repository, you should pass the license "
"key to Ant as a property that you then use in the script for the value "
"argument of the <literal>&lt;sysproperty&gt;</literal> as follows:"
msgstr ""
"但是, 你不应该将 license key 保存到源代码仓库中, 因此, 如果 Ant 脚本被保存在"
"源代码仓库中, 那么你应该以属性的形式将 license key 传递给 Ant, 然后在 Ant 脚"
"本中 <literal>&lt;sysproperty&gt;</literal> 的 value 参数中使用这个属性, 如"
"下:"

#. Tag: programlisting
#: chapter-testbench.xml:459
#, no-c-format
msgid ""
"<?pocket-size 70% ?>&lt;sysproperty key=\"vaadin.testbench.developer.license"
"\"\n"
"    value=\"<emphasis role=\"bold\">${vaadin.testbench.developer.license}</"
"emphasis>\"/&gt;"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:461
#, no-c-format
msgid ""
"When invoking Ant from the command-line, you can pass the property with a "
"<parameter>-D</parameter> parameter to Ant."
msgstr ""
"从命令行启动 Ant 时, 你可以使用 <parameter>-D</parameter> 参数来向 Ant 传递属"
"性."

#. Tag: term
#: chapter-testbench.xml:469
#, no-c-format
msgid "Apache Maven"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:471
#, no-c-format
msgid ""
"If running tests with Apache Maven, you can pass the license key with a "
"<literal>-D</literal> parameter to Maven:"
msgstr ""
"如果使用 Apache Maven 来运行测试, 你可以使用 <literal>-D</literal> 参数来向 "
"Maven 传递 license key:"

#. Tag: screen
#: chapter-testbench.xml:476
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>mvn</command> -D<parameter>vaadin.testbench."
"developer.license</parameter>=<replaceable>L1cen5e-c0de</replaceable> verify"
msgstr ""

#. Tag: term
#: chapter-testbench.xml:481
#, no-c-format
msgid "TeamCity"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:483
#, no-c-format
msgid ""
"In TeamCity, you can pass the license key to build runners as a system "
"property in the build configuration. However, this only passes it to a "
"runner. As described above, Maven passes the parameter as is to JUnit, but "
"Ant does not do so implicitly, so you need to forward it explicitly as "
"described earlier."
msgstr ""
"在 TeamCity 中, 你可以在构建配置中, 以系统属性的方式将 license key 传递给构建"
"运行器. 但是, 这种方式只将它传递给运行器. 上面我们介绍过, Maven 还会将参数再"
"传递给 JUnit, 但 Ant 不会默认地这样做, 因此你需要象前文中介绍过那样, 明确地转"
"发这个参数."

#. Tag: para
#: chapter-testbench.xml:495
#, no-c-format
msgid ""
"See <link xlink:href=\"https://vaadin.com/directory/help/installing-cval-"
"license\">the AGPL license key installation instructions</link> for more "
"details."
msgstr ""
"更多详细信息请参见 <link xlink:href=\"https://vaadin.com/directory/help/"
"installing-cval-license\">AGPL license key 安装指南</link>."

#. Tag: title
#: chapter-testbench.xml:503
#, no-c-format
msgid "Quick Start with Eclipse"
msgstr "Eclipse 环境下的快速入门"

#. Tag: para
#: chapter-testbench.xml:505
#, no-c-format
msgid ""
"Once you have installed the Vaadin Plugin for Eclipse, you can use it to "
"create a new Vaadin 7 project with the TestBench test enabled, as described "
"in <xref linkend=\"getting-started.first-project.creation\"/>. In the "
"project settings, you need to have the <guilabel>Create TestBench test</"
"guilabel> setting enabled."
msgstr ""
"安装 Vaadin Plugin for Eclipse 之后, 你可以使用它来创建新的 Vaadin 7 工程, 并"
"激活 TestBench 测试功能, 详情请参见 <xref linkend=\"getting-started.first-"
"project.creation\"/>. 在工程设置中, 你需要让 <guilabel>Create TestBench "
"test</guilabel> 选项激活."

#. Tag: para
#: chapter-testbench.xml:513
#, no-c-format
msgid ""
"The test case stub is created under <filename>test</filename> source folder, "
"so that it will not be deployed with the application. The project and source "
"folders are illustrated in <xref linkend=\"figure.testbench.quickstart."
"eclipse-project\" xrefstyle=\"select:labelnumber\"/>."
msgstr ""
"测试用例的框架代码创建在源代码文件夹 <filename>test</filename> 之下, 因此这些"
"测试代码不会随应用程序一起发布. 工程和源代码文件夹的构成请参见 <xref linkend="
"\"figure.testbench.quickstart.eclipse-project\" xrefstyle=\"select:"
"labelnumber\"/>."

#. Tag: title
#: chapter-testbench.xml:522
#, no-c-format
msgid "Eclipse Project with a Test Case"
msgstr "带 Test Case 的 Eclipse 工程"

#. Tag: para
#: chapter-testbench.xml:530
#, no-c-format
msgid ""
"You can observe that the UI and the test case are much like in the "
"illustration in <xref linkend=\"figure.testbench.webdriver\"/>. The "
"resulting test case stub is described in detail in <xref linkend=\"testbench."
"development.basic\"/>."
msgstr ""
"你可以看到, UI 及测试用例与 <xref linkend=\"figure.testbench.webdriver\"/> 非"
"常类似. 生成的测试用例框架代码的细节, 请参见 <xref linkend=\"testbench."
"development.basic\"/>."

#. Tag: para
#: chapter-testbench.xml:537
#, no-c-format
msgid ""
"To run the test, open the <filename>MyprojectTest.java</filename> file in "
"the editor and press <keycombo action=\"press\"><keycombo><keycap>Shift</"
"keycap><keycap>Alt</keycap><keycap>X</keycap></keycombo><keycap>T</keycap></"
"keycombo>. The browser should open with the application UI and TestBench run "
"the tests. The results are displayed in the <guilabel>JUnit</guilabel> view "
"in Eclipse, as shown in <xref linkend=\"figure.testbench.quickstart.eclipse-"
"junit\"/>."
msgstr ""
"要运行测试, 请在编辑器中打开 <filename>MyprojectTest.java</filename> 文件, 然"
"后按下快捷键 <keycombo action=\"press\"><keycombo><keycap>Shift</"
"keycap><keycap>Alt</keycap><keycap>X</keycap></keycombo><keycap>T</keycap></"
"keycombo>. 浏览器将打开应用程序 UI, 然后 TestBench 将会运行测试. 测试的运行结"
"果将显示在 Eclipse 的<guilabel>JUnit</guilabel> 视图中, 见 <xref linkend="
"\"figure.testbench.quickstart.eclipse-junit\"/>."

#. Tag: title
#: chapter-testbench.xml:548
#, no-c-format
msgid "JUnit Test Results in Eclipse"
msgstr "Eclipse 中的 JUnit 测试结果"

#. Tag: title
#: chapter-testbench.xml:558
#, no-c-format
msgid "Quick Start with Maven"
msgstr "使用 Maven 的快速入门"

#. Tag: para
#: chapter-testbench.xml:560
#, no-c-format
msgid ""
"With Maven, you need to create a new Vaadin project with the <literal>vaadin-"
"archetype-application</literal> archetype, as described in <xref linkend="
"\"getting-started.maven\"/>."
msgstr ""
"使用 Maven, 你需要使用 <literal>vaadin-archetype-application</literal> "
"archetype 来创建新的 Vaadin 工程, 详情请参见 <xref linkend=\"getting-started."
"maven\"/>."

#. Tag: para
#: chapter-testbench.xml:566
#, no-c-format
msgid ""
"The <filename>src</filename> folder under the project contains both the "
"sources for the application and the tests. The test case stub in the "
"<filename>src/test</filename> folder is described in detail in <xref linkend="
"\"testbench.development.basic\"/>."
msgstr ""
"工程中的 <filename>src</filename> 文件夹包含了应用程序源代码, 以及测试程序的"
"源代码. 测试用例的框架代码在 <filename>src/test</filename> 文件夹下, 详情请参"
"见 <xref linkend=\"testbench.development.basic\"/>."

#. Tag: para
#: chapter-testbench.xml:573
#, no-c-format
msgid ""
"The license needs to be installed or given as parameter for the following "
"command, as mentioned earlier. Build the project with the "
"<literal>integration-test</literal> or a later phase in the build lifecycle. "
"For example, from the command-line:"
msgstr ""
"需要安装 license, 或者对以下命令, 以参数的方式指定 license, 方法见上文的介"
"绍. 要构建工程, 可以使用 <literal>integration-test</literal>, 或者使用构建周"
"期(build lifecycle)中更晚一些的阶段(phase). 比如, 可以通过命令行:"

#. Tag: screen
#: chapter-testbench.xml:580
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>mvn</command> <parameter>integration-test</"
"parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:582
#, no-c-format
msgid ""
"This will execute all required lifecycle phases, including compilation and "
"packaging the application, launch Jetty web server to host the application, "
"and run the TestBench tests. Results are reported on the console. A Maven "
"GUI, such as the one in Eclipse, will provide more visual results."
msgstr ""
"这个命令将会执行所有需要的所有其他阶段, 包括编译, 打包应用程序, 启动 Jetty "
"Web 服务器来运行应用程序, 以及运行 TestBench 测试程序. 测试结果报告将输出到控"
"制台. Maven GUI, 比如 Eclipse 中的 Maven 插件, 会以更加可视化的方式显示测试结"
"果."

#. Tag: title
#: chapter-testbench.xml:593
#, no-c-format
msgid "Installing Vaadin TestBench"
msgstr "安装 Vaadin TestBench"

#. Tag: para
#: chapter-testbench.xml:595
#, no-c-format
msgid ""
"As with most Vaadin add-ons, you can install Vaadin TestBench as a Maven or "
"Ivy dependency in your project, or from an installation package. The "
"installation package contains some extra material, such as documentation, as "
"well as the standalone library, which you use for testing in a grid."
msgstr ""
"和大多数 Vaadin add-on 一样, 你可以在你的项目中以 Maven 或 Ivy 依赖项目的形式"
"安装 Vaadin TestBench, 或者使用安装包来安装. 安装包包含一些额外的内容, 比如文"
"档, 以及独立的库文件, 你可以在网格环境的测试程序中使用这些库文件."

#. Tag: para
#: chapter-testbench.xml:602
#, no-c-format
msgid ""
"The component element classes are Vaadin version specific and they are "
"packaged in a <filename>vaadin-testbench-api</filename> library JAR, "
"separately from the <filename>vaadin-testbench-core</filename> runtime "
"library, which is needed for executing the tests."
msgstr ""
"组件元素类是 Vaadin 独有的, 这些类打包在名为 <filename>vaadin-testbench-api</"
"filename> 的 JAR 库文件中, 与执行测试时需要的运行库 <filename>vaadin-"
"testbench-core</filename> 分离."

#. Tag: para
#: chapter-testbench.xml:609
#, no-c-format
msgid ""
"Additionally, you may need to install drivers for the browsers you are using."
msgstr "此外, 你可能需要为你使用的浏览器安装驱动程序."

#. Tag: title
#: chapter-testbench.xml:614
#, no-c-format
msgid "Test Development Setup"
msgstr "测试程序开发环境"

#. Tag: para
#: chapter-testbench.xml:616
#, no-c-format
msgid ""
"In a typical test development setup, you develop tests in a Java project and "
"run them on the development workstation. You can run the same tests in a "
"dedicated test server, such as a continuous integration system."
msgstr ""
"在通常的测试程序开发环境中, 你会在 Java 工程内开发测试程序, 并在开发工作站上"
"运行这些测试. 你可以在一个专用的测试服务器上运行同样的测试程序, 比如在持续集"
"成系统内."

#. Tag: para
#: chapter-testbench.xml:622
#, no-c-format
msgid ""
"In a test development setup, you do not need a grid hub or nodes. However, "
"if you develop tests for a grid, you can run the tests, the grid hub, and "
"one node all in your development workstation. A distributed setup is "
"described later."
msgstr ""
"在测试程序开发环境中, 你不需要网格 hub 和节点. 但是, 如果你正在为网格环境开发"
"测试程序, 你可以将测试程序, 网格 hub, 以及一个测试节点, 全部运行在你的开发工"
"作站上. 关于分布式测试环境, 将在后文中介绍."

#. Tag: title
#: chapter-testbench.xml:630
#, no-c-format
msgid "Maven Dependency"
msgstr "Maven 依赖项目"

#. Tag: para
#: chapter-testbench.xml:632
#, no-c-format
msgid "The Maven dependency for Vaadin TestBench is as follows:"
msgstr "Vaadin TestBench 的 Maven 依赖项目如下:"

#. Tag: programlisting
#: chapter-testbench.xml:637
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;dependency&gt;\n"
"    &lt;groupId&gt;com.vaadin&lt;/groupId&gt;\n"
"    &lt;artifactId&gt;vaadin-testbench&lt;/artifactId&gt;\n"
"    &lt;version&gt;<replaceable>&version.testbench;</replaceable>&lt;/"
"version&gt;\n"
"    &lt;scope&gt;test&lt;/scope&gt;\n"
"&lt;/dependency&gt;"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:639
#, no-c-format
msgid ""
"You also need to define the Vaadin add-ons repository if not already defined:"
msgstr "如果没有定义过 Vaadin add-on 的仓库, 你还需要定义它:"

#. Tag: programlisting
#: chapter-testbench.xml:644
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<repository>\n"
"   <id>vaadin-addons</id>\n"
"   <url>http://maven.vaadin.com/vaadin-addons</url>\n"
"</repository>]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:646
#, no-c-format
msgid ""
"The <literal>vaadin-archetype-application</literal> archetype, as mentioned "
"in <xref linkend=\"testbench.quickstart.maven\"/>, includes the declarations."
msgstr ""
"<literal>vaadin-archetype-application</literal> archetype (参见 <xref "
"linkend=\"testbench.quickstart.maven\"/>), 包括了这些声明."

#. Tag: title
#: chapter-testbench.xml:654
#, no-c-format
msgid "Ivy Dependency"
msgstr "Ivy 依赖项目"

#. Tag: para
#: chapter-testbench.xml:656
#, no-c-format
msgid ""
"The Ivy dependency, to be defined in <filename>ivy.xml</filename>, would be "
"as follows:"
msgstr ""
"Ivy 依赖项目, 定义在 <filename>ivy.xml</filename> 文件中, 内容应该如下:"

#. Tag: programlisting
#: chapter-testbench.xml:661
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;dependency org=\"com.vaadin\" name=\"vaadin-"
"testbench-api\"\n"
"   rev=\"<emphasis role=\"bold\">latest.release</emphasis>\" conf=\"nodeploy-"
"&gt;default\"/&gt;"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:663
#, no-c-format
msgid ""
"The optional <literal>nodeploy-&gt;default</literal> configuration mapping "
"requires a <literal>nodeploy</literal> configuration in the Ivy module; it "
"is automatically created for new Vaadin projects."
msgstr ""
"<literal>nodeploy-&gt;default</literal> 是一个可选的配置, 它需要 Ivy 模块中"
"的 <literal>nodeploy</literal> 配置; 新建 Vaadin 工程时会自动创建这个配置."

#. Tag: para
#: chapter-testbench.xml:669
#, no-c-format
msgid ""
"A new Vaadin project created with the Vaadin Plugin for Eclipse, as "
"described in <xref linkend=\"testbench.quickstart.eclipse\"/>, includes the "
"dependency."
msgstr ""
"使用 Vaadin Plugin for Eclipse 新建的 Vaadin 工程 (<xref linkend=\"testbench."
"quickstart.eclipse\"/>), 将会包含这些依赖项目."

#. Tag: title
#: chapter-testbench.xml:677
#, no-c-format
msgid "Code Organization"
msgstr "代码组织方式"

#. Tag: para
#: chapter-testbench.xml:679
#, no-c-format
msgid ""
"We generally recommend developing tests in a project or module separate from "
"the web application to be tested to avoid library problems. If the tests are "
"part of the same project, you should at least arrange the source code and "
"dependencies so that the test classes, the TestBench library, and their "
"dependencies would not be deployed unnecessarily with the web application."
msgstr ""
"我们通常建议将测试程序放在独立的工程或模块中, 与被测试的 Web 应用程序分离开, "
"以避免库版本问题. 如果测试程序是被测项目的一部分, 你至少应该管理好源代码和依"
"赖项目, 使得测试类, TestBench 库, 以及它们的依赖项目不会随 Web 应用程序一起发"
"布出去."

#. Tag: title
#: chapter-testbench.xml:691
#, no-c-format
msgid "A Distributed Testing Environment"
msgstr "分布式测试环境"

#. Tag: para
#: chapter-testbench.xml:693
#, no-c-format
msgid ""
"Vaadin TestBench supports distributed execution of tests in a grid. A test "
"grid consists of the following categories of hosts:"
msgstr ""
"Vaadin TestBench 支持在网格内分布式执行测试程序. 一个测试网格包括以下几种主机"
"类别:"

#. Tag: para
#: chapter-testbench.xml:700
#, no-c-format
msgid "One or more test servers executing the tests"
msgstr "一个或多个测试服务器, 负责运行测试程序"

#. Tag: para
#: chapter-testbench.xml:703
#, no-c-format
msgid "A grid hub"
msgstr "一个网格 hub"

#. Tag: para
#: chapter-testbench.xml:706
#, no-c-format
msgid "Grid nodes"
msgstr "网格节点"

#. Tag: para
#: chapter-testbench.xml:710
#, no-c-format
msgid ""
"The components of a grid setup are illustrated in <xref linkend=\"figure."
"testbench.architecture\"/>."
msgstr ""
"网格环境中的各种组件, 见 <xref linkend=\"figure.testbench.architecture\"/>."

#. Tag: title
#: chapter-testbench.xml:716
#, no-c-format
msgid "Vaadin TestBench Grid Setup"
msgstr "Vaadin TestBench 网格环境"

#. Tag: para
#: chapter-testbench.xml:727
#, no-c-format
msgid ""
"The grid hub is a service that handles communication between the JUnit test "
"runner and the nodes. The nodes are services that perform the actual "
"execution of test commands in the browser."
msgstr ""
"网格 hub 是一个服务, 它负责处理 JUnit 测试运行器与测试节点之间的通信. 测试节"
"点也是服务, 它负责在浏览器内执行实际的测试命令."

#. Tag: para
#: chapter-testbench.xml:733
#, no-c-format
msgid ""
"The hub requires very little resources, so you would typically run it either "
"in the test server or on one of the nodes. You can run the tests, the hub, "
"and one node all in one host, but in a fully distributed setup, you install "
"the Vaadin TestBench components on separate hosts."
msgstr ""
"hub 只需要极少的资源, 因此通常可以将它运行在测试服务器上, 或者运行在某一个测"
"试节点上. 你可以在同一台主机上同时运行测试程序, hub, 以及一个测试节点, 但在完"
"整的分布式测试环境中, 应该将 Vaadin TestBench 组件安装在不同的主机上."

#. Tag: para
#: chapter-testbench.xml:740
#, no-c-format
msgid ""
"Controlling browsers over a distributed setup requires using a remote "
"WebDriver. Grid development and use of the hub and nodes is described in "
"<xref linkend=\"testbench.grid\"/>."
msgstr ""
"通过分布式测试环境来控制浏览器, 需要使用远程 WebDriver. 关于测试网格的开发, "
"以及 hub 和测试节点的使用, 详情请参见 <xref linkend=\"testbench.grid\"/>."

#. Tag: title
#: chapter-testbench.xml:748
#, no-c-format
msgid "Installation Package Contents"
msgstr "安装包的内容"

#. Tag: para
#: chapter-testbench.xml:750
#, no-c-format
msgid "The installation package contains the following:"
msgstr "安装包中包含以下内容:"

#. Tag: filename
#: chapter-testbench.xml:756
#, no-c-format
msgid "documentation"
msgstr "文档"

#. Tag: para
#: chapter-testbench.xml:758
#, no-c-format
msgid ""
"The documentation folder contains release notes, a PDF excerpt of this "
"chapter of Book of Vaadin, and the license."
msgstr "documentation 文件夹包含发布说明文件, 本章的 PDF 摘录版, 以及 license."

#. Tag: filename
#: chapter-testbench.xml:765
#, no-c-format
msgid "maven"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:767
#, no-c-format
msgid ""
"The Maven folder contains the Vaadin TestBench library JARs (you can use "
"them in non-Maven projects as well). The folder contains a POM file, so that "
"you can install it in your local Maven repository. Please follow the "
"instructions in <xref linkend=\"testbench.execution.maven\"/>."
msgstr ""
"Maven 文件夹包含 Vaadin TestBench 库的 JAR 文件 (你也可以在非 Maven 工程中使"
"用这些 JAR 文件). 这个文件夹还包含一个 POM 文件, 因此你可以将它安装到你的本"
"地 Maven 仓库. 请参照 <xref linkend=\"testbench.execution.maven\"/> 中的安装"
"指南."

#. Tag: filename
#: chapter-testbench.xml:777
#, no-c-format
msgid "vaadin-testbench-standalone-&version.testbench;.jar"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:779
#, no-c-format
msgid ""
"This is a standalone version of the Vaadin TestBench library that is mainly "
"used for running the grid hub and node services, as described in <xref "
"linkend=\"testbench.grid\"/>."
msgstr ""
"这是 Vaadin TestBench 库的 standalone 版本, 主要用于运行网格 hub 及节点服务, "
"详情请参见 <xref linkend=\"testbench.grid\"/>."

#. Tag: title
#: chapter-testbench.xml:790
#, no-c-format
msgid "TestBench Demo"
msgstr "TestBench 示例程序"

#. Tag: para
#: chapter-testbench.xml:792
#, no-c-format
msgid ""
"A TestBench demo is available at <link xlink:href=\"https://github.com/"
"vaadin/testbench-demo\">https://github.com/vaadin/testbench-demo</link>. You "
"can browse the sources at the website and clone the repository with a Git "
"client; from command line with:"
msgstr ""
"TestBench 示例程序地址是: <link xlink:href=\"https://github.com/vaadin/"
"testbench-demo\">https://github.com/vaadin/testbench-demo</link>. 你可以在这"
"个网站上查看源代码, 也可以使用 Git 客户端将代码仓库 clone 到本地; 在命令行中"
"执行以下命令:"

#. Tag: screen
#: chapter-testbench.xml:799
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>git</command> clone <parameter>https://github."
"com/vaadin/testbench-demo</parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:801
#, no-c-format
msgid ""
"The tests can be run from the command line by issuing the following command:"
msgstr "在命令行中运行以下命令, 可以执行测试程序:"

#. Tag: screen
#: chapter-testbench.xml:806
#, no-c-format
msgid "<prompt>$</prompt> <command>mvn</command> verify"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:808
#, no-c-format
msgid ""
"The source code for the application to be tested, a desktop calculator "
"application, is given in the <filename>src/main/java</filename> subfolder."
msgstr ""
"被测应用程序是一个桌面计算器程序, 源代码位于 <filename>src/main/java</"
"filename> 文件夹下."

#. Tag: para
#: chapter-testbench.xml:813
#, no-c-format
msgid ""
"The TestBench tests for the application are located under the <filename>src/"
"test/java</filename> subfolder, in the <filename>com/vaadin/"
"testbenchexample</filename> package subfolder. They are as follows:"
msgstr ""
"针对这个应用程序的 TestBench 测试程序位于 <filename>src/test/java</filename> "
"目录下, Java 包目录为 <filename>com/vaadin/testbenchexample</filename>. 其中"
"包含以下代码:"

#. Tag: link
#: chapter-testbench.xml:822
#, no-c-format
msgid "SimpleCalculatorITCase.java"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:824
#, no-c-format
msgid ""
"Demonstrates the basic use of WebDriver. Interacts with the buttons in the "
"user interface by clicking them and checks the resulting value. Uses the "
"ElementQuery API to access the elements."
msgstr ""
"演示了 WebDriver 的基本使用. 与 UI 中的按钮交互, 点击按钮, 然后检查运行结果中"
"的值. 使用 ElementQuery API 来访问页面元素."

#. Tag: filename
#: chapter-testbench.xml:833
#, no-c-format
msgid "LoopingCalculatorITCase.java"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:835
#, no-c-format
msgid ""
"Otherwise as the simple example, but shows how to use looping to produce "
"programmatic repetition to create a complex use case."
msgstr ""
"另一个简单示例, 演示了如何使用循环来产生程序化的循环, 创建一个复杂的用例(use "
"case)."

#. Tag: filename
#: chapter-testbench.xml:843
#, no-c-format
msgid "ScreenshotITCase.java"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:845
#, no-c-format
msgid ""
"Shows how to compare screenshots, as described in <xref linkend=\"testbench."
"screenshot.comparison\"/>. Some of the test cases include random input, so "
"they require masked screenshot comparison to mask the random areas out."
msgstr ""
"演示如何比较屏幕截图, 详情请参见 <xref linkend=\"testbench.screenshot."
"comparison\"/>. 有些测试用例包含了随机的输入, 因此屏幕截图比较时需要排除随机"
"数据区域."

#. Tag: para
#: chapter-testbench.xml:852
#, no-c-format
msgid ""
"The example is ignored by default with an <literal>@Ignore</literal> "
"annotation, because the included images were taken with a specific browser "
"on a specific platform, so if you use another environment, they will fail. "
"If you enable the test, you will need to run the tests, copy the error "
"images to the reference screenshot folder, and mask out the areas with the "
"alpha channel. Please see the <filename>example/Screenshot_Comparison_Tests."
"pdf</filename> for details about how to enable the example and how to create "
"the masked reference images."
msgstr ""
"这个示例使用了 <literal>@Ignore</literal> 注解, 默认会被忽略, 因为其中包含的"
"图片是从一个特性平台的特定浏览器中截取的, 因此如果你使用的是其他环境, 测试将"
"会失败. 如果你启用这些测试程序, 你需要运行它, 将出错图片复制到参照屏幕截图的"
"文件夹中, 并使用 alpha 通道将错误区域遮蔽掉. 关于如何启用这些示例测试程序, 以"
"及如何创建被遮蔽的参照图片, 详情请参见 <filename>example/"
"Screenshot_Comparison_Tests.pdf</filename>."

#. Tag: filename
#: chapter-testbench.xml:867
#, no-c-format
msgid "SelectorExamplesITCase.java"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:869
#, no-c-format
msgid ""
"This example shows how to find elements in different ways; by using the high-"
"level ElementQuery API as well as low-level <methodname>By.xpath()</"
"methodname> selectors."
msgstr ""
"这个示例演示如何使用不同的方式查找元素; 可以使用高级的 ElementQuery API, 也可"
"以使用低级的 <methodname>By.xpath()</methodname> 选择器."

#. Tag: filename
#: chapter-testbench.xml:877
#, no-c-format
msgid "VerifyExecutionTimeITCase.java"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:879
#, no-c-format
msgid "Shows how to time the execution of a test case and how to report it."
msgstr "演示如何对一个测试用例计时, 以及如何报告计时结果."

#. Tag: filename
#: chapter-testbench.xml:886
#, no-c-format
msgid "AdvancedCommandsITCase.java"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:888
#, no-c-format
msgid ""
"Demonstrates how to test context menus (see <xref linkend=\"testbench."
"special.contextmenu\"/>) and tooltips (see <xref linkend=\"testbench.special."
"tooltip\"/>). Also shows how to send keypresses to a component and how to "
"read values of table cells."
msgstr ""
"演示如何测试上下文菜单(参见 <xref linkend=\"testbench.special.contextmenu\"/"
">)和提示信息(tooltip) (参见 <xref linkend=\"testbench.special.tooltip\"/>). "
"还演示了如何向组件发送键盘按键, 以及如何读取表格中的值."

#. Tag: filename
#: chapter-testbench.xml:898
#, no-c-format
msgid "pageobjectexample/PageObjectExampleITCase.java"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:900
#, no-c-format
msgid ""
"Shows how to create maintanable tests using the <emphasis>Page Object "
"Pattern</emphasis> that separates the low-level page structure from the "
"business logic, as described in <xref linkend=\"testbench.maintainable\"/>. "
"The page object classes that handle low-level interaction with the "
"application views are in the <filename>pageobjects</filename> subpackage."
msgstr ""
"演示如何使用 <emphasis>页面对象模式(Page Object Pattern)</emphasis> 创建可维"
"护的测试程序, 这种模式将低层页面结构与业务逻辑代码分离开, 详情请参见 <xref "
"linkend=\"testbench.maintainable\"/>. 页面对象类处理与应用程序视图的低层交"
"互, 位于 <filename>pageobjects</filename> 包内."

#. Tag: term
#: chapter-testbench.xml:912
#, no-c-format
msgid ""
"<filename>bdd/CalculatorSteps.java</filename>, <filename>bdd/"
"SimpleCalculation.java</filename>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:914
#, no-c-format
msgid ""
"Shows how to develop tests following the <emphasis>behaviour-driven "
"development</emphasis> (BDD) model, by using the <link xlink:href=\"http://"
"jbehave.org\">JBehave framework</link>. <filename>SimpleCalculation.java</"
"filename> defines a JUnit-based user story with one scenario, which is "
"defined in <filename>CalculatorSteps.java</filename>. The scenario reuses "
"the page objects defined in the page object example (see above) for low-"
"level application view access and control. The example is described in <xref "
"linkend=\"testbench.bdd\"/>."
msgstr ""
"演示如何使用 <link xlink:href=\"http://jbehave.org\">JBehave 框架</link>, 遵"
"循 <emphasis>行为驱动开发</emphasis> (behaviour-driven development, 简称 "
"BDD) 模式来开发测试程序. <filename>SimpleCalculation.java</filename> 定义了一"
"个基于 JUnit 的用户场景(user story), 其中有一个情节(scenario), 在 "
"<filename>CalculatorSteps.java</filename> 中定义. 这个情节重用了页面对象示例"
"(见上文)中定义的页面对象, 以便实现应用程序视图的低级的访问和控制. 这个示例将"
"在 <xref linkend=\"testbench.bdd\"/> 中介绍."

#. Tag: title
#: chapter-testbench.xml:931
#, no-c-format
msgid "Installing Browser Drivers"
msgstr "安装浏览器驱动程序"

#. Tag: para
#: chapter-testbench.xml:933
#, no-c-format
msgid ""
"Whether developing tests with the WebDriver in the workstation or running "
"tests in a grid, using some browsers requires that a browser driver is "
"installed."
msgstr ""
"无论是在工作站上使用 WebDriver 来开发测试程序, 还是在网格内运行测试程序, 要使"
"用浏览器就需要安装浏览器驱动程序."

#. Tag: para
#: chapter-testbench.xml:941
#, no-c-format
msgid "Download the latest browser driver"
msgstr "下载最新的浏览器驱动程序"

#. Tag: para
#: chapter-testbench.xml:945
#, no-c-format
msgid ""
"Internet Explorer (Windows only) - install <filename>IEDriverServer.exe</"
"filename> from under the latest Selenium release:"
msgstr ""
"Internet Explorer (只能用于 Windows) - 请安装 Selenium 最新发布版中的 "
"<filename>IEDriverServer.exe</filename>, 地址是:"

#. Tag: link
#: chapter-testbench.xml:952
#, no-c-format
msgid "http://selenium-release.storage.googleapis.com/index.html"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:956
#, no-c-format
msgid ""
"Chrome - install ChromeDriver (a part of the Chromium project) for your "
"platform from under the latest release at:"
msgstr ""
"Chrome - 请安装适合你的操作系统的 ChromeDriver 的最新版本(它是 Chromium 工程"
"的一部分), 地址是:"

#. Tag: link
#: chapter-testbench.xml:963
#, no-c-format
msgid "http://chromedriver.storage.googleapis.com/index.html"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:969
#, no-c-format
msgid ""
"Add the driver executable to user PATH. In a distributed testing "
"environment, give it as a command-line parameter to the grid node service, "
"as described in <xref linkend=\"testbench.grid.node\"/>."
msgstr ""
"将驱动程序可执行文件的路径添加到 PATH 中. 在分布式测试环境中, 将其指定为网格"
"节点服务的命令行参数, 详情请参见 <xref linkend=\"testbench.grid.node\"/>."

#. Tag: title
#: chapter-testbench.xml:977
#, no-c-format
msgid "Installing ChromeDriver for Ubuntu Chromium"
msgstr "为 Ubuntu Chromium 安装 ChromeDriver"

#. Tag: para
#: chapter-testbench.xml:979
#, no-c-format
msgid ""
"While you can install Google Chrome in Ubuntu, it also has its own Chromium "
"Browser, which is based on the Google Chrome. Chromium has its own version "
"of ChromeDriver, which requires some additional installation steps to be "
"usable."
msgstr ""
"虽然你可以在 Ubuntu 上安装 Google Chrome, 但它还带有自己的 Chromium 浏览器, "
"这个浏览器的代码是基于 Google Chrome 的. Chromium 也有它独自的 ChromeDriver, "
"使用这个驱动还需要一些额外的安装步骤."

#. Tag: para
#: chapter-testbench.xml:986
#, no-c-format
msgid "Install the ChromeDriver:"
msgstr "安装 ChromeDriver:"

#. Tag: screen
#: chapter-testbench.xml:990
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>sudo apt-get</command> install "
"<parameter>chromium-chromedriver</parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:992
#, no-c-format
msgid "Add the driver executable to path, such as:"
msgstr "将驱动程序的可执行文件添加到 path 中, 比如:"

#. Tag: screen
#: chapter-testbench.xml:996
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>sudo ln</command> -s <parameter>/usr/lib/"
"chromium-browser/chromedriver</parameter> <parameter>/usr/local/bin/"
"chromedriver</parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:998
#, no-c-format
msgid "The Chromium libraries need to be included in the system library path:"
msgstr "Chromium 的库文件需要包含到系统的库文件查找路径中:"

#. Tag: screen
#: chapter-testbench.xml:1002
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>sudo sh</command> -c 'echo \"/usr/lib/chromium-"
"browser/libs\" > /etc/ld.so.conf.d/chrome_libs.conf'"
msgstr ""

#. Tag: screen
#: chapter-testbench.xml:1003
#, no-c-format
msgid "<prompt>$</prompt> <command>sudo ldconfig</command>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:1009
#, no-c-format
msgid "Test Node Configuration"
msgstr "测试节点的配置"

#. Tag: para
#: chapter-testbench.xml:1011
#, no-c-format
msgid ""
"If you are running the tests in a grid environment, you need to make some "
"configuration to the test nodes to get more stable results."
msgstr ""
"如果你在网格环境中运行测试, 你需要对测试节点进行一些配置, 才能得到更稳定的测"
"试结果."

#. Tag: para
#: chapter-testbench.xml:1016
#, no-c-format
msgid ""
"Further configuration is provided in command-line parameters when starting "
"the node services, as described in <xref linkend=\"testbench.grid.node\"/>."
msgstr ""
"更多的配置可以通过节点服务启动时的命令行参数指定, 详情请参见 <xref linkend="
"\"testbench.grid.node\"/>."

#. Tag: title
#: chapter-testbench.xml:1022
#, no-c-format
msgid "Operating system settings"
msgstr "操作系统设置"

#. Tag: para
#: chapter-testbench.xml:1024
#, no-c-format
msgid ""
"Make any operating system settings that might interfere with the browser and "
"how it is opened or closed. Typical problems include crash handler dialogs."
msgstr ""
"需要对操作系统进行一些设置, 这些设置可能影响到浏览器行为, 以及浏览器如何打开"
"或关闭. 常见的问题包括浏览器崩溃时的错误对话框."

#. Tag: para
#: chapter-testbench.xml:1029
#, no-c-format
msgid ""
"On Windows, disable error reporting in case a browser crashes as follows:"
msgstr "在 Windows 中, 需要禁用浏览器崩溃时的错误报告功能, 如下:"

#. Tag: para
#: chapter-testbench.xml:1035
#, no-c-format
msgid ""
"Open <menuchoice><guimenu>Control Panel</guimenu><guimenuitem>System</"
"guimenuitem></menuchoice>"
msgstr ""
"打开 <menuchoice><guimenu>控制面板</guimenu><guimenuitem>系统</guimenuitem></"
"menuchoice>"

#. Tag: para
#: chapter-testbench.xml:1040
#, no-c-format
msgid "Select the <guilabel>Advanced</guilabel> tab"
msgstr "选择 <guilabel>高级</guilabel> Tab 页"

#. Tag: para
#: chapter-testbench.xml:1045
#, no-c-format
msgid "Select <guilabel>Error reporting</guilabel>"
msgstr "选择 <guilabel>错误报告</guilabel>"

#. Tag: para
#: chapter-testbench.xml:1050
#, no-c-format
msgid "Check that <guilabel>Disable error reporting</guilabel> is selected"
msgstr "选中 <guilabel>禁用错误报告</guilabel>"

#. Tag: para
#: chapter-testbench.xml:1055
#, no-c-format
msgid ""
"Check that <guilabel>But notify me when critical errors occur</guilabel> is "
"not selected"
msgstr "去掉 <guilabel>但在发生严重错误时通知我</guilabel>"

#. Tag: title
#: chapter-testbench.xml:1063
#, no-c-format
msgid "Settings for Screenshots"
msgstr "屏幕截图设置"

#. Tag: para
#: chapter-testbench.xml:1065
#, no-c-format
msgid ""
"The screenshot comparison feature requires that the user interface of the "
"browser stays constant. The exact features that interfere with testing "
"depend on the browser and the operating system."
msgstr ""
"屏幕截图比较功能要求浏览器的用户界面固定不变. 影响测试效果的具体功能, 取决于"
"使用的操作系统和浏览器."

#. Tag: para
#: chapter-testbench.xml:1071
#, no-c-format
msgid "In general:"
msgstr "通常需要如下设定"

#. Tag: para
#: chapter-testbench.xml:1077
#, no-c-format
msgid "Disable blinking cursor"
msgstr "禁用闪烁光标"

#. Tag: para
#: chapter-testbench.xml:1082
#, no-c-format
msgid "Use identical operating system themeing on every host"
msgstr "在所有的测试主机上使用完全相同的操作系统 theme"

#. Tag: para
#: chapter-testbench.xml:1087
#, no-c-format
msgid "Turn off any software that may suddenly pop up a new window"
msgstr "关闭可能忽然弹出新窗口的所有软件"

#. Tag: para
#: chapter-testbench.xml:1092
#, no-c-format
msgid "Turn off screen saver"
msgstr "关闭屏幕保护程序"

#. Tag: para
#: chapter-testbench.xml:1098
#, no-c-format
msgid ""
"If using Windows and Internet Explorer, you should give also the following "
"setting:"
msgstr "如果使用 Windows 和 Internet Explorer 浏览器, 你还需要进行以下设定:"

#. Tag: para
#: chapter-testbench.xml:1105
#, no-c-format
msgid ""
"Turn on <guilabel>Allow active content to run in files on My Computer</"
"guilabel> under <guilabel>Security settings</guilabel>"
msgstr ""
"关闭 <guilabel>安全</guilabel> 中的 <guilabel>允许活动内容在我的计算机上运行"
"</guilabel> 选项"

#. Tag: title
#: chapter-testbench.xml:1117
#, no-c-format
msgid "Developing JUnit Tests"
msgstr "开发 JUnit 测试程序"

#. Tag: para
#: chapter-testbench.xml:1119
#, no-c-format
msgid ""
"JUnit is a popular unit testing framework for Java development. Most Java "
"IDEs, build systems, and continuous integration systems provide support for "
"JUnit. However, while we concentrate on the development of JUnit tests in "
"this chapter, Vaadin TestBench and the WebDriver are in no way specific to "
"JUnit and you can use any test execution framework, or just regular Java "
"applications, to develop TestBench tests."
msgstr ""
"JUnit 是一个非常流行的 Java 单元测试框架. 大多数 Java IDE, 构建系统, 以及持续"
"集成系统都提供对 JUnit 的支持. 虽然我们在这一章中集中介绍 JUnit 测试程序的开"
"发, 但 Vaadin TestBench 和 WebDriver 并不特别要求使用 JUnit, 你可以使用任何其"
"他测试执行框架, 或者普通的 Java 应用程序, 来开发 TestBench 测试程序."

#. Tag: para
#: chapter-testbench.xml:1128
#, no-c-format
msgid ""
"You may want to keep your test classes in a separate source tree in your "
"application project, or in an altogether separate project, so that you do "
"not have to include them in the web application WAR. Having them in the same "
"project may be nicer for version control purposes."
msgstr ""
"你可能会希望将测试程序类保存在你的应用程序工程中的独立的源代码树中, 或者完全"
"保存在独立的工程中, 这样就可以不必将它们包含在 Web 应用程序的 WAR 文件中. 将"
"测试程序放在相同的工程内, 可能更利于源代码的版本管理."

#. Tag: title
#: chapter-testbench.xml:1136 chapter-testbench.xml:1425
#, no-c-format
msgid "Basic Test Case Structure"
msgstr "测试用例(Test Case) 的基本结构"

#. Tag: para
#: chapter-testbench.xml:1138
#, no-c-format
msgid ""
"A JUnit test case is defined with annotations for methods in a test case "
"class. With TestBench, the test case class should extend the "
"<classname>TestBenchTestCase</classname> class, which provides the WebDriver "
"and ElementQuery APIs."
msgstr ""
"JUnit 测试用例通过测试用例类的方法上的注解来定义. 使用 TestBench 时, 测试用例"
"类继承 <classname>TestBenchTestcase</classname> 类, 这个类提供了 WebDriver "
"和 ElementQuery API."

#. Tag: programlisting
#: chapter-testbench.xml:1145
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class MyTestcase extends "
"TestBenchTestCase {]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1147
#, no-c-format
msgid ""
"The basic JUnit annotations used in TestBench testing are the following:"
msgstr "在 TestBench 测试程序中使用的基本的 JUnit 注解如下:"

#. Tag: literal
#: chapter-testbench.xml:1154
#, no-c-format
msgid "@Rule"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1156
#, no-c-format
msgid ""
"You can define certain TestBench parameters and other JUnit rules with the "
"<literal>@Rule</literal> annotation."
msgstr ""
"你可以使用 <literal>@Rule</literal> 注解来定义某些 TestBench 参数, 也可以定义"
"其他 JUnit 规则."

#. Tag: para
#: chapter-testbench.xml:1161
#, no-c-format
msgid ""
"For example, to enable taking screenshots on test failures, as described in "
"<xref linkend=\"testbench.screenshots.failure\"/>, you would define:"
msgstr ""
"比如, 为了启用测试失败时的屏幕截图(详情请参见 <xref linkend=\"testbench."
"screenshots.failure\"/>), 你应该定义:"

#. Tag: programlisting
#: chapter-testbench.xml:1167
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Rule\n"
"public ScreenshotOnFailureRule screenshotOnFailureRule =\n"
"        new ScreenshotOnFailureRule(this, true);]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1169
#, no-c-format
msgid ""
"Note that if you use this rule, you must <emphasis>not</emphasis> call "
"<methodname>driver.quit()</methodname> in your <literal>@After</literal> "
"method, as the method is executed before the screenshot is taken, but the "
"driver must be open to take it."
msgstr ""
"注意, 如果使用这条规则, 在 <literal>@After</literal> 方法中, 一定 <emphasis>"
"不能</emphasis> 调用 <methodname>driver.quit()</methodname> 方法, 因为这个方"
"法会比屏幕截图更早执行, 而浏览器驱动必须保持打开才可以截取屏幕."

#. Tag: literal
#: chapter-testbench.xml:1181
#, no-c-format
msgid "@Before"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1183
#, no-c-format
msgid ""
"The annotated method is executed before each test (annotated with "
"<literal>@Test</literal>). Normally, you create and set the driver here."
msgstr ""
"标注了这个注解的方法, 会在每个测试(通过 <literal>@Test</literal> 注解来标注)"
"之前被执行. 通常, 你可以在这里创建并设置浏览器驱动."

#. Tag: programlisting
#: chapter-testbench.xml:1189
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@Before\n"
"public void setUp() throws Exception {\n"
"    setDriver(new FirefoxDriver());\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1191
#, no-c-format
msgid ""
"The driver class should be one of <classname>FirefoxDriver</classname>, "
"<classname>ChromeDriver</classname>, <classname>InternetExplorerDriver</"
"classname>, <classname>SafariDriver</classname>, or "
"<classname>PhantomJSDriver</classname>. Please check "
"<classname>RemoteWebDriver</classname> from API documentation for the "
"current list of implementations. Notice that some of the drivers require "
"installing a browser driver, as described in <xref linkend=\"testbench."
"installation.browserdrivers\"/>."
msgstr ""
"驱动类应该是 <classname>FirefoxDriver</classname>, <classname>ChromeDriver</"
"classname>, <classname>InternetExplorerDriver</classname>, "
"<classname>SafariDriver</classname>, 或 <classname>PhantomJSDriver</"
"classname> 中的一个. 关于目前的实现类一览, 请在 API  文档中查看 "
"<classname>RemoteWebDriver</classname>. 注意, 某些驱动需要安装浏览器驱动程"
"序, 详情请参见 <xref linkend=\"testbench.installation.browserdrivers\"/>."

#. Tag: para
#: chapter-testbench.xml:1204
#, no-c-format
msgid ""
"The driver instance is stored in the <literal>driver</literal> property in "
"the test case. While you can access the property directly by the member "
"variable, you should set it only with the setter."
msgstr ""
"驱动的示例保存在测试用例的 <literal>driver</literal> 属性中. 你可以直接通过成"
"员变量访问这个属性, 但应该使用 setter 方法设置这个属性."

#. Tag: literal
#: chapter-testbench.xml:1214
#, no-c-format
msgid "@Test"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1216
#, no-c-format
msgid ""
"Annotates a test method. You normally first open the page and then execute "
"commands and make assertions on the content."
msgstr ""
"这个注解标注一个测试方法. 测试方法通常会打开页面, 然后执行命令, 最后对页面内"
"容进行一些检查."

#. Tag: programlisting
#: chapter-testbench.xml:1221
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[@Test\n"
"public void testClickButton() throws Exception {\n"
"    getDriver().get(\"http://localhost:8080/myproject\");\n"
"    \n"
"    // Click the button\n"
"    ButtonElement button = $(ButtonElement.class).\n"
"            caption(\"Click Me\").first();\n"
"    button.click();\n"
"\n"
"    // Check that the label text is correct\n"
"    LabelElement label = $(LabelElement.class).first();\n"
"    assertEquals(\"Thanks!\", label.getText());\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1223
#, no-c-format
msgid ""
"Normally, you would define the URL with a variable that is common for all "
"tests, and possibly concatenate it with a URI fragment to get to an "
"application state."
msgstr ""
"通常, 对于所有测试中都相同的 URL, 应该使用变量来定义, 可能还需要将它与 URI 片"
"段相加, 得到应用程序某一个状态的地址."

#. Tag: literal
#: chapter-testbench.xml:1231
#, no-c-format
msgid "@After"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1233
#, no-c-format
msgid ""
"After each test is finished, you normally need to quit the driver to close "
"the browser."
msgstr "每个测试执行结束后, 你可能会需要退出驱动, 关闭浏览器."

#. Tag: programlisting
#: chapter-testbench.xml:1238
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@After\n"
"public void tearDown() throws Exception {\n"
"    driver.quit();\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1240
#, no-c-format
msgid ""
"However, if you enable grabbing screenshots on failure with the "
"<classname>ScreenshotOnFailureRule</classname>, as described in <xref "
"linkend=\"testbench.screenshots.failure\"/>, the rules are executed after "
"<literal>@After</literal>, but the driver needs to be open when the rule to "
"take the screenshot is executed. Therefore, you should not quit the driver "
"in that case. The rule quits the driver implicitly."
msgstr ""
"但是, 如果你使用 <classname>ScreenshotOnFailureRule</classname>, 开启了测试失"
"败时截取屏幕截图的功能, (详情请参见 <xref linkend=\"testbench.screenshots."
"failure\"/>), 这段规则会在 <literal>@After</literal> 注解的方法之后执行, 但当"
"着个规则截取屏幕时, 驱动需要处于打开状态. 因此, 这种情况下你不应该退出驱动. "
"这条规则会隐含地退出驱动."

#. Tag: para
#: chapter-testbench.xml:1253
#, no-c-format
msgid ""
"You can use any other JUnit features. Notice, however, that using TestBench "
"requires that the driver has been created and is still open."
msgstr ""
"你还可以使用 JUnit 的任何其他功能. 但是, 要注意, 使用 TestBench 时要求驱动已"
"被创建成功, 并且处于打开状态."

#. Tag: para
#: chapter-testbench.xml:1258
#, no-c-format
msgid "A complete test case could be as follows:"
msgstr "完整的测试用例的示例如下:"

#. Tag: programlisting
#: chapter-testbench.xml:1262
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[import com.vaadin.testbench."
"ScreenshotOnFailureRule;\n"
"import com.vaadin.testbench.TestBenchTestCase;\n"
"import com.vaadin.testbench.elements.ButtonElement;\n"
"import com.vaadin.testbench.elements.LabelElement;\n"
"\n"
"import org.junit.Before;\n"
"import org.junit.Rule;\n"
"import org.junit.Test;\n"
"import org.openqa.selenium.firefox.FirefoxDriver;\n"
"\n"
"import java.util.List;\n"
"\n"
"import static org.junit.Assert.assertEquals;\n"
"import static org.junit.Assert.assertFalse;\n"
"\n"
"public class MyprojectTest extends TestBenchTestCase {\n"
"    @Rule\n"
"    public ScreenshotOnFailureRule screenshotOnFailureRule =\n"
"            new ScreenshotOnFailureRule(this, true);\n"
"\n"
"    @Before\n"
"    public void setUp() throws Exception {\n"
"        setDriver(new FirefoxDriver()); // Firefox\n"
"    }\n"
"\n"
"    /**\n"
"     * Opens the URL where the application is deployed.\n"
"     */\n"
"    private void openTestUrl() {\n"
"        getDriver().get(\"http://localhost:8080/myproject\");\n"
"    }\n"
"\n"
"    @Test\n"
"    public void testClickButton() throws Exception {\n"
"        openTestUrl();\n"
"\n"
"        // At first there should be no labels\n"
"        assertFalse($(LabelElement.class).exists());\n"
"\n"
"        // Click the button\n"
"        ButtonElement clickMeButton = $(ButtonElement.class).\n"
"                caption(\"Click Me\").first();\n"
"        clickMeButton.click();\n"
"\n"
"        // There should now be one label\n"
"        assertEquals(1, $(LabelElement.class).all().size());\n"
"\n"
"        // ... with the specified text\n"
"        assertEquals(\"Thank you for clicking\",\n"
"                $(LabelElement.class).first().getText());\n"
"\n"
"        // Click the button again\n"
"        clickMeButton.click();\n"
"\n"
"        // There should now be two labels\n"
"        List<LabelElement> allLabels =\n"
"            $(LabelElement.class).all();\n"
"        assertEquals(2, allLabels.size());\n"
"\n"
"        // ... and the last label should have the correct text\n"
"        LabelElement lastLabel = allLabels.get(1);\n"
"        assertEquals(\"Thank you for clicking\",\n"
"                     lastLabel.getText());\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1264
#, no-c-format
msgid ""
"This test case stub is created by the Vaadin project wizard in Eclipse and "
"by the Maven archetype, as described in <xref linkend=\"testbench.quickstart"
"\"/>."
msgstr ""
"这段测试程序框架代码, 是由 Eclipse 的Vaadin 工程创建向导, 或 Maven archetype "
"创建的,  详情请参见 <xref linkend=\"testbench.quickstart\"/>."

#. Tag: title
#: chapter-testbench.xml:1272 chapter-testbench.xml:1374
#, no-c-format
msgid "Running JUnit Tests in Eclipse"
msgstr "在 Eclipse 中运行 JUnit 测试程序"

#. Tag: para
#: chapter-testbench.xml:1274
#, no-c-format
msgid ""
"The Eclipse IDE integrates JUnit with nice control features, such as running "
"the tests in the current test source file. The test results are reported "
"visually in the JUnit view in Eclipse."
msgstr ""
"Eclipse IDE 集成了 JUnit, 并添加了很好的控制功能, 比如可以在当前测试程序源代"
"码文件中运行测试. 在 Eclipse 的 JUnit 视图区域中会生成可视化的测试结果报告."

#. Tag: para
#: chapter-testbench.xml:1280
#, no-c-format
msgid ""
"New Vaadin projects created with the Vaadin Plugin for Eclipse contain the "
"TestBench API dependency, as described in <xref linkend=\"testbench."
"quickstart\"/>, so you can run TestBench tests right away."
msgstr ""
"使用 Vaadin Plugin for Eclipse 创建的新工程, 已经包含了 TestBench API 的依赖"
"项目, 详情请参见 <xref linkend=\"testbench.quickstart\"/>, 因此你可以直接运"
"行 TestBench 测试程序."

#. Tag: para
#: chapter-testbench.xml:1287
#, no-c-format
msgid ""
"To configure an existing project for TestBench testing, you need to do the "
"following:"
msgstr "要对一个已经存在的工程, 配置它的 TestBench 测试, 你需要进行以下操作:"

#. Tag: para
#: chapter-testbench.xml:1294
#, no-c-format
msgid "Include the TestBench API dependency in the project."
msgstr "在工程中添加 TestBench API 依赖项目."

#. Tag: para
#: chapter-testbench.xml:1300
#, no-c-format
msgid ""
"If using a project created with the Vaadin Plugin for Eclipse, add the "
"TestBench API library dependency in <filename>ivy.xml</filename>. It should "
"be as follows:"
msgstr ""
"如果使用的是 Vaadin Plugin for Eclipse 创建的工程, 可以在 <filename>ivy.xml</"
"filename> 中添加 TestBench API 库的依赖项目. 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:1306
#, no-c-format
msgid ""
"<?pocket-size 75% ?>&lt;dependency org=\"com.vaadin\"\n"
"            name=\"vaadin-testbench-api\"\n"
"            rev=\"<emphasis role=\"bold\">latest.release</emphasis>\"\n"
"            conf=\"nodeploy-&gt;default\"/&gt;"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1308
#, no-c-format
msgid ""
"The TestBench API library provides element classes for Vaadin components, so "
"its revision number follows the earliest supported Vaadin release. For old "
"Vaadin versions, you can try using the <literal>latest.release</literal> as "
"given above."
msgstr ""
"TestBench API 库提供了针对 Vaadin 组件的元素类, 因此它的版本号与它所支持的最"
"老的 Vaadin 版本号一致. 对于 Vaadin 的旧版本, 你可以尝试使用上面给出的 "
"<literal>latest.release</literal> 版本号."

#. Tag: para
#: chapter-testbench.xml:1316
#, no-c-format
msgid ""
"The project should contain the <literal>nodeploy</literal> configuration, as "
"created for new Vaadin projects. See <xref linkend=\"addons.eclipse\"/> for "
"more details."
msgstr ""
"工程中应该包含 <literal>nodeploy</literal> 配置, 新的 Vaadin 工程会创建这个配"
"置. 详情请参见 <xref linkend=\"addons.eclipse\"/>."

#. Tag: para
#: chapter-testbench.xml:1324
#, no-c-format
msgid ""
"Otherwise, add the <filename>vaadin-testbench-api</filename> and "
"<filename>vaadin-testbench-core</filename> JARs from the installation "
"package to a library folder in the project, such as <filename>lib</"
"filename>. You should not put the library in <filename>WEB-INF/lib</"
"filename> as it is not used by the deployed Vaadin web application. Refresh "
"the project by selecting it and pressing <keycap>F5</keycap>."
msgstr ""
"否则的话, 请从将安装包中的 <filename>vaadin-testbench-api</filename> 和 "
"<filename>vaadin-testbench-core</filename> JAR 文件添加到工程的库文件夹中, 比"
"如 <filename>lib</filename> 目录. 你不应该将库文件放到 <filename>WEB-INF/"
"lib</filename> 目录下, 因为部署到服务器上的 Vaadin Web 应用程序不会使用这个文"
"件夹. 请选中工程, 然后按快捷键 <keycap>F5</keycap> 刷新工程."

#. Tag: listitem
#: chapter-testbench.xml:1338
#, no-c-format
msgid ""
"Right-click the project in Project Explorer and select <guilabel>Properties</"
"guilabel>, and open the <guilabel>Java Build Path</guilabel> and the "
"<guilabel>Libraries</guilabel> tab. Click <guibutton>Add JARs</guibutton>, "
"navigate to the library folder, select the library, and click <guibutton>OK</"
"guibutton>."
msgstr ""
"在 Project Explorer 中选中工程, 按鼠标右键, 并选择 <guilabel>Properties</"
"guilabel>, 然后打开 <guilabel>Java Build Path</guilabel> 中的 "
"<guilabel>Libraries</guilabel> Tab 页. 点击 <guibutton>Add JARs</guibutton> "
"按钮, 找到库文件夹, 选中库文件, 然后点击 <guibutton>OK</guibutton> 按钮."

#. Tag: listitem
#: chapter-testbench.xml:1346
#, no-c-format
msgid ""
"Switch to the <guilabel>Order and Export</guilabel> tab in the project "
"properties. Make sure that the TestBench JAR is above the <filename>gwt-dev."
"jar</filename> (it may contain an old <filename>httpclient</filename> "
"package), by selecting it and moving it with the <guibutton>Up</guibutton> "
"and <guibutton>Down</guibutton> buttons."
msgstr ""
"在工程属性中切换到 <guilabel>Order and Export</guilabel> 页. 确认 TestBench "
"JAR 是否在 <filename>gwt-dev.jar</filename> 之上 (<filename>gwt-dev.jar</"
"filename>之内可能会包含一个老的 <filename>httpclient</filename> 包), 如果不"
"是, 可以选中它, 并使用 <guibutton>Up</guibutton> 和 <guibutton>Down</"
"guibutton> 按钮调整顺序."

#. Tag: listitem
#: chapter-testbench.xml:1355
#, no-c-format
msgid "Click <guibutton>OK</guibutton> to exit the project properties."
msgstr "点击 <guibutton>OK</guibutton>, 退出工程属性编辑界面."

#. Tag: listitem
#: chapter-testbench.xml:1359
#, no-c-format
msgid ""
"Right-click a test source file and select <menuchoice><guimenu>Run As</"
"guimenu><guimenuitem>JUnit Test</guimenuitem></menuchoice>."
msgstr ""
"选中一个测试程序源文件, 点击鼠标右键, 选择 <menuchoice><guimenu>Run As</"
"guimenu><guimenuitem>JUnit Test</guimenuitem></menuchoice>."

#. Tag: para
#: chapter-testbench.xml:1365
#, no-c-format
msgid ""
"A JUnit view should appear, and it should open the Firefox browser, launch "
"the application, run the test, and then close the browser window. If all "
"goes well, you have a passed test case, which is reported in the JUnit view "
"area in Eclipse, as illustrated in <xref linkend=\"figure.testbench."
"development.eclipse\"/>."
msgstr ""
"这时将出现一个 JUnit 视图, 它应该会打开 Firefox 浏览器, 启动应用程序, 执行测"
"试程序, 然后关闭浏览器窗口. 如果一切顺利, 你的测试用例就执行通过了, 结果会报"
"告在 Eclipse 的 JUnit 视图区域中, 见 <xref linkend=\"figure.testbench."
"development.eclipse\"/>."

#. Tag: para
#: chapter-testbench.xml:1382
#, no-c-format
msgid ""
"If you are using some other IDE, it might support JUnit tests as well. If "
"not, you can run the tests using Ant or Maven."
msgstr ""
"如果你使用的是其他 IDE, 它可能也会支持 JUnit 测试程序. 如果它不支持, 你可以使"
"用 Ant 或 Maven 来运行测试程序."

#. Tag: title
#: chapter-testbench.xml:1390
#, no-c-format
msgid "Creating a Test Case"
msgstr "创建 Test Case"

#. Tag: title
#: chapter-testbench.xml:1394
#, no-c-format
msgid "Test Setup"
msgstr "测试的启动"

#. Tag: para
#: chapter-testbench.xml:1396
#, no-c-format
msgid ""
"Test configuration is done in a method annotated with <literal>@Before</"
"literal>. The method is executed before each test case."
msgstr ""
"测试的配置可以在 <literal>@Before</literal> 注解所标记的方法之内进行. 这个方"
"法会在每个测试用例之前执行."

#. Tag: para
#: chapter-testbench.xml:1402
#, no-c-format
msgid "The basic configuration tasks are:"
msgstr "基本的配置内容包括:"

#. Tag: listitem
#: chapter-testbench.xml:1407
#, no-c-format
msgid "Set TestBench parameters"
msgstr "设置 TestBench 参数"

#. Tag: listitem
#: chapter-testbench.xml:1408
#, no-c-format
msgid "Create the web driver"
msgstr "创建 Web Driver"

#. Tag: listitem
#: chapter-testbench.xml:1409
#, no-c-format
msgid "Do any other initialization"
msgstr "其他初始化处理"

#. Tag: title
#: chapter-testbench.xml:1413
#, no-c-format
msgid "TestBench Parameters"
msgstr "TestBench 参数"

#. Tag: para
#: chapter-testbench.xml:1415
#, no-c-format
msgid ""
"TestBench parameters are defined with static methods in the <classname>com."
"vaadin.testbench.Parameters</classname> class. The parameters are mainly for "
"screenshots and documented in <xref linkend=\"testbench.screenshots\"/>."
msgstr ""
"TestBench 参数通过 <classname>com.vaadin.testbench.Parameters</classname> 类"
"的静态方法来设置. 参数主要与屏幕截图有关, 详情请参见 <xref linkend="
"\"testbench.screenshots\"/>."

#. Tag: para
#: chapter-testbench.xml:1427
#, no-c-format
msgid "A typical test case does the following:"
msgstr "一个通常的测试用例的内容大致如下:"

#. Tag: listitem
#: chapter-testbench.xml:1432
#, no-c-format
msgid "Open the URL"
msgstr "打开 URL"

#. Tag: listitem
#: chapter-testbench.xml:1433
#, no-c-format
msgid "Navigate to desired state"
msgstr "导航跳转到应用程序的某个状态"

#. Tag: listitem
#: chapter-testbench.xml:1435
#, no-c-format
msgid "Find a HTML element (<classname>WebElement</classname>) for interaction"
msgstr ""
"找到一个 HTML 元素(<classname>WebElement</classname>), 作为后面的交互对象"

#. Tag: listitem
#: chapter-testbench.xml:1436
#, no-c-format
msgid ""
"Use <methodname>click()</methodname> and other commands to interact with the "
"element"
msgstr "使用 <methodname>click()</methodname> 或其他命令与这个元素交互"

#. Tag: listitem
#: chapter-testbench.xml:1437
#, no-c-format
msgid "Repeat with different elements until desired state is reached"
msgstr "对其他元素重复以上步骤, 直到应用程序到达期望的状态"

#. Tag: listitem
#: chapter-testbench.xml:1440
#, no-c-format
msgid "Find a HTML element (<classname>WebElement</classname>) to check"
msgstr "找到一个检查对象 HTML 元素(<classname>WebElement</classname>)"

#. Tag: listitem
#: chapter-testbench.xml:1441
#, no-c-format
msgid "Get and assert the value of the HTML element"
msgstr "取得并检查这个 HTML 元素的值"

#. Tag: listitem
#: chapter-testbench.xml:1442
#, no-c-format
msgid "Get a screenshot"
msgstr "取得屏幕截图"

#. Tag: para
#: chapter-testbench.xml:1445
#, no-c-format
msgid ""
"The <classname>WebDriver</classname> allows finding HTML elements in a page "
"in various ways, for example, with XPath expressions. The access methods are "
"defined statically in the <classname>By</classname> class."
msgstr ""
"<classname>WebDriver</classname> 可以通过多种方式查找页面内的 HTML 元素, 比"
"如, 使用 XPath 表达式. 元素元素的查找方法定义为 <classname>By</classname> 类"
"中的静态方法."

#. Tag: para
#: chapter-testbench.xml:1451
#, no-c-format
msgid "These tasks are realized in the following test code:"
msgstr "以上测试内容对应的代码如下:"

#. Tag: programlisting
#: chapter-testbench.xml:1455
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[\n"
"@Test\n"
"public void basic() throws Exception {\n"
"    getDriver().get(\"http://localhost:8080/tobetested\");\n"
"\n"
"    // Find an element to interact upon    \n"
"    ButtonElement button =\n"
"        $(ButtonElement.class).id(\"mybutton\");\n"
" \n"
"    // Click the button\n"
"    button.click();\n"
"\n"
"    // Check that the label text is correct\n"
"    LabelElement label = $(LabelElement.class).first();\n"
"    assertEquals(\"Thanks!\", label.getText());\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1457
#, no-c-format
msgid ""
"You can also use URI fragments in the URL to open the application at a "
"specific state. <phrase condition=\"web\">For information about URI "
"fragments, see <xref linkend=\"advanced.urifu\"/>.</phrase>"
msgstr ""
"你也可以在 URL 中使用 URI 片段来访问应用程序的某个状态. <phrase condition="
"\"web\">关于 URI 片段, 详情请参见 <xref linkend=\"advanced.urifu\"/>.</"
"phrase>"

#. Tag: para
#: chapter-testbench.xml:1463
#, no-c-format
msgid ""
"You should use the JUnit assertion commands. They are static methods defined "
"in the <package>org.junit.Assert</package> class, which you can import (for "
"example) with:"
msgstr ""
"你应该使用 JUnit 断言语句来检查程序状态. 断言是定义在 <package>org.junit."
"Assert</package> 类中的静态方法, 举例来说, 你可以使用以下语句导入这个类:"

#. Tag: programlisting
#: chapter-testbench.xml:1469
#, no-c-format
msgid "<![CDATA[import static org.junit.Assert.assertEquals;]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1471
#, no-c-format
msgid ""
"Please see the <link xlink:href=\"http://seleniumhq.org/docs/03_webdriver."
"html#selenium-webdriver-api-commands-and-operations\">Selenium API "
"documentation</link> for a complete reference of the element search methods "
"in the <classname>WebDriver</classname> and <classname>By</classname> "
"classes and for the interaction commands in the <classname>WebElement</"
"classname> class."
msgstr ""
"关于页面元素查找方法的完整列表, 请参见 <link xlink:href=\"http://seleniumhq."
"org/docs/03_webdriver.html#selenium-webdriver-api-commands-and-operations"
"\">Selenium API 文档</link> 中的 <classname>WebDriver</classname> 和 "
"<classname>By</classname> 类, 关于与页面元素的交互命令, 请参见 "
"<classname>WebElement</classname> 类."

#. Tag: para
#: chapter-testbench.xml:1480
#, no-c-format
msgid ""
"TestBench has a collection of its own commands, defined in the "
"<interfacename>TestBenchCommands</interfacename> interface. You can get a "
"command object that you can use by calling <literal>testBench(driver)</"
"literal> in a test case."
msgstr ""
"TestBench 还有很多自己的命令, 定义在 <interfacename>TestBenchCommands</"
"interfacename> 接口中. 你可以在测试用例中调用 <literal>testBench(driver)</"
"literal>, 得到一个 Command 对象, 并使用它."

#. Tag: para
#: chapter-testbench.xml:1487
#, no-c-format
msgid ""
"While you can develop tests simply with test cases as described above, for "
"the sake of maintainability it is often best to modularize the test code "
"further, such as to separate testing at the levels of business logic and the "
"page layout. See <xref linkend=\"testbench.maintainable\"/> for information "
"about using page objects for this purpose."
msgstr ""
"虽然使用上述方法你可以很简单地编写测试用例, 但为了便于维护, 最好将测试代码进"
"行更好的模块划分, 比如将业务逻辑层的测试与页面布局层的测试分离开. 为了这个目"
"的可以使用页面对象, 详情请参见 <xref linkend=\"testbench.maintainable\"/>."

#. Tag: title
#: chapter-testbench.xml:1497
#, no-c-format
msgid "Creating and Closing a Web Driver"
msgstr "Web Driver 的创建和关闭"

#. Tag: para
#: chapter-testbench.xml:1499
#, no-c-format
msgid ""
"Vaadin TestBench uses Selenium WebDriver to execute tests in a browser. The "
"<classname>WebDriver</classname> instance is created with the static "
"<methodname>createDriver()</methodname> method in the <classname>TestBench</"
"classname> class. It takes the driver as the parameter and returns it after "
"registering it. The test cases must extend the <classname>TestBenchTestCase</"
"classname> class, which manages the TestBench-specific features. You need to "
"store the driver in the test case with <methodname>setDriver()</methodname>."
msgstr ""
"Vaadin TestBench 使用 Selenium WebDriver 在浏览器内执行测试. 可以使用 "
"<classname>TestBench</classname> 类中的静态方法 <methodname>createDriver()</"
"methodname> 来创建 <classname>WebDriver</classname> 实例. 这个方法接受一个浏"
"览器驱动作为参数, 并注册这个浏览器驱动, 最后的返回值还是同一个浏览器驱动. 测"
"试用例必须继承 <classname>TestBenchTestCase</classname> 类, 它会管理 "
"TestBench 独有的功能. 你需要使用 <methodname>setDriver()</methodname> 方法, "
"将浏览器驱动保存在测试用例中 ."

#. Tag: para
#: chapter-testbench.xml:1510
#, no-c-format
msgid ""
"The basic way is to create the driver in a method annotated with the JUnit "
"<literal>@Before</literal> annotation and close it in a method annotated "
"with <literal>@After</literal>."
msgstr ""
"通常的做法是, 在 JUnit <literal>@Before</literal> 注解标注的方法内创建浏览器"
"驱动, 并在 <literal>@After</literal> 注解标注的方法内关闭浏览器驱动."

#. Tag: programlisting
#: chapter-testbench.xml:1516
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class AdvancedTest extends "
"TestBenchTestCase {\n"
"    @Before\n"
"    public void setUp() throws Exception {\n"
"        ...\n"
"        setDriver(TestBench.createDriver(new FirefoxDriver()));\n"
"    }\n"
"    ...\n"
"    @After\n"
"    public void tearDown() throws Exception {\n"
"        driver.quit();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1518
#, no-c-format
msgid ""
"This creates the driver for each test you have in the test class, causing a "
"new browser instance to be opened and closed. If you want to keep the "
"browser open between the tests, you can use <literal>@BeforeClass</literal> "
"and <literal>@AfterClass</literal> methods to create and quit the driver. In "
"that case, the methods as well as the driver instance have to be static and "
"you need to set the driver in a <literal>@Before</literal> method."
msgstr ""
"以上代码会为测试用例之内的每一个测试创建一个浏览器驱动, 导致每次测试之前都有"
"新的浏览器实例被打开, 测试结束后被关闭. 如果你希望在整个测试期间保持浏览器实"
"例不关闭, 你可以使用 <literal>@BeforeClass</literal> 和 "
"<literal>@AfterClass</literal> 注解标注的方法来创建和退出浏览器驱动. 这种情况"
"下, 这些方法以及浏览器驱动的实例都必须是 static 的, 而且你需要在 "
"<literal>@Before</literal> 注解标注的方法中设置浏览器驱动."

#. Tag: programlisting
#: chapter-testbench.xml:1528
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class AdvancedTest extends "
"TestBenchTestCase {\n"
"    static private WebDriver driver;\n"
"\n"
"    @BeforeClass\n"
"    static public void createDriver() throws Exception {\n"
"        driver = TestBench.createDriver(new FirefoxDriver());\n"
"    }\n"
"\n"
"    @Before\n"
"    public void setUp() throws Exception {\n"
"        setDriver(driver);\n"
"    }\n"
"    ...\n"
"    @AfterClass\n"
"    static public void tearDown() throws Exception {\n"
"        driver.quit();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:1531
#, no-c-format
msgid "Browser Drivers"
msgstr "浏览器驱动"

#. Tag: para
#: chapter-testbench.xml:1533
#, no-c-format
msgid ""
"Please see the API documentation of the <interfacename>WebDriver</"
"interfacename> interface for a complete list of supported drivers, that is, "
"classes implementing the interface."
msgstr ""
"关于支持的浏览器驱动完整列表, 请参见 <interfacename>WebDriver</"
"interfacename> 接口的 API 文档, 浏览器驱动类都实现了这个接口."

#. Tag: para
#: chapter-testbench.xml:1539
#, no-c-format
msgid ""
"Both the Internet Explorer and Chrome require a special driver, as was noted "
"in <xref linkend=\"testbench.installation.browserdrivers\"/>. The driver "
"executable must be included in the operating system <literal>PATH</literal>, "
"be given with a driver-specific system Java property:"
msgstr ""
"Internet Explorer 和 Chrome 都需要特殊的驱动程序, 详情请参见 <xref linkend="
"\"testbench.installation.browserdrivers\"/>. 驱动程序的可执行文件必须包含在操"
"作系统的 <literal>PATH</literal> 路径内, 还需要通过特殊的 Java 系统属性来指"
"定:"

#. Tag: listitem
#: chapter-testbench.xml:1548
#, no-c-format
msgid "Chrome: <parameter>webdriver.chrome.driver</parameter>"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:1549
#, no-c-format
msgid "IE: <parameter>webdriver.ie.driver</parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1552
#, no-c-format
msgid ""
"You can set the property in Java with <methodname>System.setProperty(prop, "
"key))</methodname> or pass it as a command-line parameter to the Java "
"executable with <parameter>-Dwebdriver.chrome.driver=/path/to/driver</"
"parameter>."
msgstr ""
"你可以在 Java 中使用 <methodname>System.setProperty(prop, key))</methodname> "
"方法来设置属性, 也可以通过 Java 可执行文件的命令行参数来指定: <parameter>-"
"Dwebdriver.chrome.driver=/path/to/driver</parameter>."

#. Tag: para
#: chapter-testbench.xml:1559
#, no-c-format
msgid ""
"If you use an ESR version of Firefox, which is recommended for test "
"stability, you need to the binary when creating the driver as follows:"
msgstr ""
"如果你使用 ESR 版本的 Firefox, (为保证测试的稳定性, 我们推荐如此), 创建浏览器"
"驱动时你需要指定可执行文件路径, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:1564
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[FirefoxBinary binary =\n"
"    new FirefoxBinary(new File(\"/path/to/firefox_ESR_10\"));\n"
"driver = TestBench.createDriver(\n"
"    new FirefoxDriver(binary, new FirefoxProfile()));]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:1570
#, no-c-format
msgid "Querying Elements"
msgstr "查询页面元素"

#. Tag: para
#: chapter-testbench.xml:1572
#, no-c-format
msgid ""
"The high-level ElementQuery API allows querying Vaadin components in the "
"browser according to their component class type, hierarchy, caption, and "
"other properties. Once one or more components are found, they can be "
"interacted upon. The query API forms an domain-specific language (DSL), "
"embedded in the <classname>TestBenchTestCase</classname> class."
msgstr ""
"高级的 ElementQuery API 可以用于查询浏览器内的 Vaadin 组件, 查询条件可以是组"
"件类型, 层级关系, 标题, 以及其他属性. 找到一个或多个组件后, 就可以与它们进行"
"交互. 查询 API 使用一种特定领域语言(Domain-Specific Language, DSL), 包含在 "
"<classname>TestBenchTestcase</classname> 类中."

#. Tag: para
#: chapter-testbench.xml:1580
#, no-c-format
msgid ""
"The basic idea of element queries match elements and return queries, which "
"can again be queried upon, until terminated by a terminal query that returns "
"one or more elements."
msgstr ""
"页面元素查询的基本思路是先匹配元素, 再返回查询对象, 返回的查询对象又可以继续"
"进行查询, 直到遇到一个终止查询才结束, 终止查询返回一个或多个元素."

#. Tag: para
#: chapter-testbench.xml:1586
#, no-c-format
msgid "Consider the following query:"
msgstr "请看以下查询:"

#. Tag: programlisting
#: chapter-testbench.xml:1590
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[List<ButtonElement> buttons = $(ButtonElement."
"class).all();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1592
#, no-c-format
msgid ""
"The query returns a list of HTML elements of all the <classname>Button</"
"classname> components in the UI. Every Vaadin component has its "
"corresponding element class, which has methods to interact with the "
"particular component type. We could control the buttons found by the query, "
"for example, by clicking them as follows:"
msgstr ""
"这个查询返回 HTML 元素的列表, 其中包含 UI 中所有的 <classname>Button</"
"classname> 组件. 每一中 Vaadin 组件都有对应的元素类, 元素类都有方法可以与特定"
"的组件进行交互. 我们可以控制由这个查询找到的按钮, 比如, 可以点击按钮, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:1601
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[for (ButtonElement b: buttons)\n"
"    b.click();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1603
#, no-c-format
msgid ""
"In the following sub-sections, we look into the details of element queries."
msgstr "后面的小节中, 我们介绍页面元素查询的细节."

#. Tag: title
#: chapter-testbench.xml:1608
#, no-c-format
msgid "Generating Queries with Debug Window"
msgstr "使用 Debug 窗口生成查询"

#. Tag: para
#: chapter-testbench.xml:1610
#, no-c-format
msgid ""
"You can use the debug window to easily generate the element query code to "
"select a particular element in the UI. This should be especially useful when "
"starting to use TestBench, to get the idea what the queries should be like."
msgstr ""
"你可以使用 Debug 窗口, 非常简单地生成查询代码, 生成的查询可以选择 UI 中的一个"
"特定元素. 刚开始使用 TestBench 时, 这种方法非常有用, 有助于理解查询的使用方"
"法."

#. Tag: para
#: chapter-testbench.xml:1617
#, no-c-format
msgid ""
"First, enable the debug window with the <literal>&amp;debug</literal> "
"parameter for the application, as described in more detail in <xref linkend="
"\"advanced.debug\"/>. You can interact with the UI in any way you like "
"before generating the query code, but we recommend that you proceed by "
"following the sequence in which the user would use the UI in each use case, "
"making the queries at each step."
msgstr ""
"首先, 使用 <literal>&amp;debug</literal> 参数, 打开应用程序的 Debug 窗口, 详"
"情请参见 <xref linkend=\"advanced.debug\"/>. 生成查询代码之前, 你可以使用任何"
"方法与 UI 交互, 但我们建议你遵循用户在各个使用场景时正常的操作步骤, 并在每一"
"步都生成查询."

#. Tag: para
#: chapter-testbench.xml:1626
#, no-c-format
msgid ""
"Switch to the TestBench tab in the debug window, and enable the pick mode by "
"clicking the small button. Now, when you hover the mouse pointer on "
"elements, it highlights them, and when you click one, it generates the "
"TestBench element query to find the element. Use of the debug window is "
"illustrated in <xref linkend=\"figure.testbench.elementquery.debugwindow\"/>."
msgstr ""
"切换到 Debug 窗口的 TestBench Tab 页面, 点击小按钮, 启动 pick 模式. 现在, 当"
"你将鼠标指针移动到页面元素之上时, 页面元素将被高亮显示, 当你点击一个元素时, "
"将生成找到这个元素的 TestBench 的查询代码. Debug 窗口的使用, 见 <xref "
"linkend=\"figure.testbench.elementquery.debugwindow\"/>."

#. Tag: title
#: chapter-testbench.xml:1636
#, no-c-format
msgid "Using Debug Window to Generate Element Queries"
msgstr "使用 Debug 窗口生成页面元素查询"

#. Tag: para
#: chapter-testbench.xml:1647
#, no-c-format
msgid ""
"You can select and copy and paste the code from the debug window to your "
"editor. To exit the pick mode, click the pick button again."
msgstr ""
"你可以在 Debug 窗口中选中查询代码, 并复制粘贴到你的编辑器中. 要退出 pick 模"
"式, 请再次点击 pick 按钮."

#. Tag: para
#: chapter-testbench.xml:1652
#, no-c-format
msgid "The debug window feature is available in Vaadin 7.2 and later."
msgstr "Debug 窗口功能从 Vaadin 7.2 及以后的版本开始可用."

#. Tag: title
#: chapter-testbench.xml:1658
#, no-c-format
msgid "Querying Elements by Component Type (<methodname>$</methodname>)"
msgstr "使用组件类型(<methodname>$</methodname>)查询页面元素"

#. Tag: para
#: chapter-testbench.xml:1660
#, no-c-format
msgid ""
"The <methodname>$</methodname> method creates an <classname>ElementQuery</"
"classname> that looks for the given element class. The method is available "
"both in <classname>TestBenchTestcase</classname> and "
"<classname>ElementQuery</classname>, which defines the context. The search "
"is done recursively in the context."
msgstr ""
"<methodname>$</methodname> 方法创建一个 <classname>ElementQuery</classname>, "
"查找指定的元素类型. 这个方法在 <classname>TestBenchTestcase</classname> 和 "
"<classname>ElementQuery</classname> 类中都可用, 具体使用哪个类, 决定了查询的"
"上下文. 查找会在上下文中递归进行."

#. Tag: programlisting
#: chapter-testbench.xml:1669
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Find the first OK button in the UI\n"
"ButtonElement button = $(ButtonElement.class)\n"
"    .caption(\"OK\").first();\n"
"\n"
"// A nested query where the context of the latter \n"
"// component type query is the matching elements\n"
"// - matches the first Label inside the \"content\" layout.\n"
"LabelElement label = $(VerticalLayoutElement.class)\n"
"    .id(\"content\").$(LabelElement.class).first();]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:1674
#, no-c-format
msgid "Non-Recursive Component Queries (<methodname>$$</methodname>)"
msgstr "非递归的组件查询 (<methodname>$$</methodname>)"

#. Tag: para
#: chapter-testbench.xml:1676
#, no-c-format
msgid ""
"The <methodname>$$</methodname> method creates a non-recursive "
"<classname>ElementQuery</classname>. It is a shorthand for first creating a "
"recursive query with <methodname>$</methodname> and then calling "
"<methodname>recursive(false)</methodname> for the query."
msgstr ""
"<methodname>$$</methodname> 方法创建一个非递归的 <classname>ElementQuery</"
"classname>. 它是一个快捷方法, 等同于首先使用 <methodname>$</methodname> 方法"
"创建一个递归的查询, 然后对这个查询调用 <methodname>recursive(false)</"
"methodname>."

#. Tag: title
#: chapter-testbench.xml:1685
#, no-c-format
msgid "Element Classes"
msgstr "页面元素类"

#. Tag: classname
#: chapter-testbench.xml:1688
#, no-c-format
msgid "TestBenchElement"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1691
#, no-c-format
msgid ""
"Each Vaadin component has a corresponding element class in TestBench, which "
"contains methods for interacting with the particular component. The element "
"classes extend <classname>TestBenchElement</classname>. It implements "
"Selenium <interfacename>WebElement</interfacename>, so the Selenium element "
"API can be used directly. The element classes are distributed in a Vaadin "
"library rather than with TestBench, as they must correspond with the Vaadin "
"version used in the application."
msgstr ""
"每一个 Vaadin 组件在 TestBench 中都存在一个对应的元素类, 其中包含了与特定的组"
"件进行交互的方法. 元素类继承自 <classname>TestBenchElement</classname>. 它实"
"现了 Selenium 的 <interfacename>WebElement</interfacename> 接口, 因此 "
"Selenium 的页面元素 API 也可以直接使用. 元素类通过 Vaadin 库发布, 而不是通过 "
"TestBench, 因为它们必须与应用程序使用的 Vaadin 版本保持一致."

#. Tag: para
#: chapter-testbench.xml:1701
#, no-c-format
msgid ""
"In addition to components, other Vaadin UI elements such as notifications "
"(see <xref linkend=\"testbench.special.notifications\"/>) can have their "
"corresponding element class. Add-on libraries may also define their custom "
"element classes."
msgstr ""
"除组件外, 其他 Vaadin UI 元素, 比如通知(详情请参见 <xref linkend=\"testbench."
"special.notifications\"/>) 也存在对应的元素类. 其他的 Add-on 库也可以定义它们"
"自己的页面元素类."

#. Tag: para
#: chapter-testbench.xml:1708
#, no-c-format
msgid ""
"<classname>TestBenchElement</classname> is a TestBench command executor, so "
"you can always use an element to create query in the sub-tree of the "
"element. For example, in the following we first find a layout element by its "
"ID and then do a sub-query to find the first label in it:"
msgstr ""
"<classname>TestBenchElement</classname> 是一个 TestBench 命令执行器, 因此你可"
"以使用一个页面元素, 在它的子元素树上创建查询. 比如, 下例中我们首先使用 ID 找"
"到一个布局元素, 然后对它进行一次子查询找到布局之内的第一个 Label:"

#. Tag: programlisting
#: chapter-testbench.xml:1715
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[VerticalLayoutElement layout =\n"
"    $(VerticalLayoutElement.class).id(\"content\");\n"
"LabelElement label = layout.$(LabelElement.class).first();]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:1720
#, no-c-format
msgid "<classname>ElementQuery</classname> Objects"
msgstr "<classname>ElementQuery</classname> 对象"

#. Tag: para
#: chapter-testbench.xml:1722
#, no-c-format
msgid ""
"You can use an <classname>ElementQuery</classname> object to either make sub-"
"queries to refine the query, or use a query terminator to finalize the query "
"and get one or more matching elements."
msgstr ""
"你可以使用一个 <classname>ElementQuery</classname> 对象, 创建子查询来完善查询"
"结果, 或者使用一个结束符来结束查询, 并得到一个或多个匹配的页面元素."

#. Tag: title
#: chapter-testbench.xml:1730
#, no-c-format
msgid "Query Terminators"
msgstr "查询结束符"

#. Tag: para
#: chapter-testbench.xml:1732
#, no-c-format
msgid ""
"A query is finalized by a sub-query that returns an element or a collection "
"of elements."
msgstr "查询使用子查询来结束, 子查询返回单个元素, 或者多个元素的集合."

#. Tag: methodname
#: chapter-testbench.xml:1739
#, no-c-format
msgid "first()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1741
#, no-c-format
msgid "Returns the first found element."
msgstr "返回第一个找到的元素."

#. Tag: methodname
#: chapter-testbench.xml:1747
#, no-c-format
msgid "get()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1749
#, no-c-format
msgid "Returns the element by index in the collection of matching elements."
msgstr "在匹配的元素集合中, 根据索引数值返回对用的元素."

#. Tag: methodname
#: chapter-testbench.xml:1756
#, no-c-format
msgid "all()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1758
#, no-c-format
msgid ""
"Returns a <interfacename>List</interfacename> of elements of the query type."
msgstr ""
"返回一个 <interfacename>List</interfacename>, 其中的内容是所有匹配的元素."

#. Tag: methodname
#: chapter-testbench.xml:1765
#, no-c-format
msgid "id()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1767
#, no-c-format
msgid ""
"Returns the unique element having the given ID. Element IDs must always be "
"unique in the web page. It is therefore meaningless to make a complex query "
"to match the ID, just matching the element class is enough."
msgstr ""
"返回拥有指定的 ID 的唯一元素. 元素 ID 在 Web 页面内必须始终是唯一的. 因此使用"
"一个复杂的查询来匹配 ID 是无意义的, 只需要匹配元素类型就足够了."

#. Tag: title
#: chapter-testbench.xml:1778
#, no-c-format
msgid "Web Elements"
msgstr "页面元素"

#. Tag: para
#: chapter-testbench.xml:1780
#, no-c-format
msgid ""
"A query returns one or more elements extending Selenium "
"<classname>WebElement</classname>. The particular element-specific class "
"offers methods to manipulate the associated Vaadin component, while you can "
"also use the lower-level general-purpose methods defined in "
"<classname>WebElement</classname>."
msgstr ""
"查询返回一个或多个页面元素, 页面元素继承自 Selenium 的 "
"<classname>WebElement</classname> 类. 各元素类分别提供了独有的方法来操纵相关"
"的 Vaadin 组件, 但你也可以使用 <classname>WebElement</classname> 类中定义的低"
"级通用方法."

#. Tag: title
#: chapter-testbench.xml:1792
#, no-c-format
msgid "Element Selectors"
msgstr "元素选择器"

#. Tag: para
#: chapter-testbench.xml:1794
#, no-c-format
msgid ""
"In addition to the high-level ElementQuery API described in the previous "
"section, Vaadin TestBench includes the lower-level Selenium WebDriver API, "
"with Vaadin extensions. You can find elements also by a plain XPath "
"expression, an element ID, CSS style class, and so on. You can use such "
"selectors together with the element queries. Like the ElementQuery API, it "
"can be considered a domain-specific language (DSL) that is embedded in the "
"<classname>TestBenchTestCase</classname> class."
msgstr ""
"除前一小节介绍的高级的 ElementQuery API 之外, Vaadin TestBench 还包括低级的 "
"Selenium WebDriver API, 并做了一些 Vaadin 独有的扩展. 你也可以使用单纯的 "
"XPath 表达式来查找元素, 还可以使用元素 ID, CSS 样式类, 等等. 你可以将这些选择"
"器与元素查询组合起来使用. 与 ElementQuery API 类似, 这些 API 可以看作是一种特"
"定领域语言(Domain-Specific Language, DSL), 包含在 "
"<classname>TestBenchTestcase</classname> 类中."

#. Tag: para
#: chapter-testbench.xml:1804
#, no-c-format
msgid ""
"The available selectors are defined as static methods in the <classname>com."
"vaadin.testbench.By</classname> class. They create and return a "
"<classname>By</classname> instance, which you can use for the "
"<methodname>findElement()</methodname> method in <classname>WebDriver</"
"classname>."
msgstr ""
"可用的选择器定义为 <classname>com.vaadin.testbench.By</classname> 类中的静态"
"方法. 这些方法创建并返回一个 <classname>By</classname> 实例, 你可以在 "
"<classname>WebDriver</classname> 的 <methodname>findElement()</methodname> 方"
"法中使用这个 <classname>By</classname> 实例."

#. Tag: para
#: chapter-testbench.xml:1814
#, no-c-format
msgid ""
"The ID, CSS class, and Vaadin selectors are described below. For others, we "
"refer to the <link xlink:href=\"http://seleniumhq.org/docs/03_webdriver.html"
"\">Selenium WebDriver API documentation</link>."
msgstr ""
"ID, CSS 类, 以及 Vaadin 选择器将在下面的小节中介绍. 其他的选择器, 请参见 "
"<link xlink:href=\"http://seleniumhq.org/docs/03_webdriver.html\">Selenium "
"WebDriver API 文档</link>."

#. Tag: para
#: chapter-testbench.xml:1821
#, no-c-format
msgid ""
"Some selectors are not applicable to all elements, for example if an element "
"does not have an ID or it is outside the Vaadin application. In such case, "
"another selector is used according to a preference order. You can change the "
"order of the preferred selectors by selecting <menuchoice><guimenu>Options</"
"guimenu><guisubmenu>Options</guisubmenu><guimenuitem>Locator Builders</"
"guimenuitem></menuchoice> and dragging the selectors (or locators) to a "
"preferred order. Normally, the Vaadin selector should be at top of the list."
msgstr ""
"有些选择器不能适用于所有的元素, 比如, 如果一个元素没有 ID, 或者它在 Vaadin 应"
"用程序之外. 这种情况下, 会根据一个优先顺序使用其他选择器. 你可以修改选择器的"
"优先顺序, 方法是选择菜单 <menuchoice><guimenu>Options</"
"guimenu><guisubmenu>Options</guisubmenu><guimenuitem>Locator Builders</"
"guimenuitem></menuchoice>, 然后拖动选择器(或定位器)的优先顺序. 通常, Vaadin "
"selector 应该在优先顺序列表的最上方."

#. Tag: title
#: chapter-testbench.xml:1833
#, no-c-format
msgid "Finding by ID"
msgstr "通过 ID 查找"

#. Tag: para
#: chapter-testbench.xml:1835
#, no-c-format
msgid ""
"Selecting elements by their HTML element <literal>id</literal> attribute is "
"a robust way to select elements, as noted in <xref linkend=\"testbench."
"maintainable.robustness\"/>. It requires that you component IDs for the UI "
"components with <methodname>setId()</methodname>."
msgstr ""
"使用 HTML 元素的 <literal>id</literal> 属性来选择元素是一种比较健壮的方式, 这"
"个问题我们会在 <xref linkend=\"testbench.maintainable.robustness\"/> 中详细讨"
"论. 这种方式要求你使用 <methodname>setId()</methodname> 方法为组件设置 ID."

#. Tag: programlisting
#: chapter-testbench.xml:1843
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Button button = new Button(\"Push Me!\");\n"
"button.setId(\"pushmebutton\");]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1845
#, no-c-format
msgid ""
"The button would be rendered as a HTML element: <literal>&lt;div id="
"\"pushmebutton\" ...&gt;...&lt;/div&gt;</literal>. The element would then be "
"accessible with a low-level WebDriver call:"
msgstr ""
"按钮会被描绘为一个 HTML 元素: <literal>&lt;div id=\"pushmebutton\" ...&gt;..."
"&lt;/div&gt;</literal>. 然后可以使用低级的 WebDriver 调用, 取得对应的 DOM 元"
"素:"

#. Tag: programlisting
#: chapter-testbench.xml:1851
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[findElement(By.id(\"pushmebutton\")).click();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1853
#, no-c-format
msgid ""
"The selector is equivalent to the statically typed element query <literal>"
"$(ButtonElement.class).id(\"pushmebutton\")</literal>."
msgstr ""
"这个选择器等价于静态类型的元素查询 <literal>$(ButtonElement.class)."
"id(\"pushmebutton\")</literal>."

#. Tag: title
#: chapter-testbench.xml:1860
#, no-c-format
msgid "Finding by CSS Class"
msgstr "通过 CSS 类查找"

#. Tag: para
#: chapter-testbench.xml:1862
#, no-c-format
msgid ""
"An element with a particular CSS style class name can be selected with the "
"<methodname>By.className()</methodname> method. CSS selectors are useful for "
"elements which have no ID, nor can be found easily from the component "
"hierarchy, but do have a particular unique CSS style. Tooltips are one "
"example, as they are floating <literal>div</literal> elements under the root "
"element of the application. Their <literal>v-tooltip</literal> style makes "
"it possible to select them as follows:"
msgstr ""
"带有特定 CSS 样式名称的元素可以使用 <methodname>By.className()</methodname> "
"方法来查找. 如果一个组件没有 ID, 也无法简单地通过组件层级关系查找, 但拥有一个"
"特定的唯一的 CSS 样式, 那么 CSS 选择器是非常有用的. 提示信息(Tooltip)就是一个"
"例子, 它们是浮动的 <literal>div</literal> 元素, 位于应用程序根元素之下. 由于"
"它们带有 <literal>v-tooltip</literal> 样式, 所以可以使用以下方法选择:"

#. Tag: programlisting
#: chapter-testbench.xml:1872
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Verify that the tooltip contains the "
"expected text\n"
"String tooltipText = findElement(\n"
"    By.className(\"v-tooltip\")).getText();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1874
#, no-c-format
msgid ""
"For a complete example, see the <filename>AdvancedCommandsITCase.java</"
"filename> file in the TestBench demo described in <xref linkend=\"testbench."
"installation.examples\"/>."
msgstr ""
"完整的示例, 请参见 <xref linkend=\"testbench.installation.examples\"/> 中介绍"
"的 TestBench 示例程序中的 <filename>AdvancedCommandsITCase.java</filename> 文"
"件."

#. Tag: title
#: chapter-testbench.xml:1883
#, no-c-format
msgid "Special Testing Topics"
msgstr "测试中的一些特殊问题"

#. Tag: para
#: chapter-testbench.xml:1885
#, no-c-format
msgid ""
"In the following, we go through a number of TestBench features for handling "
"special cases, such as tooltips, scrolling, notifications, context menus, "
"and profiling responsiveness. Finally, we look into the Page Object pattern."
msgstr ""
"本节中, 我们介绍 TestBench 用来处理特殊情况的一些功能, 比如提示信息"
"(Tooltip), 滚动, 通知信息, 上下文菜单, 以及测量应答性能. 最后, 我们将介绍页面"
"对象模式(Page Object Pattern)."

#. Tag: title
#: chapter-testbench.xml:1892
#, no-c-format
msgid "Waiting for Vaadin"
msgstr "等待 Vaadin 处理完毕"

#. Tag: para
#: chapter-testbench.xml:1894
#, no-c-format
msgid ""
"Selenium, on which Vaadin TestBench is based, is originally intended for "
"regular web applications that load a page that is immediately rendered by "
"the browser. In such applications, you can test the page elements "
"immediately after the page is loaded. In Vaadin and other AJAX applications, "
"rendering is done by JavaScript code asynchronously, so you need to wait "
"until the server has given its response to an AJAX request and the "
"JavaScript code finishes rendering the UI. Selenium supports AJAX "
"applications by having special wait methods to poll the UI until the "
"rendering is finished. In pure Selenium, you need to use the wait methods "
"explicitly, and know what to use and when. Vaadin TestBench works together "
"with the client-side engine of Vaadin framework to immediately detect when "
"the rendering is finished. Waiting is implicit, so you do not normally need "
"to insert any wait commands yourself."
msgstr ""
"Vaadin TestBench 基于 Selenium, 而 Selenium 起初的目的是为了测试通常的 Web 应"
"用程序, 这类应用程序装载的页面会立即由浏览器显示完毕. 在这类应用程序中, 你可"
"以在页面装载后立即检查其中的元素. 在 Vaadin 以及其他 AJAX 应用程序中, 画面的"
"显示是由异步的 JavaScript 代码完成的, 因此你需要等待服务器对 AJAX 请求给出应"
"答, 以及 JavaScript 代码完成 UI 的显示工作. Selenium 支持 AJAX 应用程序, 可以"
"使用一个特殊的等待方法, 查询 UI 状态, 直到画面显示完毕. 在纯 Selenium 程序"
"中, 你需要明确地使用等待方法, 还需要知道什么时候使用, 以及使用哪一个方法. "
"Vaadin TestBench 与 Vaadin 框架的客户端引擎配合工作, 可以实时检测画面显示是否"
"结束. 等待处理是隐含进行的, 因此你通常不必自行添加任何等待命令."

#. Tag: para
#: chapter-testbench.xml:1910
#, no-c-format
msgid ""
"Waiting is automatically enabled, but it may be necessary to disable it in "
"some cases. You can do that by calling <methodname>disableWaitForVaadin()</"
"methodname> in the <interfacename>TestBenchCommands</interfacename> "
"interface. You can call it in a test case as follows:"
msgstr ""
"等待功能是自动启用的, 但某些情况下也有可能会需要禁用等待. 你可以调用 "
"<interfacename>TestBenchCommands</interfacename> 接口中的 "
"<methodname>disableWaitForVaadin()</methodname> 方法来禁用等待. 你可以在测试"
"用例中调用这个方法, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:1918
#, no-c-format
msgid "<![CDATA[testBench(driver).disableWaitForVaadin();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1920
#, no-c-format
msgid ""
"When disabled, you can wait for the rendering to finish by calling "
"<methodname>waitForVaadin()</methodname> explicitly."
msgstr ""
"当等待功能禁用时, 你可以明确地调用 <methodname>waitForVaadin()</methodname> "
"方法来等待画面显示结束."

#. Tag: programlisting
#: chapter-testbench.xml:1925
#, no-c-format
msgid "<![CDATA[testBench(driver).waitForVaadin();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1927
#, no-c-format
msgid ""
"You can re-enable the waiting with <methodname>enableWaitForVaadin()</"
"methodname> in the same interface."
msgstr ""
"你可以在同一个接口上调用 <methodname>enableWaitForVaadin()</methodname> 方"
"法, 再次启用等待功能."

#. Tag: title
#: chapter-testbench.xml:1934
#, no-c-format
msgid "Testing Tooltips"
msgstr "测试提示信息(Tooltip)"

#. Tag: para
#: chapter-testbench.xml:1936
#, no-c-format
msgid ""
"Component tooltips show when you hover the mouse over a component. Showing "
"them require special command. Handling them is also special, as the tooltips "
"are floating overlay element, which are not part of the normal component "
"hierarchy."
msgstr ""
"当你将鼠标移动到组件上方时, 将会显示组件提示信息. 显示提示信息需要特殊的命"
"令. 处理提示信息也需要特殊的方法, 因为提示信息是一个浮动的覆盖元素, 它不属于"
"通常的组件层级关系."

#. Tag: para
#: chapter-testbench.xml:1943
#, no-c-format
msgid "Let us assume that you have set the tooltip as follows:"
msgstr "假设你为组件设置了提示信息, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:1947
#, no-c-format
msgid ""
"<![CDATA[// Create a button with a component ID\n"
"Button button = new Button(\"Push Me!\");\n"
"button.setId(\"main.button\");\n"
"\n"
"// Set the tooltip        \n"
"button.setDescription(\"This is a tip\");]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1949
#, no-c-format
msgid ""
"The tooltip of a component is displayed with the <methodname>showTooltip()</"
"methodname> method in the <classname>TestBenchElementCommands</classname> "
"interface. You should wait a little to make sure it comes up. The floating "
"tooltip element is not under the element of the component, but you can find "
"it by <literal>//div[@class='v-tooltip']</literal> XPath expression."
msgstr ""
"组件的提示信息可以使用 <classname>TestBenchElementCommands</classname> 接口"
"的 <methodname>showTooltip()</methodname> 方法来显示. 你应该等待一小段时间, "
"确保提示信息正确显示. 浮动的提示信息元素并不在组件的页面元素之下, 但你可以通"
"过 XPath 表达式 <literal>//div[@class='v-tooltip']</literal> 来找到它."

#. Tag: programlisting
#: chapter-testbench.xml:1958
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Test\n"
"public void testTooltip() throws Exception {\n"
"    driver.get(appUrl);\n"
"    \n"
"    ButtonElement button =\n"
"        $(ButtonElement.class).id(\"main.button\");\n"
"\n"
"    button.showTooltip();\n"
"\n"
"    WebElement ttip = findElement(By.className(\"v-tooltip\"));\n"
"    assertEquals(ttip.getText(), \"This is a tip\");\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:1963
#, no-c-format
msgid "Scrolling"
msgstr "滚动"

#. Tag: primary
#: chapter-testbench.xml:1966
#, no-c-format
msgid "scrolling"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1969
#, no-c-format
msgid ""
"Some Vaadin components, such as <classname>Table</classname> and "
"<classname>Panel</classname> have a scrollbar. Normally, when you interact "
"with an element within such a scrolling region, TestBench implicitly tries "
"to scroll to the element to make it visible. In some cases, you may wish to "
"scroll a scrollbar explicitly. You can accomplish that with the "
"<methodname>scroll()</methodname> (vertical) and <methodname>scrollLeft()</"
"methodname> (horizontal) methods in the respective element classes for the "
"scrollable components. The scroll position is given in pixels."
msgstr ""
"某些 Vaadin 组件带有滚动条, 比如 <classname>Table</classname> 和 "
"<classname>Panel</classname>. 通常, 当你与这类滚动区域之内的元素进行交互时, "
"TestBench 会隐含地试图滚动到对象元素, 使它变得可见. 某些情况下, 你可能希望显"
"式地滚动一个滚动条. 你可以对可滚动的组件分别使用 <methodname>scroll()</"
"methodname> 方法(垂直方向) 和 <methodname>scrollLeft()</methodname> 方法(水平"
"方向)来控制它的滚动条. 滚动位置参数的单位为像素."

#. Tag: programlisting
#: chapter-testbench.xml:1981
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Scroll to a vertical position\n"
"PanelElement panel = $(PanelElement.class)\n"
"        .caption(\"Scrolling Panel\").first();\n"
"panel.scroll(123);]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:1986
#, no-c-format
msgid "Testing Notifications"
msgstr "测试通知信息"

#. Tag: classname
#: chapter-testbench.xml:1989
#, no-c-format
msgid "Notification"
msgstr ""

#. Tag: secondary
#: chapter-testbench.xml:1990
#, no-c-format
msgid "testing"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:1993
#, no-c-format
msgid ""
"You can find notification elements by the <classname>NotificationElement</"
"classname> class in the element query API. The element class supports "
"getting the caption with <methodname>getCaption()</methodname>, description "
"with <methodname>getDescription()</methodname>, and notification type with "
"<methodname>getType()</methodname>."
msgstr ""
"你可以使用页面元素查询 API 中的 <classname>NotificationElement</classname> "
"类, 查找通知信息的页面元素. 这个页面元素类可以通过 <methodname>getCaption()</"
"methodname> 方法取得标题, 通过 <methodname>getDescription()</methodname> 方法"
"取得描述信息, 通过 <methodname>getType()</methodname> 方法取得通知类型."

#. Tag: para
#: chapter-testbench.xml:2002
#, no-c-format
msgid "Let us assume that you pop the notifcation up as follows:"
msgstr "假设你弹出了一个通知信息, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:2006
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[Button button = new Button(\"Pop It Up\", e -"
"> // Java 8\n"
"    Notification.show(\"The caption\", \"The description\",\n"
"                      Notification.Type.WARNING_MESSAGE));]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2008
#, no-c-format
msgid "You could then check for the notification as follows:"
msgstr "你可以在测试程序中检查这个通知信息, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:2012
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[// Click the button to open the notification\n"
"ButtonElement button =\n"
"    $(ButtonElement.class).caption(\"Pop It Up\").first();\n"
"button.click();\n"
"\n"
"// Verify the notification\n"
"NotificationElement notification =\n"
"        $(NotificationElement.class).first();\n"
"assertEquals(\"The caption\", notification.getCaption());\n"
"assertEquals(\"The description\", notification.getDescription());\n"
"assertEquals(\"warning\", notification.getType());\n"
"notification.close();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2014
#, no-c-format
msgid ""
"You need to close the notification box with <methodname>close()</methodname> "
"to move forward."
msgstr ""
"你需要使用 <methodname>close()</methodname> 方法关闭通知信息的对话框, 应用程"
"序才能继续执行."

#. Tag: title
#: chapter-testbench.xml:2021
#, no-c-format
msgid "Testing Context Menus"
msgstr "测试上下文菜单"

#. Tag: primary
#: chapter-testbench.xml:2024
#, no-c-format
msgid "context menus"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2027
#, no-c-format
msgid ""
"Opening context menus requires special handling. First, to open a menu, you "
"need to \"context-click\" on a specific sub-element in a component that "
"supports context menus. You can do that with a <methodname>contextClick()</"
"methodname> action in a <classname>Actions</classname> object."
msgstr ""
"打开上下文菜单需要特殊的处理. 首先, 要打开一个菜单, 你需要在一个支持上下文菜"
"单的组件的特定子元素之内, \"点击鼠标右键\"(context-click). 你可以通过 "
"<classname>Actions</classname> 对象的 <methodname>contextClick()</"
"methodname> 动作来实现这个任务."

#. Tag: para
#: chapter-testbench.xml:2035
#, no-c-format
msgid ""
"A context menu is displayed as a floating element, which is under a special "
"overlays element in the HTML page, not under the component from which it "
"pops up. You can find it from the page by its CSS class <literal>v-"
"contextmenu</literal>. The menu items are represented as text, and you can "
"find the text with an XPath expression as shown in the example below."
msgstr ""
"上下文菜单会显示为一个浮动的元素, 这个元素包含在 HTML 页面中的一个特殊的覆盖"
"元素之内, 而不是在弹出菜单的那个组件之内. 你可以使用这个元素的 CSS 类 "
"<literal>v-contextmenu</literal>, 在页面内查找这个元素. 菜单项目表现为文本, "
"你可以使用下例中的 XPath 表达式查找这些文本元素."

#. Tag: para
#: chapter-testbench.xml:2044
#, no-c-format
msgid ""
"In the following example, we open a context menu in a <classname>Table</"
"classname> component, find an item by its caption text, and click it."
msgstr ""
"下例中, 我们在 <classname>Table</classname> 组件内打开上下文菜单, 通过标题文"
"字找到一个菜单项, 然后点击这个菜单项."

#. Tag: programlisting
#: chapter-testbench.xml:2050
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[// Get a table cell to work on\n"
"TableElement table = inExample(TableElement.class).first();\n"
"WebElement cell = table.getCell(3, 0); // A cell in the row\n"
"\n"
"// Perform context click action to open the context menu\n"
"new Actions(getDriver()).contextClick(cell).perform();\n"
"\n"
"// Find the opened menu\n"
"WebElement menu = findElement(By.className(\"v-contextmenu\"));\n"
"\n"
"// Find a specific menu item\n"
"WebElement menuitem = menu.findElement(\n"
"    By.xpath(\"//*[text() = 'Add Comment']\"));\n"
"\n"
"// Select the menu item\n"
"menuitem.click();]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2054
#, no-c-format
msgid "Profiling Test Execution Time"
msgstr "测量测试程序的执行时间"

#. Tag: para
#: chapter-testbench.xml:2056
#, no-c-format
msgid ""
"It is not just that it works, but also how long it takes. Profiling test "
"execution times consistently is not trivial, as a test environment can have "
"different kinds of latency and interference. For example in a distributed "
"setup, timings taken on the test server would include the latencies between "
"the test server, the grid hub, a grid node running the browser, and the web "
"server running the application. In such a setup, you could also expect "
"interference between multiple test nodes, which all might make requests to a "
"shared application server and possibly also share virtual machine resources."
msgstr ""
"我们不仅需要测试程序是否正常工作, 还关心它的执行时间. 不断地测量测试程序的执"
"行时间是很重要的, 因为测试环境可能会有各种不同的延迟和干扰. 比如, 在一个分布"
"式测试环境中, 测试服务器上耗费的时间会包含测试服务器, 网格 hub, 运行浏览器的"
"网格节点, 和运行应用程序的 Web 服务器之间的网络传输延迟. 在这样一个环境中, 你"
"还应该预计到多个测试节点之间会发生相互干扰, 因为它们可能会向同一个应用程序服"
"务器发起请求, 也可能会共用虚拟机的资源."

#. Tag: para
#: chapter-testbench.xml:2068
#, no-c-format
msgid ""
"Furthermore, in Vaadin applications, there are two sides which need to be "
"profiled: the server-side, on which the application logic is executed, and "
"the client-side, where it is rendered in the browser. Vaadin TestBench "
"includes methods for measuring execution time both on the server-side and "
"the client-side."
msgstr ""
"而且, 在 Vaadin 应用程序中, 存在两个部分需要测量: 服务器端, 它执行应用程序的"
"逻辑, 以及客户端, 它显示在浏览器内. Vaadin TestBench 针对服务器端和客户端, 都"
"包含了测量执行时间的方法."

#. Tag: para
#: chapter-testbench.xml:2076
#, no-c-format
msgid ""
"The <interfacename>TestBenchCommands</interfacename> interface offers the "
"following methods for profiling test execution time:"
msgstr ""
"<interfacename>TestBenchCommands</interfacename> 接口提供了以下方法, 用于测量"
"测试程序的执行时间:"

#. Tag: methodname
#: chapter-testbench.xml:2083
#, no-c-format
msgid "totalTimeSpentServicingRequests()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2085
#, no-c-format
msgid ""
"Returns the total time (in milliseconds) spent servicing requests in the "
"application on the server-side. The timer starts when you first navigate to "
"the application and hence start a new session. The time passes only when "
"servicing requests for the particular session. The timer is shared in the "
"servlet session, so if you have, for example, multiple portlets in the same "
"application (session), their execution times will be included in the same "
"total."
msgstr ""
"返回应用程序服务器端响应请求时消耗的总时间(毫秒单位). 当你第一次跳转到应用程"
"序之内, 启动一个新 session 时, 计时开始. 只有在应用程序响应某个 session 的请"
"求时, 才会计时. 计时器在 Servlet 的 Session 内共享, 因此, 比如说, 如果在同一"
"个应用程序(Session)之内, 你有多个 portlet, 那么它们的执行时间将被合计在一起."

#. Tag: para
#: chapter-testbench.xml:2098
#, no-c-format
msgid ""
"Notice that if you are also interested in the client-side performance for "
"the last request, you must call the "
"<methodname>timeSpentRenderingLastRequest()</methodname> before calling this "
"method. This is due to the fact that this method makes an extra server "
"request, which will cause an empty response to be rendered."
msgstr ""
"注意, 如果你还关心最后一次请求的客户端性能, 你必须在调用本方法之前调用 "
"<methodname>timeSpentRenderingLastRequest()</methodname> 方法. 这是因为, 这个"
"方法会向服务器发起一次额外的请求, 这个请求会导致一个不需要在画面上显示的应答."

#. Tag: methodname
#: chapter-testbench.xml:2109
#, no-c-format
msgid "timeSpentServicingLastRequest()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2111
#, no-c-format
msgid ""
"Returns the time (in milliseconds) spent servicing the last request in the "
"application on the server-side. Notice that not all user interaction through "
"the WebDriver cause server requests."
msgstr ""
"返回应用程序服务器端响应最后一次请求时消耗的时间(毫秒单位). 注意, 通过 "
"WebDriver 发起的用户交互, 并不是全部都会导致服务器请求."

#. Tag: para
#: chapter-testbench.xml:2118
#, no-c-format
msgid ""
"As with the total above, if you are also interested in the client-side "
"performance for the last request, you must call the "
"<methodname>timeSpentRenderingLastRequest()</methodname> before calling this "
"method."
msgstr ""
"与前面所说的获取总时间的方法一样, 如果你还关心最后一次请求的客户端性能, 你必"
"须在调用本方法之前调用 <methodname>timeSpentRenderingLastRequest()</"
"methodname> 方法."

#. Tag: methodname
#: chapter-testbench.xml:2127
#, no-c-format
msgid "totalTimeSpentRendering()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2129
#, no-c-format
msgid ""
"Returns the total time (in milliseconds) spent rendering the user interface "
"of the application on the client-side, that is, in the browser. This time "
"only passes when the browser is rendering after interacting with it through "
"the WebDriver. The timer is shared in the servlet session, so if you have, "
"for example, multiple portlets in the same application (session), their "
"execution times will be included in the same total."
msgstr ""
"返回应用程序客户端(也就是在浏览器中)描绘 UI 时消耗的总时间(毫秒单位). 只有在"
"通过 WebDriver 与浏览器交互, 并因此导致浏览器描绘 UI 界面时, 这个时间才会计"
"时. 计时器在 Servlet 的 Session 内共享, 因此, 比如说, 如果在同一个应用程序"
"(Session)之内, 你有多个 portlet, 那么它们的执行时间将被合计在一起."

#. Tag: methodname
#: chapter-testbench.xml:2141
#, no-c-format
msgid "timeSpentRenderingLastRequest()"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2143
#, no-c-format
msgid ""
"Returns the time (in milliseconds) spent rendering user interface of the "
"application after the last server request. Notice that not all user "
"interaction through the WebDriver cause server requests."
msgstr ""
"返回应用程序在最后一次服务器请求之后描绘 UI 时消耗的时间(毫秒单位). 注意, 通"
"过 WebDriver 发起的用户交互, 并不是全部都会导致服务器请求."

#. Tag: para
#: chapter-testbench.xml:2150
#, no-c-format
msgid ""
"If you also call the <methodname>timeSpentServicingLastRequest()</"
"methodname> or <methodname>totalTimeSpentServicingRequests()</methodname>, "
"you should do so before calling this method. The methods cause a server "
"request, which will zero the rendering time measured by this method."
msgstr ""
"如果你还调用 <methodname>timeSpentServicingLastRequest()</methodname> 方法或 "
"<methodname>totalTimeSpentServicingRequests()</methodname> 方法, 那么应该在本"
"方法之前调用这些方法(译注: 此处貌似写反了). 这些方法会导致一次服务器请求, 并"
"导致本方法测量的画面描绘时间变为 0."

#. Tag: para
#: chapter-testbench.xml:2162
#, no-c-format
msgid ""
"Generally, only interaction with fields in the <emphasis>immediate</"
"emphasis> mode cause server requests. This includes button clicks. Some "
"components, such as <classname>Table</classname>, also cause requests "
"otherwise, such as when loading data while scrolling. Some interaction could "
"cause multiple requests, such as when images are loaded from the server as "
"the result of user interaction."
msgstr ""
"一般来说, 只有与 <emphasis>立即</emphasis> 模式的 Field 组件交互时才会导致服"
"务器请求. 包括按钮的点击. 某些组件, 比如 <classname>Table</classname>, 也会导"
"致服务器请求, 比如表格滚动导致需要装载数据时. 某些交互会导致多次请求, 比如, "
"作为用户交互的结果, 导致需要从服务器装载图片."

#. Tag: para
#: chapter-testbench.xml:2171
#, no-c-format
msgid ""
"The following example is given in the <filename><link xlink:href=\"https://"
"github.com/vaadin/testbench-demo/blob/master/src/test/java/com/vaadin/"
"testbenchexample/VerifyExecutionTimeITCase.java\">VerifyExecutionTimeITCase."
"java</link></filename> file in the TestBench demo."
msgstr ""
"以下示例程序在 TestBench 示例程序的 <filename><link xlink:href=\"https://"
"github.com/vaadin/testbench-demo/blob/master/src/test/java/com/vaadin/"
"testbenchexample/VerifyExecutionTimeITCase.java\">VerifyExecutionTimeITCase."
"java</link></filename> 文件中."

#. Tag: programlisting
#: chapter-testbench.xml:2177
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Test\n"
"public void verifyServerExecutionTime() throws Exception {\n"
"    // Get start time on the server-side\n"
"    long currentSessionTime = testBench(getDriver())\n"
"            .totalTimeSpentServicingRequests();\n"
"\n"
"    // Interact with the application\n"
"    calculateOnePlusTwo();\n"
"\n"
"    // Calculate the passed processing time on the serve-side\n"
"    long timeSpentByServerForSimpleCalculation =\n"
"            testBench().totalTimeSpentServicingRequests() -\n"
"            currentSessionTime;\n"
"\n"
"    // Report the timing\n"
"    System.out.println(\"Calculating 1+2 took about \"\n"
"            + timeSpentByServerForSimpleCalculation\n"
"            + \"ms in servlets service method.\");\n"
"\n"
"    // Fail if the processing time was critically long\n"
"    if (timeSpentByServerForSimpleCalculation > 30) {\n"
"        fail(\"Simple calculation shouldn't take \" +\n"
"             timeSpentByServerForSimpleCalculation + \"ms!\");\n"
"    }\n"
"\n"
"    // Do the same with rendering time\n"
"    long totalTimeSpentRendering =\n"
"            testBench().totalTimeSpentRendering();\n"
"    System.out.println(\"Rendering UI took \"\n"
"            + totalTimeSpentRendering + \"ms\");\n"
"    if (totalTimeSpentRendering > 400) {\n"
"        fail(\"Rendering UI shouldn't take \"\n"
"               + totalTimeSpentRendering + \"ms!\");\n"
"    }\n"
"\n"
"    // A normal assertion on the UI state\n"
"    assertEquals(\"3.0\",\n"
"        $(TextFieldElement.class).first()\n"
"        .getAttribute(\"value\"));\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2183
#, no-c-format
msgid "Creating Maintainable Tests"
msgstr "创建可维护的测试程序"

#. Tag: para
#: chapter-testbench.xml:2185
#, no-c-format
msgid ""
"The first important rule in developing tests is to keep them readable and "
"maintainable. Otherwise, when the test fail, such as after refactoring the "
"application code, the developers get impatient in trying to understand them "
"to fix them, and easily disable them. Readability and maintainability can be "
"improved with the Page Object Pattern described below."
msgstr ""
"开发测试程序最重要的规则是, 保持代码可读, 可维护. 否则, 当测试失败时, 比如应"
"用程序代码重构之后, 开发者会觉得难以理解测试程序, 难以修复错误, 所以很容易禁"
"用这些测试程序. 可以使用页面对象模式(Page Object Pattern)来改进可读性和可维护"
"性, 详情将在下文中介绍."

#. Tag: para
#: chapter-testbench.xml:2193
#, no-c-format
msgid ""
"The second rule is to run the tests often. It is best to use a continuous "
"integration server to run them at least once a day, or preferably on every "
"commit."
msgstr ""
"第二条规则是, 应该经常运行测试程序. 最好使用一个持续集成服务器运行测试程序, "
"运行的频度至少每天一次, 如果每次代码提交之后都运行测试则更好."

#. Tag: title
#: chapter-testbench.xml:2200
#, no-c-format
msgid "Increasing Selector Robustness"
msgstr "增强选择器的健壮性"

#. Tag: para
#: chapter-testbench.xml:2202
#, no-c-format
msgid ""
"Robustness of tests is important for avoiding failures because of irrelevant "
"changes in the HTML DOM tree. Different selectors have differences in their "
"robustness and it depends on how they are used."
msgstr ""
"为了避免 HTML DOM 树结构中的无关变化导致测试失败, 保证测试程序的健壮性是很重"
"要的. 不同的选择器的健壮性是不同的, 也取决于如何使用这些选择器."

#. Tag: para
#: chapter-testbench.xml:2208
#, no-c-format
msgid ""
"The ElementQuery API uses the logical widget hierarchy to find the HTML "
"elements, instead of the exact HTML DOM structure. This makes them somewhat "
"robust, although still vulnerable to irrelevant changes in the exact "
"component hierarchy of the UI. Also, if you internationalize the "
"application, selecting components by their caption is not viable."
msgstr ""
"ElementQuery API 使用 Widget 的逻辑层次结构来查找对应的 HTML 元素, 而不是使用"
"实际的 HTML DOM 结构. 这种方式使得它比较健壮, 但仍然会受到 UI 中组件层级结构"
"变化的影响. 而且, 如果你对应用程序进行了国际化, 那么就无法通过组件的标题文字"
"来查找它了."

#. Tag: para
#: chapter-testbench.xml:2216
#, no-c-format
msgid ""
"The low-level XPath selector can be highly vulnerable to changes in the DOM "
"path, especially if the path is given down from the body element of the "
"page. The selector is, however, very flexible, and can be used in robust "
"ways, for example, by selecting by HTML element and a CSS class name or an "
"attribute value. You can likewise use a CSS selector to select specific "
"components by CSS class in a robust way."
msgstr ""
"低级的 XPath 选择器极易收到 DOM 路径变化的影响, 尤其是查询路径从页面的 body "
"元素开始时. 但是这个选择器非常灵活, 也有一种健壮的使用方式, 比如, 可以使用 "
"HTML 元素和 CSS 类名或属性名来进行选择. 你可以象 CSS 选择器那样, 以一种健壮的"
"方式, 使用 CSS 类来选择特定的组件."

#. Tag: title
#: chapter-testbench.xml:2226
#, no-c-format
msgid "Using Component IDs to Increase Robustness"
msgstr "使用组件 ID 增强测试程序健壮性"

#. Tag: para
#: chapter-testbench.xml:2228
#, no-c-format
msgid ""
"To make UIs more robust for testing, you can set a unique "
"<emphasis>component ID</emphasis> for specific components with "
"<methodname>setId()</methodname>, as described in more detail in <xref "
"linkend=\"testbench.selectors.id\"/>."
msgstr ""
"为了使 UI 在测试中更加健壮, 你可以使用 <methodname>setId()</methodname> 方"
"法, 为特定的组件设置唯一的 <emphasis>组件 ID</emphasis>, 详情请参见 <xref "
"linkend=\"testbench.selectors.id\"/>."

#. Tag: para
#: chapter-testbench.xml:2235
#, no-c-format
msgid ""
"Let us consider the following application, in which we set the IDs using a "
"hierarchical notation to ensure that they are unique; in a more modular case "
"you could consider a different strategy."
msgstr ""
"让我们来考虑一下以下应用程序, 在这个应用程序中, 我们为组件设置一种层级式的 "
"ID, 以保证 ID 唯一; 在更加模块化的情况下, 你也可以考虑使用其他方案."

#. Tag: programlisting
#: chapter-testbench.xml:2241
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class UIToBeTested extends UI {\n"
"    @Override\n"
"    protected void init(VaadinRequest request) {\n"
"        setId(\"myui\");\n"
"        \n"
"        final VerticalLayout content = new VerticalLayout();\n"
"        content.setMargin(true);\n"
"        content.setId(\"myui.content\");\n"
"        setContent(content);\n"
"        \n"
"        // Create a button\n"
"        Button button = new Button(\"Push Me!\");\n"
"        \n"
"        // Optional: give the button a unique ID\n"
"        button.setId(\"myui.content.pushmebutton\");\n"
"\n"
"        content.addComponent(button);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2243
#, no-c-format
msgid ""
"After preparing the application this way, you can find the element by the "
"component ID with the <methodname>id()</methodname> query terminator."
msgstr ""
"用这种方式准备好应用程序之后, 你就可以使用 <methodname>id()</methodname> 查询"
"结束符, 通过组件 ID 来查找页面元素了."

#. Tag: programlisting
#: chapter-testbench.xml:2249
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Click the button\n"
"ButtonElement button =\n"
"    $(ButtonElement.class).id(\"myui.content.pushmebutton\");\n"
"button.click();]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2251
#, no-c-format
msgid ""
"The IDs are HTML element <literal>id</literal> attributes and must be unique "
"in the UI, as well as in the page in which the UI is running, in case the "
"page has other content than the particular UI instance. In case there could "
"be multiple UIs, you can include a UI part in the ID, as we did in the "
"example above."
msgstr ""
"组件 ID 就是 HTML 元素的 <literal>id</literal> 属性, 在整个 UI 内必须是唯一"
"的, 如果 HTML 页面除这个 UI 之外还包含其他内容, 那么 ID 在整个 HTML 页面之内"
"也必须是唯一的. 如果存在多个 UI, 你可以在 ID 中包含 UI 名前缀, 上例中我们就是"
"这样做的."

#. Tag: title
#: chapter-testbench.xml:2261
#, no-c-format
msgid "Using CSS Class Names to Increase Robustness"
msgstr "使用 CSS 类名增强测试程序健壮性"

#. Tag: para
#: chapter-testbench.xml:2263
#, no-c-format
msgid ""
"As a similar method to using component IDs, you can add CSS class names to "
"components with <methodname>addStyleName()</methodname>. This enables "
"matching them with the <methodname>findElement(By.className())</methodname> "
"selector, as described in <xref linkend=\"testbench.selectors.css\"/>. You "
"can use the selector in element queries. Unlike IDs, CSS class names do not "
"need to be unique, so an HTML page can have many elements with the same CSS "
"class."
msgstr ""
"与使用组件 ID 的方法类似, 你可以使用 <methodname>addStyleName()</methodname> "
"方法为组件添加 CSS 类名. 然后就可以使用 <methodname>findElement(By."
"className())</methodname> 选择器来查找这些组件, 详情请参见 <xref linkend="
"\"testbench.selectors.css\"/>. 你可以在元素查询中使用这种选择器. 与 ID 不同, "
"CSS 类名不必是唯一的, 因此一个 HTML 页面内可以包含多个元素带有相同的 CSS 类."

#. Tag: para
#: chapter-testbench.xml:2274
#, no-c-format
msgid "You can use CSS class names also in XPath selectors."
msgstr "你也可以在 XPath 选择器中使用 CSS 类名."

#. Tag: title
#: chapter-testbench.xml:2281
#, no-c-format
msgid "The Page Object Pattern"
msgstr "页面对象模式(Page Object Pattern)"

#. Tag: para
#: chapter-testbench.xml:2283
#, no-c-format
msgid ""
"The Page Object Pattern aims to simplify and modularize testing application "
"views. The pattern follows the design principle of <link xlink:href=\"http://"
"en.wikipedia.org/wiki/Separation_of_concerns\">separation of concerns</"
"link>, to handle different concerns in separate modules, while hiding "
"information irrelevant to other tests by encapsulation."
msgstr ""
"页面对象模型的目标是使应用程序视图测试更加简单化和模块化. 这个模式遵循 <link "
"xlink:href=\"http://en.wikipedia.org/wiki/Separation_of_concerns\">关注点分离"
"(separation of concerns)</link> 原则, 通过不同的模块来处理关注的不同问题, 并"
"将其他测试不应该知道的信息封装起来."

#. Tag: title
#: chapter-testbench.xml:2292
#, no-c-format
msgid "Defining a Page Object"
msgstr "定义一个页面对象"

#. Tag: para
#: chapter-testbench.xml:2294
#, no-c-format
msgid ""
"A <emphasis>page object</emphasis> has methods to interact with a view or a "
"sub-view, and to retrieve values in the view. You also need a method to open "
"the page and navigate to the proper view."
msgstr ""
"一个 <emphasis>页面对象</emphasis> 带有一些方法, 可以与视图或子视图交互, 还可"
"以取得视图中的数值. 你还需要一个方法打开页面并跳转到适当的视图."

#. Tag: para
#: chapter-testbench.xml:2300 chapter-testbench.xml:2338
#: chapter-testbench.xml:2449 chapter-testbench.xml:2590
#, no-c-format
msgid "For example:"
msgstr "比如:"

#. Tag: programlisting
#: chapter-testbench.xml:2304
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[public class CalculatorPageObject\n"
"       extends TestBenchTestCase {\n"
"    @FindBy(id = \"button_=\")\n"
"    private WebElement equals;\n"
"    ...\n"
"\n"
"    /**\n"
"     * Opens the URL where the calculator resides.\n"
"     */\n"
"    public void open() {\n"
"        getDriver().get(\n"
"            \"http://localhost:8080/?restartApplication\");\n"
"    }\n"
"\n"
"    /**\n"
"     * Pushes buttons on the calculator\n"
"     *\n"
"     * @param buttons the buttons to push: \"123+2\", etc.\n"
"     * @return The same instance for method chaining.\n"
"     */\n"
"    public CalculatorPageObject enter(String buttons) {\n"
"        for (char numberChar : buttons.toCharArray()) {\n"
"            pushButton(numberChar);\n"
"        }\n"
"        return this;\n"
"    }\n"
"\n"
"    /**\n"
"     * Pushes the specified button.\n"
"     *\n"
"     * @param button The character of the button to push.\n"
"     */\n"
"    private void pushButton(char button) {\n"
"        getDriver().findElement(\n"
"            By.id(\"button_\" + button)).click();\n"
"    }\n"
"\n"
"    /**\n"
"     * Pushes the equals button and returns the contents\n"
"     * of the calculator \"display\".\n"
"     *\n"
"     * @return The string (number) shown in the \"display\"\n"
"     */\n"
"    public String getResult() {\n"
"        equals.click();\n"
"        return display.getText();\n"
"    }\n"
"\n"
"    ...\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2308
#, no-c-format
msgid "Finding Member Elements By ID"
msgstr "通过 ID 查找页面对象中的成员元素"

#. Tag: para
#: chapter-testbench.xml:2310
#, no-c-format
msgid ""
"If you have <classname>WebElement</classname> members annotated with "
"<classname>@FindBy</classname>, they can be automatically filled with the "
"HTML element matching the given component ID, as if done with "
"<literal>driver.findElement(By.id(fieldname))</literal>. To do so, you need "
"to create the page object with <classname>PageFactory</classname> as is done "
"in the following test setup:"
msgstr ""
"如果页面对象中存在 <classname>WebElement</classname> 类型的成员变量, 并使用 "
"<classname>@FindBy</classname> 注解标注它, 那么这些成员变量会被自动地设置为与"
"指定的组件 ID 匹配的 HTML 元素, 和使用 <literal>driver.findElement(By."
"id(fieldname))</literal> 的结果一样. 要执行这个页面元素的自动查找工作, 你需要"
"使用 <classname>PageFactory</classname> 来创建页面对象, 如下例:"

#. Tag: programlisting
#: chapter-testbench.xml:2319
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class PageObjectExampleITCase {\n"
"    private CalculatorPageObject calculator;\n"
"\n"
"    @Before\n"
"    public void setUp() throws Exception {\n"
"        driver = TestBench.createDriver(new FirefoxDriver());\n"
"\n"
"        // Use PageFactory to automatically initialize fields\n"
"        calculator = PageFactory.initElements(driver,\n"
"                         CalculatorPageObject.class);\n"
"    }\n"
"    ...]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2321
#, no-c-format
msgid ""
"The members must be typed dynamically as <classname>WebElement</classname>, "
"but you can wrap them to a typed element class with the <methodname>wrap()</"
"methodname> method:"
msgstr ""
"页面对象中的成员元素必须定义为 <classname>WebElement</classname> 类型, 但你可"
"以使用 <methodname>wrap()</methodname> 方法将它转换为一个具体的元素类型:"

#. Tag: programlisting
#: chapter-testbench.xml:2327
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[ButtonElement equals = equalsElement."
"wrap(ButtonElement.class);]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2331
#, no-c-format
msgid "Using a Page Object"
msgstr "使用页面对象"

#. Tag: para
#: chapter-testbench.xml:2333
#, no-c-format
msgid ""
"Test cases can use the page object methods at business logic level, without "
"knowing about the exact structure of the views."
msgstr ""
"在测试用例中可以在业务逻辑层使用页面对象的方法, 而不必意识到视图的具体组成结"
"构."

#. Tag: programlisting
#: chapter-testbench.xml:2342
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@Test\n"
"public void testAddCommentRowToLog() throws Exception {\n"
"    calculator.open();\n"
"\n"
"    // Just do some math first\n"
"    calculator.enter(\"1+2\");\n"
"\n"
"    // Verify the result of the calculation\n"
"    assertEquals(\"3.0\", calculator.getResult());\n"
"\n"
"    ...\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2346
#, no-c-format
msgid "The Page Object Example"
msgstr "页面对象示例"

#. Tag: para
#: chapter-testbench.xml:2348
#, no-c-format
msgid ""
"You can find the complete example of the Page Object Pattern in the "
"<filename>src/test/java/com/vaadin/testbenchexample/pageobjectexample/</"
"filename> folder in the TestBench Demo. The "
"<filename>PageObjectExampleITCase.java</filename> runs tests on the Calc UI "
"(also included in the example sources), using the page objects to interact "
"with the different parts of the UI and to check the results."
msgstr ""
"页面对象模式的完整的例子可以在 TestBench 示例程序的 <filename>src/test/java/"
"com/vaadin/testbenchexample/pageobjectexample/</filename> 文件夹中找到. "
"<filename>PageObjectExampleITCase.java</filename> 会对 Calc UI (也包含在示例"
"程序源代码中) 运行测试程序, 测试程序使用页面对象与 UI 中的不同部分进行交互, "
"并检查运行结果."

#. Tag: para
#: chapter-testbench.xml:2358
#, no-c-format
msgid ""
"The page objects included in the <filename>pageobjects</filename> subfolder "
"are as follows:"
msgstr "子文件夹 <filename>pageobjects</filename> 中包含的页面对象如下:"

#. Tag: para
#: chapter-testbench.xml:2364
#, no-c-format
msgid ""
"The <classname>CalculatorPageObject</classname> (as outlined in the example "
"code above) has methods to click the buttons in the calculator and the "
"retrieve the result shown in the \"display\"."
msgstr ""
"<classname>CalculatorPageObject</classname> (前文的示例代码已经列举了它的大致"
"内容), 其中存在一些方法用来点击计算器中的按钮, 以及取得 \"display\" 中显示的"
"计算结果."

#. Tag: para
#: chapter-testbench.xml:2369
#, no-c-format
msgid ""
"The <classname>LogPageObject</classname> can retrieve the content of the log "
"entries in the log table, and right-click them to open the comment sub-"
"window."
msgstr ""
"<classname>LogPageObject</classname> 可以取得日志 Table 中日志条目的内容, 并"
"在日志条目上点击鼠标右键, 打开注释子窗口."

#. Tag: para
#: chapter-testbench.xml:2373
#, no-c-format
msgid ""
"The <classname>AddComment</classname> can enter a comment string in the "
"comment editor sub-window and submit it (click the <guilabel>Add</guilabel> "
"button)."
msgstr ""
"<classname>AddComment</classname> 可以在注释编辑子窗口中输入一个注释字符串, "
"并提交(点击 <guilabel>Add</guilabel> 按钮)."

#. Tag: title
#: chapter-testbench.xml:2382
#, no-c-format
msgid "Taking and Comparing Screenshots"
msgstr "屏幕截图的取得和比较"

#. Tag: para
#: chapter-testbench.xml:2384
#, no-c-format
msgid ""
"You can take and compare screenshots with reference screenshots taken "
"earlier. If there are differences, you can fail the test case."
msgstr ""
"你可以取得屏幕截图, 并与之前取得的参照截图进行比较. 如果二者存在不同, 你可以"
"将这个测试用例判定为失败."

#. Tag: title
#: chapter-testbench.xml:2390
#, no-c-format
msgid "Screenshot Parameters"
msgstr "屏幕截图参数"

#. Tag: para
#: chapter-testbench.xml:2392
#, no-c-format
msgid ""
"The screenshot configuration parameters are defined with static methods in "
"the <classname>com.vaadin.testbench.Parameters</classname> class."
msgstr ""
"屏幕截图参数使用 <classname>com.vaadin.testbench.Parameters</classname> 类中"
"的静态方法来设置."

#. Tag: term
#: chapter-testbench.xml:2399
#, no-c-format
msgid ""
"<parameter>screenshotErrorDirectory</parameter> (default: <literal>null</"
"literal>)"
msgstr ""
"<parameter>screenshotErrorDirectory</parameter> (默认值: <literal>null</"
"literal>)"

#. Tag: listitem
#: chapter-testbench.xml:2400
#, no-c-format
msgid ""
"Defines the directory where screenshots for failed tests or comparisons are "
"stored."
msgstr "指定一个目录, 用于保存测试失败或比较失败时的屏幕截图."

#. Tag: term
#: chapter-testbench.xml:2406
#, no-c-format
msgid ""
"<parameter>screenshotReferenceDirectory</parameter> (default: <literal>null</"
"literal>)"
msgstr ""
"<parameter>screenshotReferenceDirectory</parameter> (默认值: <literal>null</"
"literal>)"

#. Tag: listitem
#: chapter-testbench.xml:2407
#, no-c-format
msgid ""
"Defines the directory where the reference images for screenshot comparison "
"are stored."
msgstr "指定一个目录, 用于保存屏幕截图比较时使用的参照图片."

#. Tag: term
#: chapter-testbench.xml:2413
#, no-c-format
msgid ""
"<parameter>screenshotComparisonTolerance</parameter> (default: "
"<literal>0.01</literal>)"
msgstr ""
"<parameter>screenshotComparisonTolerance</parameter> (默认值: <literal>0.01</"
"literal>)"

#. Tag: listitem
#: chapter-testbench.xml:2414
#, no-c-format
msgid ""
"Screen comparison is usually not done with exact pixel values, because "
"rendering in browser often has some tiny inconsistencies. Also image "
"compression may cause small artifacts."
msgstr ""
"屏幕截图通常并不使用完全一致的像素值进行比较, 因为在浏览器内显示时经常会存在"
"一些微小的偏差. 而且图片的压缩也会导致一些变化."

#. Tag: term
#: chapter-testbench.xml:2421
#, no-c-format
msgid ""
"<parameter>screenshotComparisonCursorDetection</parameter> (default: "
"<literal>false</literal>)"
msgstr ""
"<parameter>screenshotComparisonCursorDetection</parameter> (默认值: "
"<literal>false</literal>)"

#. Tag: listitem
#: chapter-testbench.xml:2422
#, no-c-format
msgid ""
"Some field component get a blinking cursor when they have the focus. The "
"cursor can cause unnecessary failures depending on whether the blink happens "
"to make the cursor visible or invisible when taking a screenshot. This "
"parameter enables cursor detection that tries to minimize these failures."
msgstr ""
"有些 Field 组件获得输入焦点时会出现闪烁的光标. 光标可能会导致不必要的比较失"
"败, 因为光标会闪烁, 使得截取屏幕时光标可能正好可见也可能正好不可见. 这个参数"
"启动光标检测功能, 尽量减少光标导致的比较失败."

#. Tag: term
#: chapter-testbench.xml:2431
#, no-c-format
msgid "<parameter>maxScreenshotRetries</parameter> (default: 2)"
msgstr "<parameter>maxScreenshotRetries</parameter> (默认值: 2)"

#. Tag: listitem
#: chapter-testbench.xml:2432
#, no-c-format
msgid ""
"Sometimes a screenshot comparison may fail because the screen rendering has "
"not yet finished, or there is a blinking cursor that is different from the "
"reference screenshot. For these reasons, Vaadin TestBench retries the "
"screenshot comparison for a number of times defined with this parameter."
msgstr ""
"有时屏幕截图的比较可能会失败, 因为屏幕描绘还未结束, 或者屏幕截图中存在一个闪"
"烁的光标, 与参照的屏幕截图不一致. 由于这些原因, Vaadin TestBench 会重试屏幕截"
"图比较, 重试次数由这个参数指定."

#. Tag: term
#: chapter-testbench.xml:2441
#, no-c-format
msgid ""
"<parameter>screenshotRetryDelay</parameter> (default: <literal>500</literal>)"
msgstr ""
"<parameter>screenshotRetryDelay</parameter> (默认值: <literal>500</literal>)"

#. Tag: listitem
#: chapter-testbench.xml:2442
#, no-c-format
msgid ""
"Delay in milliseconds for making a screenshot retry when a comparison fails."
msgstr ""
"当屏幕截图比较失败时, 会重试. 这个参数指定重试之前的时间延迟, 单位为毫秒."

#. Tag: programlisting
#: chapter-testbench.xml:2453
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Before\n"
"public void setUp() throws Exception {\n"
"    Parameters.setScreenshotErrorDirectory(\n"
"        \"screenshots/errors\");\n"
"    Parameters.setScreenshotReferenceDirectory(\n"
"        \"screenshots/reference\");\n"
"    Parameters.setMaxScreenshotRetries(2);\n"
"    Parameters.setScreenshotComparisonTolerance(1.0);\n"
"    Parameters.setScreenshotRetryDelay(10);\n"
"    Parameters.setScreenshotComparisonCursorDetection(true);\n"
"    Parameters.setCaptureScreenshotOnFailure(true);\n"
"}\n"
"]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2458
#, no-c-format
msgid "Taking Screenshots on Failure"
msgstr "测试失败时取得屏幕截图"

#. Tag: para
#: chapter-testbench.xml:2462
#, no-c-format
msgid ""
"Vaadin TestBench can take screenshots automatically when a test fails. To "
"enable the feature, you need to include the "
"<classname>ScreenshotOnFailureRule</classname> JUnit rule with a member "
"variable annotated with <classname>@Rule</classname> in the test case as "
"follows:"
msgstr ""
"Vaadin TestBench 可以在测试失败时自动取得屏幕截图. 要启用这个功能, 你需要在测"
"试用例中, 使用一个由 <classname>@Rule</classname> 注解标注的成员变量, 来包含 "
"<classname>ScreenshotOnFailureRule</classname> JUnit 规则, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:2470
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@Rule\n"
"public ScreenshotOnFailureRule screenshotOnFailureRule =\n"
"    new ScreenshotOnFailureRule(this, true);]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2472
#, no-c-format
msgid ""
"Notice that you must not call <methodname>quit()</methodname> for the driver "
"in the <literal>@After</literal> method, as that would close the driver "
"before the rule takes the screenshot."
msgstr ""
"注意, 你一定不能在 <literal>@After</literal> 方法中对浏览器驱动调用 "
"<methodname>quit()</methodname> 方法, 因为这会导致在 JUnit 规则取得屏幕截图之"
"前就关闭了浏览器驱动."

#. Tag: para
#: chapter-testbench.xml:2478
#, no-c-format
msgid ""
"The screenshots are written to the error directory defined with the "
"<parameter>screenshotErrorDirectory</parameter> parameter. You can configure "
"it in the test case setup as follows:"
msgstr ""
"屏幕截图将被写入 <parameter>screenshotErrorDirectory</parameter> 参数指定的错"
"误目录. 你可以在测试用例的设置方法中配置这个参数, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:2484
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Before\n"
"public void setUp() throws Exception {\n"
"    Parameters.setScreenshotErrorDirectory(\"screenshots/errors\");\n"
"    ...\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2488
#, no-c-format
msgid "Taking Screenshots for Comparison"
msgstr "取得用于比较的屏幕截图"

#. Tag: para
#: chapter-testbench.xml:2490
#, no-c-format
msgid ""
"Vaadin TestBench allows taking screenshots of the web browser window with "
"the <methodname>compareScreen()</methodname> command in the "
"<classname>TestBenchCommands</classname> interface. The method has a number "
"of variants."
msgstr ""
"Vaadin TestBench 可以使用 <classname>TestBenchCommands</classname> 接口中的 "
"<methodname>compareScreen()</methodname> 命令取得 Web 浏览器窗口的屏幕截图. "
"这个方法存在很多变体."

#. Tag: para
#: chapter-testbench.xml:2497
#, no-c-format
msgid ""
"The <methodname>compareScreen(<classname>File</classname>)</methodname> "
"takes a <classname>File</classname> object pointing to the reference image. "
"In this case, a possible error image is written to the error directory with "
"the same file name. You can get a file object to a reference image with the "
"static <methodname>ImageFileUtil.getReferenceScreenshotFile()</methodname> "
"helper method."
msgstr ""
"<methodname>compareScreen(<classname>File</classname>)</methodname> 方法的参"
"数是一个 <classname>File</classname> 对象, 指向比较用的参照图片. 这种情况下, "
"错误图片会被使用同样的文件名写入到错误目录中. 你可以使用静态的帮助方法 "
"<methodname>ImageFileUtil.getReferenceScreenshotFile()</methodname>, 得到指向"
"参照图片的 File 对象."

#. Tag: programlisting
#: chapter-testbench.xml:2507
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[assertTrue(\"Screenshots differ\",\n"
"           testBench(driver).compareScreen(\n"
"               ImageFileUtil.getReferenceScreenshotFile(\n"
"                   \"myshot.png\")));]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2509
#, no-c-format
msgid ""
"The <methodname>compareScreen(<classname>String</classname>)</methodname> "
"takes a base name of the screenshot. It is appended with browser identifier "
"and the file extension."
msgstr ""
"<methodname>compareScreen(<classname>String</classname>)</methodname> 方法的"
"参数是屏幕截图的基础文件名(base name). 这个基础文件名再加上浏览器标识符和文件"
"扩展名, 就是比较用的参照图片的实际文件名."

#. Tag: programlisting
#: chapter-testbench.xml:2515
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[assertTrue(testBench(driver)."
"compareScreen(\"tooltip\"));]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2517
#, no-c-format
msgid ""
"The <methodname>compareScreen(<classname>BufferedImage</classname>, "
"<classname>String</classname>)</methodname> allows keeping the reference "
"image in memory. An error image is written to a file with a name determined "
"from the base name given as the second parameter."
msgstr ""
"<methodname>compareScreen(<classname>BufferedImage</classname>, "
"<classname>String</classname>)</methodname> 可以与保存在内存中的参照图片进行"
"比较. 错误图片会被写入到文件, 文件名根据第二个参数指定的基础文件名自动决定."

#. Tag: para
#: chapter-testbench.xml:2524
#, no-c-format
msgid ""
"Screenshots taken with the <methodname>compareScreen()</methodname> method "
"are compared to a reference image stored in the reference image folder. If "
"differences are found (or the reference image is missing), the comparison "
"method returns <literal>false</literal> and stores the screenshot in the "
"error folder. It also generates an HTML file that highlights the differing "
"regions."
msgstr ""
"使用 <methodname>compareScreen()</methodname> 方法取得的屏幕截图将与存储在参"
"照图片文件夹内的参照图片进行比较. 如果发现图片中存在差异(或者参照图片不存"
"在), 比较方法将返回 <literal>false</literal>, 并将屏幕截图保存到错误文件夹"
"中. 比较方法还会产生一个 HTML 文件, 将图片中存在差异的区域高亮显示."

#. Tag: title
#: chapter-testbench.xml:2534
#, no-c-format
msgid "Screenshot Comparison Error Images"
msgstr "屏幕截图比较的错误图片"

#. Tag: para
#: chapter-testbench.xml:2536
#, no-c-format
msgid ""
"Screenshots with errors are written to the error folder, which is defined "
"with the <parameter>screenshotErrorDirectory</parameter> parameter described "
"in <xref linkend=\"testbench.screenshots.parameters\"/>."
msgstr ""
"错误情况下的屏幕截图会被写入到错误文件夹中, 这个文件夹的路径由 "
"<parameter>screenshotErrorDirectory</parameter> 参数指定, 详情请参见 <xref "
"linkend=\"testbench.screenshots.parameters\"/>."

#. Tag: para
#: chapter-testbench.xml:2543
#, no-c-format
msgid ""
"For example, the error caused by a missing reference image could be written "
"to <filename>screenshot/errors/tooltip_firefox_12.0.png</filename>. The "
"image is shown in <xref linkend=\"figure.testbench.screenshot.comparison."
"error-images.calc\"/>."
msgstr ""
"比如, 由于参照图片不存在导致的错误可能被写入到 <filename>screenshot/errors/"
"tooltip_firefox_12.0.png</filename> 文件中. 图片见 <xref linkend=\"figure."
"testbench.screenshot.comparison.error-images.calc\"/>."

#. Tag: title
#: chapter-testbench.xml:2552
#, no-c-format
msgid "A screenshot taken by a test run"
msgstr "测试程序运行中取得的屏幕截图"

#. Tag: para
#: chapter-testbench.xml:2563
#, no-c-format
msgid ""
"Screenshots cover the visible page area in the browser. The size of the "
"browser is therefore relevant for screenshot comparison. The browser is "
"normally sized with a predefined default size. You can set the size of the "
"browser window in a couple of ways. You can set the size of the browser "
"window with, for example, <literal>driver.manage().window().setSize(new "
"Dimension(1024, 768));</literal> in the <literal>@Before</literal> method. "
"The size includes any browser chrome, so the actual screenshot size will be "
"smaller. To set the actual view area, you can use <literal>TestBenchCommands."
"resizeViewPortTo(1024, 768)</literal>."
msgstr ""
"屏幕截图包括浏览器内页面的可见区域. 因此屏幕截图的比较也与浏览器的尺寸相关. "
"浏览器通常会被调整为预定义的默认尺寸. 你可以通过很多方法设置浏览器窗口的尺"
"寸. 比如, 可以在 <literal>@Before</literal> 方法内通过 <literal>driver."
"manage().window().setSize(new Dimension(1024, 768));</literal> 来设置. 这个尺"
"寸包含浏览器本身的窗口框架, 因此实际取得的屏幕截图尺寸会更小一些. 如果要设置"
"实际视图区域的尺寸, 你可以使用 <literal>TestBenchCommands."
"resizeViewPortTo(1024, 768)</literal> 方法."

#. Tag: title
#: chapter-testbench.xml:2578
#, no-c-format
msgid "Reference Images"
msgstr "参照图片"

#. Tag: para
#: chapter-testbench.xml:2580
#, no-c-format
msgid ""
"Reference images are expected to be found in the reference image folder, as "
"defined with the <parameter>screenshotReferenceDirectory</parameter> "
"parameter described in <xref linkend=\"testbench.screenshots.parameters\"/>. "
"To create a reference image, just copy a screenshot from the "
"<filename>errors/</filename> directory to the <filename>reference/</"
"filename> directory."
msgstr ""
"参照图片是应该存在于参照图片文件夹内, 文件夹路径由 "
"<parameter>screenshotReferenceDirectory</parameter> 参数指定, 详情请参见 "
"<xref linkend=\"testbench.screenshots.parameters\"/>. 要创建参照图片, 只需要"
"将屏幕截图从 <filename>errors/</filename> 文件夹复制到 <filename>reference/</"
"filename> 文件夹即可."

#. Tag: screen
#: chapter-testbench.xml:2594
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>cp</command> <parameter>screenshot/errors/"
"tooltip_firefox_12.0.png</parameter> <parameter>screenshot/reference/</"
"parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2596
#, no-c-format
msgid ""
"Now, when the proper reference image exists, rerunning the test outputs "
"success:"
msgstr ""
"现在正确的参照图片已经存在了, 所以再次运行测试程序会输出测试成功的信息:"

#. Tag: screen
#: chapter-testbench.xml:2601
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>java</command> ...\n"
"JUnit version 4.5\n"
".\n"
"Time: 18.222\n"
"\n"
"OK (1 test)"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:2622
#, no-c-format
msgid "Masking Screenshots"
msgstr "屏幕截图的遮蔽(Mask)"

#. Tag: para
#: chapter-testbench.xml:2624
#, no-c-format
msgid ""
"You can make masked screenshot comparison with reference images that have "
"non-opaque regions. Non-opaque pixels in the reference image, that is, ones "
"with less than 1.0 value in the alpha channel, are ignored in the screenshot "
"comparison."
msgstr ""
"屏幕截图比较时, 你可以使用带透明区域的参照图片来遮蔽(Mask)其中一部分. 参照图"
"片中的透明像素(也就是 Alpha 通道值小于 1.0 的像素), 在屏幕截图比较中将被忽略."

#. Tag: para
#: chapter-testbench.xml:2631
#, no-c-format
msgid ""
"Please see the <filename>ScreenshotITCase.java</filename> example in the "
"TestBench Demo for an example of using masked screenshots. The "
"<filename>example/Screenshot_Comparison_Tests.pdf</filename> document "
"describes how to enable the example and how to create the screenshot masks "
"in an image editor."
msgstr ""
"关于使用带遮蔽的屏幕截图的示例, 请 TestBench 示例程序中的 "
"<filename>ScreenshotITCase.java</filename> 示例程序. <filename>example/"
"Screenshot_Comparison_Tests.pdf</filename> 文档介绍了如何启用这个示例程序, 以"
"及如何使用图片编辑器来创建带遮蔽的屏幕截图."

#. Tag: title
#: chapter-testbench.xml:2641
#, no-c-format
msgid "Visualization of Differences in Screenshots with Highlighting"
msgstr "通过高亮度来显示屏幕截图中的差异部分"

#. Tag: para
#: chapter-testbench.xml:2643
#, no-c-format
msgid ""
"Vaadin TestBench supports advanced difference visualization between a "
"captured screenshot and the reference image. A difference report is written "
"to a HTML file that has the same name as the failed screenshot, but with "
"<filename>.html</filename> suffix. The reports are written to the same "
"<filename>errors/</filename> folder as the screenshots from the failed tests."
msgstr ""
"Vaadin TestBench 支持一种高级的显示方式, 可以显示出抓取的屏幕截图与参照图片之"
"间的差异. 差异报告会被写入到一个 HTML 文件中, 文件名与测试失败的屏幕截图一"
"样, 但使用 <filename>.html</filename> 扩展名. 差异报告与测试失败的屏幕截图一"
"样, 会写入到同一个 <filename>errors/</filename> 文件夹中."

#. Tag: para
#: chapter-testbench.xml:2652
#, no-c-format
msgid ""
"The differences in the images are highlighted with blue rectangles. Moving "
"the mouse pointer over a square shows the difference area as it appears in "
"the reference image. Clicking the image switches the entire view to the "
"reference image and back. Text \"<guilabel>Image for this run</guilabel>\" "
"is displayed in the top-left corner of the screenshot to distinguish it from "
"the reference image."
msgstr ""
"图片中存在差异的部分会使用蓝色方框高亮标出. 将鼠标指针移动到某个差异区域, 将"
"会显示出这个区域在参照图片中对应区域的内容. 点击图片会将整个图片切换到参照图"
"片, 再次点击将切换回实际的屏幕截图. 在屏幕截图的左上角会显示会显示文字 "
"\"<guilabel>Image for this run</guilabel>\", 以便与参照图片区别开."

#. Tag: para
#: chapter-testbench.xml:2661
#, no-c-format
msgid ""
"shows a difference report with one difference between the visualized "
"screenshot (bottom) and the reference image (top)."
msgstr ""
"显示了一个差异报告, 其中存在一个差异区域, 屏幕截图显示在下方, 参照图片显示在"
"上方."

#. Tag: title
#: chapter-testbench.xml:2669
#, no-c-format
msgid "The reference image and a highlighted error image"
msgstr "参照图片和被高亮显示的错误图片"

#. Tag: title
#: chapter-testbench.xml:2691
#, no-c-format
msgid "Practices for Handling Screenshots"
msgstr "处理屏幕截图时的一些实际经验"

#. Tag: para
#: chapter-testbench.xml:2693
#, no-c-format
msgid ""
"Access to the screenshot reference image directory should be arranged so "
"that a developer who can view the results can copy the valid images to the "
"reference directory. One possibility is to store the reference images in a "
"version control system and check-out them to the <filename>reference/</"
"filename> directory."
msgstr ""
"屏幕截图的参照图片文件夹需要设置好读写权限, 以便开发者可以查看测试程序的运行"
"结果, 并将正确的图片复制到参照图片文件夹中. 一种可行的方案是将参照图片保存到"
"一个版本管理系统内, 再将它们 check-out 到 <filename>reference/</filename> 文"
"件夹中."

#. Tag: para
#: chapter-testbench.xml:2701
#, no-c-format
msgid ""
"A build system or a continuous integration system can be configured to "
"automatically collect and store the screenshots as build artifacts."
msgstr ""
"在构建系统或持续集成系统中, 可以配置一个 Build Artifact, 自动地收集和保存屏幕"
"截图."

#. Tag: title
#: chapter-testbench.xml:2709
#, no-c-format
msgid "Known Compatibility Problems"
msgstr "已知的兼容性问题"

#. Tag: para
#: chapter-testbench.xml:2713
#, no-c-format
msgid "Screenshots when running Internet Explorer 9 in Compatibility Mode"
msgstr "Internet Explorer 9 运行在兼容模式时的屏幕截图"

#. Tag: para
#: chapter-testbench.xml:2715
#, no-c-format
msgid ""
"Internet Explorer prior to version 9 adds a two-pixel border around the "
"content area. Version 9 no longer does this and as a result screenshots "
"taken using Internet Explorer 9 running in compatibility mode (IE7/IE8) will "
"include the two pixel border, contrary to what the older versions of "
"Internet Explorer do."
msgstr ""
"Internet Explorer 在版本 9 之前会在内容区域周围加上 2 像素的边框. 版本 9 不会"
"再加这个边框, 因此使用 Internet Explorer 9 运行在兼容模式时(IE7/IE8) 得到的屏"
"幕截图会包括这个 2 像素的边框, 这一点与旧版本的 Internet Explorer 不同(译注: "
"此段理解不能, 待校)."

#. Tag: title
#: chapter-testbench.xml:2730
#, no-c-format
msgid "Running Tests"
msgstr "运行测试"

#. Tag: para
#: chapter-testbench.xml:2732
#, no-c-format
msgid ""
"During test development, you usually run the tests from your IDE. After "
"that, you want to have them run by a build system, possibly under a "
"continuous integration system. In the following, we describe how to run "
"tests by Ant and Maven."
msgstr ""
"在测试程序的开发阶段, 你通常会在你的 IDE 内运行. 开发完毕后, 你会希望通过构建"
"系统来运行测试, 有可能在持续集成系统中运行. 下面, 我们介绍如何使用 Ant 和 "
"Maven 来运行测试程序."

#. Tag: title
#: chapter-testbench.xml:2740
#, no-c-format
msgid "Running Tests with Ant"
msgstr "使用 Ant 运行测试"

#. Tag: para
#: chapter-testbench.xml:2742
#, no-c-format
msgid ""
"Apache Ant has built-in support for executing JUnit tests; you can use the "
"<literal>&lt;junit&gt;</literal> task in an Ant script to execute JUnit "
"tests. Note that in earlier versions, you need to enable the support, you "
"need to have the JUnit library <filename>junit.jar</filename> and its Ant "
"integration library <filename>ant-junit.jar</filename> in the Ant classpath, "
"as described in the Ant documentation."
msgstr ""
"Apache Ant 内部支持运行 JUnit 测试程序, 你可以在 Ant 脚本中使用 <literal>&lt;"
"junit&gt;</literal> task 来执行 JUnit 测试程序.注意, 在较老的版本中, 要启用这"
"个功能, 你需要将 JUnit 的库文件 <filename>junit.jar</filename> 以及它与 Ant "
"集成的库文件 <filename>ant-junit.jar</filename> 放在 Ant 的类路径中, 详情请参"
"见 Ant 文档."

#. Tag: para
#: chapter-testbench.xml:2751
#, no-c-format
msgid ""
"The following Ant script allows testing a Vaadin application created with "
"the Vaadin Plugin for Eclipse. It assumes that the test source files are "
"located under a <filename>test</filename> directory under the current "
"directory and compiles them to the <filename>classes</filename> directory. "
"The the class path is defined with the <literal>classpath</literal> "
"reference ID and should contain TestBench and other necessary libraries."
msgstr ""
"以下 Ant 脚本可以测试一个通过 Vaadin Plugin for Eclipse 创建的 Vaadin 应用程"
"序. 这段脚本假设测试程序源代码位于当前目录之下的 <filename>test</filename> 目"
"录内, 然后它编译测试程序, 输出到 <filename>classes</filename> 目录内. 类路径"
"定义在参照 ID(reference ID) <literal>classpath</literal> 中, 其中应该包含 "
"TestBench 以及其他必要的库."

#. Tag: programlisting
#: chapter-testbench.xml:2761
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<project default=\"run-tests\">\n"
"    <path id=\"classpath\">\n"
"        <fileset dir=\"lib\">\n"
"            <include name=\"vaadin-testbench-*.jar\"/>\n"
"            <include name=\"junit-*.jar\"/>\n"
"        </fileset>\n"
"    </path>\n"
"        \n"
"    <!-- This target compiles the JUnit tests. -->\n"
"    <target name=\"compile-tests\">\n"
"        <mkdir dir=\"classes\" />\n"
"        <javac srcdir=\"test\" destdir=\"classes\"\n"
"               debug=\"on\" encoding=\"utf-8\"\n"
"                   includeantruntime=\"false\">\n"
"            <classpath>\n"
"                <path refid=\"classpath\" />\n"
"            </classpath>\n"
"        </javac>\n"
"    </target>\n"
"\n"
"    <!-- This target calls JUnit -->\n"
"    <target name=\"run-tests\" depends=\"compile-tests\">\n"
"        <junit fork=\"yes\">\n"
"            <classpath>\n"
"                <path refid=\"classpath\" />\n"
"                <pathelement path=\"classes\" />\n"
"            </classpath>\n"
"\n"
"            <formatter type=\"brief\" usefile=\"false\" />\n"
"                                \n"
"            <batchtest>\n"
"                <fileset dir=\"test\">\n"
"                    <include name=\"**/**.java\" />\n"
"                </fileset>\n"
"            </batchtest>\n"
"        </junit>\n"
"    </target>\n"
"</project>]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2763
#, no-c-format
msgid ""
"You also need to deploy the application to test, and possibly launch a "
"dedicated server for it."
msgstr ""
"你还需要将被测应用程序部署到服务器上, 可能需要为它启动一个专用的服务器."

#. Tag: title
#: chapter-testbench.xml:2769
#, no-c-format
msgid "Retrieving TestBench with Ivy"
msgstr "通过 Ivy 获取 TestBench"

#. Tag: para
#: chapter-testbench.xml:2771
#, no-c-format
msgid ""
"To retrieve TestBench and its dependencies with Ivy in the Ant script, first "
"install Ivy to your Ant installation, if necessary. In the build script, you "
"need to enable Ivy with the namespace declaration and include a target for "
"retrieving the libraries, as follows:"
msgstr ""
"要在 Ant 中使用 Ivy 来取得 TestBench 及其依赖项目, 首先, 如果需要的话, 要在你"
"的 Ant 环境内安装 Ivy. 在构建脚本内, 你需要使用 namespace 声明来启用 Ivy, 并"
"包含一个用来获取库文件的构建目标(target), 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:2778
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<project xmlns:ivy=\"antlib:org.apache.ivy.ant"
"\"\n"
"         default=\"run-tests\">\n"
"...\n"
"    <!-- Retrieve dependencies with Ivy -->\n"
"    <target name=\"resolve\">\n"
"        <ivy:retrieve conf=\"testing\" type=\"jar,bundle\"\n"
"            pattern=\"lib/[artifact]-[revision].[ext]\"/>\n"
"    </target>\n"
"\n"
"    <!-- This target compiles the JUnit tests. -->\n"
"    <target name=\"compile-tests\" depends=\"resolve\">\n"
"        ...]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2780
#, no-c-format
msgid ""
"This requires that you have a \"<literal>testing</literal>\" configuration "
"in your <filename>ivy.xml</filename> and that the TestBench dependency are "
"enabled in the configuration."
msgstr ""
"以上脚本要求在你的 <filename>ivy.xml</filename> 文件中存在一个 "
"\"<literal>testing</literal>\" 配置, 而且在这个配置中定义了 TestBench 依赖项"
"目."

#. Tag: programlisting
#: chapter-testbench.xml:2786
#, no-c-format
msgid ""
"<?pocket-size 75% ?>\n"
"&lt;ivy-module&gt;\n"
"    ...\n"
"    &lt;configurations&gt;\n"
"        ...\n"
"        <emphasis role=\"bold\">&lt;conf name=\"testing\" /&gt;</emphasis>\n"
"    &lt;/configurations&gt;\n"
"\n"
"    &lt;dependencies&gt;\n"
"        ...\n"
"        &lt;!-- TestBench 4 --&gt;\n"
"        &lt;dependency org=\"com.vaadin\"\n"
"                    name=\"vaadin-testbench-api\"\n"
"                    rev=\"latest.release\"\n"
"                    conf=\"nodeploy<emphasis role=\"bold\">,testing</"
"emphasis> -&gt; default\" /&gt;\n"
"        ..."
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2788
#, no-c-format
msgid ""
"You also need to build and deploy the application to be tested to the server "
"and install the TestBench license key."
msgstr ""
"你还需要编译被测应用程序, 并发布到服务器, 此外还需要安装 TestBench 的 "
"license key."

#. Tag: title
#: chapter-testbench.xml:2796
#, no-c-format
msgid "Running Tests with Maven"
msgstr "使用 Maven 运行测试"

#. Tag: para
#: chapter-testbench.xml:2798
#, no-c-format
msgid ""
"Executing JUnit tests with Vaadin TestBench under Maven requires defining it "
"as a dependency in any POM that needs to execute TestBench tests."
msgstr ""
"在 Maven 中使用 Vaadin TestBench 来执行 JUnit 测试, 需要在 POM 文件内将 "
"TestBench 定义为一个依赖项目."

#. Tag: para
#: chapter-testbench.xml:2803
#, no-c-format
msgid ""
"A complete example of a Maven test setup is given in the TestBench demo "
"project available at <link xlink:href=\"https://github.com/vaadin/testbench-"
"demo\">github.com/vaadin/testbench-demo</link>. See the <filename>README</"
"filename> for further instructions."
msgstr ""
"关于 Maven 测试环境的完整示例, 可参见 TestBench 示例程序工程, 地址是 <link "
"xlink:href=\"https://github.com/vaadin/testbench-demo\">github.com/vaadin/"
"testbench-demo</link>. 详情请阅读其中的 <filename>README</filename> 文件."

#. Tag: title
#: chapter-testbench.xml:2811
#, no-c-format
msgid "Defining TestBench as a Dependency"
msgstr "将 TestBench 定义为依赖项目"

#. Tag: para
#: chapter-testbench.xml:2813
#, no-c-format
msgid ""
"You need to define the TestBench library as a dependency in the Maven POM of "
"your project as follows:"
msgstr ""
"你需要在你的工程的 Maven POM 文件中, 将 TestBench 库定义为依赖项目, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:2818
#, no-c-format
msgid ""
"&lt;dependency&gt;\n"
"      &lt;groupId&gt;com.vaadin&lt;/groupId&gt;\n"
"      &lt;artifactId&gt;vaadin-testbench&lt;/artifactId&gt;\n"
"      &lt;version&gt;&version.testbench;&lt;/version&gt;\n"
"    &lt;/dependency&gt;"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2820
#, no-c-format
msgid ""
"For instructions on how to create a new Vaadin project with Maven, please "
"see <xref linkend=\"getting-started.maven\"/>."
msgstr ""
"关于如何使用 Maven 来创建新的 Vaadin 工程, 详情请参见 <xref linkend="
"\"getting-started.maven\"/>."

#. Tag: title
#: chapter-testbench.xml:2827
#, no-c-format
msgid "Running the Tests"
msgstr "运行测试程序"

#. Tag: para
#: chapter-testbench.xml:2829
#, no-c-format
msgid ""
"To compile and run the tests, simply execute the <literal>test</literal> "
"lifecycle phase with Maven as follows:"
msgstr ""
"要编译并运行测试程序, 只需要使用 Maven 简单地执行 <literal>test</literal> 生"
"命周期阶段(Lifecycle Phase), 如下:"

#. Tag: screen
#: chapter-testbench.xml:2834
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>mvn</command> test\n"
"...\n"
"-----------------------------------------------------\n"
" T E S T S\n"
"-----------------------------------------------------\n"
"Running TestBenchExample\n"
"Tests run: 6, Failures: 1, Errors: 0, Skipped: 1, Time elapsed: 36.736 sec "
"&lt;&lt;&lt; FAILURE!\n"
"\n"
"Results :\n"
"\n"
"Failed tests: \n"
"  testDemo(TestBenchExample):\n"
"      expected:&lt;[5/17/]12&gt; but was:&lt;[17.6.20]12&gt;\n"
"\n"
"Tests run: 6, Failures: 1, Errors: 0, Skipped: 1\n"
"..."
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2836
#, no-c-format
msgid ""
"The example configuration starts Jetty to run the application that is tested."
msgstr "示例程序中的配置会启动 Jetty 来运行被测应用程序."

#. Tag: para
#: chapter-testbench.xml:2841
#, no-c-format
msgid ""
"If you have screenshot tests enabled, as mentioned in <xref linkend="
"\"testbench.installation.examples\"/>, you will get failures from screenshot "
"comparison. The failed screenshots are written to the <filename>target/"
"testbench/errors</filename> folder. To enable comparing them to \"expected\" "
"screenshots, you need to copy the screenshots to the <filename>src/test/"
"resources/screenshots/reference/</filename> folder. See <xref linkend="
"\"testbench.screenshots\"/> for more information regarding screenshots."
msgstr ""
"如果你启用了屏幕截图测试(详情请参见 <xref linkend=\"testbench.installation."
"examples\"/>), 屏幕截图比较将会导致测试失败. 失败的屏幕截图会被写入到 "
"<filename>target/testbench/errors</filename> 文件夹. 为了将它们与 \"期待的\" "
"屏幕截图进行比较, 你需要将这些屏幕截图复制到 <filename>src/test/resources/"
"screenshots/reference/</filename> 文件夹中. 关于屏幕截图, 详情请参见 <xref "
"linkend=\"testbench.screenshots\"/> ."

#. Tag: title
#: chapter-testbench.xml:2857
#, no-c-format
msgid "Running Tests in a Distributed Environment"
msgstr "在分布式环境中运行测试"

#. Tag: para
#: chapter-testbench.xml:2859
#, no-c-format
msgid ""
"A distributed test environment consists of a grid hub and a number of test "
"nodes. The hub listens to calls from test runners and delegates them to the "
"grid nodes. Different nodes can run on different operating system platforms "
"and have different browsers installed."
msgstr ""
"分布式测试环境包括一个网格 hub, 以及多个测试节点. hub 监听从测试运行器发起的"
"调用, 并将这些调用转发给网格节点. 不同的节点可以运行在不同的操作系统平台之"
"上, 并安装不同的浏览器."

#. Tag: para
#: chapter-testbench.xml:2866
#, no-c-format
msgid ""
"A basic distributed installation was covered in <xref linkend=\"testbench."
"installation.distributed\"/>."
msgstr ""
"<xref linkend=\"testbench.installation.distributed\"/> 介绍了基本的分布式测试"
"环境."

#. Tag: title
#: chapter-testbench.xml:2872
#, no-c-format
msgid "Running Tests Remotely"
msgstr "远程运行测试"

#. Tag: para
#: chapter-testbench.xml:2874
#, no-c-format
msgid ""
"Remote tests are just like locally executed tests, except instead of using a "
"browser driver, you use a remote web driver that can connect to the hub. The "
"hub delegates the connection to a grid node with the desired capabilities, "
"that is, which browsers are installed in the node."
msgstr ""
"远程测试与本地运行的测试类似, 区别在于使用的不是浏览器驱动, 而是远程 web 驱"
"动, 这个驱动可以连接到 hub. hub 将连接转发到一个浏览器能力符合需求的网格节"
"点, 也就是说, 转发到安装在一个节点上的浏览器上."

#. Tag: para
#: chapter-testbench.xml:2881
#, no-c-format
msgid ""
"Instead of creating and handling the remote driver explicitly, as described "
"in the following, you can use the <classname>ParallelTest</classname> "
"framework presented in <xref linkend=\"testbench.parallel\"/>."
msgstr ""
"下面我们介绍如何明确地创建并管理远程驱动程序, 但除了这种方式之外, 你还可以使"
"用 <classname>ParallelTest</classname> 框架, 详情请参见 <xref linkend="
"\"testbench.parallel\"/>."

#. Tag: para
#: chapter-testbench.xml:2889
#, no-c-format
msgid ""
"An example of remote execution of tests is given in the TestBench demo "
"described in <xref linkend=\"testbench.installation.examples\"/>. See the "
"<filename>README.md</filename> file for further instructions."
msgstr ""
"关于远程运行测试的示例, 请参见 <xref linkend=\"testbench.installation."
"examples\"/> 中的 TestBench 示例程序. 更多细节请阅读其中的 <filename>README."
"md</filename> 文件."

#. Tag: para
#: chapter-testbench.xml:2895
#, no-c-format
msgid ""
"In the following example, we create and use a remote driver that runs tests "
"in a Selenium cloud at <uri>testingbot.com</uri>. The desired capabilities "
"of a test node are described with a <classname>DesiredCapabilities</"
"classname> object."
msgstr ""
"下例中, 我们创建并使用一个远程浏览器驱动, 它将在位于 <uri>testingbot.com</"
"uri> 的 Selenium 云端服务中运行测试程序. 测试节点需要的浏览器能力通过 "
"<classname>DesiredCapabilities</classname> 对象来描述."

#. Tag: programlisting
#: chapter-testbench.xml:2902
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class UsingHubITCase extends "
"TestBenchTestCase {\n"
"\n"
"    private String baseUrl;\n"
"    private String clientKey = \"INSERT-YOUR-CLIENT-KEY-HERE\";\n"
"    private String clientSecret = \"INSERT-YOUR-CLIENT-KEY-HERE\";\n"
"\n"
"    @Before\n"
"    public void setUp() throws Exception {\n"
"        // Create a RemoteDriver against the hub.\n"
"        // In you local setup you don't need key and secret,\n"
"        // but if you use service like testingbot.com, they\n"
"        // can be used for authentication\n"
"        URL testingbotdotcom = new URL(\"http://\" +\n"
"                clientKey + \":\" + clientSecret +\n"
"                \"@hub.testingbot.com:4444/wd/hub\");\n"
"        setDriver(new RemoteWebDriver(testingbotdotcom,\n"
"                DesiredCapabilities.iphone()));\n"
"        baseUrl = \"http://demo.vaadin.com/Calc/\";\n"
"    }\n"
"\n"
"    @Test\n"
"    @Ignore(\"Requires testingbot.com credientials\")\n"
"    public void testOnePlusTwo() throws Exception {\n"
"        // run the test just as with \"local bots\"\n"
"        openCalculator();\n"
"        $(ButtonElement.class).caption(\"1\").first().click();\n"
"        $(ButtonElement.class).caption(\"+\").first().click();\n"
"        $(ButtonElement.class).caption(\"2\").first().click();\n"
"        $(ButtonElement.class).caption(\"=\").first().click();\n"
"        assertEquals(\"3.0\", $(TextFieldElement.class)\n"
"                            .first().getAttribute(\"value\"));\n"
"\n"
"        // Thats it. Services may provide also some other goodies\n"
"        // like the video replay of your test in testingbot.com\n"
"    }\n"
"\n"
"    private void openCalculator() {\n"
"        getDriver().get(baseUrl);\n"
"    }\n"
"\n"
"    @After\n"
"    public void tearDown() throws Exception {\n"
"        getDriver().quit();\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2904
#, no-c-format
msgid ""
"Please see the API documentation of the <classname>DesiredCapabilities</"
"classname> class for a complete list of supported capabilities."
msgstr ""
"关于支持的浏览器能力的完整列表, 请参见 <classname>DesiredCapabilities</"
"classname> 类的 API 文档."

#. Tag: para
#: chapter-testbench.xml:2910
#, no-c-format
msgid ""
"Running the example requires that the hub service and the nodes are running. "
"Starting them is described in the subsequent sections. Please refer to <link "
"xlink:href=\"http://seleniumhq.org/docs/07_selenium_grid.html\">Selenium "
"documentation</link> for more detailed information."
msgstr ""
"要运行上面的例子, 需要 hub 服务以及网格节点都在运行中. 它们的启动方法将在后面"
"的小节中介绍. 详情请参见 <link xlink:href=\"http://seleniumhq.org/"
"docs/07_selenium_grid.html\">Selenium 文档</link>."

#. Tag: title
#: chapter-testbench.xml:2920
#, no-c-format
msgid "Starting the Hub"
msgstr "启动 Hub"

#. Tag: para
#: chapter-testbench.xml:2922
#, no-c-format
msgid ""
"The TestBench grid hub listens to calls from test runners and delegates them "
"to the grid nodes. The grid hub service is included in the Vaadin TestBench "
"JAR and you can start it with the following command:"
msgstr ""
"TestBench 网格 hub 监听测试运行器发起的调用, 并将这些调用转发给网格节点. 网"
"格 hub 服务包含在 Vaadin TestBench 的 JAR 文件之内, 你可以使用以下命令启动它:"

#. Tag: screen
#: chapter-testbench.xml:2928
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>java</command> -jar vaadin-testbench-standalone-"
"&version.testbench;.jar \\\n"
"       -role hub"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2930
#, no-c-format
msgid ""
"You can open the control interface of the hub also with a web browser. Using "
"the default port, just open URL <uri>http://localhost:4444/</uri>. Once you "
"have started one or more grid nodes, as instructed in the next section, the "
"\"console\" page displays a list of the grid nodes with their browser "
"capabilities."
msgstr ""
"你也可以使用 Web 浏览器打开 hub 的控制界面. 使用默认的端口时, 打开 URL "
"<uri>http://localhost:4444/</uri>. 如果你启动了一个或多个网格节点(方法将在下"
"一节中介绍), \"console\" 页面将会列出所有的网格节点以及它们的浏览器能力."

#. Tag: title
#: chapter-testbench.xml:2940
#, no-c-format
msgid "Node Service Configuration"
msgstr "测试节点的服务配置"

#. Tag: para
#: chapter-testbench.xml:2942
#, no-c-format
msgid ""
"Test nodes can be configured with command-line options, as described later, "
"or in a configuration file in JSON format. If no configuration file is "
"provided, a default configuration is used."
msgstr ""
"测试节点可以通过命令行选项来配置, 详情见后文, 也可以使用 JSON 格式的配置文"
"件. 如果没有配置文件, 将使用默认配置."

#. Tag: para
#: chapter-testbench.xml:2948
#, no-c-format
msgid ""
"A node configuration file is specified with the <parameter>-nodeConfig</"
"parameter> parameter to the node service, for example as follows:"
msgstr ""
"节点配置文件通过节点服务程序的 <parameter>-nodeConfig</parameter> 参数来指"
"定, 如下例:"

#. Tag: screen
#: chapter-testbench.xml:2954
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>java</command> -jar vaadin-testbench-standalone-"
"&version.testbench;.jar\n"
"       -role node -nodeConfig <parameter>nodeConfig.json</parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2956
#, no-c-format
msgid ""
"See <xref linkend=\"testbench.grid.node\"/> for further details on starting "
"the node service."
msgstr ""
"关于节点服务程序的启动, 详情请参见 <xref linkend=\"testbench.grid.node\"/> ."

#. Tag: title
#: chapter-testbench.xml:2962
#, no-c-format
msgid "Configuration File Format"
msgstr "配置文件格式"

#. Tag: para
#: chapter-testbench.xml:2964
#, no-c-format
msgid ""
"The test node configuration file follows the JSON format, which defines "
"nested associative maps. An associative map is defined as a block enclosed "
"in curly braces (<literal>{}</literal>). A mapping is a key-value pair "
"separated with a colon (<literal>:</literal>). A key is a string literal "
"quoted with double quotes (<literal>\"key\"</literal>). The value can be a "
"string literal, list, or a nested associative map. A list a comma-separated "
"sequence enclosed within square brackets (<literal>[]</literal>)."
msgstr ""
"测试节点配置文件遵循 JSON 格式, 其中定义了一组嵌套的关联映射(Associative "
"Map). 一个关联映射通过大括号(<literal>{}</literal>)括起的一个块来定义. 一个映"
"射就是以冒号(<literal>:</literal>)分隔的一个键-值对(key-value pair). 键是双引"
"号(<literal>\"key\"</literal>)括起的一个文字列. 值可以是文字列, 列表, 或者一"
"个嵌套的关联映射. 列表是以逗号分隔的多个值, 以方括号(<literal>[]</literal>)括"
"起."

#. Tag: para
#: chapter-testbench.xml:2975
#, no-c-format
msgid ""
"The top-level associative map should have two associations: "
"<literal>capabilities</literal> (to a list of associative maps) and "
"<literal>configuration</literal> (to a nested associative map)."
msgstr ""
"最顶层的关联映射应该包含两个项目: <literal>capabilities</literal> (值应该是一"
"组关联映射的列表) 和 <literal>configuration</literal> (值是一个嵌套的关联映"
"射)."

#. Tag: programlisting
#: chapter-testbench.xml:2981
#, no-c-format
msgid ""
"<?pocket-size 75% ?>{\n"
"  \"capabilities\":\n"
"    [\n"
"      {\n"
"        \"browserName\": \"<parameter>firefox</parameter>\",\n"
"        ...\n"
"      },\n"
"      ...\n"
"    ],\n"
"  \"configuration\":\n"
"  {\n"
"    \"port\": 5555,\n"
"    ...\n"
"  }\n"
"}"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:2983
#, no-c-format
msgid "A complete example is given later."
msgstr "后文将会给出完整的示例."

#. Tag: title
#: chapter-testbench.xml:2989 chapter-testbench.xml:3100
#, no-c-format
msgid "Browser Capabilities"
msgstr "浏览器能力"

#. Tag: para
#: chapter-testbench.xml:2991
#, no-c-format
msgid ""
"The browser capabilities are defined as a list of associative maps as the "
"value of the <literal>capabilities</literal> key. The capabilities can also "
"be given from command-line using the <parameter>-browser</parameter> "
"parameter, as described in <xref linkend=\"testbench.grid.node\"/>."
msgstr ""
"浏览器能力通过一组关联映射的列表来定义, 并设置为 <literal>capabilities</"
"literal> 项目的值. 浏览器能力也可以通过命令行参数 <parameter>-browser</"
"parameter> 来指定, 详情请参见 <xref linkend=\"testbench.grid.node\"/>."

#. Tag: para
#: chapter-testbench.xml:2999
#, no-c-format
msgid "The keys in the map are the following:"
msgstr "映射内的键如下:"

#. Tag: parameter
#: chapter-testbench.xml:3005
#, no-c-format
msgid "platform"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:3006
#, no-c-format
msgid ""
"The operating system platform of the test node: <literal>WINDOWS</literal>, "
"<literal>XP</literal>, <literal>VISTA</literal>, <literal>LINUX</literal>, "
"or <literal>MAC</literal>."
msgstr ""
"测试节点的操作系统平台: <literal>WINDOWS</literal>, <literal>XP</literal>, "
"<literal>VISTA</literal>, <literal>LINUX</literal>, 或 <literal>MAC</"
"literal>."

#. Tag: parameter
#: chapter-testbench.xml:3014
#, no-c-format
msgid "browserName"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:3015
#, no-c-format
msgid ""
"A browser identifier, any of: <literal>android</literal>, <literal>chrome</"
"literal>, <literal>firefox</literal>, <literal>htmlunit</literal>, "
"<literal>internet explorer</literal>, <literal>iphone</literal>, "
"<literal>opera</literal>, or <literal>phantomjs</literal> (as of TestBench "
"3.1)."
msgstr ""
"浏览器标识符, 可以是以下浏览器之一: <literal>android</literal>, "
"<literal>chrome</literal>, <literal>firefox</literal>, <literal>htmlunit</"
"literal>, <literal>internet explorer</literal>, <literal>iphone</literal>, "
"<literal>opera</literal>, 或 <literal>phantomjs</literal> (从 TestBench 3.1 "
"开始可用)."

#. Tag: parameter
#: chapter-testbench.xml:3025
#, no-c-format
msgid "maxInstances"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:3026
#, no-c-format
msgid ""
"The maximum number of browser instances of this type open at the same time "
"for parallel testing."
msgstr "并行测试时, 同时可以打开的浏览器实例的最大数目."

#. Tag: parameter
#: chapter-testbench.xml:3032
#, no-c-format
msgid "version"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:3033
#, no-c-format
msgid "The major version number of the browser."
msgstr "浏览器的主版本号."

#. Tag: parameter
#: chapter-testbench.xml:3038
#, no-c-format
msgid "seleniumProtocol"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:3039
#, no-c-format
msgid "This should be <literal>WebDriver</literal> for WebDriver use."
msgstr "使用 WebDriver 时应该设置为 <literal>WebDriver</literal>."

#. Tag: parameter
#: chapter-testbench.xml:3044
#, no-c-format
msgid "firefox_binary"
msgstr ""

#. Tag: listitem
#: chapter-testbench.xml:3045
#, no-c-format
msgid ""
"Full path and file name of the Firefox executable. This is typically needed "
"if you have Firefox ESR installed in a location that is not in the system "
"path."
msgstr ""
"Firefox 可执行文件的完整路径及文件名. 当你使用 Firefox ESR 版, 并且安装路径不"
"在系统的 PATH 路径中时, 通常会需要设置这个项目."

#. Tag: title
#: chapter-testbench.xml:3055
#, no-c-format
msgid "Server Configuration"
msgstr "服务器配置"

#. Tag: para
#: chapter-testbench.xml:3057
#, no-c-format
msgid ""
"The node service configuration is defined as a nested associative map as the "
"value of the <literal>configuration</literal> key. The configuration "
"parameters can also be given as command-line parameters to the node service, "
"as described in <xref linkend=\"testbench.grid.node\"/>."
msgstr ""
"节点服务的配置以嵌套的关联映射, 并设置为 <literal>configuration</literal> 项"
"目的值. 配置参数也可以通过节点服务程序的命令行参数来指定, 详情请参见 <xref "
"linkend=\"testbench.grid.node\"/>."

#. Tag: para
#: chapter-testbench.xml:3064
#, no-c-format
msgid "See the following example for a typical server configuration."
msgstr "一个通常的服务器配置, 请见下例."

#. Tag: title
#: chapter-testbench.xml:3070
#, no-c-format
msgid "Example Configuration"
msgstr "配置示例"

#. Tag: programlisting
#: chapter-testbench.xml:3072
#, no-c-format
msgid ""
"<?pocket-size 75% ?>{\n"
"  \"capabilities\":\n"
"    [\n"
"      {\n"
"        \"browserName\": \"<parameter>firefox</parameter>\",\n"
"        \"maxInstances\": <parameter>5</parameter>,\n"
"        \"seleniumProtocol\": \"<parameter>WebDriver</parameter>\",\n"
"        \"version\": \"<parameter>10</parameter>\",\n"
"        \"firefox_binary\": \"<parameter>/path/to/firefox10</parameter>\"\n"
"      },\n"
"      {\n"
"        \"browserName\": \"<parameter>firefox</parameter>\",\n"
"        \"maxInstances\": <parameter>5</parameter>,\n"
"        \"version\": \"<parameter>16</parameter>\",\n"
"        \"firefox_binary\": \"<parameter>/path/to/firefox16</parameter>\"\n"
"      },\n"
"      {\n"
"        \"browserName\": \"<parameter>chrome</parameter>\",\n"
"        \"maxInstances\": <parameter>5</parameter>,\n"
"        \"seleniumProtocol\": \"<parameter>WebDriver</parameter>\"\n"
"      },\n"
"      {\n"
"        \"platform\": \"<parameter>WINDOWS</parameter>\",\n"
"        \"browserName\": \"<parameter>internet explorer</parameter>\",\n"
"        \"maxInstances\": <parameter>1</parameter>,\n"
"        \"seleniumProtocol\": \"<parameter>WebDriver</parameter>\"\n"
"      }\n"
"    ],\n"
"  \"configuration\":\n"
"  {\n"
"    \"proxy\": \"org.openqa.grid.selenium.proxy.DefaultRemoteProxy\",\n"
"    \"maxSession\": 5,\n"
"    \"port\": 5555,\n"
"    \"host\": ip,\n"
"    \"register\": true,\n"
"    \"registerCycle\": 5000,\n"
"    \"hubPort\": 4444\n"
"  }\n"
"}"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:3077
#, no-c-format
msgid "Starting a Grid Node"
msgstr "启动一个测试网格节点"

#. Tag: para
#: chapter-testbench.xml:3079
#, no-c-format
msgid ""
"A TestBench grid node listens to calls from the hub and is capable of "
"opening a browser. The grid node service is included in the Vaadin TestBench "
"JAR and you can start it with the following command:"
msgstr ""
"TestBench 网格节点监听来自 hub 的调用, 并且可以打开浏览器. 网格节点服务程序包"
"含在 Vaadin TestBench 的 JAR 文件内, 你可以使用以下命令启动它:"

#. Tag: screen
#: chapter-testbench.xml:3085
#, no-c-format
msgid ""
"<prompt>$</prompt> <command>java</command> -jar \\\n"
"       vaadin-testbench-standalone-&version.testbench;.jar \\\n"
"       -role node \\\n"
"       -hub <parameter>http://localhost:4444/grid/register</parameter>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3087
#, no-c-format
msgid ""
"The node registers itself in the grid hub. You need to give the address of "
"the hub either with the <parameter>-hub</parameter> parameter or in the node "
"configuration file as described in <xref linkend=\"testbench.grid.node-"
"configuration\"/>."
msgstr ""
"测试节点会将自己注册到网格 hub 中. 你需要通过 <parameter>-hub</parameter> 参"
"数或节点配置文件, 来指定 hub 的地址, 节点配置文件请参见 <xref linkend="
"\"testbench.grid.node-configuration\"/>."

#. Tag: para
#: chapter-testbench.xml:3094
#, no-c-format
msgid ""
"You can run one grid node in the same host as the hub, as is done in the "
"example above with the localhost address."
msgstr ""
"你可以在同一台主机上同时运行 hub 和网格节点, 前面的例子中我们就是这样做的, 使"
"用的地址是 localhost."

#. Tag: para
#: chapter-testbench.xml:3102
#, no-c-format
msgid ""
"The browsers installed in the node can be defined either with command-line "
"parameters or with a configuration file in JSON format, as described in "
"<xref linkend=\"testbench.grid.node-configuration\"/>."
msgstr ""
"节点上安装的浏览器可以通过命令行参数来指定, 也可以使用 JSON 格式的配置文件, "
"详情请参见 <xref linkend=\"testbench.grid.node-configuration\"/>."

#. Tag: para
#: chapter-testbench.xml:3108
#, no-c-format
msgid ""
"On command-line, you can issue one or more <parameter>-browser</parameter> "
"options to define the browser capabilities. It must be followed by a comma-"
"separated list of property-value definitions, such as the following:"
msgstr ""
"使用命令行参数时, 可以通过一个或多个 <parameter>-browser</parameter> 参数来定"
"义浏览器性能. 参数后面跟着的必须是逗号分隔的, 一组属性-值定义列表, 如下例:"

#. Tag: screen
#: chapter-testbench.xml:3115
#, no-c-format
msgid ""
"-browser \"browserName=firefox,version=10,firefox_binary=/path/to/"
"firefox10\" \\\n"
"-browser \"browserName=firefox,version=16,firefox_binary=/path/to/"
"firefox16\" \\\n"
"-browser \"browserName=chrome,maxInstances=5\" \\\n"
"-browser \"browserName=internet explorer,maxInstances=1,platform=WINDOWS\""
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3117
#, no-c-format
msgid ""
"The configuration properties are described in <xref linkend=\"testbench.grid."
"node-configuration\"/>."
msgstr ""
"关于配置中的属性项目名, 请参见 <xref linkend=\"testbench.grid.node-"
"configuration\"/>."

#. Tag: title
#: chapter-testbench.xml:3124
#, no-c-format
msgid "Browser Driver Parameters"
msgstr "浏览器驱动参数"

#. Tag: para
#: chapter-testbench.xml:3126
#, no-c-format
msgid ""
"If you use Chrome or Internet Explorer, their remote driver executables must "
"be in the system path (in the <literal>PATH</literal> environment variable) "
"or be given with a command-line parameter to the node service:"
msgstr ""
"如果使用 Chrome 或 Internet Explorer, 它们的远程驱动的可执行文件必须存在于系"
"统路径内 (在 <literal>PATH</literal> 环境变量中), 或者通过节点服务程序的命令"
"行参数指向:"

#. Tag: term
#: chapter-testbench.xml:3135
#, no-c-format
msgid "<term>Internet Explorer</term>"
msgstr ""

#. Tag: parameter
#: chapter-testbench.xml:3137
#, no-c-format
msgid "-Dwebdriver.ie.driver=C:\\path\\to\\IEDriverServer.exe"
msgstr ""

#. Tag: term
#: chapter-testbench.xml:3141
#, no-c-format
msgid "<term>Google Chrome</term>"
msgstr ""

#. Tag: parameter
#: chapter-testbench.xml:3143
#, no-c-format
msgid "-Dwebdriver.chrome.driver=/path/to/ChromeDriver"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:3151
#, no-c-format
msgid "Mobile Testing"
msgstr "移动设备测试"

#. Tag: para
#: chapter-testbench.xml:3153
#, no-c-format
msgid ""
"Vaadin TestBench includes an iPhone and an Android driver, with which you "
"can test on mobile devices. The tests can be run either in a device or in an "
"emulator/simulator."
msgstr ""
"Vaadin TestBench 包含了 iPhone 和 Android 驱动, 使用这些驱动可以在移动设备上"
"进行测试. 测试程序可以运行在真实的设备内, 也可以运行在仿真器/模拟器内."

#. Tag: para
#: chapter-testbench.xml:3162
#, no-c-format
msgid ""
"The actual testing is just like with any WebDriver, using either the "
"<classname>IPhoneDriver</classname> or the <classname>AndroidDriver</"
"classname>. The Android driver assumes that the hub (<filename>android-"
"server</filename>) is installed in the emulator and forwarded to port 8080 "
"in localhost, while the iPhone driver assumes port 3001. You can also use "
"the <classname>RemoteWebDriver</classname> with either the "
"<methodname>iphone()</methodname> or the <methodname>android()</methodname> "
"capability, and specify the hub URI explicitly."
msgstr ""
"移动设备上的测试程序类似于其他任何类型的 WebDriver, 可以使用 "
"<classname>IPhoneDriver</classname> 或 <classname>AndroidDriver</classname>. "
"Android 驱动假定 hub (<filename>android-server</filename>) 安装在仿真器中, 并"
"被转发到 localhost 的 8080 端口, iPhone 驱动则假定转发到端口 3001. 你也可以使"
"用 <classname>RemoteWebDriver</classname>, 并配合 <methodname>iphone()</"
"methodname> 或 <methodname>android()</methodname> 的浏览器性能, 并明确指定 "
"hub 的 URI."

#. Tag: para
#: chapter-testbench.xml:3174
#, no-c-format
msgid ""
"The mobile testing setup is covered in detail in the Selenium documentation "
"for both the <link xlink:href=\"http://ios-driver.github.io/ios-driver/"
"\">iOS driver</link> and the <link xlink:href=\"http://selendroid.io/"
"mobileWeb.html\">AndroidDriver</link>."
msgstr ""
"移动设备的测试环境在 Selenium 文档中有详细介绍, 请参见关于 <link xlink:href="
"\"http://ios-driver.github.io/ios-driver/\">iOS driver</link> 和 <link xlink:"
"href=\"http://selendroid.io/mobileWeb.html\">AndroidDriver</link> 的部分."

#. Tag: title
#: chapter-testbench.xml:3185
#, no-c-format
msgid "Parallel Execution of Tests"
msgstr "测试程序的并行执行"

#. Tag: para
#: chapter-testbench.xml:3187
#, no-c-format
msgid ""
"The <classname>ParallelTest</classname> class provides an easy way to run "
"tests in parallel locally, as well as remotely in a test grid."
msgstr ""
"<classname>ParallelTest</classname> 类提供了一种简单的方式来并行地运行测试程"
"序, 可以在本地运行, 也可以在测试网格环境中远程运行."

#. Tag: title
#: chapter-testbench.xml:3193
#, no-c-format
msgid "Local Parallel Execution"
msgstr "本地并行测试"

#. Tag: para
#: chapter-testbench.xml:3195
#, no-c-format
msgid ""
"To enable parallel execution of tests, usually during test development, you "
"need to extend the <classname>ParallelTest</classname> instead of "
"<classname>TestBenchTestCase</classname> and annotate the test case class "
"with <literal>@RunLocally</literal>."
msgstr ""
"测试程序的并行执行通常用在开发阶段, 要启用这个功能, 你的测试用例类需要继承自 "
"<classname>ParallelTest</classname>, 而不是 <classname>TestBenchTestCase</"
"classname>,  还需要使用 <literal>@RunLocally</literal> 注解来标记测试用例类."

#. Tag: programlisting
#: chapter-testbench.xml:3202
#, no-c-format
msgid ""
"<![CDATA[@RunLocally\n"
"public class MyTest extends ParallelTest {\n"
"   @Test\n"
"   ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3204
#, no-c-format
msgid ""
"When you run the tests, TestBench launches multiple browser windows to run "
"each test in parallel."
msgstr ""
"当你运行测试程序时, TestBench 会启动多个浏览器窗口来并行地运行各个测试."

#. Tag: para
#: chapter-testbench.xml:3209
#, no-c-format
msgid ""
"Parallel execution defaults to Firefox. You can give another browser as a "
"parameter for the annotation, as enumerated in the <classname>Browser</"
"classname> enumeration:"
msgstr ""
"测试程序的并行执行默认使用 Firefox. 你也可以通过注解的参数的方式指定其他浏览"
"器, 浏览器类型定义在 <classname>Browser</classname> 枚举型中:"

#. Tag: programlisting
#: chapter-testbench.xml:3215
#, no-c-format
msgid "<![CDATA[@RunLocally(Browser.CHROME)]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3217
#, no-c-format
msgid ""
"For Chrome and IE, you need to have the browser driver installed, as "
"described in <xref linkend=\"testbench.installation.browserdrivers\"/>."
msgstr ""
"对于 Chrome 和 IE, 你需要安装对应的浏览器驱动程序, 详情请参见 <xref linkend="
"\"testbench.installation.browserdrivers\"/>."

#. Tag: title
#: chapter-testbench.xml:3224
#, no-c-format
msgid "Multi-Browser Execution in a Grid"
msgstr "在网格环境中使用多个浏览器执行测试程序"

#. Tag: para
#: chapter-testbench.xml:3226
#, no-c-format
msgid ""
"To run tests in multiple different browsers or remotely, you first need to "
"set up and launch a grid hub and one or more grid nodes, as described in "
"<xref linkend=\"testbench.grid\"/>. This enables remote execution in a test "
"grid, although you can run the hub and a test node also in your development "
"workstation."
msgstr ""
"要在多个不同的浏览器中运行测试程序, 或者远程运行应用程序, 你首先需要安装并启"
"动一个网格 hub 以及一个以上的网格节点, 详情请参见 <xref linkend=\"testbench."
"grid\"/>. 然后就可以在测试网格中远程运行测试程序了, 当然, 你也可以在你的开发"
"机器上同时运行网格 hub 和测试节点."

#. Tag: para
#: chapter-testbench.xml:3234
#, no-c-format
msgid ""
"To run a test case class in a grid, you simply need to annotate the test "
"case classes with the <literal>@RunOnHub</literal> annotation. It takes the "
"host address of the hub as parameter, with <literal>localhost</literal> as "
"the default host. You need to define the desired browser capabilities in a "
"method annotated with <literal>@BrowserConfiguration</literal>. It must "
"return a list of <classname>DesiredCapabilities</classname>."
msgstr ""
"要在网格环境中运行一个测试用例, 你只需要对测试用例类使用 <literal>@RunOnHub</"
"literal> 注解. 这个注解的参数是网格 hub 的主机地址, 默认主机是 "
"<literal>localhost</literal>. 你需要在一个使用了 "
"<literal>@BrowserConfiguration</literal> 注解的方法中定义测试程序需要的浏览器"
"能力. 这个方法必须返回 <classname>DesiredCapabilities</classname> 的列表."

#. Tag: programlisting
#: chapter-testbench.xml:3244
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@RunOnHub(\"hub.testgrid.mydomain.com\")\n"
"public class MyTest extends ParallelTest {\n"
"   @Test\n"
"   ...\n"
"\n"
"   @BrowserConfiguration\n"
"   public List<DesiredCapabilities> getBrowserConfiguration() {\n"
"       List<DesiredCapabilities> browsers =\n"
"           new ArrayList<DesiredCapabilities>();\n"
"        \n"
"       // Add all the browsers you want to test\n"
"       browsers.add(BrowserUtil.firefox());\n"
"       browsers.add(BrowserUtil.chrome());\n"
"       browsers.add(BrowserUtil.ie11());\n"
"        \n"
"       return browsers;\n"
"   }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3246
#, no-c-format
msgid ""
"The actual browsers tested depends on the browser capabilities of the test "
"node or nodes."
msgstr "测试运行中实际使用的浏览器, 由各测试节点的浏览器能力决定."

#. Tag: para
#: chapter-testbench.xml:3251
#, no-c-format
msgid ""
"If you have more test classes, you can put the configuration in a common "
"base class that extends <classname>ParallelTest</classname>."
msgstr ""
"如果你有很多测试类, 你可以将上例中的配置信息放在一个共同的基类中, 基类继承自 "
"<classname>ParallelTest</classname>."

#. Tag: title
#: chapter-testbench.xml:3259
#, no-c-format
msgid "Headless Testing"
msgstr "无头(Headless)测试"

#. Tag: para
#: chapter-testbench.xml:3261
#, no-c-format
msgid ""
"TestBench (3.1 and later) supports fully-featured headless testing with "
"PhantomJS (<link xlink:href=\"http://phantomjs.org\">http://phantomjs.org</"
"link>), a headless browser based on WebKit. It has fast native support for "
"various web standards: JavaScript, DOM handling, CSS selector, JSON, Canvas, "
"and SVG."
msgstr ""
"TestBench (3.1 及以上版本) 支持使用 PhantomJS (<link xlink:href=\"http://"
"phantomjs.org\">http://phantomjs.org</link>)进行全功能的无头(headless)测试 , "
"PhantomJS 是一个基于 WebKit 的无头浏览器. 它对很多种 Web 标准都带有高速的原生"
"支持: JavaScript, DOM 处理, CSS 选择器, JSON, Canvas, 以及 SVG."

#. Tag: para
#: chapter-testbench.xml:3269
#, no-c-format
msgid ""
"Headless testing using PhantomJS allows for around 15% faster test execution "
"without having to start a graphical web browser, even when performing "
"screenshot-based testing! This also makes it possible to run full-scale "
"functional tests on the front-end directly on a build server, without the "
"need to install any web browsers."
msgstr ""
"使用 PhantomJS 进行无头测试, 测试的执行可变快大约 15%, 它不必启动图形化的 "
"Web 浏览器, 即使在进行屏幕截图测试时也是如此! 因此也可以直接在构建服务器上运"
"行全量程的(full-scale) 前端功能测试, 而不必安装任何 Web 浏览器."

#. Tag: para
#: chapter-testbench.xml:3277
#, no-c-format
msgid ""
"It is usually best to use a graphical browser to develop the test cases, as "
"it is possible to see interactively what happens while the tests are being "
"executed. Once the tests are working correctly in a graphical browser, you "
"can migrate them to run on the PhantomJS headless browser."
msgstr ""
"通常来说, 最好使用图像化的浏览器来开发测试用例, 因为可以直观地看到测试执行过"
"程中发生了什么. 一旦测试程序在图形化浏览器上可以正确工作了, 你就可以将它移植"
"到 PhantomJS 无头浏览器环境去运行."

#. Tag: title
#: chapter-testbench.xml:3285
#, no-c-format
msgid "Basic Setup for Running Headless Tests"
msgstr "运行无头测试所需要的基本设置"

#. Tag: para
#: chapter-testbench.xml:3287
#, no-c-format
msgid ""
"The only set up required is to install the PhantomJS binary. Follow the "
"instructions for your operating system at <link xlink:href=\"http://"
"phantomjs.org/download.html\">PhantomJS download page</link>, and place the "
"binary in the system path."
msgstr ""
"所需要的唯一的设置就是安装 PhantomJS 的可执行文件. 请访问 <link xlink:href="
"\"http://phantomjs.org/download.html\">PhantomJS 下载页面</link>, 遵照你的操"
"作系统上的安装指示, 并将 PhantomJS 的可执行文件放在系统路径中."

#. Tag: para
#: chapter-testbench.xml:3294
#, no-c-format
msgid "The PhantomJSDriver dependency is already included in Vaadin TestBench."
msgstr "PhantomJSDriver 依赖项目已经包含在 Vaadin TestBench 中了."

#. Tag: title
#: chapter-testbench.xml:3299
#, no-c-format
msgid "Creating a Headless WebDriver Instance"
msgstr "创建一个无头的 WebDriver 实例"

#. Tag: para
#: chapter-testbench.xml:3301
#, no-c-format
msgid ""
"Creating an instance of the <classname>PhantomJSDriver</classname> is just "
"as easy as creating an instance of <classname>FirefoxDriver</classname>."
msgstr ""
"创建一个 <classname>PhantomJSDriver</classname> 实例, 与创建 "
"<classname>FirefoxDriver</classname> 实例一样简单."

#. Tag: programlisting
#: chapter-testbench.xml:3306
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[setDriver(TestBench.createDriver(\n"
"    new PhantomJSDriver()));]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3308
#, no-c-format
msgid ""
"Some tests may fail because of the small default window size in PhantomJS. "
"Such tests are, for example, tests containing elements that pop up and might "
"go off-screen when the window is small. To make them work better, specify a "
"size for the window:"
msgstr ""
"某些测试程序可能会失败, 因为 PhantomJS 默认的窗口尺寸很小. 比如, 当窗口太小"
"时, 弹出的页面元素可能出现在屏幕之外, 相关的测试可能会因此失败. 要让这类测试"
"程序更好地运行, 需要指定窗口尺寸, 如下:"

#. Tag: programlisting
#: chapter-testbench.xml:3315
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[getDriver().manage().window().setSize(\n"
"        new Dimension(1024, 768));]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3317
#, no-c-format
msgid "Nothing else is needed to run tests headlessly."
msgstr "除此之外, 以无头模式运行测试程序, 并不需要其他的设置."

#. Tag: title
#: chapter-testbench.xml:3324
#, no-c-format
msgid "Running Headless Tests in a Distributed Environment"
msgstr "在分布式环境中运行无头测试"

#. Tag: para
#: chapter-testbench.xml:3326
#, no-c-format
msgid ""
"Running PhantomJS in a distributed grid is equally easy. First, install "
"PhantomJS in the nodes by following the instructions in <xref linkend="
"\"testbench.headless.running\"/>. Then, start PhantomJS using the following "
"command:"
msgstr ""
"在分布式网格中运行 PhantomJS 也很简单. 首先, 遵照 <xref linkend=\"testbench."
"headless.running\"/> 中的安装指示, 在网格节点内安装 PhantomJS. 然后, 使用以下"
"命令启动 PhantomJS:"

#. Tag: programlisting
#: chapter-testbench.xml:3333
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[phantomjs --webdriver=8080 \\\n"
"          --webdriver-selenium-grid-hub=http://127.0.0.1:4444]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3335
#, no-c-format
msgid ""
"The above will start PhantomJS in the WebDriver mode and register it with a "
"grid hub running at <literal>127.0.0.1:4444</literal>. After this, running "
"tests in the grid is as easy as passing <methodname>DesiredCapabilities."
"phantomjs()</methodname> to the <literal>RemoteWebDriver</literal> "
"constructor."
msgstr ""
"以上命令将以 WebDriver 模式启动 PhantomJS, 并将它注册到网格 hub 中, hub 的运"
"行地址是 <literal>127.0.0.1:4444</literal>. 然后, 在测试网格中运行测试程序很"
"简单, 只需要在 <literal>RemoteWebDriver</literal> 构造函数中使用 "
"<methodname>DesiredCapabilities.phantomjs()</methodname> 作为参数."

#. Tag: programlisting
#: chapter-testbench.xml:3343
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[setDriver(new RemoteWebDriver(\n"
"        DesiredCapabilities.phantomjs()));]]>"
msgstr ""

#. Tag: title
#: chapter-testbench.xml:3348
#, no-c-format
msgid "Behaviour-Driven Development"
msgstr "行为驱动开发"

#. Tag: para
#: chapter-testbench.xml:3350
#, no-c-format
msgid ""
"Behaviour-driven development (BDD) is a development methodology based on "
"test-driven development, where development starts from writing tests for the "
"software-to-be. BDD involves using a <emphasis>ubiquitous language</"
"emphasis> to communicate between business goals - the desired behaviour - "
"and tests to ensure that the software fulfills those goals."
msgstr ""
"行为驱动开发(Behaviour-driven development, 简称 BDD) 是在测试驱动开发模式"
"(Test-driven development, 简称 TDD)基础上发展的一种开发模式, 在测试驱动开发模"
"式中, 首先需要针对所期待的软件正确行为编写测试程序. BDD 使用一种 <emphasis>通"
"用语言</emphasis>(ubiquitous language) 来表达业务目标 - 也就是所要求的行为 - "
"并对此进行测试, 以确保软件完全满足了这些目标."

#. Tag: para
#: chapter-testbench.xml:3358
#, no-c-format
msgid ""
"The BDD process starts by collection of business requirements expressed as "
"<emphasis>user stories</emphasis>, as is typical in agile methodologies. A "
"user with a <emphasis>role</emphasis> requests a <emphasis>feature</"
"emphasis> to gain a <emphasis>benefit</emphasis>."
msgstr ""
"与敏捷开发模式一样, BDD 过程从收集业务需求开始, 业务需求以 <emphasis>用户场景"
"</emphasis>(user stories) 的形式表达. 用户称为一个 <emphasis>角色</"
"emphasis>(role), 角色要求一个 <emphasis>功能特性</emphasis>(feature) 来获得一"
"种 <emphasis>利益</emphasis>(benefit)."

#. Tag: para
#: chapter-testbench.xml:3365
#, no-c-format
msgid ""
"Stories can be expressed as number of <emphasis>scenarios</emphasis> that "
"describe different cases of the desired behaviour. Such a scenario can be "
"formalized with the following three phases:"
msgstr ""
"用户场景可以通过多个 <emphasis>情节</emphasis> (scenario)来表达, 情节负责描述"
"各种期望的行为. 情节形式化地表达为以下三个阶段:"

#. Tag: para
#: chapter-testbench.xml:3372
#, no-c-format
msgid "<emphasis>Given</emphasis> that I have calculator open"
msgstr "<emphasis>Given</emphasis> (假定)我打开了计算器"

#. Tag: para
#: chapter-testbench.xml:3373
#, no-c-format
msgid "<emphasis>When</emphasis> I push calculator buttons"
msgstr "<emphasis>When</emphasis> (当)我按下计算器按钮"

#. Tag: para
#: chapter-testbench.xml:3374
#, no-c-format
msgid "<emphasis>Then</emphasis> the display should show the result"
msgstr "<emphasis>Then</emphasis> (那么)屏幕应该显示出计算结果"

#. Tag: para
#: chapter-testbench.xml:3377
#, no-c-format
msgid ""
"This kind of formalization is realized in the JBehave BDD framework for "
"Java. The TestBench Demo includes a JBehave example, where the above "
"scenario is written as the <link xlink:href=\"https://github.com/vaadin/"
"testbench-demo/blob/master/src/test/java/com/vaadin/testbenchexample/bdd/"
"CalculatorSteps.java\">following test class</link>:"
msgstr ""
"在 Java 中, JBehave BDD 框架实现了上面这种形式化表达. TestBench 示例程序包含"
"一个 JBehave 示例, 在这个示例中, 上例的场景表达为 <link xlink:href=\"https://"
"github.com/vaadin/testbench-demo/blob/master/src/test/java/com/vaadin/"
"testbenchexample/bdd/CalculatorSteps.java\">以下测试用例类</link>:"

#. Tag: programlisting
#: chapter-testbench.xml:3385
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class CalculatorSteps extends "
"TestBenchTestCase {\n"
"    private WebDriver driver;\n"
"    private CalculatorPageObject calculator;\n"
"\n"
"    @BeforeScenario\n"
"    public void setUpWebDriver() {\n"
"        driver = TestBench.createDriver(new FirefoxDriver());\n"
"        calculator = PageFactory.initElements(driver,\n"
"                CalculatorPageObject.class);\n"
"    }\n"
"\n"
"    @AfterScenario\n"
"    public void tearDownWebDriver() {\n"
"        driver.quit();\n"
"    }\n"
"\n"
"    @Given(\"I have the calculator open\")\n"
"    public void theCalculatorIsOpen() {\n"
"        calculator.open();\n"
"    }\n"
"\n"
"    @When(\"I push $buttons\")\n"
"    public void enter(String buttons) {\n"
"        calculator.enter(buttons);\n"
"    }\n"
"\n"
"    @Then(\"the display should show $result\")\n"
"    public void displayShows(String result) {\n"
"        assertEquals(result, calculator.getResult());\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-testbench.xml:3387
#, no-c-format
msgid ""
"The demo employs the page object defined for the application UI, as "
"described in <xref linkend=\"testbench.maintainable.pageobject\"/>."
msgstr ""
"上面的示例程序使用了针对应用程序 UI 定义的页面对象, 详情请参见 <xref linkend="
"\"testbench.maintainable.pageobject\"/>."

#. Tag: para
#: chapter-testbench.xml:3392
#, no-c-format
msgid ""
"Such scenarios are included in one or more stories, which need to be "
"configured in a class extending <classname>JUnitStory</classname> or "
"<classname>JUnitStories</classname>. In the example, this is done in the "
"<link xlink:href=\"https://github.com/vaadin/testbench-demo/blob/master/src/"
"test/java/com/vaadin/testbenchexample/bdd/SimpleCalculation.java"
"\"><classname>SimpleCalculation</classname></link> class. It defines how "
"story classes can be found dynamically by the class loader and how stories "
"are reported."
msgstr ""
"这样的场景出现在一个或多个用户场景中, 需要继承 <classname>JUnitStory</"
"classname> 或 <classname>JUnitStories</classname>, 然后在子类中设置用户场景. "
"在示例程序中, 这个设置工作由 <link xlink:href=\"https://github.com/vaadin/"
"testbench-demo/blob/master/src/test/java/com/vaadin/testbenchexample/bdd/"
"SimpleCalculation.java\"><classname>SimpleCalculation</classname></link> 类实"
"现. 这个类指定了类装载器如何动态查找 Story 类, 以及如何报告用户场景的测试结"
"果."

#. Tag: para
#: chapter-testbench.xml:3401
#, no-c-format
msgid ""
"For further documentation, please see JBehave website at <link xlink:href="
"\"http://jbehave.org/\">jbehave.org</link>."
msgstr ""
"更详细的文档, 请访问 JBehave 网站, 地址是 <link xlink:href=\"http://jbehave."
"org/\">jbehave.org</link>."

#. Tag: title
#: chapter-testbench.xml:3408
#, no-c-format
msgid "Known Issues"
msgstr "已知的问题"

#. Tag: para
#: chapter-testbench.xml:3410
#, no-c-format
msgid ""
"This section provides information and instructions on a few features that "
"are known to be difficult to use or need modification to work."
msgstr ""
"本节将介绍如何处理一部分比较难于使用的功能特性, 以及需要一点调整才可以使用的"
"功能特性."

#. Tag: title
#: chapter-testbench.xml:3416
#, no-c-format
msgid "Running Firefox Tests on Mac OS X"
msgstr "在 Mac OS X 上运行 Firefox 测试程序"

#. Tag: para
#: chapter-testbench.xml:3418
#, no-c-format
msgid ""
"Firefox needs to have focus in the main window for any focus events to be "
"triggered. This sometimes causes problems if something interferes with the "
"focus. For example, a <classname>TextField</classname> that has an input "
"prompt relies on the JavaScript <methodname>onFocus()</methodname> event to "
"clear the prompt when the field is focused."
msgstr ""
"Firefox 的主窗口需要获得焦点, 才可以触发聚焦事件. 如果别的什么程序干扰了焦"
"点, 这一点有时会导致一些问题. 比如, <classname>TextField</classname> 的输入提"
"示功能依赖于 JavaScript 的 <methodname>onFocus()</methodname> 事件, 以便在 "
"Field 得到焦点时清除提示信息."

#. Tag: para
#: chapter-testbench.xml:3426
#, no-c-format
msgid ""
"The problem occurs when OS X considers the Java process of an application "
"using TestBench (or the node service) to have a native user interface "
"capability, as with AWT or Swing, even when they are not used. This causes "
"the focus to switch from Firefox to the process using TestBench, causing "
"tests requiring focus to fail. To remedy this problem, you need to start the "
"JVM in which the tests are running with the <parameter>-Djava.awt."
"headless=true</parameter> parameter to disable the user interface capability "
"of the Java process."
msgstr ""
"使用 TestBench 的应用程序(或网格节点服务程序)存在对应的 Java 进程, OS X 会认"
"为这些进程带有本地 UI 能力, 就像 AWT 或 Swing 一样, 但实际上它们并没有这个能"
"力, 此时就会发生问题. 这个问题会导致焦点离开 Firefox, 聚焦到使用 TestBench 的"
"进程上, 于是需要获得焦点的那些测试程序就会失败. 为了解决这个问题, 启动运行测"
"试程序的 JVM 时, 你需要使用 <parameter>-Djava.awt.headless=true</parameter> "
"参数, 来禁用 Java 进程的 UI 能力."

#. Tag: para
#: chapter-testbench.xml:3437
#, no-c-format
msgid ""
"Note that the same problem is present also when debugging tests with "
"Firefox. We therefore recommend using Chrome for debugging tests, unless "
"Firefox is necessary."
msgstr ""
"注意, 使用 Firefox 调试测试程序时, 也会出现同样的问题. 因此我们建议, 除非必须"
"使用 Firefox, 否则在调试测试程序时请使用 Chrome."
