# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-10-31 20:38+0000\n"
"PO-Revision-Date: 2014-11-03 00:32+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-components.xml:11
#, no-c-format
msgid "User Interface Components"
msgstr "UI 组件"

#. Tag: para
#: chapter-components.xml:13
#, no-c-format
msgid ""
"This chapter provides an overview and a detailed description of all non-"
"layout components in Vaadin."
msgstr "本章介绍 Vaadin 中主要的 UI 组件(layout 管理组件除外)."

#. Tag: emphasis
#: chapter-components.xml:19
#, no-c-format
msgid ""
"Because of pressing release schedules to get this edition to your hands, "
"some topics still require revision for Vaadin 7, especially the data binding "
"of the <classname>Table</classname> component. Please consult the web "
"version once it is updated, or the next print edition."
msgstr ""
"对于 Vaadin 7 版本, 本章的一部分内容还有待审核, 尤其是关于 <classname>Table</"
"classname> 组件的数据绑定问题, 为了尽快完成本书, 我们暂时发布这个未审核完毕的"
"版本. 因此请随时查看本书的 Web 版有无更新, 或者请关注印刷版的下一个版本."

#. Tag: title
#: chapter-components.xml:26
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-components.xml:28
#, no-c-format
msgid ""
"Vaadin provides a comprehensive set of user interface components and allows "
"you to define custom components. <xref linkend=\"figure.uicomponents\"/> "
"illustrates the inheritance hierarchy of the UI component classes and "
"interfaces. Interfaces are displayed in gray, abstract classes in orange, "
"and regular classes in blue. An annotated version of the diagram is featured "
"in the <emphasis>Vaadin Cheat Sheet</emphasis>."
msgstr ""
"Vaadin 提供了功能广泛的 UI 组件, 还允许你开发自定义组件. <xref linkend="
"\"figure.uicomponents\"/> 展示了 UI 组件类和接口的继承层级关系. 接口表示为灰"
"色, 抽象类为桔黄色, 一般类为蓝色. 这个图的详细注解版本可参见 "
"<emphasis>Vaadin Cheat Sheet</emphasis>."

#. Tag: title
#: chapter-components.xml:38
#, no-c-format
msgid "User Interface Component Class Hierarchy"
msgstr "UI 组件的类层级关系图"

#. Tag: classname
#: chapter-components.xml:50
#, no-c-format
msgid "Component"
msgstr "组件"

#. Tag: para
#: chapter-components.xml:50
#, no-c-format
msgid ""
"At the top of the interface hierarchy, we have the <classname>Component</"
"classname> interface. <indexterm><primary><classname>AbstractComponent</"
"classname></primary></indexterm> At the top of the class hierarchy, we have "
"the <classname>AbstractComponent</classname> class. "
"<indexterm><primary><classname>AbstractField</classname></primary></"
"indexterm> <indexterm><primary><classname>AbstractComponentContainer</"
"classname></primary></indexterm> It is inherited by two other abstract "
"classes: <classname>AbstractField</classname>, inherited further by field "
"components, and <classname>AbstractComponentContainer</classname>, inherited "
"by various container and layout components. Components that are not bound to "
"a content data model, such as labels and links, inherit "
"<classname>AbstractComponent</classname> directly."
msgstr ""
"在接口层级关系最顶端的是 <classname>Component</classname> 接口. "
"<indexterm><primary><classname>AbstractComponent</classname></primary></"
"indexterm> 在类层级关系最顶端的是 <classname>AbstractComponent</classname> "
"类. <indexterm><primary><classname>AbstractField</classname></primary></"
"indexterm> <indexterm><primary><classname>AbstractComponentContainer</"
"classname></primary></indexterm> 从这个类继承了两个其他抽象类: "
"<classname>AbstractField</classname>, 是所有 Field 组件的基类, 以及 "
"<classname>AbstractComponentContainer</classname>, 是各种容器组件和 Layout 管"
"理组件的基类. 不与数据模型绑定的组件, 比如 Label 和 Link, 直接继承自 "
"<classname>AbstractComponent</classname>."

#. Tag: primary
#: chapter-components.xml:72
#, no-c-format
msgid "layout"
msgstr "布局"

#. Tag: classname
#: chapter-components.xml:73
#, no-c-format
msgid "Layout"
msgstr "布局"

#. Tag: para
#: chapter-components.xml:73
#, no-c-format
msgid ""
"The layout of the various components in a window is controlled, logically, "
"by layout components, just like in conventional Java UI toolkits for desktop "
"applications. In addition, with the <classname>CustomLayout</classname> "
"component, you can write a custom layout as an HTML template that includes "
"the locations of any contained components. Looking at the inheritance "
"diagram, we can see that layout components inherit the "
"<classname>AbstractComponentContainer</classname> and the <classname>Layout</"
"classname> interface. Layout components are described in detail in <xref "
"linkend=\"layout\"/>."
msgstr ""
"同一个窗口内的多个组件, 其布局由布局管理组件来控制, 这一点与桌面应用程序的 "
"Java UI 开发工具类似. 此外, 使用 <classname>CustomLayout</classname> 组件, 你"
"可以编写自定义的布局组件, 自定义布局是 HTML 模板形式, 模板中包含了其他子组件"
"的位置. 阅读上面的继承关系图, 我们可以看到布局管理组件继承自 "
"<classname>AbstractComponentContainer</classname> 类, 以及 "
"<classname>Layout</classname> 接口. 布局管理组件的详情, 请参见 <xref linkend="
"\"layout\"/>."

#. Tag: classname
#: chapter-components.xml:87
#, no-c-format
msgid "Window"
msgstr "窗口"

#. Tag: para
#: chapter-components.xml:87
#, no-c-format
msgid ""
"Looking at it from the perspective of an object hierarchy, we would have a "
"<classname>Window</classname> object, which contains a hierachy of layout "
"components, which again contain other layout components, field components, "
"and other visible components."
msgstr ""
"从对象包含层级关系的角度来看, 最顶层是 <classname>Window</classname> 对象, 它"
"之下包含了多层级的布局管理组件, 这些布局管理组件再包含其他布局管理组件, "
"Field 组件, 以及其他各种可见组件."

#. Tag: primary
#: chapter-components.xml:96
#, no-c-format
msgid "Sampler"
msgstr "示例"

#. Tag: primary
#: chapter-components.xml:97
#, no-c-format
msgid "JavaDoc"
msgstr ""

#. Tag: para
#: chapter-components.xml:97
#, no-c-format
msgid ""
"You can browse the built-in UI components of Vaadin library in the "
"<application>Sampler</application> application of the <application>Vaadin "
"Demo</application>. The Sampler shows a description, JavaDoc documentation, "
"and a code samples for each of the components."
msgstr ""
"你可以在 <application>Vaadin Demo</application> 的<application>示例</"
"application>应用程序中浏览 Vaadin 库中的内建 UI 组件. 这个示例程序会为每个 "
"UI 组件显示一段介绍信息, JavaDoc 文档, 以及示例代码."

#. Tag: para
#: chapter-components.xml:105
#, no-c-format
msgid ""
"In addition to the built-in components, many components are available as add-"
"ons, either from the Vaadin Directory or from independent sources. Both "
"commercial and free components exist. The installation of add-ons is "
"described in <xref linkend=\"addons\"/>."
msgstr ""
"除内建组件外, 还有很多组件可以通过插件的形式获得, 插件可从 Vaadin Directory "
"得到, 或者从其他来源得到. 既有商业插件, 也有免费插件. 关于插件的安装方法, 请"
"参见 <xref linkend=\"addons\"/>."

#. Tag: title
#: chapter-components.xml:113
#, no-c-format
msgid "Vaadin Cheat Sheet and Refcard"
msgstr "Vaadin Cheat Sheet 和 Refcard"

#. Tag: para
#: chapter-components.xml:115
#, no-c-format
msgid ""
"is included in the Vaadin Cheat Sheet that illustrates the basic "
"relationship hierarchy of the user interface components and data binding "
"classes and interfaces. You can download it at <link xlink:href=\"http://"
"vaadin.com/book\">http://vaadin.com/book</link>."
msgstr ""
"包含在 Vaadin Cheat Sheet 中, Vaadin Cheat Sheet 展示了 UI 组件级数据绑定类/"
"接口的基本层级关系. 你可以在以下地址下载 Vaadin Cheat Sheet: <link xlink:"
"href=\"http://vaadin.com/book\">http://vaadin.com/book</link>."

#. Tag: para
#: chapter-components.xml:123
#, no-c-format
msgid ""
"The diagram is also included in the six-page DZone Refcard, which you can "
"find at <link xlink:href=\"https://vaadin.com/refcard\">https://vaadin.com/"
"refcard</link>."
msgstr ""
"上图也包含在 DZone Refcard 中, DZone Refcard 可以在以下地址得到: <link xlink:"
"href=\"https://vaadin.com/refcard\">https://vaadin.com/refcard</link>."

#. Tag: title
#: chapter-components.xml:132
#, no-c-format
msgid "Interfaces and Abstractions"
msgstr "接口和抽象类"

#. Tag: primary
#: chapter-components.xml:135
#, no-c-format
msgid "interfaces"
msgstr "接口"

#. Tag: para
#: chapter-components.xml:135
#, no-c-format
msgid ""
"Vaadin user interface components are built on a skeleton of interfaces and "
"abstract classes that define and implement the features common to all "
"components and the basic logic how the component states are serialized "
"between the server and the client."
msgstr ""
"Vaadin UI 组件构建在一系列接口和抽象类的基础之上, 这些接口和抽象类定义并实现"
"了所有组件的共通功能, 还定义并实现了组件状态在服务器端和客户端之间序列化的基"
"本逻辑."

#. Tag: para
#: chapter-components.xml:143
#, no-c-format
msgid ""
"This section gives details on the basic component interfaces and "
"abstractions. The layout and other component container abstractions are "
"described in <xref linkend=\"layout\"/>. The interfaces that define the "
"Vaadin data model are described in <xref linkend=\"datamodel\"/>."
msgstr ""
"本节介绍基本的组件接口和抽象类. 关于布局组件和其他组件容器的抽象类, 请参见"
"<xref linkend=\"layout\"/>. Vaadin 数据模型相关的接口, 请参见<xref linkend="
"\"datamodel\"/>."

#. Tag: title
#: chapter-components.xml:151
#, no-c-format
msgid "Component Interfaces and Abstractions"
msgstr "组件接口和抽象类"

#. Tag: classname
#: chapter-components.xml:163
#, no-c-format
msgid "Paintable"
msgstr ""

#. Tag: classname
#: chapter-components.xml:164
#, no-c-format
msgid "VariableOwner"
msgstr ""

#. Tag: para
#: chapter-components.xml:164
#, no-c-format
msgid ""
"All components also implement the <classname>Paintable</classname> "
"interface, which is used for serializing (\"painting\") the components to "
"the client, and the reverse <classname>VariableOwner</classname> interface, "
"which is needed for deserializing component state or user interaction from "
"the client."
msgstr ""
"所有的组件也都实现了 <classname>Paintable</classname> 接口, 这个接口用于将组"
"件序列化 (\"描绘\") 到客户端, 还实现了相反地 <classname>VariableOwner</"
"classname> 接口, 这个接口用于将组件状态或用户操作从客户端反序列化到服务器端."

#. Tag: classname
#: chapter-components.xml:173
#, no-c-format
msgid "Serializable"
msgstr ""

#. Tag: para
#: chapter-components.xml:173
#, no-c-format
msgid ""
"In addition to the interfaces defined within the Vaadin framework, all "
"components implement the <classname>java.io.Serializable</classname> "
"interface to allow serialization. Serialization is needed in many clustering "
"and cloud computing solutions."
msgstr ""
"除 Vaadin 框架定义的接口外, 所有的组件还都实现了 <classname>java.io."
"Serializable</classname> 接口, 用于序列化. 对于很多集群计算和云计算解决方案来"
"说, 序列化功能是必须的."

#. Tag: title
#: chapter-components.xml:182
#, no-c-format
msgid "<classname>Component</classname> Interface"
msgstr "<classname>Component</classname> 组件"

#. Tag: primary
#: chapter-components.xml:185 chapter-components.xml:241
#, no-c-format
msgid "<classname>Component</classname> interface"
msgstr "<classname>Component</classname> 组件"

#. Tag: para
#: chapter-components.xml:188
#, no-c-format
msgid ""
"The <classname>Component</classname> interface is paired with the "
"<classname>AbstractComponent</classname> class, which implements all the "
"methods defined in the interface."
msgstr ""
"<classname>Component</classname> 接口与 <classname>AbstractComponent</"
"classname> 类相对应, AbstractComponent 类实现了 Component 接口定义的所有方法."

#. Tag: title
#: chapter-components.xml:195
#, no-c-format
msgid "Component Tree Management"
msgstr "组件包含层级关系的管理"

#. Tag: para
#: chapter-components.xml:197
#, no-c-format
msgid ""
"Components are laid out in the user interface hierarchically. The layout is "
"managed by layout components, or more generally components that implement "
"the <classname>ComponentContainer</classname> interface. Such a container is "
"the parent of the contained components."
msgstr ""
"组件以 UI 层级关系的形式管理. 层级关系由布局管理组件控制, 或者更一般地说, 由"
"实现了 <classname>ComponentContainer</classname> 接口的容器组件控制. 因此一个"
"容器就是它包含的子组件的父组件."

#. Tag: para
#: chapter-components.xml:204
#, no-c-format
msgid ""
"The <methodname>getParent()</methodname> method allows retrieving the parent "
"component of a component. While there is a <methodname>setParent()</"
"methodname>, you rarely need it as you usually add components with the "
"<methodname>addComponent()</methodname> method of the "
"<classname>ComponentContainer</classname> interface, which automatically "
"sets the parent."
msgstr ""
"<methodname>getParent()</methodname> 方法可以得到一个组件的父组件. 与此对应的"
"存在一个 <methodname>setParent()</methodname> 方法, 但一般很少使用这个方法, "
"通常我们使用 <classname>ComponentContainer</classname> 接口的 "
"<methodname>addComponent()</methodname> 方法来添加子组件, 这个方法将自动地为"
"子组件设置它的父组件."

#. Tag: para
#: chapter-components.xml:214
#, no-c-format
msgid ""
"A component does not know its parent when the component is still being "
"created, so you can not refer to the parent in the constructor with "
"<methodname>getParent()</methodname>."
msgstr ""
"组件创建过程中还不能确定自己的父组件, 所以在组件的构造方法中, 你无法通过 "
"<methodname>getParent()</methodname> 方法得到父组件."

#. Tag: para
#: chapter-components.xml:220
#, no-c-format
msgid ""
"Attaching a component to an UI triggers a call to its <methodname>attach()</"
"methodname> method. Correspondingly, removing a component from a container "
"triggers calling the <methodname>detach()</methodname> method. If the parent "
"of an added component is already connected to the UI, the "
"<methodname>attach()</methodname> is called immediately from "
"<methodname>setParent()</methodname>."
msgstr ""
"将组件关联到 UI, 会触发对 <methodname>attach()</methodname> 方法的调用. 相对"
"的, 将组件从容器中删除, 会触发对 <methodname>detach()</methodname> 方法的调"
"用. 如果新添加的组件的父组件已经被关联到 UI 上, 那么 "
"<methodname>setParent()</methodname> 方法会立即调用 <methodname>attach()</"
"methodname> 方法."

#. Tag: programlisting
#: chapter-components.xml:230
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class AttachExample extends "
"CustomComponent {\n"
"    public AttachExample() {\n"
"    }\n"
"    \n"
"    @Override\n"
"    public void attach() {\n"
"        super.attach(); // Must call.\n"
"        \n"
"        // Now we know who ultimately owns us.\n"
"        ClassResource r = new ClassResource(\"smiley.jpg\");\n"
"        Image image = new Image(\"Image:\", r); \n"
"        setCompositionRoot(image);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:232
#, no-c-format
msgid ""
"The attachment logic is implemented in <classname>AbstractComponent</"
"classname>, as described in <xref linkend=\"components.interfaces."
"abstractcomponent\"/>."
msgstr ""
"组件与 UI 的绑定逻辑由 <classname>AbstractComponent</classname> 类实现, 详情"
"请参见 <xref linkend=\"components.interfaces.abstractcomponent\"/>."

#. Tag: classname
#: chapter-components.xml:246 chapter-components.xml:249
#, no-c-format
msgid "AbstractComponent"
msgstr ""

#. Tag: para
#: chapter-components.xml:252
#, no-c-format
msgid ""
"<classname>AbstractComponent</classname> is the base class for all user "
"interface components. It is the (only) implementation of the "
"<classname>Component</classname> interface, implementing all the methods "
"defined in the interface."
msgstr ""
"<classname>AbstractComponent</classname> 是所有 UI 组件的基类. 它是"
"<classname>Component</classname> 接口的(唯一的)实现类, 它实现了 Component 接"
"口定义的所有方法."

#. Tag: para
#: chapter-components.xml:259
#, no-c-format
msgid ""
"<classname>AbstractComponent</classname> has a single abstract method, "
"<methodname>getTag()</methodname>, which returns the serialization "
"identifier of a particular component class. It needs to be implemented when "
"(and only when) creating entirely new components. "
"<classname>AbstractComponent</classname> manages much of the serialization "
"of component states between the client and the server. Creation of new "
"components and serialization is described in <xref linkend=\"gwt\"/>."
msgstr ""
"<classname>AbstractComponent</classname> 中有唯一一个抽象方法, "
"<methodname>getTag()</methodname> 方法, 它返回各个特定组件类的序列化 ID. 当"
"(而且仅当)创建全新的组件时, 需要实现这个方法. <classname>AbstractComponent</"
"classname> 类管理了组件状态在客户端与服务器端之间序列化的大多数任务. 关于创建"
"新组件以及组件的序列化, 详情请参见 <xref linkend=\"gwt\"/>."

#. Tag: title
#: chapter-components.xml:275
#, no-c-format
msgid "Common Component Features"
msgstr "组件的共通功能"

#. Tag: para
#: chapter-components.xml:277
#, no-c-format
msgid ""
"The component base classes and interfaces provide a large number of "
"features. Let us look at some of the most commonly needed features. Features "
"not documented here can be found from the Java API Reference."
msgstr ""
"组件的基类和接口提供了大量的功能. 下面我们来看看最常用到的功能. 本文未介绍到"
"的其他功能, 请参见 Java API 文档."

#. Tag: para
#: chapter-components.xml:283
#, no-c-format
msgid ""
"The interface defines a number of properties, which you can retrieve or "
"manipulate with the corresponding setters and getters."
msgstr ""
"Component 接口定义了很多属性, 通过对应的 getter 方法可以得到属性值, 通过 "
"setter方法可以控制属性值."

#. Tag: title
#: chapter-components.xml:289
#, no-c-format
msgid "Caption"
msgstr "标题"

#. Tag: primary
#: chapter-components.xml:292
#, no-c-format
msgid "caption property"
msgstr "caption 属性"

#. Tag: primary
#: chapter-components.xml:296 chapter-components.xml:393
#: chapter-components.xml:486 chapter-components.xml:564
#: chapter-components.xml:644 chapter-components.xml:757
#: chapter-components.xml:857 chapter-components.xml:921
#, no-c-format
msgid "Component interface"
msgstr "Component 接口"

#. Tag: secondary
#: chapter-components.xml:297
#, no-c-format
msgid "caption"
msgstr "标题"

#. Tag: para
#: chapter-components.xml:300
#, no-c-format
msgid ""
"A caption is an explanatory textual label accompanying a user interface "
"component, usually shown above, left of, or inside the component. The "
"contents of a caption are automatically quoted, so no raw HTML can be "
"rendered in a caption."
msgstr ""
"标题是与 UI 组件相伴随的文字, 用于解释 UI 组件, 通常显示在组件的上方, 左方, "
"或内部. 标题的内容会被自动理解为原始字符串,因此在标题中不能显示原生的 HTML 内"
"容."

#. Tag: para
#: chapter-components.xml:307
#, no-c-format
msgid ""
"The caption text can usually be given as the first parameter of a "
"constructor of a component or with <methodname>setCaption()</methodname>."
msgstr ""
"标题文本通常通过组件构造函数的第一个参数来设置, 或者使用 "
"<methodname>setCaption()</methodname> 方法来设置."

#. Tag: programlisting
#: chapter-components.xml:312
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// New text field with caption \"Name\"\n"
"TextField name = new TextField(\"Name\");\n"
"layout.addComponent(name);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:314
#, no-c-format
msgid ""
"The caption of a component is, by default, managed and displayed by the "
"layout component or component container inside which the component is "
"placed. For example, the <classname>VerticalLayout</classname> component "
"shows the captions left-aligned above the contained components, while the "
"<classname>FormLayout</classname> component shows the captions on the left "
"side of the vertically laid components, with the captions and their "
"associated components left-aligned in their own columns. The "
"<classname>CustomComponent</classname> does not manage the caption of its "
"composition root, so if the root component has a caption, it will not be "
"rendered."
msgstr ""
"组件标题的管理和显示, 默认由这个组件所属的布局管理组件或组件容器负责. 比如, "
"布局管理组件 <classname>VerticalLayout</classname> 将它的子组件的标题在各组件"
"的上方左对齐显示, 而布局管理组件 <classname>FormLayout</classname>将它的子组"
"件垂直排列, 并将标题显示在各组件左侧, 标题与对应的组件在各自的列中左对齐显示"
"(译注: 原文如此, 参照下面的图, 貌似组件左对齐显示, 标题右对齐显示). "
"<classname>CustomComponent</classname> 不管理它的复合组件的根组件的标题, 因此"
"即使根组件有标题, 它也不会被显示在画面中."

#. Tag: title
#: chapter-components.xml:328
#, no-c-format
msgid ""
"Caption Management by <classname>VerticalLayout</classname> and "
"<classname>FormLayout</classname>."
msgstr ""
"由 <classname>VerticalLayout</classname> 和 <classname>FormLayout</"
"classname> 管理的组件标题."

#. Tag: para
#: chapter-components.xml:339
#, no-c-format
msgid ""
"Some components, such as <classname>Button</classname> and <classname>Panel</"
"classname>, manage the caption themselves and display it inside the "
"component."
msgstr ""
"某些组件, 比如 <classname>Button</classname> 和 <classname>Panel</"
"classname>, 会管理自己的标题, 将标题显示在自己内部."

#. Tag: para
#: chapter-components.xml:345
#, no-c-format
msgid ""
"Icon (see <xref linkend=\"components.features.icon\"/>) is closely related "
"to caption and is usually displayed horizontally before or after it, "
"depending on the component and the containing layout. Also the required "
"indicator in field components is usually shown before or after the caption."
msgstr ""
"图标 (参见 <xref linkend=\"components.features.icon\"/>) 与标题关系密切, 通常"
"显示在标题的左侧或右侧, 具体情况由不同的组件及组件所属的布局决定. 此外, "
"Field 组件的\"必须项目指示器\"通常也显示在标题的左侧或右侧."

#. Tag: para
#: chapter-components.xml:353
#, no-c-format
msgid ""
"An alternative way to implement a caption is to use another component as the "
"caption, typically a <classname>Label</classname>, a <classname>TextField</"
"classname>, or a <classname>Panel</classname>. A <classname>Label</"
"classname>, for example, allows highlighting a shortcut key with HTML markup "
"or to bind the caption to a data source. The <classname>Panel</classname> "
"provides an easy way to add both a caption and a border around a component."
msgstr ""
"实现标题的另一种方案, 是使用另一个组件来当作标题, 通常是用 <classname>Label</"
"classname>, <classname>TextField</classname>, 或 <classname>Panel</"
"classname>. 以 <classname>Label</classname> 为例, 它可以使用 HTML 来高亮显示"
"快捷键, 也可以将标题内容绑定到数据源. <classname>Panel</classname> 则提供了一"
"种简便方法, 可以在组件外围同时添加标题和边框."

#. Tag: title
#: chapter-components.xml:364 chapter-components.xml:532
#: chapter-components.xml:624 chapter-components.xml:829
#: chapter-components.xml:1197 chapter-components.xml:2401
#: chapter-components.xml:2523 chapter-components.xml:2878
#: chapter-components.xml:3006 chapter-components.xml:3057
#: chapter-components.xml:3171 chapter-components.xml:3381
#: chapter-components.xml:3465 chapter-components.xml:3568
#: chapter-components.xml:3632 chapter-components.xml:3754
#: chapter-components.xml:3816 chapter-components.xml:3860
#: chapter-components.xml:3955 chapter-components.xml:4055
#: chapter-components.xml:4942 chapter-components.xml:5178
#: chapter-components.xml:5352 chapter-components.xml:5463
#: chapter-components.xml:5585
#, no-c-format
msgid "CSS Style Rules"
msgstr "CSS 样式规则"

#. Tag: programlisting
#: chapter-components.xml:366
#, no-c-format
msgid ""
"<![CDATA[.v-caption {}\n"
"  .v-captiontext {}\n"
"  .v-caption-clearelem {}\n"
"  .v-required-field-indicator {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:368
#, no-c-format
msgid ""
"A caption is be rendered inside an HTML element that has the <literal>v-"
"caption</literal> CSS style class. The containing layout may enclose a "
"caption inside other caption-related elements."
msgstr ""
"标题被描绘在 HTML 元素的内部, 这个元素带有 <literal>v-caption</literal> CSS "
"样式类. 组件所属的布局管理组件可能会将组件标题封装在其他某种与标题相关的 "
"HTML 元素内部."

#. Tag: para
#: chapter-components.xml:374
#, no-c-format
msgid ""
"Some layouts put the caption text in a <literal>v-captiontext</literal> "
"element. A <literal>v-caption-clearelem</literal> is used in some layouts to "
"clear a CSS <literal>float</literal> property in captions. An optional "
"required indicator in field components is contained in a separate element "
"with <literal>v-required-field-indicator</literal> style."
msgstr ""
"某些布局方案将标题文本放在 <literal>v-captiontext</literal> 元素内. 某些布局"
"方案在标题内使用 <literal>v-caption-clearelem</literal> 来清除 CSS "
"<literal>float</literal> 属性. Field 组件的(可选的)\"必须项目指示器\"被包含在"
"一个独立的元素中, 这个元素的样式是 <literal>v-required-field-indicator</"
"literal>."

#. Tag: title
#: chapter-components.xml:386
#, no-c-format
msgid "Description and Tooltips"
msgstr "描述信息和提示信息"

#. Tag: primary
#: chapter-components.xml:389
#, no-c-format
msgid "description property"
msgstr "description 属性"

#. Tag: secondary
#: chapter-components.xml:394
#, no-c-format
msgid "<secondary>description</secondary>"
msgstr ""

#. Tag: primary
#: chapter-components.xml:398
#, no-c-format
msgid "tooltips"
msgstr ""

#. Tag: para
#: chapter-components.xml:401
#, no-c-format
msgid ""
"All components (that inherit <classname>AbstractComponent</classname>) have "
"a description separate from their caption. The description is usually shown "
"as a tooltip that appears when the mouse pointer hovers over the component "
"for a short time."
msgstr ""
"继承自 <classname>AbstractComponent</classname>的所有组件, 除标题之外还有一个"
"描述信息. 描述信息通常以提示信息(tooltip)的方式显示, 当鼠标指针在组件上停留一"
"个短暂的时间之后, 提示信息就会显示出来."

#. Tag: para
#: chapter-components.xml:408
#, no-c-format
msgid ""
"You can set the description with <methodname>setDescription()</methodname> "
"and retrieve with <methodname>getDescription()</methodname>."
msgstr ""
"描述信息可以使用 <methodname>setDescription()</methodname> 方法来设置, 使用 "
"<methodname>getDescription()</methodname> 方法来取得."

#. Tag: programlisting
#: chapter-components.xml:413
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Button button = new Button(\"A Button\");\n"
"button.setDescription(\"This is the tooltip\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:415
#, no-c-format
msgid ""
"The tooltip is shown in <xref linkend=\"figure.components.tooltip.plain\"/>."
msgstr ""
"提示信息的显示状况参见 <xref linkend=\"figure.components.tooltip.plain\"/>."

#. Tag: title
#: chapter-components.xml:421
#, no-c-format
msgid "Component Description as a Tooltip"
msgstr "组件描述信息以提示信息(Tooltip)的方式显示"

#. Tag: para
#: chapter-components.xml:432
#, no-c-format
msgid "A description is rendered as a tooltip in most components."
msgstr "描述信息在大多数组件中都作为提示信息来显示."

#. Tag: para
#: chapter-components.xml:437
#, no-c-format
msgid ""
"When a component error has been set with <methodname>setComponentError()</"
"methodname>, the error is usually also displayed in the tooltip, below the "
"description. Components that are in error state will also display the error "
"indicator. See <xref linkend=\"application.errors.error-indicator\"/>."
msgstr ""
"当使用 <methodname>setComponentError()</methodname> 方法设置了组件错误信息"
"时, 错误信息通常也会被显示在提示信息中, 但在描述信息的下方. 处于错误状态的组"
"件还会显示错误指示器. 详情请参见 <xref linkend=\"application.errors.error-"
"indicator\"/>."

#. Tag: para
#: chapter-components.xml:445
#, no-c-format
msgid ""
"The description is actually not plain text, but you can use HTML tags to "
"format it. Such a rich text description can contain any HTML elements, "
"including images."
msgstr ""
"描述信息实际上不是纯文本, 你可以使用 HTML tag 控制它的格式. 这种富文本的描述"
"信息中可以包含任意的 HTML 元素, 包括图片."

#. Tag: programlisting
#: chapter-components.xml:452
#, no-c-format
msgid ""
"<?pocket-size 60% ?><![CDATA[button.setDescription(\n"
"    \"<h2><img src=\\\"../VAADIN/themes/sampler/icons/comment_yellow.gif\\\"/"
">\"+\n"
"    \"A richtext tooltip</h2>\"+\n"
"    \"<ul>\"+\n"
"    \"  <li>Use rich formatting with HTML</li>\"+\n"
"    \"  <li>Include images from themes</li>\"+\n"
"    \"  <li>etc.</li>\"+\n"
"    \"</ul>\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:454
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.tooltip.richtext\"/"
">."
msgstr "运行结果参见 <xref linkend=\"figure.components.tooltip.richtext\"/>."

#. Tag: title
#: chapter-components.xml:460
#, no-c-format
msgid "A Rich Text Tooltip"
msgstr "富文本的提示信息"

#. Tag: para
#: chapter-components.xml:471
#, no-c-format
msgid ""
"Notice that the setter and getter are defined for all fields in the "
"<classname>Field</classname> interface, not for all components in the "
"<classname>Component</classname> interface."
msgstr ""
"注意, 这个属性的设置方法和取得方法定义在 <classname>Field</classname> 接口"
"中, 是属于所有 Field 的, 而不是定义在 <classname>Component</classname> 接口"
"中, 属于所有组件的.(译注, 这句话对于 Vaadin 6 是正确的, 但在 Vaadin 7中, 这个"
"属性的取得方法定义在 <classname>Component</classname> 接口中, 设置方法定义在 "
"<classname>AbstractComponent</classname> 类中)"

#. Tag: title
#: chapter-components.xml:479
#, no-c-format
msgid "Enabled"
msgstr "激活与禁用"

#. Tag: primary
#: chapter-components.xml:482
#, no-c-format
msgid "enabled property"
msgstr "enabled 属性"

#. Tag: secondary
#: chapter-components.xml:487
#, no-c-format
msgid "enabled"
msgstr ""

#. Tag: para
#: chapter-components.xml:490
#, no-c-format
msgid ""
"The <emphasis>enabled</emphasis> property controls whether the user can "
"actually use the component. A disabled component is visible, but grayed to "
"indicate the disabled state."
msgstr ""
"<emphasis>enabled</emphasis> 属性控制用户是否可以使用这个组件. 被禁用的组件是"
"可见的, 但被显示为灰色, 表示它目前不可使用."

#. Tag: para
#: chapter-components.xml:496
#, no-c-format
msgid ""
"Components are always enabled by default. You can disable a component with "
"<methodname>setEnabled(false)</methodname>."
msgstr ""
"组件默认总是激活的. 你可以使用 <methodname>setEnabled(false)</methodname> 方"
"法禁用一个组件."

#. Tag: programlisting
#: chapter-components.xml:501
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[Button enabled = new Button(\"Enabled\");\n"
"enabled.setEnabled(true); // The default\n"
"layout.addComponent(enabled);\n"
"        \n"
"Button disabled = new Button(\"Disabled\");\n"
"disabled.setEnabled(false);\n"
"layout.addComponent(disabled);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:503
#, no-c-format
msgid "shows the enabled and disabled buttons."
msgstr "展示了激活的按钮和禁用的按钮."

#. Tag: title
#: chapter-components.xml:509
#, no-c-format
msgid "An Enabled and Disabled <classname>Button</classname>"
msgstr "激活和禁用的 <classname>Button</classname>"

#. Tag: para
#: chapter-components.xml:520
#, no-c-format
msgid ""
"A disabled component is automatically put in read-only state. No client "
"interaction with such a component is sent to the server and, as an important "
"security feature, the server-side components do not receive state updates "
"from the client in the read-only state. This feature exists in all built-in "
"components in Vaadin and is automatically handled for all <classname>Field</"
"classname> components for the field property value. For custom widgets, you "
"need to make sure that the read-only state is checked on the server-side for "
"all safety-critical variables."
msgstr ""
"被禁用的组件会自动进入只读状态. 这种组件不会有用户操作发送到服务器端, 而且, "
"作为一种重要的安全特性, 服务器端组件处于只读状态时也不会接收来自客户端的状态"
"更新. 这个特性存在于 Vaadin 的所有内建组件中, 而且对于所有 <classname>Field</"
"classname> 组件的值属性也自动做了这类处理. 对于自定义 widget, 你需要保证在服"
"务器端对于所有安全攸关的变量, 都有正确地检查只读状态."

#. Tag: para
#: chapter-components.xml:534
#, no-c-format
msgid ""
"Disabled components have the <literal>v-disabled</literal> CSS style in "
"addition to the component-specific style. To match a component with both the "
"styles, you have to join the style class names with a dot as done in the "
"example below."
msgstr ""
"被禁用的组件除组件原有的样式外, 还会带有 <literal>v-disabled</literal> CSS 样"
"式. 如果要匹配同时具有这两种样式的组件, 你需要将两种样式类名用点号结合起来, "
"参见下面的例子."

#. Tag: programlisting
#: chapter-components.xml:541
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[.v-textfield.v-disabled {\n"
"    border: dotted;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:543
#, no-c-format
msgid "This would make the border of all disabled text fields dotted."
msgstr "这个 CSS 规则会让被禁用的文本输入框的边框显示为点状."

#. Tag: para
#: chapter-components.xml:548
#, no-c-format
msgid ""
"In Valo theme, the opacity of disabled components is specified with the "
"<varname>$v-disabled-opacity</varname> parameter<phrase condition=\"web\">, "
"as described in <xref linkend=\"themes.valo.variables\"/></phrase>."
msgstr ""
"在 Valo Theme 中, 被禁用组件的不透明度是由 <varname>$v-disabled-opacity</"
"varname> 参数指定的<phrase condition=\"web\">, 详情请参见 <xref linkend="
"\"themes.valo.variables\"/></phrase>."

#. Tag: title
#: chapter-components.xml:557
#, no-c-format
msgid "Icon"
msgstr "图标"

#. Tag: primary
#: chapter-components.xml:560
#, no-c-format
msgid "icon property"
msgstr "icon 属性"

#. Tag: secondary
#: chapter-components.xml:565
#, no-c-format
msgid "icon"
msgstr ""

#. Tag: para
#: chapter-components.xml:568
#, no-c-format
msgid ""
"An icon is an explanatory graphical label accompanying a user interface "
"component, usually shown above, left of, or inside the component. Icon is "
"closely related to caption (see <xref linkend=\"components.features.caption"
"\"/>) and is usually displayed horizontally before or after it, depending on "
"the component and the containing layout."
msgstr ""
"图标是与 UI 组件相伴随的一种图像标记, 用于解释组件的含义, 通常显示在组件上"
"方, 左方, 或组件内部. 图标与标题密切相关(参见 <xref linkend=\"components."
"features.caption\"/>) , 通常显示在标题的左侧或右侧, 具体如何由组件和包含组件"
"的布局管理器决定."

#. Tag: para
#: chapter-components.xml:577
#, no-c-format
msgid ""
"The icon of a component can be set with the <methodname>setIcon()</"
"methodname> method. The image is provided as a resource, perhaps most "
"typically a <classname>ThemeResource</classname>."
msgstr ""
"可以通过 <methodname>setIcon()</methodname> 方法设置组件的图标. 图片以资源的"
"方式提供, 最通用的是 <classname>ThemeResource</classname>."

#. Tag: programlisting
#: chapter-components.xml:583
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Component with an icon from a custom theme\n"
"TextField name = new TextField(\"Name\");\n"
"name.setIcon(new ThemeResource(\"icons/user.png\"));\n"
"layout.addComponent(name);\n"
"        \n"
"// Component with an icon from another theme ('runo')\n"
"Button ok = new Button(\"OK\");\n"
"ok.setIcon(new ThemeResource(\"../runo/icons/16/ok.png\"));\n"
"layout.addComponent(ok);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:585
#, no-c-format
msgid ""
"The icon of a component is, by default, managed and displayed by the layout "
"component or component container in which the component is placed. For "
"example, the <classname>VerticalLayout</classname> component shows the icons "
"left-aligned above the contained components, while the "
"<classname>FormLayout</classname> component shows the icons on the left side "
"of the vertically laid components, with the icons and their associated "
"components left-aligned in their own columns. The "
"<classname>CustomComponent</classname> does not manage the icon of its "
"composition root, so if the root component has an icon, it will not be "
"rendered."
msgstr ""
"组件图标的管理和显示, 默认由组件所属的布局管理组件或组件容器负责. 比如, 布局"
"管理组件 <classname>VerticalLayout</classname> 将它的子组件的图标在各组件的上"
"方左对齐显示, 而布局管理组件 <classname>FormLayout</classname> 将它的子组件垂"
"直排列, 并将图标显示在各组件左侧, 图标与对应的组件在各自的列中左对齐显示. "
"<classname>CustomComponent</classname> 不管理它的复合组件的根组件的图标, 因此"
"即使根组件有图标, 它也不会被显示在画面中."

#. Tag: title
#: chapter-components.xml:599
#, no-c-format
msgid "Displaying an Icon from a Theme Resource."
msgstr "使用 Theme Resource 显示一个图标."

#. Tag: para
#: chapter-components.xml:610
#, no-c-format
msgid ""
"Some components, such as <classname>Button</classname> and <classname>Panel</"
"classname>, manage the icon themselves and display it inside the component."
msgstr ""
"某些组件, 比如 <classname>Button</classname> 和 <classname>Panel</"
"classname>, 会管理自己的图标, 将图标显示在自己内部."

#. Tag: para
#: chapter-components.xml:616
#, no-c-format
msgid ""
"In addition to image resources, you can use <emphasis>font icons</emphasis>, "
"which are icons included in special fonts, but which are handled as special "
"resources. See <xref linkend=\"themes.fonticon\"/> for more details."
msgstr ""
"除图片资源外, 你还可以使用 <emphasis>字体图标</emphasis>, 这是一种包含在特殊"
"字体之内的图标, 但以特殊资源的方式进行处理. 详情请参见 <xref linkend="
"\"themes.fonticon\"/>."

#. Tag: para
#: chapter-components.xml:626
#, no-c-format
msgid ""
"An icon will be rendered inside an HTML element that has the <literal>v-"
"icon</literal> CSS style class. The containing layout may enclose an icon "
"and a caption inside elements related to the caption, such as <literal>v-"
"caption</literal>."
msgstr ""
"标签被描绘在 HTML 元素的内部, 这个元素带有 <literal>v-icon</literal> CSS 样式"
"类. 组件所属的布局管理组件可能会将组件图标和标签封装在与标签相关的 HTML 元素"
"内部, 比如 <literal>v-caption</literal>."

#. Tag: title
#: chapter-components.xml:636
#, no-c-format
msgid "Locale"
msgstr "语言环境(Locale)"

#. Tag: primary
#: chapter-components.xml:639
#, no-c-format
msgid "locale property"
msgstr "locale 属性"

#. Tag: secondary
#: chapter-components.xml:640
#, no-c-format
msgid "in <classname>Component</classname>"
msgstr ""

#. Tag: secondary
#: chapter-components.xml:645
#, no-c-format
msgid "locale"
msgstr ""

#. Tag: para
#: chapter-components.xml:648
#, no-c-format
msgid ""
"The locale property defines the country and language used in a component. "
"You can use the locale information in conjunction with an "
"internationalization scheme to acquire localized resources. Some components, "
"such as <classname>DateField</classname>, use the locale for component "
"localization."
msgstr ""
"locale 属性定义了组件使用的国家和语言. 你可以将 locale 信息与国际化方案结合起"
"来, 实现资源的本地化. 某些组件, 比如 <classname>DateField</classname>, 使用语"
"言环境来实现组件的本地化."

#. Tag: para
#: chapter-components.xml:656
#, no-c-format
msgid ""
"You can set the locale of a component (or the application) with "
"<methodname>setLocale()</methodname> as follows:"
msgstr ""
"你可以使用 <methodname>setLocale()</methodname> 方法来设置一个组件(或整个应用"
"程序)的语言环境, 例子如下:"

#. Tag: programlisting
#: chapter-components.xml:662
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Component for which the locale is "
"meaningful\n"
"InlineDateField date = new InlineDateField(\"Datum\");\n"
"        \n"
"// German language specified with ISO 639-1 language\n"
"// code and ISO 3166-1 alpha-2 country code. \n"
"date.setLocale(new Locale(\"de\", \"DE\"));\n"
"        \n"
"date.setResolution(Resolution.DAY);\n"
"layout.addComponent(date);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:664
#, no-c-format
msgid ""
"The resulting date field is shown in <xref linkend=\"figure.components."
"features.locale.simple\"/>."
msgstr ""
"日期输入框的运行结果参见 <xref linkend=\"figure.components.features.locale."
"simple\"/>."

#. Tag: title
#: chapter-components.xml:670
#, no-c-format
msgid "Set Locale for <classname>InlineDateField</classname>"
msgstr "为 <classname>InlineDateField</classname> 设置语言环境"

#. Tag: title
#: chapter-components.xml:682
#, no-c-format
msgid "Getting the Locale"
msgstr "取得语言环境"

#. Tag: methodname
#: chapter-components.xml:685
#, no-c-format
msgid "getLocale()"
msgstr ""

#. Tag: para
#: chapter-components.xml:685
#, no-c-format
msgid ""
"You can get the locale of a component with <methodname>getLocale()</"
"methodname>. If the locale is undefined for a component, that is, not "
"explicitly set, the locale of the parent component is used. If none of the "
"parent components have a locale set, the locale of the UI is used, and if "
"that is not set, the default system locale is set, as given by "
"<methodname>Locale.getDefault()</methodname>."
msgstr ""
"你可以使用<methodname>getLocale()</methodname> 方法得到组件的语言环境. 如果组"
"件的语言环境没有指定, 也就是说没有被明确地设置过, 将会使用父组件的语言环境. "
"如果所有父组件的语言环境都没有设置过, 将会使用 UI 的语言环境, 如果 UI 的语言"
"环境也没有设置过, 则会使用系统默认的语言环境, 系统默认语言环境由 "
"<methodname>Locale.getDefault()</methodname> 决定."

#. Tag: para
#: chapter-components.xml:696
#, no-c-format
msgid ""
"The <methodname>getLocale()</methodname> returns null if the component is "
"not yet attached to the UI, which is usually the case in most constructors, "
"so it is a bit awkward to use it for internationalization. You can get the "
"locale in <methodname>attach()</methodname>, as shown in the following "
"example:"
msgstr ""
"如果组件还没有关联到 UI, 那么 <methodname>getLocale()</methodname> 方法会返"
"回 null, 在组件构造方法中通常就会发生这种情况, 所以使用这个方法进行国际化需要"
"用一种比较笨拙的手段. 你可以在 <methodname>attach()</methodname> 方法内取得语"
"言环境, 例子如下:"

#. Tag: programlisting
#: chapter-components.xml:705
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Button cancel = new Button() {\n"
"    @Override\n"
"    public void attach() {\n"
"        super.attach();\n"
"        ResourceBundle bundle = ResourceBundle.getBundle(\n"
"            MyAppCaptions.class.getName(), getLocale());\n"
"        setCaption(bundle.getString(MyAppCaptions.CancelKey));\n"
"    }\n"
"};\n"
"layout.addComponent(cancel);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:707
#, no-c-format
msgid ""
"However, it is normally a better practice to use the locale of the current "
"UI to get the localized resource right when the component is created."
msgstr ""
"但在实际运用中比较好的一种手段是, 在组件的创建过程中, 使用当前 UI 的语言环境"
"来取得本地化资源."

#. Tag: programlisting
#: chapter-components.xml:714
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Captions are stored in MyAppCaptions "
"resource bundle\n"
"// and the UI object is known in this context.\n"
"ResourceBundle bundle =\n"
"    ResourceBundle.getBundle(MyAppCaptions.class.getName(),\n"
"        UI.getCurrent().getLocale());\n"
"        \n"
"// Get a localized resource from the bundle\n"
"Button cancel =\n"
"    new Button(bundle.getString(MyAppCaptions.CancelKey));\n"
"layout.addComponent(cancel);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:718 chapter-components.xml:735
#, no-c-format
msgid "Selecting a Locale"
msgstr "选择语言环境"

#. Tag: para
#: chapter-components.xml:720
#, no-c-format
msgid ""
"A common task in many applications is selecting a locale. This is done in "
"the following example with a <classname>ComboBox</classname>, which gets the "
"available locales in Java."
msgstr ""
"对许多应用程序来说面临的一个共同任务就是选择语言环境. 在下面的例子中, 我们用"
"一个 <classname>ComboBox</classname> 来实现这个任务, 这个下拉框的选择项列出"
"了 Java 中所有可用的语言环境."

#. Tag: programlisting
#: chapter-components.xml:727
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// The locale in which we want to have the "
"language\n"
"// selection list\n"
"Locale displayLocale = Locale.ENGLISH;\n"
"        \n"
"// All known locales\n"
"final Locale[] locales = Locale.getAvailableLocales();\n"
"        \n"
"// Allow selecting a language. We are in a constructor of a\n"
"// CustomComponent, so preselecting the current\n"
"// language of the application can not be done before\n"
"// this (and the selection) component are attached to\n"
"// the application.\n"
"final ComboBox select = new ComboBox(\"Select a language\") {\n"
"    @Override\n"
"    public void attach() {\n"
"        super.attach();\n"
"        setValue(getLocale());\n"
"    }\n"
"};\n"
"for (int i=0; i<locales.length; i++) {\n"
"    select.addItem(locales[i]);\n"
"    select.setItemCaption(locales[i],\n"
"                          locales[i].getDisplayName(displayLocale));\n"
"    \n"
"    // Automatically select the current locale\n"
"    if (locales[i].equals(getLocale()))\n"
"        select.setValue(locales[i]);\n"
"}\n"
"layout.addComponent(select);\n"
"\n"
"// Locale code of the selected locale\n"
"final Label localeCode = new Label(\"\");\n"
"layout.addComponent(localeCode);\n"
"\n"
"// A date field which language the selection will change\n"
"final InlineDateField date =\n"
"    new InlineDateField(\"Calendar in the selected language\");\n"
"date.setResolution(Resolution.DAY);\n"
"layout.addComponent(date);\n"
"        \n"
"// Handle language selection\n"
"select.addValueChangeListener(new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        Locale locale = (Locale) select.getValue();\n"
"        date.setLocale(locale);\n"
"        localeCode.setValue(\"Locale code: \" +\n"
"                            locale.getLanguage() + \"_\" +\n"
"                            locale.getCountry());\n"
"    }\n"
"});\n"
"select.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:729
#, no-c-format
msgid ""
"The user interface is shown in <xref linkend=\"figure.components.features."
"locale.selection\"/>."
msgstr ""
"上面的例子产生的 UI 参见 <xref linkend=\"figure.components.features.locale."
"selection\"/>."

#. Tag: title
#: chapter-components.xml:750
#, no-c-format
msgid "Read-Only"
msgstr "只读"

#. Tag: primary
#: chapter-components.xml:753
#, no-c-format
msgid "read-only property"
msgstr "read-only 属性"

#. Tag: secondary
#: chapter-components.xml:758
#, no-c-format
msgid "read-only"
msgstr ""

#. Tag: para
#: chapter-components.xml:761
#, no-c-format
msgid ""
"The property defines whether the value of a component can be changed. The "
"property is mainly applicable to <classname>Field</classname> components, as "
"they have a value that can be edited by the user."
msgstr ""
"这个属性决定组件的值是否可以变更. 这个属性通常适用于 <classname>Field</"
"classname> 组件, 这类组件拥有可被用户编辑的值."

#. Tag: programlisting
#: chapter-components.xml:767
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[TextField readwrite = new TextField(\"Read-Write"
"\");\n"
"readwrite.setValue(\"You can change this\");\n"
"readwrite.setReadOnly(false); // The default\n"
"layout.addComponent(readwrite);\n"
"        \n"
"TextField readonly = new TextField(\"Read-Only\");\n"
"readonly.setValue(\"You can't touch this!\");\n"
"readonly.setReadOnly(true);\n"
"layout.addComponent(readonly);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:769
#, no-c-format
msgid ""
"The resulting read-only text field is shown in <xref linkend=\"figure."
"components.features.readonly.simple\"/>."
msgstr ""
"上述例子的运行结果是产生一个只读的文本输入框, 参见 <xref linkend=\"figure."
"components.features.readonly.simple\"/>."

#. Tag: title
#: chapter-components.xml:775
#, no-c-format
msgid "A Read-Only Component."
msgstr "只读组件."

#. Tag: para
#: chapter-components.xml:786
#, no-c-format
msgid ""
"Setting a layout or some other component container as read-only does not "
"usually make the contained components read-only recursively. This is "
"different from, for example, the disabled state, which is usually applied "
"recursively."
msgstr ""
"将布局管理组件或者别的某种组件容器设置为只读, 通常不会导致它包含的子组件也递"
"归地设置为只读. 这一点与其他属性不同, 比如禁用状态, 通常就会递归地适用到包含"
"的子组件上."

#. Tag: para
#: chapter-components.xml:793
#, no-c-format
msgid ""
"Notice that the value of a selection component is the selection, not its "
"items. A read-only selection component doesn't therefore allow its selection "
"to be changed, but other changes are possible. For example, if you have a "
"read-only <classname>Table</classname> in editable mode, its contained "
"fields and the underlying data model can still be edited, and the user could "
"sort it or reorder the columns."
msgstr ""
"注意 Selection 组件的值是一个选项列表, 而不是其中的选择项. 所以一个只读的 "
"Selection 组件只是禁止它的选项列表发生变更, 但其他变更是允许的. 比如, 如果你"
"有一个只读的 <classname>Table</classname> 处于可编辑模式, 那么它包含的 "
"Field, 以及底层的数据模型仍然是可以编辑的, 而且用户还可以对表进行排序, 也可以"
"调整列的顺序."

#. Tag: para
#: chapter-components.xml:802
#, no-c-format
msgid ""
"Client-side state modifications will not be communicated to the server-side "
"and, more importantly, server-side field components will not accept changes "
"to the value of a read-only <classname>Field</classname> component. The "
"latter is an important security feature, because a malicious user can not "
"fabricate state changes in a read-only field. This is handled at the level "
"of <classname>AbstractField</classname> in <methodname>setValue()</"
"methodname>, so you can not change the value programmatically either. "
"Calling <methodname>setValue()</methodname> on a read-only field results in "
"<classname>Property.ReadOnlyException</classname>."
msgstr ""
"客户端状态变更无法被发送到服务器端, 而且更重要的是, 服务器端不会接受对一个只"
"读的 <classname>Field</classname> 组件的值的变更. 后面这一点是很重要的安全特"
"性, 因为恶意用户可以对只读的 Field 伪造状态变更请求. 这个功能由 "
"<classname>AbstractField</classname> 类的 <methodname>setValue()</"
"methodname> 方法进行处理, 所以你也不能通过程序来改变只读 Field 组件的值. 在只"
"读 Field 组件上调用 <methodname>setValue()</methodname>  方法将导致 "
"<classname>Property.ReadOnlyException</classname> 例外."

#. Tag: para
#: chapter-components.xml:815
#, no-c-format
msgid ""
"Also notice that while the read-only status applies automatically to the "
"property value of a field, it does not apply to other component variables. A "
"read-only component can accept some other variable changes from the client-"
"side and some of such changes could be acceptable, such as change in the "
"scroll bar position of a <classname>Table</classname>. Custom widgets should "
"check the read-only state for variables bound to business data."
msgstr ""
"还要注意, 当只读状态被应用到 Field 的属性值上时, 它并不会被适用到组件的其他变"
"量上. 只读组件可以从客户端收到其他变量的变更请求, 某些变更请求是可以接受的, "
"比如 <classname>Table</classname> 的滚动条位置. 自定义的 widget 应该对绑定到"
"业务数据上的变量检查其只读状态."

#. Tag: para
#: chapter-components.xml:831
#, no-c-format
msgid ""
"Setting a normally editable component to read-only state can change its "
"appearance to disallow editing the value. In addition to CSS styling, also "
"the HTML structure can change. For example, <classname>TextField</classname> "
"loses the edit box and appears much like a <classname>Label</classname>."
msgstr ""
"将一个通常可编辑的组件设置为只读状态, 可能会改变它的外观表现, 以便禁止用户编"
"辑它. 只读状态下, 除 CSS 样式外, HTML 接口也可能变化. 比如, "
"<classname>TextField</classname> 的文本编辑框会消失, 它的外观表现会变得类似"
"于 <classname>Label</classname>."

#. Tag: para
#: chapter-components.xml:839
#, no-c-format
msgid ""
"A read-only component will have the <literal>v-readonly</literal> style. The "
"following CSS rule would make the text in all read-only "
"<classname>TextField</classname> components appear in italic."
msgstr ""
"只读组件将带有 <literal>v-readonly</literal> 样式. 以下 CSS 样式规则将使所有"
"的只读 <classname>TextField</classname> 组件的文字显示为斜体字."

#. Tag: programlisting
#: chapter-components.xml:845
#, no-c-format
msgid ""
"<![CDATA[.v-textfield.v-readonly {\n"
"    font-style: italic;\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:850
#, no-c-format
msgid "Style Name"
msgstr "样式名称"

#. Tag: primary
#: chapter-components.xml:853
#, no-c-format
msgid "style name property"
msgstr "style name 属性"

#. Tag: secondary
#: chapter-components.xml:858
#, no-c-format
msgid "style name"
msgstr ""

#. Tag: para
#: chapter-components.xml:861
#, no-c-format
msgid ""
"The <emphasis>style name</emphasis> property defines one or more custom CSS "
"style class names for the component. The <methodname>getStyleName()</"
"methodname> returns the current style names as a space-separated list. The "
"<methodname>setStyleName()</methodname> replaces all the styles with the "
"given style name or a space-separated list of style names. You can also add "
"and remove individual style names with <methodname>addStylename()</"
"methodname> and <methodname>removeStyleName()</methodname>. A style name "
"must be a valid CSS style name."
msgstr ""
"<emphasis>style name</emphasis> 属性为组件指定一个或多个自定义的 CSS 样式类. "
"<methodname>getStyleName()</methodname> 方法返回当前的样式名称列表, 多个样式"
"名称之间以空格分隔. <methodname>setStyleName()</methodname> 方法将目前的样式"
"替换为指定的样式名称, 或以空格分隔的样式名称列表. 你也可以使用"
"<methodname>addStylename()</methodname> 和 <methodname>removeStyleName()</"
"methodname> 方法增加或删除单个的样式名称. 这里的样式名称必须是有效的 CSS 样式"
"名."

#. Tag: programlisting
#: chapter-components.xml:873
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Label label = new Label(\"This text has a lot "
"of style\");\n"
"label.addStyleName(\"mystyle\");\n"
"layout.addComponent(label);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:875
#, no-c-format
msgid ""
"The style name will appear in the component's HTML element in two forms: "
"literally as given and prefixed with the component-specific style name. For "
"example, if you add a style name <literal>mystyle</literal> to a "
"<classname>Button</classname>, the component would get both "
"<literal>mystyle</literal> and <literal>v-button-mystyle</literal> styles. "
"Neither form may conflict with built-in style names of Vaadin. For example, "
"<literal>focus</literal> style would conflict with a built-in style of the "
"same name, and an <literal>content</literal> style for a <classname>Panel</"
"classname> component would conflict with the built-in <literal>v-panel-"
"content</literal> style."
msgstr ""
"样式名称将以两种方式出现在组件的 HTML 元素上: 1, 以你指定的样式名原样出现 2, "
"以组件特有的样式名为前缀, 你指定的样式名附加在其后. 比如, 如果你在 "
"<classname>Button</classname> 上添加了一个样式名 <literal>mystyle</literal>, "
"这个组件将同时带有 <literal>mystyle</literal> 和<literal>v-button-mystyle</"
"literal> 样式. 这两种形式的样式都可能与 Vaadin 内建的样式名冲突. 比如, "
"<literal>focus</literal> 样式可能与内建的同名样式发生冲突, <classname>Panel</"
"classname> 组件的 <literal>content</literal> 样式会与内建的 <literal>v-panel-"
"content</literal> 样式冲突."

#. Tag: para
#: chapter-components.xml:888
#, no-c-format
msgid ""
"The following CSS rule would apply the style to any component that has the "
"<literal>mystyle</literal> style."
msgstr "下面的 CSS 规则将适用于带有 <literal>mystyle</literal> 样式的所有组件."

#. Tag: programlisting
#: chapter-components.xml:893
#, no-c-format
msgid ""
"<![CDATA[.mystyle {\n"
"    font-family: fantasy;\n"
"    font-style:  italic;\n"
"    font-size:   25px;\n"
"    font-weight: bolder;\n"
"    line-height: 30px;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:895
#, no-c-format
msgid ""
"The resulting styled component is shown in <xref linkend=\"figure.components."
"features.stylename\"/>"
msgstr ""
"上例的运行结果参见 <xref linkend=\"figure.components.features.stylename\"/>"

#. Tag: title
#: chapter-components.xml:901
#, no-c-format
msgid "Component with a Custom Style"
msgstr "带有自定义样式的组件"

#. Tag: title
#: chapter-components.xml:914
#, no-c-format
msgid "Visible"
msgstr "可见和隐藏"

#. Tag: primary
#: chapter-components.xml:917
#, no-c-format
msgid "visible property"
msgstr "visible 属性"

#. Tag: secondary
#: chapter-components.xml:922
#, no-c-format
msgid "visible"
msgstr ""

#. Tag: para
#: chapter-components.xml:925
#, no-c-format
msgid ""
"Components can be hidden by setting the <emphasis>visible</emphasis> "
"property to <emphasis>false</emphasis>. Also the caption, icon and any other "
"component features are made hidden. Hidden components are not just "
"invisible, but their content is not communicated to the browser at all. That "
"is, they are not made invisible cosmetically with only CSS rules. This "
"feature is important for security if you have components that contain "
"security-critical information that must only be shown in specific "
"application states."
msgstr ""
"通过将 <emphasis>visible</emphasis> 属性设置为 <emphasis>false</emphasis>, 可"
"以隐藏一个组件. 标题, 图标, 以及组件的其他一切元素全部都会被隐藏. 隐藏组件不"
"仅仅是不可见, 而且它的内容也会完全不发送到浏览器端. 也就是说, 隐藏组件不仅仅"
"是通过 CSS 规则达到不可见的效果. 如果你的某个组件包含了机密信息, 必须只在某些"
"特定的状态下才显示, 那么这个功能对于安全性是很重要的, 因为将组件设置为隐藏可"
"以保证它的内容在浏览器中完全不出现."

#. Tag: programlisting
#: chapter-components.xml:936
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[TextField invisible = new TextField(\"No-see-um"
"\");\n"
"invisible.setValue(\"You can't see this!\");\n"
"invisible.setVisible(false);\n"
"layout.addComponent(invisible);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:938
#, no-c-format
msgid ""
"The resulting invisible component is shown in <xref linkend=\"figure."
"components.features.visible.simple\"/>."
msgstr ""
"上面例子生成的不可见组件参见 <xref linkend=\"figure.components.features."
"visible.simple\"/>."

#. Tag: title
#: chapter-components.xml:945
#, no-c-format
msgid "An Invisible Component."
msgstr "不可见组件."

#. Tag: para
#: chapter-components.xml:956
#, no-c-format
msgid ""
"Beware that invisible beings can leave footprints. The containing layout "
"cell that holds the invisible component will not go away, but will show in "
"the layout as extra empty space. Also expand ratios work just like if the "
"component was visible - it is the layout cell that expands, not the "
"component."
msgstr ""
"注意不可见元素还是会留下一些痕迹. 不可见组件所属的布局元素不会消失, 而会在整"
"体布局中留下额外的空白. 而且组件的扩张比例也会与组件可见时一样有效, 因为扩张"
"比例是由组件所属的布局元素实现的, 而不是组件本身实现的."

#. Tag: para
#: chapter-components.xml:964
#, no-c-format
msgid ""
"If you need to make a component only cosmetically invisible, you should use "
"a custom theme to set it <literal>display: none</literal> style. This is "
"mainly useful for some special components that have effects even when made "
"invisible in CSS. If the hidden component has undefined size and is enclosed "
"in a layout that also has undefined size, the containing layout will "
"collapse when the component disappears. If you want to have the component "
"keep its size, you have to make it invisible by setting all its font and "
"other attributes to be transparent. In such cases, the invisible content of "
"the component can be made visible easily in the browser."
msgstr ""
"如果你希望组件只是在视觉上不可见, 你可以使用自定义 theme 来将它设置为 "
"<literal>display: none</literal> 样式. 对某些特别的组件来说, 即使在 CSS 中将"
"它们设置为不可见, 它们也会留下一个界面效果, 那么前面讲的这种办法就很有用. 如"
"果被隐藏的组件的尺寸未指定, 而且它所属的布局管理组件的尺寸也未指定, 那么当组"
"件消失时, 布局容器本身也会消失. 如果你希望组件保持它的尺寸, 你必须将它的字体"
"等等所有属性都设置为透明, 来达到让它不可见的效果. 这种情况下, 在浏览器端其实"
"是很容易将组件的不可见内容变为可见的."

#. Tag: para
#: chapter-components.xml:976
#, no-c-format
msgid ""
"A component made invisible with the <emphasis>visible</emphasis> property "
"has no particular CSS style class to indicate that it is hidden. The element "
"does exist though, but has <literal>display: none</literal> style, which "
"overrides any CSS styling."
msgstr ""
"通过 <emphasis>visible</emphasis> 属性变为不可见的组件不存在一个对应的 CSS 样"
"式类来标识它是隐藏的. 组件的 HTML 元素虽然存在, 但带有 <literal>display: "
"none</literal> 样式, 这个样式将覆盖其他所有的 CSS 样式."

#. Tag: title
#: chapter-components.xml:985
#, no-c-format
msgid "Sizing Components"
msgstr "控制组件的尺寸"

#. Tag: primary
#: chapter-components.xml:988
#, no-c-format
msgid "<classname>Sizeable</classname> interface"
msgstr "<classname>Sizeable</classname> 接口"

#. Tag: para
#: chapter-components.xml:991
#, no-c-format
msgid ""
"Vaadin components are sizeable; not in the sense that they were fairly large "
"or that the number of the components and their features are sizeable, but in "
"the sense that you can make them fairly large on the screen if you like, or "
"small or whatever size."
msgstr "Vaadin 组件的尺寸是可控的; 你可以自由控制组件在屏幕上显示的大小."

#. Tag: para
#: chapter-components.xml:998
#, no-c-format
msgid ""
"The <classname>Sizeable</classname> interface, shared by all components, "
"provides a number of manipulation methods and constants for setting the "
"height and width of a component in absolute or relative units, or for "
"leaving the size undefined."
msgstr ""
"所有的组件都实现了 <classname>Sizeable</classname> 接口, 这个接口提供了很多控"
"制方法和常数, 用于设置组件的宽和高, 尺寸可以是绝对单位也可以是相对单位, 也可"
"以将尺寸保留为未定义的状态."

#. Tag: para
#: chapter-components.xml:1005
#, no-c-format
msgid ""
"The size of a component can be set with <methodname>setWidth()</methodname> "
"and <methodname>setHeight()</methodname> methods. The methods take the size "
"as a floating-point value. You need to give the unit of the measure as the "
"second parameter for the above methods. The available units are listed in "
"<xref linkend=\"components.features.sizeable.units.table\"/> below."
msgstr ""
"组件的尺寸可以通过 <methodname>setWidth()</methodname> 和 "
"<methodname>setHeight()</methodname> 方法来设置. 这些方法接受浮点值作为尺寸参"
"数. 在第 2 个参数中你需要给定一个尺寸单位. 可用的单位参见下面的 <xref "
"linkend=\"components.features.sizeable.units.table\"/>."

#. Tag: programlisting
#: chapter-components.xml:1014
#, no-c-format
msgid ""
"<![CDATA[mycomponent.setWidth(100, Sizeable.UNITS_PERCENTAGE);\n"
"mycomponent.setWidth(400, Sizeable.UNITS_PIXELS);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1016
#, no-c-format
msgid ""
"Alternatively, you can speficy the size as a string. The format of such a "
"string must follow the HTML/CSS standards for specifying measures."
msgstr ""
"另一种方法是以字符串的形式指定尺寸. 字符串格式遵照 HTML/CSS 中用于指定元素尺"
"寸的格式标准."

#. Tag: programlisting
#: chapter-components.xml:1021
#, no-c-format
msgid ""
"<![CDATA[mycomponent.setWidth(\"100%\");\n"
"mycomponent.setHeight(\"400px\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1023
#, no-c-format
msgid ""
"The \"<literal>100%</literal>\" percentage value makes the component take "
"all available size in the particular direction (see the description of "
"<parameter>Sizeable.UNITS_PERCENTAGE</parameter> in the table below). You "
"can also use the shorthand method <methodname>setSizeFull()</methodname> to "
"set the size to 100% in both directions."
msgstr ""
"百分数 \"<literal>100%</literal>\" 将使组件占据某个方向上所有的可用空间 (参见"
"下表中的 <parameter>Sizeable.UNITS_PERCENTAGE</parameter>). 你也可以使用比较"
"简便的 <methodname>setSizeFull()</methodname> 方法, 将纵横两个方向的尺寸都设"
"置为 100%."

#. Tag: para
#: chapter-components.xml:1031
#, no-c-format
msgid ""
"The size can be <emphasis>undefined</emphasis> in either or both dimensions, "
"which means that the component will take the minimum necessary space. Most "
"components have undefined size by default, but some layouts have full size "
"in horizontal direction. You can set the height or width as undefined with "
"<parameter>Sizeable.SIZE_UNDEFINED</parameter> parameter for "
"<methodname>setWidth()</methodname> and <methodname>setHeight()</methodname>."
msgstr ""
"组件在单个或两个方向上的尺寸可以是 <emphasis>未定义</emphasis>, 这时组件会占"
"据它所需要的最小空间. 大多数组件默认尺寸都是未定义, 但某些布局管理组件会在水"
"平方向上占据全尺寸. 你可以对 <methodname>setWidth()</methodname> 和 "
"<methodname>setHeight()</methodname> 方法使用 <parameter>Sizeable."
"SIZE_UNDEFINED</parameter> 参数, 将高度或宽度设置为未定义  ."

#. Tag: para
#: chapter-components.xml:1041
#, no-c-format
msgid ""
"You always need to keep in mind that <emphasis>a layout with undefined size "
"may not contain components with defined relative size</emphasis>, such as "
"\"full size\". See <xref linkend=\"layout.settings.size\"/> for details."
msgstr ""
"要时刻注意,  <emphasis>尺寸未定义的布局组件, 其中包含的组件的尺寸不能定义为相"
"对大小</emphasis>, 比如 \"全尺寸\". 详情请参见 <xref linkend=\"layout."
"settings.size\"/>."

#. Tag: para
#: chapter-components.xml:1048
#, no-c-format
msgid ""
"The <xref linkend=\"components.features.sizeable.units.table\"/> lists the "
"available units and their codes defined in the <classname>Sizeable</"
"classname> interface."
msgstr ""
"<xref linkend=\"components.features.sizeable.units.table\"/> 中列出了所有可用"
"的尺寸单位, 以及这些单位在 <classname>Sizeable</classname> 接口中对应的常数."

#. Tag: title
#: chapter-components.xml:1055
#, no-c-format
msgid "Size Units"
msgstr "尺寸单位"

#. Tag: parameter
#: chapter-components.xml:1062
#, no-c-format
msgid "Unit.PIXELS"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1063
#, no-c-format
msgid "<entry>px</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1065
#, no-c-format
msgid ""
"The <emphasis>pixel</emphasis> is the basic hardware-specific measure of one "
"physical display pixel."
msgstr ""
"<emphasis>像素</emphasis> 是基本的硬件单位, 指显示设备上的一个物理像素."

#. Tag: parameter
#: chapter-components.xml:1070
#, no-c-format
msgid "Unit.POINTS"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1071
#, no-c-format
msgid "<entry>pt</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1073
#, no-c-format
msgid ""
"The <emphasis>point</emphasis> is a typographical unit, which is usually "
"defined as 1/72 inches or about 0.35 mm. However, on displays the size can "
"vary significantly depending on display metrics."
msgstr ""
"<emphasis>磅</emphasis> 是一种印刷单位, 1 磅通常定义为 1/72 英寸, 也就是大约 "
"0.35 毫米. 但是, 在不同的显示度量标准下,磅的实际显示大小会有显著的不同."

#. Tag: parameter
#: chapter-components.xml:1079
#, no-c-format
msgid "Unit.PICAS"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1080
#, no-c-format
msgid "<entry>pc</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1082
#, no-c-format
msgid ""
"The <emphasis>pica</emphasis> is a typographical unit, defined as 12 points, "
"or 1/7 inches or about 4.233 mm. On displays, the size can vary depending on "
"display metrics."
msgstr ""
"<emphasis>pica</emphasis> 是一种印刷单位, 1 pica 定义为 12 磅, 也就是 1/7 英"
"寸(译注: 原文如此, 貌似应该是 1/6 英寸才对) , 大约 4.233 毫米. 在不同的显示度"
"量标准下, pica 的实际显示大小会有显著的不同."

#. Tag: parameter
#: chapter-components.xml:1088
#, no-c-format
msgid "Unit.EM"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1089
#, no-c-format
msgid "<entry>em</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1091
#, no-c-format
msgid ""
"A unit relative to the used font, the width of the upper-case \"M\" letter."
msgstr "这是与当前使用的字体相关的一个单位, 1 em 等于大写字母 \"M\" 的宽度."

#. Tag: parameter
#: chapter-components.xml:1095
#, no-c-format
msgid "Unit.EX"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1096
#, no-c-format
msgid "<entry>ex</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1098
#, no-c-format
msgid ""
"A unit relative to the used font, the height of the lower-case \"x\" letter."
msgstr "这是与当前使用的字体相关的一个单位, 1 ex 等于小写字母 \"x\" 的高度."

#. Tag: parameter
#: chapter-components.xml:1102
#, no-c-format
msgid "Unit.MM"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1103
#, no-c-format
msgid "<entry>mm</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1105
#, no-c-format
msgid ""
"A physical length unit, millimeters on the surface of a display device. "
"However, the actual size depends on the display, its metrics in the "
"operating system, and the browser."
msgstr ""
"物理长度单位, 指显示设备上的 1 毫米. 但实际的显示尺寸决定于: 1,显示设备本身, "
"2,显示设备在操作系统中的度量标准, 3,浏览器."

#. Tag: parameter
#: chapter-components.xml:1111
#, no-c-format
msgid "Unit.CM"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1112
#, no-c-format
msgid "<entry>cm</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1114
#, no-c-format
msgid ""
"A physical length unit, <emphasis>centimeters</emphasis> on the surface of a "
"display device. However, the actual size depends on the display, its metrics "
"in the operating system, and the browser."
msgstr ""
"物理长度单位, 指显示设备上的 1 <emphasis>厘米</emphasis>.但实际的显示尺寸决定"
"于: 1,显示设备本身, 2,显示设备在操作系统中的度量标准, 3,浏览器."

#. Tag: parameter
#: chapter-components.xml:1120
#, no-c-format
msgid "Unit.INCH"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1121
#, no-c-format
msgid "<entry>in</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1123
#, no-c-format
msgid ""
"A physical length unit, <emphasis>inches</emphasis> on the surface of a "
"display device. However, the actual size depends on the display, its metrics "
"in the operating system, and the browser."
msgstr ""
"物理长度单位, 指显示设备上的 1 <emphasis>英寸</emphasis>. 但实际的显示尺寸决"
"定于: 1,显示设备本身, 2,显示设备在操作系统中的度量标准, 3,浏览器."

#. Tag: parameter
#: chapter-components.xml:1129
#, no-c-format
msgid "Unit.PERCENTAGE"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1130
#, no-c-format
msgid "<entry>%</entry>"
msgstr ""

#. Tag: entry
#: chapter-components.xml:1132
#, no-c-format
msgid ""
"A relative percentage of the available size. For example, for the top-level "
"layout <parameter>100%</parameter> would be the full width or height of the "
"browser window. The percentage value must be between 0 and 100."
msgstr ""
"相对于可用尺寸的百分比. 比如, 对最顶层的布局管理器来说 <parameter>100%</"
"parameter> 就等于浏览器窗口的全部宽度和高度. 百分比值必须在 0 到 100 之间."

#. Tag: para
#: chapter-components.xml:1141
#, no-c-format
msgid ""
"If a component inside <classname>HorizontalLayout</classname> or "
"<classname>VerticalLayout</classname> has full size in the namesake "
"direction of the layout, the component will expand to take all available "
"space not needed by the other components. See <xref linkend=\"layout."
"settings.size\"/> for details."
msgstr ""
"如果 <classname>HorizontalLayout</classname> 或 <classname>VerticalLayout</"
"classname> 之内的某个组件在水平(或垂直)方向上为全尺寸, 那么这个组件将会占据其"
"他组件没有占据的所有可用空间. 详情请参见 <xref linkend=\"layout.settings.size"
"\"/>."

#. Tag: title
#: chapter-components.xml:1159
#, no-c-format
msgid "Managing Input Focus"
msgstr "管理输入焦点"

#. Tag: para
#: chapter-components.xml:1161
#, no-c-format
msgid ""
"When the user clicks on a component, the component gets the <emphasis>input "
"focus</emphasis>, which is indicated by highlighting according to style "
"definitions. If the component allows inputting text, the focus and insertion "
"point are indicated by a cursor. Pressing the <keycap>Tab</keycap> key moves "
"the focus to the component next in the <emphasis>focus order</emphasis>."
msgstr ""
"当用户点击一个组件时, 组件就会获得 <emphasis>输入焦点</emphasis>, 这个状态使"
"用组件样式来高亮度显示. 如果组件允许输入文字, 焦点和文字插入位置将通过光标来"
"显示. 按下 <keycap>Tab</keycap> 键会使输入焦点按照 <emphasis>焦点顺序</"
"emphasis> 跳转到下一个组件."

#. Tag: para
#: chapter-components.xml:1170
#, no-c-format
msgid ""
"Focusing is supported by all <classname>Field</classname> components and "
"also by <classname>Upload</classname>."
msgstr ""
"所有的 <classname>Field</classname> 组件都支持输入焦点, <classname>Upload</"
"classname> 也支持输入焦点."

#. Tag: para
#: chapter-components.xml:1175
#, no-c-format
msgid ""
"The focus order or <emphasis>tab index</emphasis> of a component is defined "
"as a positive integer value, which you can set with "
"<methodname>setTabIndex()</methodname> and get with "
"<methodname>getTabIndex()</methodname>. The tab index is managed in the "
"context of the page in which the components are contained. The focus order "
"can therefore jump between two any lower-level component containers, such as "
"sub-windows or panels."
msgstr ""
"组件的焦点顺序, 或者叫 <emphasis>TAB 序号</emphasis> 是通过一个正整数定义的, "
"可以通过 <methodname>setTabIndex()</methodname> 方法设置这个值, 可以通过 "
"<methodname>getTabIndex()</methodname> 方法得到这个值. TAB 序号由组件所属的页"
"面整体进行管理. 因此焦点顺序在不同层次的组件容器之间也可以跳转, 比如子窗口和"
"面板."

#. Tag: para
#: chapter-components.xml:1185
#, no-c-format
msgid ""
"The default focus order is determined by the natural hierarchical order of "
"components in the order in which they were added under their parents. The "
"default tab index is 0 (zero)."
msgstr ""
"默认的焦点顺序由组件自然的层次关系顺序决定, 也就是与组件添加到父组件的先后顺"
"序一致. 组件默认的 TAB 序号是 0."

#. Tag: para
#: chapter-components.xml:1191
#, no-c-format
msgid ""
"Giving a negative integer as the tab index removes the component from the "
"focus order entirely."
msgstr "将组件的 TAB 序号指定为负数, 会将这个组件从焦点顺序中彻底删除."

#. Tag: para
#: chapter-components.xml:1199
#, no-c-format
msgid ""
"The component having the focus will have an additional style class with the "
"<literal>-focus</literal> suffix. For example, a <classname>TextField</"
"classname>, which normally has the <literal>v-textfield</literal> style, "
"would additionally have the <literal>v-textfield-focus</literal> style."
msgstr ""
"获得焦点的组件将带有一个额外的样式, 样式名后缀为 <literal>-focus</literal>. "
"比如, <classname>TextField</classname>, 通常的样式为 <literal>v-textfield</"
"literal>, 获得焦点后将额外带有一个 <literal>v-textfield-focus</literal> 样式."

#. Tag: para
#: chapter-components.xml:1207
#, no-c-format
msgid ""
"For example, the following would make a text field blue when it has focus."
msgstr "比如, 下面的例子会让获得焦点的文本输入框显示为蓝色."

#. Tag: programlisting
#: chapter-components.xml:1212
#, no-c-format
msgid ""
"<![CDATA[.v-textfield-focus {\n"
"    background: lightblue;\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:1218 chapter-components.xml:1232
#, no-c-format
msgid "Field Components"
msgstr "Field 组件"

#. Tag: classname
#: chapter-components.xml:1221
#, no-c-format
msgid "Field"
msgstr ""

#. Tag: para
#: chapter-components.xml:1224
#, no-c-format
msgid ""
"<emphasis>Fields</emphasis> are components that have a value that the user "
"can change through the user interface. <xref linkend=\"figure.components."
"fields\"/> illustrates the inheritance relationships and the important "
"interfaces and base classes."
msgstr ""
"<emphasis>Field</emphasis> 是一类特殊的组件, 它拥有数据值, 并允许用户通过 UI "
"编辑这个值. <xref linkend=\"figure.components.fields\"/> 展示了 Field 组件的"
"继承关系及一些重要的接口和类."

#. Tag: para
#: chapter-components.xml:1243
#, no-c-format
msgid ""
"Field components are built upon the framework defined in the "
"<classname>Field</classname> interface and the <classname>AbstractField</"
"classname> base class. <classname>AbstractField</classname> is the base "
"class for all field components. In addition to the component features "
"inherited from <classname>AbstractComponent</classname>, it implements a "
"number of features defined in <classname>Property</classname>, "
"<classname>Buffered</classname>, <classname>Validatable</classname>, and "
"<classname>Component.Focusable</classname> interfaces."
msgstr ""
"Field 组件的基本框架定义在 <classname>Field</classname> 接口和 "
"<classname>AbstractField</classname> 基类中. <classname>AbstractField</"
"classname> 是所有 Field 组件的基类. 这个基类除继承了 "
"<classname>AbstractComponent</classname> 的功能外, 还实现了很多其他功能, 这些"
"功能定义在 <classname>Property</classname>, <classname>Buffered</classname>, "
"<classname>Validatable</classname>, 和 <classname>Component.Focusable</"
"classname> 接口中."

#. Tag: para
#: chapter-components.xml:1255
#, no-c-format
msgid ""
"The description of the field interfaces and base classes is broken down in "
"the following sections."
msgstr "对 Field 接口和基类的介绍分为以下几节."

#. Tag: title
#: chapter-components.xml:1261
#, no-c-format
msgid "<classname>Field</classname> Interface"
msgstr "<classname>Field</classname> 接口"

#. Tag: para
#: chapter-components.xml:1263
#, no-c-format
msgid ""
"The <classname>Field</classname> interface inherits the "
"<classname>Component</classname> superinterface and also the "
"<classname>Property</classname> interface to have a value for the field. "
"<classname>AbstractField</classname> is the only class implementing the "
"<classname>Field</classname> interface directly. The relationships are "
"illustrated in <xref linkend=\"figure.components.fields.field\"/>."
msgstr ""
"<classname>Field</classname> 接口继承了 <classname>Component</classname> 接"
"口, 另外它还继承了 <classname>Property</classname> 接口, 因此 Field 拥有数据"
"值. <classname>AbstractField</classname> 是 <classname>Field</classname> 接口"
"唯一的直接实现类. 这些接口和类的关系请参见 <xref linkend=\"figure.components."
"fields.field\"/>."

#. Tag: title
#: chapter-components.xml:1274
#, no-c-format
msgid "<classname>Field</classname> Interface Inheritance Diagram"
msgstr "<classname>Field</classname> 接口的继承关系图"

#. Tag: para
#: chapter-components.xml:1285
#, no-c-format
msgid ""
"You can set the field value with the <methodname>setValue()</methodname> and "
"read with the <methodname>getValue()</methodname> method defined in the "
"<classname>Property</classname> interface. The actual value type depends on "
"the component."
msgstr ""
"你可以通过 <methodname>setValue()</methodname> 方法设置 Field 值, 通过 "
"<methodname>getValue()</methodname> 方法获得 Field 值, getValue() 方法定义在 "
"<classname>Property</classname> 接口中. 值的实际数据类型由各个 Field 组件决"
"定."

#. Tag: para
#: chapter-components.xml:1292
#, no-c-format
msgid ""
"The <classname>Field</classname> interface defines a number of attributes, "
"which you can retrieve or manipulate with the corresponding setters and "
"getters."
msgstr ""
"<classname>Field</classname> 接口定义了很多属性, 你可以通过相应的取得方法和设"
"置方法来获取和操纵这些属性."

#. Tag: methodname
#: chapter-components.xml:1300
#, no-c-format
msgid "<methodname>description</methodname>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1302
#, no-c-format
msgid ""
"All fields have a description. Notice that while this attribute is defined "
"in the <classname>Field</classname> component, it is implemented in "
"<classname>AbstractField</classname>, which does not directly implement "
"<classname>Field</classname>, but only through the <classname>AbstractField</"
"classname> class."
msgstr ""
"所有 Field 都有一个描述信息. 请注意这个属性虽然定义在 <classname>Field</"
"classname> (译注: 此处有误, 应该是 Component)接口中, 但它在 "
"<classname>AbstractField</classname> 类中实现, AbstractField 并没有直接实现 "
"<classname>Field</classname> (译注: 此处有误, 应该是 Component)接口, 而是通"
"过 <classname>AbstractField</classname> (译注: 此处有误, 应该是 "
"AbstractComponent)类实现的."

#. Tag: methodname
#: chapter-components.xml:1314
#, no-c-format
msgid "required"
msgstr ""

#. Tag: para
#: chapter-components.xml:1316
#, no-c-format
msgid ""
"When enabled, a required indicator (usually the asterisk * character) is "
"displayed on the left, above, or right the field, depending on the "
"containing layout and whether the field has a caption. If such fields are "
"validated but are empty and the <methodname>requiredError</methodname> "
"property (see below) is set, an error indicator is shown and the component "
"error is set to the text defined with the error property. Without "
"validation, the required indicator is merely a visual guide."
msgstr ""
"当这个特性打开时, \"必须项目指示器\" (通常是一个 * 符号) 会显示在 Field 组件"
"的左侧, 上方, 或右侧, 具体的位置决定于组件所属的布局, 以及附件是否带有标题. "
"如果组件的输入校验功能设置为有效, 但输入值为空, 并且组件被设置了 "
"<methodname>requiredError</methodname> 属性(详情见后文), 那么会显示一个错误指"
"示器, 并且组件的错误信息会被设置为 error 属性中指定的文字. 输入校验功能无效"
"时, \"必须项目指示器\"仅仅只是一种提示信息, 并不强制要求必须输入数据值."

#. Tag: methodname
#: chapter-components.xml:1330
#, no-c-format
msgid "requiredError"
msgstr ""

#. Tag: para
#: chapter-components.xml:1332
#, no-c-format
msgid ""
"Defines the error message to show when a value is required, but none is "
"entered. The error message is set as the component error for the field and "
"is usually displayed in a tooltip when the mouse pointer hovers over the "
"error indicator."
msgstr ""
"定义了数据值未输入的错误消息, 当 Field 组件值必须输入但用户没有输入值时, 就会"
"显示这个错误. 这个错误消息会被设置为 Field 组件的错误信息, 通常显示在提示信息"
"(tooltip)中, 当鼠标指针移动到错误指示器上时, 提示信息就会显示."

#. Tag: title
#: chapter-components.xml:1345
#, no-c-format
msgid "Data Binding and Conversions"
msgstr "数据绑定和数据转换"

#. Tag: para
#: chapter-components.xml:1347
#, no-c-format
msgid ""
"Fields are strongly coupled with the Vaadin data model. The field value is "
"handled as a <classname>Property</classname> of the field component, as "
"documented in <xref linkend=\"datamodel.properties\"/>. Selection fields "
"allow management of the selectable items through the <classname>Container</"
"classname> interface."
msgstr ""
"Field 通常会与 Vaadin 数据模型结合在一起. Field 的数据值会以 Field 组件的 "
"<classname>Property</classname> 的形式管理, 详情请参见 <xref linkend="
"\"datamodel.properties\"/>. 选择 Field 可以通过 <classname>Container</"
"classname> 接口管理它的选择项."

#. Tag: para
#: chapter-components.xml:1355
#, no-c-format
msgid ""
"Fields are <emphasis>editors</emphasis> for some particular type. For "
"example, <classname>TextField</classname> allows editing <classname>String</"
"classname> values. When bound to a data source, the property type of the "
"data model can be something different, say an <classname>Integer</"
"classname>. <emphasis>Converters</emphasis> are used for converting the "
"values between the representation and the model. They are described in <xref "
"linkend=\"datamodel.properties.converter\"/>."
msgstr ""
"Field 是某种数据类型的 <emphasis>编辑器</emphasis>. 比如, "
"<classname>TextField</classname> 可以编辑 <classname>String</classname> 类型"
"的值. 当绑定到数据源时, 数据模型中的数据类型可能会与界面输入的值不同, 比如可"
"能是 <classname>Integer</classname> 类型. <emphasis>Converters</emphasis> 被"
"用来在数据模型与数据的界面表现之间做相互转换. 详情请参见 <xref linkend="
"\"datamodel.properties.converter\"/>."

#. Tag: title
#: chapter-components.xml:1367
#, no-c-format
msgid "Handling Field Value Changes"
msgstr "处理 Field 值的变更"

#. Tag: para
#: chapter-components.xml:1369
#, no-c-format
msgid ""
"<classname>Field</classname> inherits <classname>Property."
"ValueChangeListener</classname> to allow listening for field value changes "
"and <classname>Property.Editor</classname> to allow editing values."
msgstr ""
"<classname>Field</classname> 继承了 <classname>Property.ValueChangeListener</"
"classname>, 因此可以监听 Field 数据值变化的事件, 还继承了 "
"<classname>Property.Editor</classname>, 因此可以编辑数据值."

#. Tag: para
#: chapter-components.xml:1376
#, no-c-format
msgid ""
"When the value of a field changes, a <classname>Property.ValueChangeEvent</"
"classname> is triggered for the field. You should not implement the "
"<methodname>valueChange()</methodname> method in a class inheriting "
"<classname>AbstractField</classname>, as it is already implemented in "
"<classname>AbstractField</classname>. You should instead implement the "
"method explicitly by adding the implementing object as a listener."
msgstr ""
"当 Field 中的数据值发生变化时, 会在这个 Field 上触发 <classname>Property."
"ValueChangeEvent</classname> 事件. 你不应该在继承自 "
"<classname>AbstractField</classname> 的类中实现 <methodname>valueChange()</"
"methodname> 方法,  因为这个方法已经由 <classname>AbstractField</classname> 实"
"现了. 你应该以事件监听器的方式另外添加类, 在这个监听器类中实现 "
"<methodname>valueChange()</methodname> 方法."

#. Tag: title
#: chapter-components.xml:1388
#, no-c-format
msgid "Field Buffering"
msgstr "Field 值的缓存"

#. Tag: para
#: chapter-components.xml:1390
#, no-c-format
msgid ""
"Field components implement the <interfacename>Buffered</interfacename> and "
"<interfacename>BufferedValidatable</interfacename> interfaces. When "
"buffering is enabled for a field with <methodname>setBuffered(true)</"
"methodname>, the value is not written to the property data source before the "
"<methodname>commit()</methodname> method is called for the field. Calling "
"<methodname>commit()</methodname> also runs validators added to the field, "
"and if any fail (and the <parameter>invalidCommitted</parameter> is "
"disabled), the value is not written."
msgstr ""
"Field 组件实现了 <interfacename>Buffered</interfacename> 和 "
"<interfacename>BufferedValidatable</interfacename> 接口. 当通过 "
"<methodname>setBuffered(true)</methodname> 将 Field 的缓存功能设置为有效时, "
"在 Field 的 <methodname>commit()</methodname> 方法被调用之前, 输入的数据值不"
"会被写入到数据源中去. 调用 <methodname>commit()</methodname> 方法同时也会执"
"行 Field 上的校验器, 如果有任何一个校验器校验失败 (并且 "
"<parameter>invalidCommitted</parameter> 被设置为禁用), 那么值就不会被写入."

#. Tag: programlisting
#: chapter-components.xml:1403
#, no-c-format
msgid ""
"<![CDATA[form.addComponent(new Button(\"Commit\",\n"
"    new Button.ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        try {\n"
"            editor.commit();\n"
"        } catch (InvalidValueException e) {\n"
"            Notification.show(e.getMessage());\n"
"        }\n"
"    }\n"
"}));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1405
#, no-c-format
msgid ""
"Calling <methodname>discard()</methodname> reads the value from the property "
"date source to the current input."
msgstr ""
"调用 <methodname>discard()</methodname> 方法会从数据源中重新读入数据, 然后反"
"应到输入界面中."

#. Tag: para
#: chapter-components.xml:1410
#, no-c-format
msgid ""
"If the fields are bound in a <classname>FieldGroup</classname> that has "
"buffering enabled, calling <methodname>commit()</methodname> for the group "
"runs validation on all fields in the group, and if successful, all the field "
"values are written to the item data source. See <xref linkend=\"datamodel."
"itembinding.buffering\"/>."
msgstr ""
"如果 Field 被绑定到 <classname>FieldGroup</classname> 中, 并且 FieldGroup 的"
"缓存功能有效, 对 FieldGroup 调用 <methodname>commit()</methodname> 方法会执"
"行 FieldGroup 内所有 Field 的所有校验器, 如果校验成功, 则所有的 Field 数据值"
"都会被写入到数据源中. 详情请参见 <xref linkend=\"datamodel.itembinding."
"buffering\"/>."

#. Tag: title
#: chapter-components.xml:1420
#, no-c-format
msgid "Field Validation"
msgstr "Field 值校验"

#. Tag: para
#: chapter-components.xml:1422
#, no-c-format
msgid ""
"The input for a field component can be syntactically or semantically "
"invalid. Fields implement the <interfacename>Validatable</interfacename> "
"interface, which allows checking validity of the input with "
"<emphasis>validators</emphasis> that implement the <interfacename>Validator</"
"interfacename> interface. You can add validators to fields with "
"<methodname>addValidator()</methodname>."
msgstr ""
"Field 组件的输入在语法上或在语义上都有可能是无效的. Field 实现了 "
"<interfacename>Validatable</interfacename> 接口, 因此可以使用实现了 "
"<interfacename>Validator</interfacename> 接口的 <emphasis>校验器</emphasis> "
"来检查用户输入是否正确. 你可以通过  <methodname>addValidator()</methodname> "
"方法来向 Field 添加校验器."

#. Tag: programlisting
#: chapter-components.xml:1432
#, no-c-format
msgid ""
"<![CDATA[TextField field = new TextField(\"Name\");\n"
"field.addValidator(new StringLengthValidator(\n"
"    \"The name must be 1-10 letters (was {0})\",\n"
"    1, 10, true));\n"
"layout.addComponent(field);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1434
#, no-c-format
msgid ""
"Failed validation is indicated with the error indicator of the field, "
"described in <xref linkend=\"application.errors.error-indicator\"/>, unless "
"disabled with <methodname>setValidationVisible(false)</methodname>. Hovering "
"mouse on the field displays the error message given as a parameter for the "
"validator. If validated explicitly with <methodname>validate()</methodname>, "
"as described later, the <classname>InvalidValueException</classname> is "
"thrown if the validation fails, also carrying the error message. The value "
"<literal>{0}</literal> in the error message string is replaced with the "
"invalid input value."
msgstr ""
"输入校验的失败通过 Field 组件的错误指示器来表示在 UI 中, 详情请参见 <xref "
"linkend=\"application.errors.error-indicator\"/>, 这个功能可以通过 "
"<methodname>setValidationVisible(false)</methodname> 来禁用. 鼠标指针移动到 "
"Field 上方时, 会显示校验失败的错误消息, 这个错误消息是以参数的形式设置给校验"
"器的. 如果通过 <methodname>validate()</methodname> 方法显式地进行校验(详情参"
"见后文), 那么在校验失败时会抛出 <classname>InvalidValueException</classname> "
"例外, 例外信息中也带有前面所说的错误消息. 错误消息中的 <literal>{0}</"
"literal> 会被替换为用户输入的不正确的值."

#. Tag: para
#: chapter-components.xml:1447
#, no-c-format
msgid ""
"Validators validate the property type of the field after a possible "
"conversion, not the presentation type. For example, an "
"<classname>IntegerRangeValidator</classname> requires that the value type of "
"the property data source is <classname>Integer</classname>."
msgstr ""
"输入值首先进行类型转换, 校验器的校验对象是转换后的数据类型, 而不是界面上显示"
"的类型. 比如, <classname>IntegerRangeValidator</classname> 要求数据源属性值的"
"数据类型为 <classname>Integer</classname>."

#. Tag: title
#: chapter-components.xml:1455
#, no-c-format
msgid "Built-in Validators"
msgstr "内建的校验器"

#. Tag: para
#: chapter-components.xml:1457
#, no-c-format
msgid ""
"Vaadin includes the following built-in validators. The property value type "
"is indicated."
msgstr "Vaadin 包含以下内建的校验器. 相应的属性值数据类型在冒号后给出."

#. Tag: classname
#: chapter-components.xml:1466
#, no-c-format
msgid "BeanValidator"
msgstr ""

#. Tag: para
#: chapter-components.xml:1468
#, no-c-format
msgid ""
"Validates a bean property according to annotations defined in the Bean "
"Validation API 1.0 (JSR-303). This validator is usually not used explicitly, "
"but they are created implicitly when binding fields in a "
"<classname>BeanFieldGroup</classname>. Using bean validation requires an "
"implementation library of the API. See <xref linkend=\"datamodel.itembinding."
"beanvalidation\"/> for details."
msgstr ""
"依照 Bean Validation API 1.0 (JSR-303)定义的注解标准来校验 Bean 的属性. 这个"
"校验器通常不会显式使用, 当将 Field 绑定到 <classname>BeanFieldGroup</"
"classname> 时, 会隐含地创建这个校验器. 使用 Bean 校验需要 Bean Validation "
"API 的实现库. 详情请参见 <xref linkend=\"datamodel.itembinding.beanvalidation"
"\"/>."

#. Tag: classname
#: chapter-components.xml:1482
#, no-c-format
msgid "CompositeValidator"
msgstr ""

#. Tag: para
#: chapter-components.xml:1484
#, no-c-format
msgid "Combines validators using logical AND and OR operators."
msgstr "使用逻辑 AND 和 OR 操作将多个校验器组合起来."

#. Tag: term
#: chapter-components.xml:1490
#, no-c-format
msgid "<classname>DateRangeValidator</classname>: <classname>Date</classname>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1492
#, no-c-format
msgid ""
"Checks that the date value is within the range at or between two given dates/"
"times."
msgstr "检查日期值是否在指定的日期/时间范围之内."

#. Tag: term
#: chapter-components.xml:1499
#, no-c-format
msgid ""
"<classname>DoubleRangeValidator</classname>: <classname>Double</classname>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1501
#, no-c-format
msgid "Checks that the double value is at or between two given values."
msgstr "检查 Double 值是否在指定的范围之内."

#. Tag: term
#: chapter-components.xml:1507
#, no-c-format
msgid "<classname>EmailValidator</classname>: <classname>String</classname>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1509
#, no-c-format
msgid ""
"Checks that the string value is a syntactically valid email address. The "
"validated syntax is close to the RFC 822 standard regarding email addresses."
msgstr ""
"检查字符串值是否合法的邮件地址. 这个校验器使用的文法规则接近于 RFC 822 中定义"
"的邮件地址."

#. Tag: term
#: chapter-components.xml:1517
#, no-c-format
msgid ""
"<classname>IntegerRangeValidator</classname>: <classname>Integer</classname>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1519
#, no-c-format
msgid "Checks that the integer value is at or between two given values."
msgstr "检查整数值是否在指定的范围之内."

#. Tag: classname
#: chapter-components.xml:1525
#, no-c-format
msgid "NullValidator"
msgstr ""

#. Tag: para
#: chapter-components.xml:1527
#, no-c-format
msgid "Checks that the value is or is not a null value."
msgstr "检查值是否为 null."

#. Tag: term
#: chapter-components.xml:1533
#, no-c-format
msgid "<classname>RegexpValidator</classname>: <classname>String</classname>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1535
#, no-c-format
msgid "Checks that the value matches with the given regular expression."
msgstr "检查值是否符合指定的正规表达式."

#. Tag: term
#: chapter-components.xml:1541
#, no-c-format
msgid ""
"<classname>StringLengthValidator</classname>: <classname>String</classname>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1543
#, no-c-format
msgid ""
"Checks that the length of the input string is at or between two given "
"lengths."
msgstr "检查输入的字符串长度是否都在指定的范围之内."

#. Tag: para
#: chapter-components.xml:1551
#, no-c-format
msgid "Please see the API documentation for more details."
msgstr "以上各校验器的详细信息请阅读 API 文档."

#. Tag: title
#: chapter-components.xml:1557
#, no-c-format
msgid "Automatic Validation"
msgstr "自动校验"

#. Tag: para
#: chapter-components.xml:1559
#, no-c-format
msgid ""
"The validators are normally, when <literal>validationVisible</literal> is "
"true for the field, executed implicitly on the next server request if the "
"input has changed. If the field is in immediate mode, it (and any other "
"fields with changed value) are validated immediately when the focus leaves "
"the field."
msgstr ""
"当 Field 的 <literal>validationVisible</literal> 为 true 时, 如果 Field 的输"
"入发生变化, 校验器通常会在下一次向服务器发送请求时隐含地执行. 如果 Field 处"
"于 immediate 模式, 它 (以及输入值发生了变化的其他 Field) 会在输入焦点离开时立"
"即进行校验."

#. Tag: programlisting
#: chapter-components.xml:1568
#, no-c-format
msgid ""
"<![CDATA[TextField field = new TextField(\"Name\");\n"
"field.addValidator(new StringLengthValidator(\n"
"    \"The name must be 1-10 letters (was {0})\",\n"
"    1, 10, true));\n"
"field.setImmediate(true);\n"
"layout.addComponent(field);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:1572
#, no-c-format
msgid "Explicit Validation"
msgstr "显式校验"

#. Tag: para
#: chapter-components.xml:1574
#, no-c-format
msgid ""
"The validators are executed when the <methodname>validate()</methodname> or "
"<methodname>commit()</methodname> methods are called for the field."
msgstr ""
"当调用 Field 的 <methodname>validate()</methodname> 或 <methodname>commit()</"
"methodname> 方法时, 会执行校验器."

#. Tag: programlisting
#: chapter-components.xml:1581
#, no-c-format
msgid ""
"<![CDATA[// A field with automatic validation disabled\n"
"final TextField field = new TextField(\"Name\");\n"
"layout.addComponent(field);\n"
"        \n"
"// Define validation as usual\n"
"field.addValidator(new StringLengthValidator(\n"
"    \"The name must be 1-10 letters (was {0})\",\n"
"    1, 10, true));\n"
"        \n"
"// Run validation explicitly\n"
"Button validate = new Button(\"Validate\");\n"
"validate.addClickListener(new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        field.setValidationVisible(false);\n"
"        try {\n"
"            field.validate();\n"
"        } catch (InvalidValueException e) {\n"
"            Notification.show(e.getMessage());\n"
"            field.setValidationVisible(true);\n"
"        }\n"
"    }\n"
"});\n"
"layout.addComponent(validate);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:1586
#, no-c-format
msgid "Implementing a Custom Validator"
msgstr "实现自定义校验器"

#. Tag: para
#: chapter-components.xml:1588
#, no-c-format
msgid ""
"You can create custom validators by implementing the "
"<interfacename>Validator</interfacename> interface and implementing its "
"<methodname>validate()</methodname> method. If the validation fails, the "
"method should throw either <classname>InvalidValueException</classname> or "
"<classname>EmptyValueException</classname>."
msgstr ""
"你可以实现 <interfacename>Validator</interfacename> 接口, 并实现其中的 "
"<methodname>validate()</methodname> 方法, 这样既可创建自定义的校验器. 如果校"
"验失败, 这个方法应该抛出 <classname>InvalidValueException</classname> 或 "
"<classname>EmptyValueException</classname> 异常."

#. Tag: programlisting
#: chapter-components.xml:1598
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyValidator implements Validator {\n"
"    @Override\n"
"    public void validate(Object value)\n"
"            throws InvalidValueException {\n"
"        if (!(value instanceof String &&\n"
"                ((String)value).equals(\"hello\")))\n"
"            throw new InvalidValueException(\"You're impolite\");\n"
"    }\n"
"}\n"
"\n"
"final TextField field = new TextField(\"Say hello\");\n"
"field.addValidator(new MyValidator());\n"
"field.setImmediate(true);\n"
"layout.addComponent(field);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:1603
#, no-c-format
msgid "Validation in Field Groups"
msgstr "在 Field Group 中进行校验"

#. Tag: para
#: chapter-components.xml:1605
#, no-c-format
msgid ""
"If the field is bound to a <classname>FieldGroup</classname>, described in "
"<xref linkend=\"datamodel.itembinding\"/>, calling <methodname>commit()</"
"methodname> for the group runs the validation for all the fields in the "
"group, and if successful, writes the input values to the data source."
msgstr ""
"如果 Field 绑定到 <classname>FieldGroup</classname> 上, (详情请参见 <xref "
"linkend=\"datamodel.itembinding\"/>), 那么调用 FieldGroup 的 "
"<methodname>commit()</methodname> 方法, 会执行 FieldGroup 内所有 Field 的校验"
"器, 只有校验成功时, 输入数据才会写入数据源中."

#. Tag: title
#: chapter-components.xml:1619
#, no-c-format
msgid "Selection Components"
msgstr "选择组件"

#. Tag: para
#: chapter-components.xml:1621
#, no-c-format
msgid ""
"Vaadin offers many alternative ways for selecting one or more items. The "
"core library includes the following selection components, all based on the "
"<classname>AbstractSelect</classname> class:"
msgstr ""
"Vaadin 提供了很多种不同的方式, 用于选择一个或多个项目. 核心库包含以下几种选择"
"组件, 都继承自 <classname>AbstractSelect</classname> 基类:"

#. Tag: term
#: chapter-components.xml:1629
#, no-c-format
msgid ""
"<classname>ComboBox</classname> (Section <xref linkend=\"components.combobox"
"\" xrefstyle=\"select:labelnumber\"/>)"
msgstr ""
"<classname>ComboBox</classname> (第 <xref linkend=\"components.combobox\" "
"xrefstyle=\"select:labelnumber\"/> 节)"

#. Tag: listitem
#: chapter-components.xml:1631
#, no-c-format
msgid ""
"A drop-down list with a text box, where the user can type text to find "
"matching items. The component also provides an input prompt and the user can "
"enter new items."
msgstr ""
"带下拉列表的文本输入框, 用户可以输入文本来查找与之匹配的选项. 这个组件还提供"
"一个输入提示, 允许用户添加新的选项."

#. Tag: term
#: chapter-components.xml:1638
#, no-c-format
msgid ""
"<classname>ListSelect</classname> (Section <xref linkend=\"components."
"listselect\" xrefstyle=\"select:labelnumber\"/>)"
msgstr ""
"<classname>ListSelect</classname> (第 <xref linkend=\"components.listselect"
"\" xrefstyle=\"select:labelnumber\"/> 节)"

#. Tag: listitem
#: chapter-components.xml:1640
#, no-c-format
msgid ""
"A vertical list box for selecting items in either single or multiple "
"selection mode."
msgstr "垂直列表框, 可以选择一个或多个项目."

#. Tag: term
#: chapter-components.xml:1646
#, no-c-format
msgid ""
"<classname>NativeSelect</classname> (Section <xref linkend=\"components."
"nativeselect\" xrefstyle=\"select:labelnumber\"/>)"
msgstr ""
"<classname>NativeSelect</classname> (第 <xref linkend=\"components."
"nativeselect\" xrefstyle=\"select:labelnumber\"/> 节)"

#. Tag: listitem
#: chapter-components.xml:1648
#, no-c-format
msgid ""
"Provides selection using the native selection component of the browser, "
"typically a drop-down list for single selection and a multi-line list in "
"multiselect mode. This uses the <literal>&lt;select&gt;</literal> element in "
"HTML."
msgstr ""
"使用浏览器自己的选择框提供选择能力, 单选通常使用下拉列表, 多选通常使用多行列"
"表. 这个组件使用 HTML 的 <literal>&lt;select&gt;</literal> 元素."

#. Tag: term
#: chapter-components.xml:1656
#, no-c-format
msgid ""
"<classname>OptionGroup</classname> (Section <xref linkend=\"components."
"optiongroup\" xrefstyle=\"select:labelnumber\"/>)"
msgstr ""
"<classname>OptionGroup</classname> (第 <xref linkend=\"components.optiongroup"
"\" xrefstyle=\"select:labelnumber\"/> 节)"

#. Tag: listitem
#: chapter-components.xml:1658
#, no-c-format
msgid ""
"Shows the items as a vertically arranged group of radio buttons in the "
"single selection mode and of check boxes in multiple selection mode."
msgstr ""
"一组选择项垂直排列, 单选模式下选择项表示为 Radio Button, 多选模式下选择项表示"
"为 Check Box."

#. Tag: term
#: chapter-components.xml:1664
#, no-c-format
msgid ""
"<classname>TwinColSelect</classname> (Section <xref linkend=\"components."
"twincolselect\" xrefstyle=\"select:labelnumber\"/>)"
msgstr ""
"<classname>TwinColSelect</classname> (第 <xref linkend=\"components."
"twincolselect\" xrefstyle=\"select:labelnumber\"/> 节)"

#. Tag: listitem
#: chapter-components.xml:1666
#, no-c-format
msgid ""
"Shows two list boxes side by side where the user can select items from a "
"list of available items and move them to a list of selected items using "
"control buttons."
msgstr ""
"并列显示两个列表框, 一个是可选项目的列表, 另一个是已选项目的列表, 用户可以使"
"用控制按钮在这两个列表框中选择项目."

#. Tag: para
#: chapter-components.xml:1674
#, no-c-format
msgid ""
"In addition, the <classname>Tree</classname>, <classname>Table</classname>, "
"and <classname>TreeTable</classname> components allow special forms of "
"selection. They also inherit the <classname>AbstractSelect</classname>."
msgstr ""
"除以上组件之外, <classname>Tree</classname>, <classname>Table</classname>, 以"
"及 <classname>TreeTable</classname> 组件也支持特别形式的项目选择能力. 这些组"
"件也继承自 <classname>AbstractSelect</classname> 基类."

#. Tag: title
#: chapter-components.xml:1681
#, no-c-format
msgid "Binding Selection Components to Data"
msgstr "将选择组件绑定到数据"

#. Tag: para
#: chapter-components.xml:1683
#, no-c-format
msgid ""
"The selection components are strongly coupled with the Vaadin Data Model, "
"described in <xref linkend=\"datamodel\"/>. The selectable items in all "
"selection components are objects that implement the <classname>Item</"
"classname> interface. The items are contained in a <classname>Container</"
"classname>."
msgstr ""
"选择组件与 Vaadin 数据模型(详情请参见 <xref linkend=\"datamodel\"/>)结合得非"
"常紧密. 在所有的选择组件中, 可选项目必须是实现了 <classname>Item</classname> "
"接口的对象, 可选项目包含在 <classname>Container</classname> 之内."

#. Tag: para
#: chapter-components.xml:1691
#, no-c-format
msgid ""
"All selection components are containers themselves and simply forward all "
"container operations to the underlying container data source. You can give "
"the container in the constructor or set it set "
"<methodname>setContainerDataSource()</methodname>. This is further described "
"in <xref linkend=\"datamodel.container.intro\"/>."
msgstr ""
"所有的选择组件本身都是数据项目的容器(container), 它们只是简单地将所有的容器操"
"作抓发给下层的数据源. 你可以在构造函数中给定一个数据容器, 也可以通过 "
"<methodname>setContainerDataSource()</methodname> 方法来设置. 关于这个问题, "
"将在 <xref linkend=\"datamodel.container.intro\"/> 中详细介绍."

#. Tag: programlisting
#: chapter-components.xml:1699
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a container data source of some kind\n"
"IndexedContainer container = new IndexedContainer();\n"
"container.addContainerProperty(\"name\", String.class, null);\n"
"...\n"
"\n"
"// Create a selection component bound to the container\n"
"OptionGroup group = new OptionGroup(\"My Select\", container);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1701
#, no-c-format
msgid ""
"If you do not bind a selection component to a container data source, a "
"default container is used. It is usually either an "
"<classname>IndexedContainer</classname> or a "
"<classname>HierarchicalContainer</classname>."
msgstr ""
"如果你没有将一个选择组件绑定到一个数据源, 那么它将会使用一个默认的数据容器. "
"默认数据容器通常是一个 <classname>IndexedContainer</classname> 或一个 "
"<classname>HierarchicalContainer</classname>."

#. Tag: para
#: chapter-components.xml:1708
#, no-c-format
msgid ""
"The current selection of a selection component is bound to the "
"<classname>Property</classname> interface, so you can get the current "
"selection as the value of the selection component. Also selection changes "
"are handled as value change events, as is described later."
msgstr ""
"选择组件的当前选中项目绑定到 <classname>Property</classname> 接口, 因此你可以"
"通过选择组件的值得到它的当前选中项目. 同样的, 选择项目的变更也以值变更事件的"
"方式来处理, 详情将在后续章节中介绍."

#. Tag: title
#: chapter-components.xml:1717
#, no-c-format
msgid "Adding New Items"
msgstr "添加新的选择项"

#. Tag: para
#: chapter-components.xml:1719
#, no-c-format
msgid ""
"New items are added with the <methodname>addItem()</methodname> method "
"defined in the <classname>Container</classname> interface, described in "
"<xref linkend=\"datamodel.container.intro\"/>."
msgstr ""
"使用 <classname>Container</classname> 接口的 <methodname>addItem()</"
"methodname> 方法可以追加新的选择项. 详情请参见 <xref linkend=\"datamodel."
"container.intro\"/>."

#. Tag: programlisting
#: chapter-components.xml:1725
#, no-c-format
msgid ""
"<![CDATA[// Create a selection component\n"
"ComboBox select = new ComboBox(\"My ComboBox\");\n"
"\n"
"// Add items with given item IDs\n"
"select.addItem(\"Mercury\");\n"
"select.addItem(\"Venus\");\n"
"select.addItem(\"Earth\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1727
#, no-c-format
msgid ""
"The <methodname>addItem()</methodname> method creates an empty "
"<classname>Item</classname>, which is identified by its <emphasis>item "
"identifier</emphasis> (IID) object, given as the parameter. This item ID is "
"by default used also as the caption of the item, as described in more detail "
"later."
msgstr ""
"<methodname>addItem()</methodname> 方法创建空的 <classname>Item</classname>, "
"项目通过它的 <emphasis>项目ID(item identifier)</emphasis> (IID) 对象来区分, "
"项目ID通过参数给定. 项目ID默认也会用作项目的标题, 详情请见后文."

#. Tag: para
#: chapter-components.xml:1735
#, no-c-format
msgid ""
"We emphasize that <methodname>addItem()</methodname> is a factory method "
"that <emphasis>takes an item ID, not the actual item</emphasis> as the "
"parameter - the item is returned by the method. The item is of a type that "
"is specific to the container and has itself little relevance for most "
"selection components, as the properties of an item may not be used in any "
"way (except in <classname>Table</classname>), only the item ID."
msgstr ""
"我们要强调的是 <methodname>addItem()</methodname> 是一个工程方法, 它接受的参"
"数 <emphasis>是项目 ID, 而不是真实的项目</emphasis> - 项目是这个方法的返回"
"值. 项目的类型由容器决定, 而且在大多数选择组件中类型并不重要, 因为项目仅有项"
"目 ID, 其他所有属性都不会被使用(但在 <classname>Table</classname> 中例外)."

#. Tag: para
#: chapter-components.xml:1744
#, no-c-format
msgid ""
"The item identifier is typically a string, in which case it can be used as "
"the caption, but can be any object type. We could as well have given "
"integers for the item identifiers and set the captions explicitly with "
"<methodname>setItemCaption()</methodname>. You could also add an item with "
"the parameterless <methodname>addItem()</methodname>, which returns an "
"automatically generated item ID."
msgstr ""
"项目 ID 通常是字符串, 这种情况下它可以用作项目标签, 但项目 ID 也可以是任何对"
"象类型. 我们完全可以使用整数作为项目 ID , 然后使用"
"<methodname>setItemCaption()</methodname> 方法明确设定项目标签. 你也可以使用"
"无参数的 <methodname>addItem()</methodname> 方法来添加项目, 这个方法会返回一"
"个自动生成的项目 ID."

#. Tag: programlisting
#: chapter-components.xml:1753
#, no-c-format
msgid ""
"<![CDATA[// Create a selection component\n"
"ComboBox select = new ComboBox(\"My Select\");\n"
"\n"
"// Add an item with a generated ID\n"
"Object itemId = select.addItem();\n"
"select.setItemCaption(itemId, \"The Sun\");\n"
"\n"
"// Select the item\n"
"select.setValue(itemId);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1755
#, no-c-format
msgid ""
"Some container types may support passing the actual data object to the add "
"method. For example, you can add items to a <classname>BeanItemContainer</"
"classname> with <methodname>addBean()</methodname>. Such implementations can "
"use a separate item ID object, or the data object itself as the item ID, as "
"is done in <methodname>addBean()</methodname>. In the latter case you can "
"not depend on the default way of acquiring the item caption; see the "
"description of the different caption modes later."
msgstr ""
"某些容器类型可能支持传递真实数据对象来添加项目. 比如, 你可以使用 "
"<methodname>addBean()</methodname> 方法向 <classname>BeanItemContainer</"
"classname> 添加项目. 这样的容器实现可以使用一个独立的项目 ID 对象, 也可以使用"
"真实数据对象本身作为项目 ID, <methodname>addBean()</methodname> 方法正是如"
"此. 后一种情况下你不能使用默认的方式得到项目标签; 取得项目标签的其他方法见后"
"文."

#. Tag: para
#: chapter-components.xml:1766
#, no-c-format
msgid ""
"The next section describes the different options for determining the item "
"captions."
msgstr "下面的小节介绍取得项目标签的不同方式."

#. Tag: title
#: chapter-components.xml:1773
#, no-c-format
msgid "Item Captions"
msgstr "项目标题"

#. Tag: para
#: chapter-components.xml:1775
#, no-c-format
msgid ""
"The displayed captions of items in a selection component can be set "
"explicitly with <methodname>setItemCaption()</methodname> or determined from "
"the item IDs or item properties. The caption determination is defined with "
"the <emphasis>caption mode</emphasis>, any of the modes in the "
"<classname>AbstractSelect.ItemCaptionMode</classname> enum, which you can "
"set with <methodname>setItemCaptionMode()</methodname>. The default mode is "
"<parameter>EXPLICIT_DEFAULTS_ID</parameter>, which uses the item identifiers "
"for the captions, unless given explicitly."
msgstr ""
"选择组件中显示的项目标签可以使用 <methodname>setItemCaption()</methodname> 方"
"法明确指定, 也可以通过项目 ID 或 项目属性自动获得. 标题的取得方式由 "
"<emphasis>标题模式</emphasis> 决定, 标题模式定义在 <classname>AbstractSelect."
"ItemCaptionMode</classname> 枚举型内, 你可以使用 "
"<methodname>setItemCaptionMode()</methodname> 方法来设置标题模式. 默认的模式"
"是 <parameter>EXPLICIT_DEFAULTS_ID</parameter>, 这个模式下, 除非明确给定标"
"题, 否则就使用项目 ID 作为标题."

#. Tag: para
#: chapter-components.xml:1786
#, no-c-format
msgid ""
"In addition to a caption, an item can have an icon. The icon is set with "
"<methodname>setItemIcon()</methodname>."
msgstr ""
"除标题外, 项目还可以有图标. 图标使用 <methodname>setItemIcon()</methodname> "
"方法设置."

#. Tag: para
#: chapter-components.xml:1791
#, no-c-format
msgid ""
"The caption modes defined in <classname>ItemCaptionMode</classname> are the "
"following:"
msgstr "标题模式定义在 <classname>ItemCaptionMode</classname> 中, 如下:"

#. Tag: title
#: chapter-components.xml:1797
#, no-c-format
msgid "Caption Modes for Selection Components"
msgstr "选择组件的标题模式"

#. Tag: constant
#: chapter-components.xml:1799
#, no-c-format
msgid "EXPLICIT_DEFAULTS_ID"
msgstr ""

#. Tag: para
#: chapter-components.xml:1801
#, no-c-format
msgid ""
"This is the default caption mode and its flexibility allows using it in most "
"cases. By default, the item identifier will be used as the caption. The "
"identifier object does not necessarily have to be a string; the caption is "
"retrieved with <methodname>toString()</methodname> method. If the caption is "
"specified explicitly with <methodname>setItemCaption()</methodname>, it "
"overrides the item identifier."
msgstr ""
"这是默认的标题模式, 这是一种很灵活的模式, 可以用于大多数情况. 默认会使用项目 "
"ID 最为标题. 项目 ID 对象不必一定是字符串类型; 标题文字可以通过 "
"<methodname>toString()</methodname> 方法得到. 如果使用 "
"<methodname>setItemCaption()</methodname> 方法明确指定了标题, 那么将会使用指"
"定的标题, 而不是项目 ID."

#. Tag: programlisting
#: chapter-components.xml:1812
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a selection component\n"
"ComboBox select = new ComboBox(\"Moons of Mars\");\n"
"select.setItemCaptionMode(ItemCaptionMode.EXPLICIT_DEFAULTS_ID);\n"
"\n"
"// Use the item ID also as the caption of this item\n"
"select.addItem(new Integer(1));\n"
"\n"
"// Set item caption for this item explicitly\n"
"select.addItem(2); // same as \"new Integer(2)\"\n"
"select.setItemCaption(2, \"Deimos\");]]>"
msgstr ""

#. Tag: constant
#: chapter-components.xml:1817
#, no-c-format
msgid "EXPLICIT"
msgstr ""

#. Tag: para
#: chapter-components.xml:1819
#, no-c-format
msgid ""
"Captions must be explicitly specified with <methodname>setItemCaption()</"
"methodname>. If they are not, the caption will be empty. Such items with "
"empty captions will nevertheless be displayed in the selection component as "
"empty items. If they have an icon, they will be visible."
msgstr ""
"这个模式下, 必须使用 <methodname>setItemCaption()</methodname> 方法明确指定标"
"题. 如果没有指定, 标题将为空. 标题为空的项目仍然会显示在选择组件中. 如果带有"
"图标, 项目在界面上就是可见的了."

#. Tag: constant
#: chapter-components.xml:1829
#, no-c-format
msgid "ICON_ONLY"
msgstr ""

#. Tag: para
#: chapter-components.xml:1831
#, no-c-format
msgid "Only icons are shown, captions are hidden."
msgstr "这个模式下只显示图标, 标题将被隐藏."

#. Tag: constant
#: chapter-components.xml:1837
#, no-c-format
msgid "<constant>ID</constant>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1839
#, no-c-format
msgid ""
"String representation of the item identifier object is used as caption. This "
"is useful when the identifier is a string, and also when the identifier is "
"an complex object that has a string representation. For example:"
msgstr ""
"这个模式使用项目 ID 对象的字符串表达作为标题. 当项目 ID 为字符串型时, 这个模"
"式是很有用的, 如果项目 ID 是一个复杂对象, 但有字符串形式的表达, 也可以使用这"
"个模式. 比如:"

#. Tag: programlisting
#: chapter-components.xml:1846
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[ComboBox select = new ComboBox(\"Inner Planets"
"\");\n"
"select.setItemCaptionMode(ItemCaptionMode.ID);\n"
"\n"
"// A class that implements toString()\n"
"class PlanetId extends Object implements Serializable {\n"
"    String planetName;\n"
"\n"
"    PlanetId (String name) {\n"
"        planetName = name;\n"
"    }\n"
"    public String toString () {\n"
"        return \"The Planet \" + planetName;\n"
"    }\n"
"}\n"
"\n"
"// Use such objects as item identifiers\n"
"String planets[] = {\"Mercury\", \"Venus\", \"Earth\", \"Mars\"};\n"
"for (int i=0; i<planets.length; i++)\n"
"    select.addItem(new PlanetId(planets[i]));]]>"
msgstr ""

#. Tag: constant
#: chapter-components.xml:1850
#, no-c-format
msgid "INDEX"
msgstr ""

#. Tag: para
#: chapter-components.xml:1852
#, no-c-format
msgid ""
"Index number of item is used as caption. This caption mode is applicable "
"only to data sources that implement the <classname>Container.Indexed</"
"classname> interface. If the interface is not available, the component will "
"throw a <classname>ClassCastException</classname>. The "
"<classname>AbstractSelect</classname> itself does not implement this "
"interface, so the mode is not usable without a separate data source. An "
"<classname>IndexedContainer</classname>, for example, would work."
msgstr ""
"这个模式使用项目的索引顺序作为标题. 只有在数据源实现了 <classname>Container."
"Indexed</classname> 接口时才可以使用这个模式. 否则, 组件将抛出一个 "
"<classname>ClassCastException</classname> 异常. <classname>AbstractSelect</"
"classname> 类本身没有实现这个接口, 因此这个模式必须与一个独立的数据源组合使"
"用. 比如 <classname>IndexedContainer</classname>."

#. Tag: constant
#: chapter-components.xml:1867
#, no-c-format
msgid "ITEM"
msgstr ""

#. Tag: para
#: chapter-components.xml:1869
#, no-c-format
msgid ""
"<classname>String</classname> representation of item, acquired with "
"<methodname>toString()</methodname>, is used as the caption. This is "
"applicable mainly when using a custom <classname>Item</classname> class, "
"which also requires using a custom <classname>Container</classname> that is "
"used as a data source for the selection component."
msgstr ""
"这个模式下, 通过项目的 <methodname>toString()</methodname> 方法得到的 "
"<classname>String</classname> 型表达, 被用作标题. 这个模式主要适用于自定义 "
"<classname>Item</classname> 类的情况, 此时还需要自定义 <classname>Container</"
"classname> 类, 并将它用作选择组件的数据源."

#. Tag: constant
#: chapter-components.xml:1880
#, no-c-format
msgid "PROPERTY"
msgstr ""

#. Tag: para
#: chapter-components.xml:1882
#, no-c-format
msgid ""
"Item captions are read from the <classname>String</classname> representation "
"of the property with the identifier specified with "
"<methodname>setItemCaptionPropertyId()</methodname>. This is useful, for "
"example, when you have a container that you use as the data source for the "
"selection component, and you want to use a specific property for caption."
msgstr ""
"这个模式下, 项目标题通过项目属性值的 <classname>String</classname> 表达获得, "
"用作标题的属性 ID 使用 <methodname>setItemCaptionPropertyId()</methodname> 方"
"法来指定. 当你使用一个容器作为选择组件的数据源, 如果你希望使用某个特定的属性"
"作为项目标题, 这个模式就很有用."

#. Tag: para
#: chapter-components.xml:1891
#, no-c-format
msgid ""
"In the example below, we bind a selection component to a bean container and "
"use a property of the bean as the caption."
msgstr ""
"下面的例子中, 我们将一个选择组件绑定到一个 Bean 容器, 并使用 Bean 的一个属性"
"作为选择项目的标题."

#. Tag: programlisting
#: chapter-components.xml:1896
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/** A bean with a \"name\" property. */\n"
"public class Planet implements Serializable {\n"
"    int    id;\n"
"    String name;\n"
"    \n"
"    public Planet(int id, String name) {\n"
"        this.id   = id;\n"
"        this.name = name;\n"
"    }\n"
"\n"
"    ... setters and getters ...    \n"
"}\n"
"\n"
"public void captionproperty(VerticalLayout layout) {\n"
"    // Have a bean container to put the beans in\n"
"    BeanItemContainer<Planet> container =\n"
"        new BeanItemContainer<Planet>(Planet.class);\n"
"\n"
"    // Put some example data in it\n"
"    container.addItem(new Planet(1, \"Mercury\"));\n"
"    container.addItem(new Planet(2, \"Venus\"));\n"
"    container.addItem(new Planet(3, \"Earth\"));\n"
"    container.addItem(new Planet(4, \"Mars\"));\n"
"\n"
"    // Create a selection component bound to the container\n"
"    ComboBox select = new ComboBox(\"Planets\", container);\n"
"\n"
"    // Set the caption mode to read the caption directly\n"
"    // from the 'name' property of the bean\n"
"    select.setItemCaptionMode(ItemCaptionMode.PROPERTY);\n"
"    select.setItemCaptionPropertyId(\"name\");\n"
"\n"
"    ...]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:1903
#, no-c-format
msgid "Getting and Setting Selection"
msgstr "取得和设置当前选中项目"

#. Tag: para
#: chapter-components.xml:1905
#, no-c-format
msgid ""
"A selection component provides the current selection as the property of the "
"component (with the <classname>Property</classname> interface). The property "
"value is an item identifier object that identifies the selected item. You "
"can get the identifier with <methodname>getValue()</methodname> of the "
"<classname>Property</classname> interface."
msgstr ""
"选择组件的当前选中项目以组件的属性(<classname>Property</classname> 接口)的方"
"式提供. 这个属性的值是项目 ID 对象, ID 对象标识了被选中的项目是哪个. 你可以使"
"用 <classname>Property</classname> 接口的 <methodname>getValue()</"
"methodname> 方法来得到当前选中项目的 ID."

#. Tag: para
#: chapter-components.xml:1913
#, no-c-format
msgid ""
"You can select an item with the corresponding <methodname>setValue()</"
"methodname> method. In multiselect mode, the property will be an "
"unmodifiable set of item identifiers. If no item is selected, the property "
"will be <parameter>null</parameter> in single selection mode or an empty "
"collection in multiselect mode."
msgstr ""
"使用对应的 <methodname>setValue()</methodname> 方法可以选中某个项目. 在多选模"
"式下, 属性值应该是项目 ID 组成的不可变集合. 如果没有项目被选中, 单选模式下的"
"属性值应该是 <parameter>null</parameter> , 多选模式下应该是空集合."

#. Tag: para
#: chapter-components.xml:1921
#, no-c-format
msgid ""
"The <classname>ComboBox</classname> and <classname>NativeSelect</classname> "
"will show empty selection when no actual item is selected. This is the "
"<emphasis>null selection item identifier</emphasis>. You can set an "
"alternative ID with <methodname>setNullSelectionItemId()</methodname>. "
"Setting the alternative null ID is merely a visual text; the "
"<methodname>getValue()</methodname> will still return <parameter>null</"
"parameter> value if no item is selected, or an empty set in multiselect mode."
msgstr ""
"当没有项目被选中时, <classname>ComboBox</classname> 和 "
"<classname>NativeSelect</classname> 将会显示空的选中项. 也就是 "
"<emphasis>null 选择项目 ID</emphasis>. 你可以使用 "
"<methodname>setNullSelectionItemId()</methodname> 方法设置一个替代的 ID. 设置"
"替代的 null ID 只会影响界面表现文字; 没有项目被选中时, "
"<methodname>getValue()</methodname> 方法在单选模式下仍然会返回 "
"<parameter>null</parameter> 值, 在多选模式先仍然会返回空集合."

#. Tag: title
#: chapter-components.xml:1934
#, no-c-format
msgid "Handling Selection Changes"
msgstr "处理选择项的变化事件"

#. Tag: para
#: chapter-components.xml:1936
#, no-c-format
msgid ""
"The item identifier of the currently selected item will be set as the "
"property of the selection component. You can access it with the "
"<methodname>getValue()</methodname> method of the <classname>Property</"
"classname> interface of the component. Also, when handling selection changes "
"with a <classname>Property.ValueChangeListener</classname>, the "
"<classname>ValueChangeEvent</classname> will have the selected item as the "
"property of the event, accessible with the <methodname>getProperty()</"
"methodname> method."
msgstr ""
"当前选中项目的 ID 将被设置为选择组件的属性. 你可以通过组件本身的 "
"<classname>Property</classname> 接口的 <methodname>getValue()</methodname> 方"
"法访问它. 还可以使用 <classname>Property.ValueChangeListener</classname> 监听"
"器来处理选择项的变化事件, <classname>ValueChangeEvent</classname> 事件的属性"
"将是被选中的项目, 可以通过 <methodname>getProperty()</methodname> 方法访问."

#. Tag: programlisting
#: chapter-components.xml:1948
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create a selection component with some "
"items\n"
"ComboBox select = new ComboBox(\"My Select\");\n"
"select.addItems(\"Io\", \"Europa\", \"Ganymedes\", \"Callisto\");\n"
"        \n"
"// Handle selection change\n"
"select.addValueChangeListener(event -> // Java 8\n"
"    layout.addComponent(new Label(\"Selected \" +\n"
"        event.getProperty().getValue())));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1950
#, no-c-format
msgid ""
"The result of user interaction is shown in <xref linkend=\"figure.components."
"selection.valuechange\"/>."
msgstr ""
"用户操作这个 ComboBox 之后的运行结果, 参见 <xref linkend=\"figure.components."
"selection.valuechange\"/>."

#. Tag: title
#: chapter-components.xml:1956
#, no-c-format
msgid "Selected Item"
msgstr "被选中的项目"

#. Tag: title
#: chapter-components.xml:1975
#, no-c-format
msgid "Allowing Adding New Items"
msgstr "允许添加新项目"

#. Tag: para
#: chapter-components.xml:1977
#, no-c-format
msgid ""
"Some selection components can allow the user to add new items. Currently, "
"only <classname>ComboBox</classname> allows it, when the user types in a "
"value and presses <keycap>Enter</keycap>. You need to enable the mode with "
"<methodname>setNewItemsAllowed(true)</methodname>. Setting the component "
"also in immediate mode may be necessary, as otherwise the item would not be "
"added immediately when the user interacts with the component, but after some "
"other component causes a server request."
msgstr ""
"某些选择组件可以允许用户添加新项目. 目前只有 <classname>ComboBox</classname> "
"支持这个功能, 当用户输入一个值, 并按下 <keycap>Enter</keycap> 键时, 新项目就"
"被添加了. 你需要使用 <methodname>setNewItemsAllowed(true)</methodname> 方法打"
"开这个模式. 有可能还需要将组件设置为立即模式, 否则 新项目可能不会在用户操作这"
"个组件时立即添加, 而是在其他操作之后才出发服务器请求."

#. Tag: programlisting
#: chapter-components.xml:1988
#, no-c-format
msgid ""
"<![CDATA[myselect.setNewItemsAllowed(true);\n"
"myselect.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:1990
#, no-c-format
msgid ""
"The user interface for adding new items depends on the selection component. "
"The regular <classname>ComboBox</classname> component allows you to simply "
"type the new item in the combo box and hit <keycap>Enter</keycap> to add it."
msgstr ""
"用于添加新项目的用户界面由各个选择组件决定. 通常的 <classname>ComboBox</"
"classname> 组件允许你在复合框内直接输入新项目内容, 然后按下 <keycap>Enter</"
"keycap> 键就可以添加这个新项目."

#. Tag: para
#: chapter-components.xml:1997
#, no-c-format
msgid ""
"Adding new items in not possible if the selection component is read-only or "
"is bound to a <classname>Container</classname> that does not allow adding "
"new items, and an attempt may result in an exception."
msgstr ""
"当组件为只读时, 或者组件绑定的 <classname>Container</classname> 不支持添加新"
"项目时, 向组件添加新项目是不可能的, 尝试添加新项目可能会导致一个例外."

#. Tag: title
#: chapter-components.xml:2004
#, no-c-format
msgid "Handling New Items"
msgstr "处理新项目"

#. Tag: para
#: chapter-components.xml:2006
#, no-c-format
msgid ""
"Adding new items is handled by a <interfacename>NewItemHandler</"
"interfacename>, which gets the item caption string as parameter for the "
"<methodname>addNewItem()</methodname> method. The default implementation, "
"<classname>DefaultNewItemHandler</classname>, checks for read-only state, "
"adds the item using the entered caption as the item ID, and if the selection "
"component gets the captions from a property, copies the caption to that "
"property. It also selects the item. The default implementation may not be "
"suitable for all container types, in which case you need to define a custom "
"handler. For example, a <classname>BeanItemContainer</classname> expects the "
"items to have the bean object itself as the ID, not a string."
msgstr ""
"新项目的添加由 <interfacename>NewItemHandler</interfacename> 负责处理, 它的 "
"<methodname>addNewItem()</methodname> 方法将接受项目标题字符串作为参数. 默认"
"实现类是 <classname>DefaultNewItemHandler</classname>, 它将检查组件的只读状"
"态, 将用户输入的标题作为项目 ID 来添加新项目, 如果选则组件从项目属性中获取项"
"目标题的话, 它还要将标题复制到对应的属性中. 它还会选中这个项目. 这个默认实现"
"类可能不能适用于所有的容器类型, 这种情况下你需要创建自定义的处理器. 比如, "
"<classname>BeanItemContainer</classname> 要求项目使用 Bean 对象本身作为 ID, "
"而不是使用字符串作为 ID."

#. Tag: programlisting
#: chapter-components.xml:2022
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a bean container to put the beans in\n"
"final BeanItemContainer<Planet> container =\n"
"    new BeanItemContainer<Planet>(Planet.class);\n"
"\n"
"// Put some example data in it\n"
"container.addItem(new Planet(1, \"Mercury\"));\n"
"container.addItem(new Planet(2, \"Venus\"));\n"
"container.addItem(new Planet(3, \"Earth\"));\n"
"container.addItem(new Planet(4, \"Mars\"));\n"
"\n"
"final ComboBox select =\n"
"    new ComboBox(\"Select or Add a Planet\", container);\n"
"select.setNullSelectionAllowed(false);\n"
"        \n"
"// Use the name property for item captions\n"
"select.setItemCaptionPropertyId(\"name\");\n"
"        \n"
"// Allow adding new items\n"
"select.setNewItemsAllowed(true);\n"
"select.setImmediate(true);\n"
"\n"
"// Custom handling for new items\n"
"select.setNewItemHandler(new NewItemHandler() {\n"
"    @Override\n"
"    public void addNewItem(String newItemCaption) {\n"
"        // Create a new bean - can't set all properties\n"
"        Planet newPlanet = new Planet(0, newItemCaption);\n"
"        container.addBean(newPlanet);\n"
"        \n"
"        // Remember to set the selection to the new item\n"
"        select.select(newPlanet);\n"
"        \n"
"        Notification.show(\"Added new planet called \" +\n"
"                          newItemCaption);\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:2027
#, no-c-format
msgid "Multiple Selection"
msgstr "复数选择"

#. Tag: para
#: chapter-components.xml:2031
#, no-c-format
msgid ""
"Some selection components, such as <classname>OptionGroup</classname> and "
"<classname>ListSelect</classname> support a multiple selection mode, which "
"you can enable with <methodname>setMultiSelect()</methodname>. For "
"<classname>TwinColSelect</classname>, which is especially intended for "
"multiple selection, it is enabled by default."
msgstr ""
"某些选择组件, 比如 <classname>OptionGroup</classname> 和 "
"<classname>ListSelect</classname> 支持多选模式, 你可以使用 "
"<methodname>setMultiSelect()</methodname> 方法打开多选模式. 对于 "
"<classname>TwinColSelect</classname> 来说, 它本身的目的就是选择多个项目, 因此"
"它默认就是多选模式."

#. Tag: programlisting
#: chapter-components.xml:2039
#, no-c-format
msgid "<![CDATA[myselect.setMultiSelect(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2041
#, no-c-format
msgid ""
"As in single selection mode, the property value of the component indicates "
"the selection. In multiple selection mode, however, the property value is a "
"<classname>Collection</classname> of the item IDs of the currently selected "
"items. You can get and set the property with the <methodname>getValue()</"
"methodname> and <methodname>setValue()</methodname> methods as usual."
msgstr ""
"在单选模式下, 组件的属性值就代表它目前选中的项目. 但在多选模式下, 属性值将是"
"当前被选中的项目 ID 组成的 <classname>Collection</classname>. 你可以使用 "
"<methodname>getValue()</methodname> 和 <methodname>setValue()</methodname> 方"
"法读写属性值 ."

#. Tag: para
#: chapter-components.xml:2050
#, no-c-format
msgid ""
"A change in the selection will trigger a <classname>ValueChangeEvent</"
"classname>, which you can handle with a <classname>Propery."
"ValueChangeListener</classname>. As usual, you should use "
"<methodname>setImmediate(true)</methodname> to trigger the event immediately "
"when the user changes the selection. The following example shows how to "
"handle selection changes with a listener."
msgstr ""
"选择状态的变化将激发 <classname>ValueChangeEvent</classname> 事件, 可以使用 "
"<classname>Propery.ValueChangeListener</classname> 监听器来处理这个事件. 通常"
"应该使用 <methodname>setImmediate(true)</methodname>, 当用户修改选择状态时立"
"即激发事件. 下面的例子演示如何使用监听器来处理选择的变化."

#. Tag: programlisting
#: chapter-components.xml:2060
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// A selection component with some items\n"
"ListSelect select = new ListSelect(\"My Selection\");\n"
"select.addItems(\"Mercury\", \"Venus\", \"Earth\",\n"
"    \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n"
"\n"
"// Multiple selection mode\n"
"select.setMultiSelect(true);\n"
"\n"
"// Feedback on value changes\n"
"select.addValueChangeListener(\n"
"    new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        // Some feedback\n"
"        layout.addComponent(new Label(\"Selected: \" +\n"
"            event.getProperty().getValue().toString()));\n"
"    }\n"
"});\n"
"select.setImmediate(true);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:2065
#, no-c-format
msgid "Item Icons"
msgstr "项目图标"

#. Tag: para
#: chapter-components.xml:2067
#, no-c-format
msgid ""
"You can set an icon for each item with <methodname>setItemIcon()</"
"methodname>, or define an item property that provides the icon resource with "
"<methodname>setItemIconPropertyId()</methodname>, in a fashion similar to "
"captions. Notice, however, that icons are not supported in "
"<classname>NativeSelect</classname>, <classname>TwinColSelect</classname>, "
"and some other selection components and modes. This is because HTML does not "
"support images inside the native <literal>select</literal> elements. Icons "
"are also not really visually applicable."
msgstr ""
"你可以使用 <methodname>setItemIcon()</methodname> 方法为每个项目设置图标, 或"
"者使用 <methodname>setItemIconPropertyId()</methodname> 方法指定一个项目属性"
"来提供图标资源, 具体方法与我们前面讲过的\"通过属性来指定标题\"是类似的. 注"
"意, 图标在 <classname>NativeSelect</classname> 组件, "
"<classname>TwinColSelect</classname> 组件, 以及其他某些选择组件或模式下是不支"
"持的. 这是因为 HTML 不支持在原生的 <literal>select</literal> 元素旁边显示图"
"片. Icons are also not really visually applicable(译注: 这句不理解, 待校)."

#. Tag: title
#: chapter-components.xml:2082
#, no-c-format
msgid "Component Extensions"
msgstr "组件的扩展"

#. Tag: para
#: chapter-components.xml:2084
#, no-c-format
msgid ""
"Components and UIs can have extensions which are attached to the component "
"dynamically. Especially, many add-ons are extensions."
msgstr ""
"组件和 UI 可以拥有动态关联在其上的扩展(extension). 很多插件实际上都是扩展."

#. Tag: para
#: chapter-components.xml:2089
#, no-c-format
msgid ""
"How a component is extended depends on the extension. Typically, they have "
"an <methodname>extend()</methodname> method that takes the component to be "
"extended as the parameter."
msgstr ""
"如何扩充一个组件的功能由具体的扩展来决定. 扩展通常会有一个 "
"<methodname>extend()</methodname> 方法, 参数是需要扩充的对象组件."

#. Tag: programlisting
#: chapter-components.xml:2095
#, no-c-format
msgid ""
"<![CDATA[TextField tf = new TextField(\"Hello\");\n"
"layout.addComponent(tf);\n"
"\n"
"// Add a simple extension\n"
"new CapsLockWarning().extend(tf);\n"
"\n"
"// Add an extension that requires some parameters\n"
"CSValidator validator = new CSValidator();\n"
"validator.setRegExp(\"[0-9]*\");\n"
"validator.setErrorMessage(\"Must be a number\");\n"
"validator.extend(tf);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2097
#, no-c-format
msgid ""
"Development of custom extensions is described in <xref linkend=\"gwt."
"extension\"/>."
msgstr "如何开发自定义的扩展, 详情请参阅 <xref linkend=\"gwt.extension\"/>."

#. Tag: classname
#: chapter-components.xml:2104
#, no-c-format
msgid "Label"
msgstr "Label"

#. Tag: para
#: chapter-components.xml:2106
#, no-c-format
msgid ""
"<classname>Label</classname> component displays non-editable text. This text "
"can be used for short simple labels or for displaying long text, such as "
"paragraphs. The text can be formatted in HTML or as preformatted text, "
"depending on the <emphasis>content mode</emphasis> of the label."
msgstr ""
"<classname>Label</classname> 组件显示一段不可编辑的文本. 这段文本可以用来显示"
"简短的标签, 也可以用来显示长文本, 比如一个段落. 通过设置 <classname>Label</"
"classname> 组件的 <emphasis>内容模式</emphasis>, 文本可以使用 HTML 格式, 也可"
"以使用预格式化的文本."

#. Tag: para
#: chapter-components.xml:2113
#, no-c-format
msgid ""
"You can give the label text most conviniently in the constructor, as is done "
"in the following. Label has 100% default width, so the containing layout "
"must also have defined width."
msgstr ""
"可以在构造函数中指定 Label 的文本内容, 这是最方便的方式, 如下例所示. Label 的"
"默认宽度为 100%, 因此包含它的布局组件宽度必须为固定值."

#. Tag: programlisting
#: chapter-components.xml:2120
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// A container that is 100% wide by default\n"
"VerticalLayout layout = new VerticalLayout();\n"
"\n"
"Label label = new Label(\"Labeling can be dangerous\");\n"
"layout.addComponent(label);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2122
#, no-c-format
msgid ""
"<classname>Label</classname> implements the <interfacename>Property</"
"interfacename> interface to allow accessing the text value, so you can get "
"and set the text with <methodname>getValue()</methodname> and "
"<methodname>setValue()</methodname>."
msgstr ""

#. Tag: programlisting
#: chapter-components.xml:2130
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Get the label's text to initialize a field\n"
"TextField editor = new TextField(null, // No caption\n"
"                                 label.getValue());\n"
"        \n"
"// Change the label's text\n"
"editor.addValueChangeListener(event -> // Java 8\n"
"    label.setValue(editor.getValue()));\n"
"editor.setImmediate(true); // Send on Enter]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2132
#, no-c-format
msgid ""
"Label also supports data binding to a property data source, as described "
"later in <xref linkend=\"components.label.databinding\"/>. However, in that "
"case the value can not be set through the label, as <classname>Label</"
"classname> is not a <interfacename>Property.Editor</interfacename> and is "
"not allowed to write to a bound property."
msgstr ""
"Label 还支持绑定到一个属性(property)数据源, 详情将在 <xref linkend="
"\"components.label.databinding\"/> 中介绍. 但是, 这时无法通过 label 来设置数"
"据值, 因为 <classname>Label</classname> 不是一个 <interfacename>Property."
"Editor</interfacename>, 不允许向绑定的属性写入数据."

#. Tag: para
#: chapter-components.xml:2140
#, no-c-format
msgid ""
"Even though <classname>Label</classname> is text and is often used as a "
"caption, it is a normal component and therefore also has a caption that you "
"can set with <methodname>setCaption()</methodname>. As with most other "
"components, the caption is managed by the containing layout."
msgstr ""
"虽然 <classname>Label</classname> 是一段文本, 通常用做标题文字, 但它也是一个"
"通常的组件, 因此它本身也有标题, 你可以通过 <methodname>setCaption()</"
"methodname> 方法来设置标题. 和大多数其他组件一样, <classname>Label</"
"classname> 的标题也是由包含它的布局组件来管理的."

#. Tag: title
#: chapter-components.xml:2148
#, no-c-format
msgid "Text Width and Wrapping"
msgstr "文本的宽度与折行"

#. Tag: para
#: chapter-components.xml:2150
#, no-c-format
msgid ""
"<classname>Label</classname> has 100% default width, so the containing "
"layout must also have a defined width. If the width of the label's text "
"exceeds the width of the label, the text will wrap around and continue on "
"the next line. Some layout components have undefined width by default, such "
"as <classname>HorizontalLayout</classname>, so you need to pay special care "
"with them."
msgstr ""
"<classname>Label</classname> 的默认宽度为100%, 因此包含它的容器布局必须有一个"
"给定的宽度. 如果 Label 中文本的宽度超微了 Label 的宽度, 文本将会折行. 某些布"
"局组件默认宽度为未指定, 比如 <classname>HorizontalLayout</classname>, 因此你"
"需要特别注意."

#. Tag: programlisting
#: chapter-components.xml:2160
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// A container with a defined width.\n"
"Panel panel = new Panel(\"Panel Containing a Label\");\n"
"panel.setWidth(\"300px\");\n"
"\n"
"panel.setContent(\n"
"    new Label(\"This is a Label inside a Panel. There is \" +\n"
"              \"enough text in the label to make the text \" +\n"
"              \"wrap when it exceeds the width of the panel.\"));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2162
#, no-c-format
msgid ""
"As the size of the <classname>Panel</classname> in the above example is "
"fixed and the width of <classname>Label</classname> is the default 100%, the "
"text in the <classname>Label</classname> will wrap to fit the panel, as "
"shown in <xref linkend=\"figure.components.label\"/>."
msgstr ""
"上例中 <classname>Panel</classname> 的尺寸为固定值, <classname>Label</"
"classname> 的宽度为默认值 100%, 因此 <classname>Label</classname> 中的文字将"
"折行显示, 宽度与 Panel 相适应, 运行结果参见 <xref linkend=\"figure."
"components.label\"/>."

#. Tag: title
#: chapter-components.xml:2170
#, no-c-format
msgid "The Label Component"
msgstr "Label 组件"

#. Tag: para
#: chapter-components.xml:2181
#, no-c-format
msgid ""
"Setting <classname>Label</classname> to undefined width will cause it to not "
"wrap at the end of the line, as the width of the content defines the width. "
"If placed inside a layout with defined width, the <classname>Label</"
"classname> will overflow the layout horizontally and, normally, be truncated."
msgstr ""
"将 <classname>Label</classname> 宽度设置为未定义, 将导致它的内容不折行, 因为"
"此时 Label 的宽度将由文本内容的宽度决定. 如果 Label 所属布局组件的宽度有指"
"定, <classname>Label</classname> 将在水平方向上超过布局组件的显示范围, 超出的"
"部分通常会被截断, 不显示."

#. Tag: title
#: chapter-components.xml:2190
#, no-c-format
msgid "Content Mode"
msgstr "内容模式"

#. Tag: para
#: chapter-components.xml:2192
#, no-c-format
msgid ""
"The content of a label is formatted depending on a <emphasis>content mode</"
"emphasis>. By default, the text is assumed to be plain text and any "
"contained XML-specific characters will be quoted appropriately to allow "
"rendering the contents of a label in HTML in a web browser. The content mode "
"can be set in the constructor or with <methodname>setContentMode()</"
"methodname>, and can have the values defined in the <classname>ContentMode</"
"classname> enumeration type in <package>com.vaadin.shared.ui.label</package> "
"package:"
msgstr ""
"Label 内容的格式由 <emphasis>内容模式</emphasis> 决定. 默认情况下, 内容被认为"
"是纯文字, 任何特殊的 XML 字符都将被适当地转换, 以 HTML 形式在浏览器内正确地显"
"示 Label 内容. 内容模式可以在构造函数中设置, 也可以通过 "
"<methodname>setContentMode()</methodname> 方法设置, 可指定的值由 "
"<package>com.vaadin.shared.ui.label</package> 包的 <classname>ContentMode</"
"classname> 枚举型定义:"

#. Tag: constant
#: chapter-components.xml:2205
#, no-c-format
msgid "TEXT"
msgstr ""

#. Tag: para
#: chapter-components.xml:2207
#, no-c-format
msgid ""
"The default content mode where the label contains only plain text. All "
"characters are allowed, including the special <literal>&lt;</literal>, "
"<literal>&gt;</literal>, and <literal>&amp;</literal> characters in XML or "
"HTML, which are quoted properly in HTML while rendering the component. This "
"is the default mode."
msgstr ""
"这种模式下 Label 只包含纯文本. 文本中可以包含任意字符, 包括 XML 和 HTML 中的"
"特殊字符 <literal>&lt;</literal>, <literal>&gt;</literal>, 和 <literal>&amp;"
"</literal>, 这些特殊字符在显示组件时会被转义为适当的 HTML. 这个模式是默认的内"
"容模式."

#. Tag: constant
#: chapter-components.xml:2218
#, no-c-format
msgid "PREFORMATTED"
msgstr ""

#. Tag: para
#: chapter-components.xml:2220
#, no-c-format
msgid ""
"Content mode where the label contains preformatted text. It will be, by "
"default, rendered with a fixed-width typewriter font. Preformatted text can "
"contain line breaks, written in Java with the <literal>\\n</literal> escape "
"sequence for a newline character (ASCII 0x0a), or tabulator characters "
"written with <literal>\\t</literal> (ASCII 0x09)."
msgstr ""
"这种模式下 Label 包含的是格式化文本. 默认情况下会显示为定宽字体. 格式化文本可"
"以包含换行符, Java 语言中换行符(ASCII 0x0a)书写为转义字符串 <literal>\\n</"
"literal>, 也可以包含制表符, Java 语言中制表符(ASCII 0x09)书写为转义字符串 "
"<literal>\\t</literal> ."

#. Tag: constant
#: chapter-components.xml:2231
#, no-c-format
msgid "HTML"
msgstr ""

#. Tag: para
#: chapter-components.xml:2233
#, no-c-format
msgid "Content mode where the label contains HTML."
msgstr "这个模式下 Label 包含的是 HTML."

#. Tag: para
#: chapter-components.xml:2237
#, no-c-format
msgid ""
"Please note the following security and validity warnings regarding the HTML "
"content mode."
msgstr "请注意 HTML 内容模式下, 存在以下安全性和校验问题."

#. Tag: title
#: chapter-components.xml:2246 chapter-components.xml:3120
#, no-c-format
msgid "Cross-Site Scripting Warning"
msgstr "跨站脚本警告"

#. Tag: para
#: chapter-components.xml:2248
#, no-c-format
msgid ""
"Having <classname>Label</classname> in <constant>HTML</constant> content "
"mode allows pure HTML content. If the content comes from user input, you "
"should always carefully sanitize it to prevent cross-site scripting (XSS) "
"attacks. Please see <xref linkend=\"advanced.security.sanitizing\"/>."
msgstr ""
"当 <classname>Label</classname> 处于 <constant>HTML</constant> 内容模式时, 会"
"允许 Label 输出纯 HTML 的内容. 如果这些内容来自用户的输入, 你应该仔细处理用户"
"输入, 以防发生跨站脚本(XSS, cross-site scripting) 攻击. 详情请参见 <xref "
"linkend=\"advanced.security.sanitizing\"/>."

#. Tag: para
#: chapter-components.xml:2256
#, no-c-format
msgid ""
"Also, the validity of the HTML content is not checked when rendering the "
"component and any errors can result in an error in the browser. If the "
"content comes from an uncertain source, you should always validate it before "
"displaying it in the component."
msgstr ""
"另外, 在显示 Label 组件时, 对其中的 HTML 内容也没有检验其正确性, 因此 HTML 内"
"容的任何错误都有可能导致浏览器端的错误. 如果 HTML 内容来自不可靠的来源, 那么"
"你在使用 Label 组件输出 HTML 内容之前一定要检验其是否正确."

#. Tag: para
#: chapter-components.xml:2264
#, no-c-format
msgid ""
"The following example demonstrates the use of <classname>Label</classname> "
"in different modes."
msgstr "下面的例子演示了 <classname>Label</classname> 不同内容模式的使用方法."

#. Tag: programlisting
#: chapter-components.xml:2270
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[Label textLabel = new Label(\n"
"    \"Text where formatting characters, such as \\\\n, \" +\n"
"    \"and HTML, such as <b>here</b>, are quoted.\",\n"
"    ContentMode.TEXT);\n"
"\n"
"Label preLabel = new Label(\n"
"    \"Preformatted text is shown in an HTML <pre> tag.\\n\" +\n"
"    \"Formatting such as\\n\" +\n"
"    \"  * newlines\\n\" + \n"
"    \"  * whitespace\\n\" +\n"
"    \"and such are preserved. HTML tags, \\n\"+\n"
"    \"such as <b>bold</b>, are quoted.\",\n"
"    ContentMode.PREFORMATTED);\n"
"\n"
"Label htmlLabel = new Label(\n"
"    \"In HTML mode, all HTML formatting tags, such as \\n\" +\n"
"    \"<ul>\"+\n"
"    \"  <li><b>bold</b></li>\"+\n"
"    \"  <li>itemized lists</li>\"+\n"
"    \"  <li>etc.</li>\"+\n"
"    \"</ul> \"+\n"
"    \"are preserved.\",\n"
"    ContentMode.HTML);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2272
#, no-c-format
msgid ""
"The rendering will look as shown in <xref linkend=\"figure.components.label."
"content-mode\"/>."
msgstr ""
"上例的显示效果见 <xref linkend=\"figure.components.label.content-mode\"/>."

#. Tag: title
#: chapter-components.xml:2277
#, no-c-format
msgid "Label Content Modes"
msgstr "Label 的各种内容模式"

#. Tag: title
#: chapter-components.xml:2328
#, no-c-format
msgid "Spacing with a <classname>Label</classname>"
msgstr "用 <classname>Label</classname> 来控制空白"

#. Tag: para
#: chapter-components.xml:2330
#, no-c-format
msgid ""
"You can use a <classname>Label</classname> to create vertical or horizontal "
"space in a layout. If you need a empty \"line\" in a vertical layout, having "
"just a label with empty text is not enough, as it will collapse to zero "
"height. The same goes for a label with only whitespace as the label text. "
"You need to use a non-breaking space character, either <literal>&amp;nbsp;</"
"literal> or <literal>&amp;#160;</literal>:"
msgstr ""
"你可以使用 <classname>Label</classname> 在布局中生成垂直或水平的空白. 如果你"
"在垂直布局中需要一个空\"行\", 那么使用一个文本为空的 Label 是不够的, 因为它的"
"高度将会为 0. 文本为一个空格的 Label 也会产生同样的结果. 你需要使用不换行空格"
"(non-breaking space)字符, 可以是 <literal>&amp;nbsp;</literal> 或 "
"<literal>&amp;#160;</literal>:"

#. Tag: programlisting
#: chapter-components.xml:2339
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[layout.addComponent(new Label(\"&nbsp;\", "
"ContentMode.HTML));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2341
#, no-c-format
msgid ""
"Using the <parameter>ContentMode.PREFORMATTED</parameter> mode has the same "
"effect; preformatted spaces do not collapse in a vertical layout. In a "
"<classname>HorizontalLayout</classname>, the width of a space character may "
"be unpredictable if the label font is proportional, so you can use the "
"preformatted mode to add em-width wide spaces."
msgstr ""
"使用 <parameter>ContentMode.PREFORMATTED</parameter> 模式也有同样效果; 格式化"
"文本中的空格在垂直布局中不会消失. 在 <classname>HorizontalLayout</classname> "
"中, 如果 Label 使用比例字体(proportional font), 则空白字符的宽度将是不可预测"
"的, 你可以使用格式化文本内容模式来添加 em 单位宽度的空白."

#. Tag: para
#: chapter-components.xml:2349
#, no-c-format
msgid ""
"If you want a gap that has adjustable width or height, you can use an empty "
"label if you specify a height or width for it. For example, to create "
"vertical space in a <classname>VerticalLayout</classname>:"
msgstr ""
"如果你希望空白区域拥有可调节的宽度或高度, 那么你可以使用空白 Label, 并指定它"
"的宽度或高度. 比如, 如果要在 <classname>VerticalLayout</classname> 内创建垂直"
"空白的话:"

#. Tag: programlisting
#: chapter-components.xml:2355
#, no-c-format
msgid ""
"<![CDATA[Label gap = new Label();\n"
"gap.setHeight(\"1em\");\n"
"verticalLayout.addComponent(gap);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2357
#, no-c-format
msgid ""
"You can make a flexible expanding spacer by having a relatively sized empty "
"label with <literal>100%</literal> height or width and setting the label as "
"expanding in the layout."
msgstr ""
"你可以创造一个灵活扩展的空白区域, 方法是使用一个空白 Label, 设置它的高度或宽"
"度为相对大小 <literal>100%</literal>, 并将它设置为随布局一起扩展."

#. Tag: programlisting
#: chapter-components.xml:2363
#, no-c-format
msgid ""
"<![CDATA[// A wide component bar\n"
"HorizontalLayout horizontal = new HorizontalLayout();\n"
"horizontal.setWidth(\"100%\");\n"
"\n"
"// Have a component before the gap (a collapsing cell)\n"
"Button button1 = new Button(\"I'm on the left\");\n"
"horizontal.addComponent(button1);\n"
"\n"
"// An expanding gap spacer\n"
"Label expandingGap = new Label();\n"
"expandingGap.setWidth(\"100%\");\n"
"horizontal.addComponent(expandingGap);\n"
"horizontal.setExpandRatio(expandingGap, 1.0f);\n"
"\n"
"// A component after the gap (a collapsing cell)\n"
"Button button2 = new Button(\"I'm on the right\");\n"
"horizontal.addComponent(button2);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:2367 chapter-components.xml:2623
#, no-c-format
msgid "Data Binding"
msgstr "数据绑定"

#. Tag: para
#: chapter-components.xml:2369
#, no-c-format
msgid ""
"While <classname>Label</classname> is not a field component, it is a "
"<interfacename>Property.Viewer</interfacename> and can be bound to a "
"property data source, described in <xref linkend=\"datamodel.properties\"/>. "
"You can specify the data source either in the constructor or by the "
"<methodname>setPropertyDataSource()</methodname> method."
msgstr ""
"虽然 <classname>Label</classname> 不是一个 Field 组件, 但它是一个 "
"<interfacename>Property.Viewer</interfacename>, 可以绑定到 property 数据源, "
"详情请参见 <xref linkend=\"datamodel.properties\"/>. 你可以在构造函数中指定数"
"据源, 或使用 <methodname>setPropertyDataSource()</methodname> 方法."

#. Tag: programlisting
#: chapter-components.xml:2379
#, no-c-format
msgid ""
"<![CDATA[// Some property\n"
"ObjectProperty<String> property =\n"
"    new ObjectProperty<String>(\"some value\");\n"
"        \n"
"// Label that is bound to the property\n"
"Label label = new Label(property);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2381
#, no-c-format
msgid ""
"Further, as <classname>Label</classname> is a <interfacename>Property</"
"interfacename>, you can edit its value with a property editor, such as a "
"field:"
msgstr ""
"此外, <classname>Label</classname> 也是一个 <interfacename>Property</"
"interfacename>, 因此你可以使用属性编辑器来编辑它的值, 比如使用一个 Field:"

#. Tag: programlisting
#: chapter-components.xml:2388
#, no-c-format
msgid ""
"<![CDATA[Label label = new Label(\"some value\");\n"
"TextField editor = new TextField();\n"
"editor.setPropertyDataSource(label);\n"
"editor.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2390
#, no-c-format
msgid ""
"However, <classname>Label</classname> is <emphasis>not</emphasis> a "
"<interfacename>Property.Editor</interfacename>, so it is read-only when "
"bound to a data source. Therefore, you can not use <methodname>setValue()</"
"methodname> to set the value of a connected data source through a "
"<classname>Label</classname> nor bind the label to an editor field, in which "
"case writes would be delegated through the label."
msgstr ""
"但是, <classname>Label</classname> <emphasis>不是</emphasis> 一个 "
"<interfacename>Property.Editor</interfacename>, 因此它绑定到数据源之后, 将是"
"只读的. 因此, 你不能通过 <classname>Label</classname> 的 "
"<methodname>setValue()</methodname> 方法来设置绑定的数据源的值, 也不能将 "
"Label 绑定到一个编辑 Field, 这种情况下对值的写操作将被代理到 Label 之上."

#. Tag: programlisting
#: chapter-components.xml:2403
#, no-c-format
msgid ""
"<?dbfo-need height=\"3cm\" ?><![CDATA[.v-label { }\n"
"  pre { } /* In PREFORMATTED content mode */]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2405
#, no-c-format
msgid ""
"The <classname>Label</classname> component has a <literal>v-label</literal> "
"overall style. In the <parameter>PREFORMATTED</parameter> content mode, the "
"text is wrapped inside a <literal>&lt;pre&gt;</literal> element."
msgstr ""
"<classname>Label</classname> 组件的最外层样式为 <literal>v-label</literal>.  "
"在 <parameter>PREFORMATTED</parameter> 内容模式下, 文本将被包装在一个 "
"<literal>&lt;pre&gt;</literal> 元素之内."

#. Tag: classname
#: chapter-components.xml:2415
#, no-c-format
msgid "Link"
msgstr "Link"

#. Tag: para
#: chapter-components.xml:2417
#, no-c-format
msgid ""
"The <classname>Link</classname> component allows making hyperlinks. "
"References to locations are represented as resource objects, explained in "
"<xref linkend=\"application.resources\"/>. The <classname>Link</classname> "
"is a regular HTML hyperlink, that is, an <literal>&lt;a href&gt;</literal> "
"anchor element that is handled natively by the browser. Unlike when clicking "
"a <classname>Button</classname>, clicking a <classname>Link</classname> does "
"not cause an event on the server-side."
msgstr ""
"<classname>Link</classname> 组件可以创建超链接(hyperlink). 链接目标地址以资源"
"对象的方式表达, 详情请参见 <xref linkend=\"application.resources\"/>. "
"<classname>Link</classname> 是通常的 HTML 链接, 也就是一个由浏览器处理的 "
"<literal>&lt;a href&gt;</literal> 元素. 与点击 <classname>Button</classname> "
"不同, 点击 <classname>Link</classname> 不会在服务器端触发事件."

#. Tag: para
#: chapter-components.xml:2427
#, no-c-format
msgid ""
"Links to an arbitrary URL can be made by using an "
"<classname>ExternalResource</classname> as follows:"
msgstr ""
"指向任意 URL 的链接可以使用 <classname>ExternalResource</classname> 生成, 如"
"下例:"

#. Tag: programlisting
#: chapter-components.xml:2433
#, no-c-format
msgid ""
"<![CDATA[// Textual link\n"
"Link link = new Link(\"Click Me!\",\n"
"        new ExternalResource(\"http://vaadin.com/\"));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2435
#, no-c-format
msgid ""
"You can use <methodname>setIcon()</methodname> to make image links as "
"follows:"
msgstr ""
"你可以使用 <methodname>setIcon()</methodname> 方法来生成图片链接, 如下例:"

#. Tag: programlisting
#: chapter-components.xml:2439
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Image link\n"
"Link iconic = new Link(null,\n"
"        new ExternalResource(\"http://vaadin.com/\"));\n"
"iconic.setIcon(new ThemeResource(\"img/nicubunu_Chain.png\"));\n"
"\n"
"// Image + caption\n"
"Link combo = new Link(\"To appease both literal and visual\",\n"
"        new ExternalResource(\"http://vaadin.com/\"));\n"
"combo.setIcon(new ThemeResource(\"img/nicubunu_Chain.png\"));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2441
#, no-c-format
msgid ""
"The resulting links are shown in <xref linkend=\"figure.components.link.basic"
"\"/>. You could add a \"<literal>display: block</literal>\" style for the "
"icon element to place the caption below it."
msgstr ""
"上例的运行结果见 <xref linkend=\"figure.components.link.basic\"/>. 你可以对图"
"标元素添加一个 \"<literal>display: block</literal>\" 样式, 将标签放置到图标的"
"下方."

#. Tag: title
#: chapter-components.xml:2448
#, no-c-format
msgid "<classname>Link</classname> Example"
msgstr "<classname>Link</classname> 示例"

#. Tag: para
#: chapter-components.xml:2459
#, no-c-format
msgid ""
"With the simple constructor used in the above example, the resource is "
"opened in the current window. Using the constructor that takes the target "
"window as a parameter, or by setting the target window with "
"<methodname>setTargetName()</methodname>, you can open the resource in "
"another window, such as a popup browser window/tab. As the target name is an "
"HTML <literal>target</literal> string managed by the browser, the target can "
"be any window, including windows not managed by the application itself. You "
"can use the special underscored target names, such as <literal>_blank</"
"literal> to open the link to a new browser window or tab."
msgstr ""
"在上例中使用的简单构造方法, 会将链接对象资源在当前窗口中打开. 如果通过构造方"
"法参数指定, 或者通过 <methodname>setTargetName()</methodname> 方法来指定链接"
"的打开对象窗口, 你可以将链接对象资源在其他窗口中打开, 比如浏览器的弹出窗口/"
"TAB. 由于对象窗口名称是由浏览器管理的 HTML <literal>target</literal> 字符串, "
"因此对象窗口可以是任何窗口, 包括不被应用程序管理的窗口. 你还可以使用带下划线"
"的特殊窗口名, 比如 <literal>_blank</literal>, 可以在新的浏览器窗口或 TAB 中打"
"开链接."

#. Tag: programlisting
#: chapter-components.xml:2472
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Hyperlink to a given URL\n"
"Link link = new Link(\"Take me a away to a faraway land\",\n"
"        new ExternalResource(\"http://vaadin.com/\"));\n"
"\n"
"// Open the URL in a new window/tab\n"
"link.setTargetName(\"_blank\");\n"
"        \n"
"// Indicate visually that it opens in a new window/tab\n"
"link.setIcon(new ThemeResource(\"icons/external-link.png\"));\n"
"link.addStyleName(\"icon-after-caption\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2474
#, no-c-format
msgid ""
"Normally, the link icon is before the caption. You can have it right of the "
"caption by reversing the text direction in the containing element."
msgstr ""
"链接的图标通常在标题之前. 你可以让它出现在标题右侧, 方法是在 HTML 容器元素中"
"颠倒文字方向."

#. Tag: programlisting
#: chapter-components.xml:2479
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/* Position icon right of the link caption. */\n"
".icon-after-caption {\n"
"    direction: rtl;\n"
"}\n"
"/* Add some padding around the icon. */\n"
".icon-after-caption .v-icon {\n"
"    padding: 0 3px;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2481
#, no-c-format
msgid ""
"The resulting link is shown in <xref linkend=\"figure.components.link.new-"
"window\"/>."
msgstr ""
"上面例子的运行结果见 <xref linkend=\"figure.components.link.new-window\"/>."

#. Tag: title
#: chapter-components.xml:2486
#, no-c-format
msgid "Link That Opens a New Window"
msgstr "打开新窗口的链接"

#. Tag: para
#: chapter-components.xml:2497
#, no-c-format
msgid ""
"With the <literal>_blank</literal> target, a normal new browser window is "
"opened. If you wish to open it in a popup window (or tab), you need to give "
"a size for the window with <methodname>setTargetWidth()</methodname> and "
"<methodname>setTargetHeight()</methodname>. You can control the window "
"border style with <methodname>setTargetBorder()</methodname>, which takes "
"any of the defined border styles <parameter>TARGET_BORDER_DEFAULT</"
"parameter>, <parameter>TARGET_BORDER_MINIMAL</parameter>, and "
"<parameter>TARGET_BORDER_NONE</parameter>. The exact result depends on the "
"browser."
msgstr ""
"使用目标窗口名 <literal>_blank</literal>, 会打开一个通常的浏览器新窗口. 如果"
"你希望打开一个弹出窗口(或 TAB), 你需要使用<methodname>setTargetWidth()</"
"methodname> 和 <methodname>setTargetHeight()</methodname>方法指定窗口的大小. "
"你可以使用<methodname>setTargetBorder()</methodname>方法控制窗口的边框风格, "
"这个方法的参数可以是以下窗口边框风格: <parameter>TARGET_BORDER_DEFAULT</"
"parameter>, <parameter>TARGET_BORDER_MINIMAL</parameter>, 以及 "
"<parameter>TARGET_BORDER_NONE</parameter>. 但最终的运行结果由浏览器决定."

#. Tag: programlisting
#: chapter-components.xml:2509
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Open the URL in a popup\n"
"link.setTargetName(\"_blank\");\n"
"link.setTargetBorder(Link.TARGET_BORDER_NONE);\n"
"link.setTargetHeight(300);\n"
"link.setTargetWidth(400);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2513
#, no-c-format
msgid ""
"In addition to the <classname>Link</classname> component, Vaadin allows "
"alternative ways to make hyperlinks. The <classname>Button</classname> "
"component has a <parameter>Reindeer.BUTTON_LINK</parameter> style name that "
"makes it look like a hyperlink, while handling clicks in a server-side click "
"listener instead of in the browser. Also, you can make hyperlinks (or any "
"other HTML) in a <classname>Label</classname> in HTML content mode."
msgstr ""
"除 <classname>Link</classname> 组件外, Vaadin 还允许其他方式创建超链接. "
"<classname>Button</classname> 组件有一种 <parameter>Reindeer.BUTTON_LINK</"
"parameter> 样式, 使得按钮的外观类似于超链接, 但它可以在服务器端的监听器中处理"
"点击事件, 而不是由浏览器自行处理. 此外, 你还可以使用 HTML 内容模式的 "
"<classname>Label</classname> 来创建超链接(或者其他的任何 HTML 内容) ."

#. Tag: programlisting
#: chapter-components.xml:2525
#, no-c-format
msgid ""
"<?dbfo-need height=\"3cm\" ?><![CDATA[.v-link { }\n"
"  a { }\n"
"    .v-icon {}\n"
"    span {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2527
#, no-c-format
msgid ""
"The overall style for the <classname>Link</classname> component is "
"<literal>v-link</literal>. The root element contains the <literal>&lt;a "
"href&gt;</literal> hyperlink anchor. Inside the anchor are the icon, with "
"<literal>v-icon</literal> style, and the caption in a text span."
msgstr ""
"<classname>Link</classname> 组件的最外层样式为 <literal>v-link</literal>. 它"
"是包含 <literal>&lt;a href&gt;</literal> 超链接元素的根元素. 在链接之内是图"
"标, 带有 <literal>v-icon</literal> 样式, 以及标题, 在 span 内."

#. Tag: para
#: chapter-components.xml:2534
#, no-c-format
msgid ""
"Hyperlink anchors have a number of <emphasis>pseudo-classes</emphasis> that "
"are active at different times. An unvisited link has <literal>a:link</"
"literal> class and a visited link <literal>a:visited</literal>. When the "
"mouse pointer hovers over the link, it will have <varname>a:hover</varname>, "
"and when the mouse button is being pressed over the link, the <literal>a:"
"active</literal> class. When combining the pseudo-classes in a selector, "
"please notice that <literal>a:hover</literal> must come after an <literal>a:"
"link</literal> and <literal>a:visited</literal>, and <literal>a:active</"
"literal> after the <literal>a:hover</literal>."
msgstr ""
"超链接有大量的 <emphasis>伪类(pseudo-class)</emphasis>, 分别在不同的场合有"
"效. 未访问过的链接带有 <literal>a:link</literal> 类, 已访问过的链接则带有 "
"<literal>a:visited</literal>. 鼠标指针移动到链接上方时, 链接将带有 "
"<varname>a:hover</varname> 类, 当鼠标指针在链接上方按下时, 链接将带有 "
"<literal>a:active</literal> 类. 如果在 CSS 选择器中组合使用这些伪类时, 请注"
"意 <literal>a:hover</literal> 必须出现在 <literal>a:link</literal> 和 "
"<literal>a:visited</literal> 之后, <literal>a:active</literal> 必须出现在 "
"<literal>a:hover</literal> 之后."

#. Tag: classname
#: chapter-components.xml:2550 chapter-components.xml:2553
#, no-c-format
msgid "TextField"
msgstr "TextField"

#. Tag: para
#: chapter-components.xml:2556
#, no-c-format
msgid ""
"<classname>TextField</classname> is one of the most commonly used user "
"interface components. It is a <classname>Field</classname> component that "
"allows entering textual values using keyboard."
msgstr ""
"<classname>TextField</classname> 是最常用的 UI 组件之一. 它是 "
"<classname>Field</classname> 组件的一种, 可通过键盘来输入文本值."

#. Tag: para
#: chapter-components.xml:2562
#, no-c-format
msgid "The following example creates a simple text field:"
msgstr "下面的例子创建一个简单的 TextField:"

#. Tag: programlisting
#: chapter-components.xml:2568
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a text field\n"
"TextField tf = new TextField(\"A Field\");\n"
"        \n"
"// Put some initial content in it\n"
"tf.setValue(\"Stuff in the field\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2570
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.textfield.basic\"/>."
msgstr "运行结果参见 <xref linkend=\"figure.components.textfield.basic\"/>."

#. Tag: title
#: chapter-components.xml:2575
#, no-c-format
msgid "<classname>TextField</classname> Example"
msgstr ""

#. Tag: para
#: chapter-components.xml:2586
#, no-c-format
msgid ""
"Value changes are handled with a <classname>Property.ValueChangeListener</"
"classname>, as in most other fields. The value can be acquired with "
"<methodname>getValue()</methodname> directly from the text field, as is done "
"in the example below, or from the property reference of the event."
msgstr ""
"与其他大多数 Field 组件一样, 值的变化由 <classname>Property."
"ValueChangeListener</classname> 监听器处理. 值可以通过 TextField 的 "
"<methodname>getValue()</methodname> 方法直接取得, 如下面的例子所示, 也可以通"
"过事件绑定的 property 得到. "

#. Tag: programlisting
#: chapter-components.xml:2596
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Handle changes in the value\n"
"tf.addValueChangeListener(new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        // Assuming that the value type is a String\n"
"        String value = (String) event.getProperty().getValue();\n"
"\n"
"        // Do something with the value\n"
"        Notification.show(\"Value is: \" + value);\n"
"    }\n"
"});\n"
"\n"
"// Fire value changes immediately when the field loses focus\n"
"tf.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2598
#, no-c-format
msgid ""
"As with other event listeners, you can use lambda expression with one "
"parameter to handle the events in Java 8."
msgstr ""
"和其他的事件监听器一样, 在 Java 8 中, 你可以使用单个参数的 lambda 表达式来处"
"理事件."

#. Tag: para
#: chapter-components.xml:2603
#, no-c-format
msgid ""
"Much of the API of <classname>TextField</classname> is defined in "
"<classname>AbstractTextField</classname>, which allows different kinds of "
"text input fields, such as rich text editors, which do not share all the "
"features of the single-line text fields."
msgstr ""
"<classname>TextField</classname> 的大多数 API 定义"
"在 <classname>AbstractTextField</classname> 中, 从这个类可以继承出各种不同类"
"型的文本输入组件, 比如 富文本编辑器, 这些文本输入组件的功能与单行文本框并于完"
"全相同."

#. Tag: title
#: chapter-components.xml:2611
#, no-c-format
msgid "Text Field Class Relationships"
msgstr "文本编辑框的类关系"

#. Tag: para
#: chapter-components.xml:2626
#, no-c-format
msgid ""
"<classname>TextField</classname> edits <classname>String</classname> values, "
"but you can bind it to any property type that has a proper converter, as "
"described in <xref linkend=\"datamodel.properties.converter\"/>."
msgstr ""
"<classname>TextField</classname> 用于编辑 <classname>String</classname> 类型"
"值, 但你可以将它绑定到任意的属性类型上, 只要存在适当的转换器, 详情请参见 "
"<xref linkend=\"datamodel.properties.converter\"/>."

#. Tag: programlisting
#: chapter-components.xml:2635
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an initial data model. As Double is "
"unmodificable and\n"
"// doesn't support assignment from String, the object is\n"
"// reconstructed in the wrapper when the value is changed.\n"
"Double trouble = 42.0;\n"
"        \n"
"// Wrap it in a property data source\n"
"final ObjectProperty<Double> property =\n"
"    new ObjectProperty<Double>(trouble);\n"
"        \n"
"// Create a text field bound to it\n"
"// (StringToDoubleConverter is used automatically)\n"
"TextField tf = new TextField(\"The Answer\", property);\n"
"tf.setImmediate(true);\n"
"\n"
"// Show that the value is really written back to the\n"
"// data source when edited by user.\n"
"Label feedback = new Label(property);\n"
"feedback.setCaption(\"The Value\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2637
#, no-c-format
msgid ""
"When you put a <classname>Table</classname> in editable mode or create "
"fields with a <classname>FieldGroup</classname>, the "
"<classname>DefaultFieldFactory</classname> creates a <classname>TextField</"
"classname> for almost every property type by default. You often need to make "
"a custom factory to customize the creation and to set the field tooltip, "
"validation, formatting, and so on."
msgstr ""
"当你将一个 <classname>Table</classname> 设为可编辑模式时, 或使用 "
"<classname>FieldGroup</classname>创建 Field 时, "
"<classname>DefaultFieldFactory</classname> 默认就会创建 "
"<classname>TextField</classname> 用作大多数属性类型的编辑器. 你经常会需要编写"
"一个自定义的 Factory, 以便自定义 TextField 的创建过程, 设置 Field 提示信息, "
"校验, 格式, 等等."

#. Tag: para
#: chapter-components.xml:2646
#, no-c-format
msgid ""
"See <xref linkend=\"datamodel\"/> for more details on data binding, field "
"factories for <classname>Table</classname> in <xref linkend=\"components."
"table.editing\"/>, and <xref linkend=\"datamodel.itembinding\"/> regarding "
"forms."
msgstr ""
"关于数据绑定, 详情请参见 <xref linkend=\"datamodel\"/>, 关于 "
"<classname>Table</classname> 的 Field Factory, 详情请参见 <xref linkend="
"\"components.table.editing\"/>, 关于 Form, 详情请参见 <xref linkend="
"\"datamodel.itembinding\"/>."

#. Tag: book-example
#: chapter-components.xml:2653
#, no-c-format
msgid "Bean Binding"
msgstr "绑定到 Bean"

#. Tag: title
#: chapter-components.xml:2659
#, no-c-format
msgid "String Length"
msgstr "字符串长度"

#. Tag: para
#: chapter-components.xml:2661
#, no-c-format
msgid ""
"The <methodname>setMaxLength()</methodname> method sets the maximum length "
"of the input string so that the browser prevents the user from entering a "
"longer one. As a security feature, the input value is automatically "
"truncated on the server-side, as the maximum length setting could be "
"bypassed on the client-side. The maximum length property is defined at "
"<classname>AbstractTextField</classname> level."
msgstr ""
"<methodname>setMaxLength()</methodname> 方法可以设置字符串输入的最大长度, 浏"
"览器将禁止用户输入更长的文字. 作为一种安全功能, 输入的字符串会在服务器端自动"
"截断, 因为最大长度限制在客户端有可能被恶意用户绕过. 最大长度属性定义在 "
"<classname>AbstractTextField</classname> 中."

#. Tag: para
#: chapter-components.xml:2670
#, no-c-format
msgid ""
"Notice that the maximum length setting does not affect the width of the "
"field. You can set the width with <methodname>setWidth()</methodname>, as "
"with other components. Using <emphasis>em</emphasis> widths is recommended "
"to better approximate the proper width in relation to the size of the used "
"font. There is no standard way in HTML for setting the width exactly to a "
"number of letters (in a monospaced font). You can trick your way around this "
"restriction by putting the text field in an undefined-width "
"<classname>VerticalLayout</classname> together with an undefined-width "
"<classname>Label</classname> that contains a sample text, and setting the "
"width of the text field as 100%. The layout will get its width from the "
"label, and the text field will use that."
msgstr ""
"注意, 最大长度设置不会影响 Field 的宽度. 与其他组件一样, 你可以使用 "
"<methodname>setWidth()</methodname> 方法来设置宽度. 建议使用 <emphasis>em</"
"emphasis> 单位的宽度, 因为这个单位与当前使用的字体相关, 显示效果较好. 在 "
"HTML 中没有标准的方法可以将宽度设置为恰好等于多少个字母 (使用等宽字体时). 你"
"可以绕过这个限制, 方法是将 TextField 放在一个未定义宽度的 "
"<classname>VerticalLayout</classname> 内, 同时再放一个未定义宽度的 "
"<classname>Label</classname>, Label 中包含一串示例文本, 然后将 TextField 的宽"
"度设置为 100%. 布局管理器将根据 Label 的宽度决定自己的宽度, 然后 TextField 将"
"与布局管理器的宽度相同."

#. Tag: book-example
#: chapter-components.xml:2684
#, no-c-format
msgid "Fitting TextField width to fixed input length"
msgstr "将 TextField 宽度调整为固定的输入长度"

#. Tag: title
#: chapter-components.xml:2690
#, no-c-format
msgid "Handling Null Values"
msgstr "处理 Null 值"

#. Tag: primary
#: chapter-components.xml:2693
#, no-c-format
msgid "Null representation"
msgstr "Null 值的表现"

#. Tag: methodname
#: chapter-components.xml:2697
#, no-c-format
msgid "setNullRepresentation()"
msgstr ""

#. Tag: para
#: chapter-components.xml:2697
#, no-c-format
msgid ""
"As with any field, the value of a <classname>TextField</classname> can be "
"set as <parameter>null</parameter>. This occurs most commonly when you "
"create a new field without setting a value for it or bind the field value to "
"a data source that allows null values. In such case, you might want to show "
"a special value that stands for the null value. You can set the null "
"representation with the <methodname>setNullRepresentation()</methodname> "
"method. Most typically, you use an empty string for the null representation, "
"unless you want to differentiate from a string that is explicitly empty. The "
"default null representation is \"<literal>null</literal>\", which "
"essentially warns that you may have forgotten to initialize your data "
"objects properly."
msgstr ""
"与任何一种 Field 相同, <classname>TextField</classname> 的值可以被设置为 "
"<parameter>null</parameter>. 如果你创建了一个新的 Field 但没有为它设置值, 或"
"者将 Field 值绑定到一个允许 Null 值的数据源, 就会发生这样的情况. 这种情况下, "
"你可能希望为 Null 值显示某个特别的值. 你可以使用"
"<methodname>setNullRepresentation()</methodname> 方法设置 Null 值的表现. 一般"
"可以用空字符串作为 Null 值的表现, 除非你希望将 Null 值与空字符串明确地区分"
"开. 默认的 Null 值表现是 \"<literal>null</literal>\", 这个表现的本来目的是提"
"示你有可能忘记了正确地初始化数据对象."

#. Tag: methodname
#: chapter-components.xml:2713
#, no-c-format
msgid "setNullSettingAllowed()"
msgstr ""

#. Tag: para
#: chapter-components.xml:2713
#, no-c-format
msgid ""
"The <methodname>setNullSettingAllowed()</methodname> controls whether the "
"user can actually input a null value by using the null value representation. "
"If the setting is <literal>false</literal>, which is the default, inputting "
"the null value representation string sets the value as the literal value of "
"the string, not null. This default assumption is a safeguard for data "
"sources that may not allow null values."
msgstr ""
"<methodname>setNullSettingAllowed()</methodname> 方法控制用户能否使用 Null 值"
"表现来输入 Null 值. 如果设定为 <literal>false</literal>, 默认值就是如此, 那么"
"用户输入的 Null 值表现字符串会被当作真实的字符串输入, 而不会被识别为 Null "
"值. 这种默认假设是一种安全措施, 因为数据源可能不接受 Null 值."

#. Tag: programlisting
#: chapter-components.xml:2725
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Have a property with null value\n"
"ObjectProperty<Double> dataModel =\n"
"    new ObjectProperty<Double>(new Double(0.0));\n"
"dataModel.setValue(null); // Have to set it null here\n"
"\n"
"// Create a text field bound to the null data\n"
"TextField tf = new TextField(\"Field Energy (J)\", dataModel);\n"
"tf.setNullRepresentation(\"-- null-point --\");\n"
"\n"
"// Allow user to input the null value by its representation\n"
"tf.setNullSettingAllowed(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2727
#, no-c-format
msgid ""
"The <classname>Label</classname>, which is bound to the value of the "
"<classname>TextField</classname>, displays a null value as empty. The "
"resulting user interface is shown in <xref linkend=\"figure.components."
"textfield.nullvalues\"/>."
msgstr ""
"上例中的 <classname>Label</classname>, 绑定到 <classname>TextField</"
"classname> 的值上, 讲 Null 值显示为空字符串. 上例的运行结果参见 <xref "
"linkend=\"figure.components.textfield.nullvalues\"/>."

#. Tag: title
#: chapter-components.xml:2735
#, no-c-format
msgid "Null Value Representation"
msgstr "Null 值的表现"

#. Tag: title
#: chapter-components.xml:2758 chapter-components.xml:2791
#, no-c-format
msgid "Text Change Events"
msgstr "文本变更事件"

#. Tag: classname
#: chapter-components.xml:2761
#, no-c-format
msgid "Text change events"
msgstr "文本变更事件"

#. Tag: para
#: chapter-components.xml:2764
#, no-c-format
msgid ""
"Often you want to receive a change event immediately when the text field "
"value changes. The <emphasis>immediate</emphasis> mode is not literally "
"immediate, as the changes are transmitted only after the field loses focus. "
"In the other extreme, using keyboard events for every keypress would make "
"typing unbearably slow and also processing the keypresses is too complicated "
"for most purposes. <emphasis>Text change events</emphasis> are transmitted "
"asynchronously soon after typing and do not block typing while an event is "
"being processed."
msgstr ""
"当 TextField 值发生变更时, 你通常希望立即收到一个变更事件. "
"<emphasis>immediate</emphasis> 模式并不是字面意思那样的立即模式, 因为仅在 "
"Field 失去输入焦点后才会发生变更事件. 另一种极端情况是, 对每一次按键都使用键"
"盘事件, 但这会让输入过程慢到不可忍受, 而且对于大多数目的来说, 处理每个按键的"
"事件也太过于复杂. <emphasis>文本变更事件</emphasis> 会在输入发生后异步的发送"
"到服务器, 事件处理过程不会阻碍客户端的输入过程."

#. Tag: classname
#: chapter-components.xml:2776
#, no-c-format
msgid "TextChangeListener"
msgstr ""

#. Tag: para
#: chapter-components.xml:2776
#, no-c-format
msgid ""
"Text change events are received with a <classname>TextChangeListener</"
"classname>, as is done in the following example that demonstrates how to "
"create a text length counter:"
msgstr ""
"文本变更事件通过 <classname>TextChangeListener</classname> 监听器来接收, 如下"
"例所示, 我们演示如何实现一个文字长度计数器:"

#. Tag: programlisting
#: chapter-components.xml:2784
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Text field with maximum length\n"
"final TextField tf = new TextField(\"My Eventful Field\");\n"
"tf.setValue(\"Initial content\");\n"
"tf.setMaxLength(20);\n"
"\n"
"// Counter for input length\n"
"final Label counter = new Label();\n"
"counter.setValue(tf.getValue().length() +\n"
"                 \" of \" + tf.getMaxLength());\n"
"\n"
"// Display the current length interactively in the counter\n"
"tf.addTextChangeListener(new TextChangeListener() {\n"
"    public void textChange(TextChangeEvent event) {\n"
"        int len = event.getText().length();\n"
"        counter.setValue(len + \" of \" + tf.getMaxLength());\n"
"    }\n"
"});\n"
"\n"
"// The lazy mode is actually the default\n"
"tf.setTextChangeEventMode(TextChangeEventMode.LAZY);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2786
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.textfield."
"textchangeevents\"/>."
msgstr ""
"运行结果参见 <xref linkend=\"figure.components.textfield.textchangeevents\"/"
">."

#. Tag: para
#: chapter-components.xml:2802
#, no-c-format
msgid ""
"The <emphasis>text change event mode</emphasis> defines how quickly the "
"changes are transmitted to the server and cause a server-side event. Lazier "
"change events allow sending larger changes in one event if the user is "
"typing fast, thereby reducing server requests."
msgstr ""
"<emphasis>文本变更事件的模式</emphasis> 决定了变更以什么样的速度传送到服务器"
"并触发服务器端事件. 当用户输入速度很快时, 比较慢速的变更事件可以一次性传输比"
"较大的变更, 因此可以减少对服务器的请求次数."

#. Tag: classname
#: chapter-components.xml:2810
#, no-c-format
msgid "TextChangeEventMode"
msgstr ""

#. Tag: para
#: chapter-components.xml:2810
#, no-c-format
msgid ""
"You can set the text change event mode of a <classname>TextField</classname> "
"with <methodname>setTextChangeEventMode()</methodname>. The allowed modes "
"are defined in <classname>TextChangeEventMode</classname> enum and are as "
"follows:"
msgstr ""
"你可以使用 <classname>TextField</classname> 的 "
"<methodname>setTextChangeEventMode()</methodname>方法设置它的文本变更事件模"
"式. 合法的模式定义在 <classname>TextChangeEventMode</classname> 枚举型中, 说"
"明如下:"

#. Tag: term
#: chapter-components.xml:2821
#, no-c-format
msgid "<parameter>TextChangeEventMode.LAZY</parameter> (default)"
msgstr "<parameter>TextChangeEventMode.LAZY</parameter> (默认)"

#. Tag: para
#: chapter-components.xml:2823
#, no-c-format
msgid ""
"An event is triggered when there is a pause in editing the text. The length "
"of the pause can be modified with <methodname>setInputEventTimeout()</"
"methodname>. As with the <parameter>TIMEOUT</parameter> mode, a text change "
"event is forced before a possible <classname>ValueChangeEvent</classname>, "
"even if the user did not keep a pause while entering the text."
msgstr ""
"当文本编辑发生暂停时触发事件. 暂停的长度可以通过 "
"<methodname>setInputEventTimeout()</methodname> 方法设置. 与 "
"<parameter>TIMEOUT</parameter> 模式一样, 在 <classname>ValueChangeEvent</"
"classname> 事件之前会强制发生一个文本变更事件, 即使用户在输入文本时没有出现暂"
"停."

#. Tag: para
#: chapter-components.xml:2833
#, no-c-format
msgid "This is the default mode."
msgstr "这是默认模式."

#. Tag: parameter
#: chapter-components.xml:2839
#, no-c-format
msgid "TextChangeEventMode.TIMEOUT"
msgstr ""

#. Tag: para
#: chapter-components.xml:2841
#, no-c-format
msgid ""
"A text change in the user interface causes the event to be communicated to "
"the application after a timeout period. If more changes are made during this "
"period, the event sent to the server-side includes the changes made up to "
"the last change. The length of the timeout can be set with "
"<methodname>setInputEventTimeout()</methodname>."
msgstr ""
"UI 中的文本变更, 会在一个 TIMEOUT 期间之后发送事件到应用程序中. 如果在这个 "
"TIMEOUT 期间之内又发生了更多的变更, 发送给服务器端的事件会包含最新的变更. "
"TIMEOUT 期间的长度可以使用 <methodname>setInputEventTimeout()</methodname> 方"
"法设置."

#. Tag: para
#: chapter-components.xml:2850
#, no-c-format
msgid ""
"If a <classname>ValueChangeEvent</classname> would occur before the timeout "
"period, a <classname>TextChangeEvent</classname> is triggered before it, on "
"the condition that the text content has changed since the previous "
"<classname>TextChangeEvent</classname>."
msgstr ""
"如果 <classname>ValueChangeEvent</classname> 事件在 TIMEOUT 期间之前发生,  并"
"且在前一次 <classname>TextChangeEvent</classname> 事件之后发生了文本变更, 那"
"么在 ValueChangeEvent 事件之前会触发<classname>TextChangeEvent</classname> 事"
"件."

#. Tag: parameter
#: chapter-components.xml:2860
#, no-c-format
msgid "TextChangeEventMode.EAGER"
msgstr ""

#. Tag: para
#: chapter-components.xml:2862
#, no-c-format
msgid ""
"An event is triggered immediately for every change in the text content, "
"typically caused by a key press. The requests are separate and are processed "
"sequentially one after another. Change events are nevertheless communicated "
"asynchronously to the server, so further input can be typed while event "
"requests are being processed."
msgstr ""
"每当文本内容发生变更(通常由键盘击键导致)时, 事件都会立刻触发. 多个事件会分隔"
"开, 并按顺序逐个处理. 但事件是异步传输到服务器的, 因此在事件的处理过程中还可"
"以继续输入."

#. Tag: programlisting
#: chapter-components.xml:2880 chapter-components.xml:3059
#, no-c-format
msgid "<![CDATA[.v-textfield { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2882
#, no-c-format
msgid ""
"The HTML structure of <classname>TextField</classname> is extremely simple, "
"consisting only of an element with the <literal>v-textfield</literal> style."
msgstr ""
"<classname>TextField</classname> 的 HTML 结构非常简单, 只包含一个带有 "
"<literal>v-textfield</literal> 样式的元素."

#. Tag: para
#: chapter-components.xml:2887
#, no-c-format
msgid "For example, the following custom style uses dashed border:"
msgstr "比如, 下面的自定义风格为文本输入框使用虚线边框:"

#. Tag: programlisting
#: chapter-components.xml:2893
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[.v-textfield-dashing {\n"
"    border:     thin dashed;\n"
"    background: white; /* Has shading image by default */\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2895
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.textfield.css\"/>."
msgstr "运行结果参见 <xref linkend=\"figure.components.textfield.css\"/>."

#. Tag: title
#: chapter-components.xml:2900
#, no-c-format
msgid "Styling TextField with CSS"
msgstr "使用 CSS 控制 TextField 样式"

#. Tag: para
#: chapter-components.xml:2911
#, no-c-format
msgid ""
"The style name for <classname>TextField</classname> is also used in several "
"components that contain a text input field, even if the text input is not an "
"actual <classname>TextField</classname>. This ensures that the style of "
"different text input boxes is similar."
msgstr ""
"<classname>TextField</classname> 使用的样式名, 也被其他几种含有文本输入框的组"
"件使用, 即便这些文本输入框实际上不是 <classname>TextField</classname>. 这一点"
"保证不同的文本输入框使用类似的样式."

#. Tag: classname
#: chapter-components.xml:2923
#, no-c-format
msgid "TextArea"
msgstr "TextArea"

#. Tag: para
#: chapter-components.xml:2925
#, no-c-format
msgid ""
"<classname>TextArea</classname> is a multi-line version of the "
"<classname>TextField</classname> component described in <xref linkend="
"\"components.textfield\"/>."
msgstr ""
"<classname>TextArea</classname> 是 <classname>TextField</classname> 组件的多"
"行版本,  TextField 参见 <xref linkend=\"components.textfield\"/>."

#. Tag: para
#: chapter-components.xml:2931
#, no-c-format
msgid "The following example creates a simple text area:"
msgstr "下例创建一个简单的 TextArea:"

#. Tag: programlisting
#: chapter-components.xml:2937
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create the area\n"
"TextArea area = new TextArea(\"Big Area\");\n"
"        \n"
"// Put some content in it\n"
"area.setValue(\"A row\\n\"+\n"
"              \"Another row\\n\"+\n"
"              \"Yet another row\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2939
#, no-c-format
msgid "The result is shown in <xref linkend=\"figure.components.textarea\"/>."
msgstr "运行结果参见 <xref linkend=\"figure.components.textarea\"/>."

#. Tag: title
#: chapter-components.xml:2944
#, no-c-format
msgid "<classname>TextArea</classname> Example"
msgstr "<classname>TextArea</classname> 示例"

#. Tag: para
#: chapter-components.xml:2955
#, no-c-format
msgid ""
"You can set the number of visible rows with <methodname>setRows()</"
"methodname> or use the regular <methodname>setHeight()</methodname> to "
"define the height in other units. If the actual number of rows exceeds the "
"number, a vertical scrollbar will appear. Setting the height with "
"<methodname>setRows()</methodname> leaves space for a horizontal scrollbar, "
"so the actual number of visible rows may be one higher if the scrollbar is "
"not visible."
msgstr ""
"你可以使用 <methodname>setRows()</methodname> 方法设置可见的行数, 也可以使用"
"通常的 <methodname>setHeight()</methodname> 方法以其他单位来控制高度. 如果内"
"容的行数超过了可见行数, 会出现垂直滚动条. 使用 <methodname>setRows()</"
"methodname> 方法设置高度会为水平滚动条留下空间, 因此当水平滚动条不出现时, 实"
"际的可见行数可能会比设定值高一行."

#. Tag: para
#: chapter-components.xml:2965
#, no-c-format
msgid ""
"You can set the width with the regular <methodname>setWidth()</methodname> "
"method. Setting the size with the <emphasis>em</emphasis> unit, which is "
"relative to the used font size, is recommended."
msgstr ""
"你可以使用通常的 <methodname>setWidth()</methodname> 方法来设置宽度. 推荐使"
"用 <emphasis>em</emphasis> 单位来设置尺寸, 这个单位与当前使用的字体相关."

#. Tag: title
#: chapter-components.xml:2972
#, no-c-format
msgid "Word Wrap"
msgstr "单词折行"

#. Tag: para
#: chapter-components.xml:2974
#, no-c-format
msgid ""
"The <methodname>setWordwrap()</methodname> sets whether long lines are "
"wrapped (<literal>true</literal> - default) when the line length reaches the "
"width of the writing area. If the word wrap is disabled (<literal>false</"
"literal>), a vertical scrollbar will appear instead. The word wrap is only a "
"visual feature and wrapping a long line does not insert line break "
"characters in the field value; shortening a wrapped line will undo the "
"wrapping."
msgstr ""
"<methodname>setWordwrap()</methodname> 方法控制当行的长度达到表示区域最大宽度"
"时, 长的行是否折行表示(默认设定为 <literal>true</literal>). 如果禁止折行"
"(<literal>false</literal>), 则会出现垂直滚动条(译注: 原文如此, 似乎应该是水平"
"滚动条才对). 折行显示只是一种视觉上的效果, 长行的折行不会在 Field 值中插入换"
"行符; 如果将被折行显示的内容变短, 就可以看到折行效果消失了."

#. Tag: programlisting
#: chapter-components.xml:2986
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[TextArea area1 = new TextArea(\"Wrapping\");\n"
"area1.setWordwrap(true); // The default\n"
"area1.setValue(\"A quick brown fox jumps over the lazy dog\");\n"
"\n"
"TextArea area2 = new TextArea(\"Nonwrapping\");\n"
"area2.setWordwrap(false);\n"
"area2.setValue(\"Victor jagt zw&ouml;lf Boxk&auml;mpfer quer \"+\n"
"               \"&uuml;ber den Sylter Deich\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:2988
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.textarea.wordwrap\"/"
">."
msgstr "运行结果参见 <xref linkend=\"figure.components.textarea.wordwrap\"/>."

#. Tag: title
#: chapter-components.xml:2993
#, no-c-format
msgid "Word Wrap in <classname>TextArea</classname>"
msgstr "<classname>TextArea</classname> 中的单词折行"

#. Tag: programlisting
#: chapter-components.xml:3008
#, no-c-format
msgid "<![CDATA[.v-textarea { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3010
#, no-c-format
msgid ""
"The HTML structure of <classname>TextArea</classname> is extremely simple, "
"consisting only of an element with <literal>v-textarea</literal> style."
msgstr ""
"<classname>TextArea</classname> 的 HTML 结构非常简单, 只包含一个带有 "
"<literal>v-textarea</literal> 样式的元素."

#. Tag: book-example
#: chapter-components.xml:3015 chapter-components.xml:3068
#, no-c-format
msgid "CSS Styling"
msgstr "CSS 样式"

#. Tag: classname
#: chapter-components.xml:3020 chapter-components.xml:3036
#, no-c-format
msgid "PasswordField"
msgstr "PasswordField"

#. Tag: para
#: chapter-components.xml:3022
#, no-c-format
msgid ""
"The <classname>PasswordField</classname> is a variant of "
"<classname>TextField</classname> that hides the typed input from visual "
"inspection."
msgstr ""
"<classname>PasswordField</classname> 是 <classname>TextField</classname> 的变"
"体, 它会将输入的内容隐藏起来."

#. Tag: programlisting
#: chapter-components.xml:3029
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[PasswordField tf = new PasswordField(\"Keep it "
"secret\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3031
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.passwordfield.basic"
"\"/>."
msgstr ""
"运行结果参见 <xref linkend=\"figure.components.passwordfield.basic\"/>."

#. Tag: para
#: chapter-components.xml:3047
#, no-c-format
msgid ""
"You should note that the <classname>PasswordField</classname> hides the "
"input only from \"over the shoulder\" visual observation. Unless the server "
"connection is encrypted with a secure connection, such as HTTPS, the input "
"is transmitted in clear text and may be intercepted by anyone with low-level "
"access to the network. Also phishing attacks that intercept the input in the "
"browser may be possible by exploiting JavaScript execution security holes in "
"the browser."
msgstr ""
"要注意, <classname>PasswordField</classname> 对输入内容的隐藏只对 \"躲在人背"
"后\" 的肉眼窥探者有效. 除非与服务器之间使用加密连接, 比如 HTTPS, 否则输入内容"
"仍然会以明文传输, 因此可以被那些能够监视网络的人窥探到. 此外, 利用浏览器端的 "
"JavaScript 执行安全漏洞, 攻击者也可以发起钓鱼攻击, 拦截浏览器端的输入内容."

#. Tag: para
#: chapter-components.xml:3061
#, no-c-format
msgid ""
"The <classname>PasswordField</classname> does not have its own CSS style "
"name but uses the same <literal>v-textfield</literal> style as the regular "
"<classname>TextField</classname>. See <xref linkend=\"components.textfield."
"css\"/> for information on styling it."
msgstr ""
"<classname>PasswordField</classname> 没有独自的 CSS 样式名, 与通常的 "
"<classname>TextField</classname> 使用相同的 <literal>v-textfield</literal> 样"
"式. 关于它的样式控制, 请参见 <xref linkend=\"components.textfield.css\"/>."

#. Tag: classname
#: chapter-components.xml:3073
#, no-c-format
msgid "RichTextArea"
msgstr "RichTextArea"

#. Tag: para
#: chapter-components.xml:3075
#, no-c-format
msgid ""
"The <classname>RichTextArea</classname> field allows entering or editing "
"formatted text. The toolbar provides all basic editing functionalities. The "
"text content of <classname>RichTextArea</classname> is represented in HTML "
"format. <classname>RichTextArea</classname> inherits <classname>TextField</"
"classname> and does not add any API functionality over it. You can add new "
"functionality by extending the client-side components "
"<classname>VRichTextArea</classname> and <classname>VRichTextToolbar</"
"classname>."
msgstr ""
"<classname>RichTextArea</classname> 组件可用于输入和编辑格式化的文本. 它的工"
"具条提供了所有基本的的编辑功能. <classname>RichTextArea</classname> 的文本内"
"容以 HTML 格式表达. <classname>RichTextArea</classname> 继承自 "
"<classname>TextField</classname>, 没有增加任何 API 功能. 你可以扩展客户端组件"
"<classname>VRichTextArea</classname> 和 <classname>VRichTextToolbar</"
"classname>来添加功能."

#. Tag: para
#: chapter-components.xml:3086
#, no-c-format
msgid ""
"As with <classname>TextField</classname>, the textual content of the rich "
"text area is the <classname>Property</classname> of the field and can be set "
"with <methodname>setValue()</methodname> and read with "
"<methodname>getValue()</methodname>."
msgstr ""
"与 <classname>TextField</classname> 一样, RichTextArea 的文本内容是 Field 的 "
"<classname>Property</classname> , 可以使用 <methodname>setValue()</"
"methodname> 方法来设置, 可以使用 <methodname>getValue()</methodname> 方法来获"
"取."

#. Tag: programlisting
#: chapter-components.xml:3093
#, no-c-format
msgid ""
"<![CDATA[// Create a rich text area\n"
"final RichTextArea rtarea = new RichTextArea();\n"
"rtarea.setCaption(\"My Rich Text Area\");\n"
"\n"
"// Set initial content as HTML\n"
"rtarea.setValue(\"<h1>Hello</h1>\\n\" +\n"
"    \"<p>This rich text area contains some text.</p>\");]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:3096
#, no-c-format
msgid "Rich Text Area Component"
msgstr "Rich Text Area 组件"

#. Tag: para
#: chapter-components.xml:3107
#, no-c-format
msgid ""
"Above, we used context-specific tags such as <literal>&lt;h1&gt;</literal> "
"in the initial HTML content. The rich text area component does not allow "
"creating such tags, only formatting tags, but it does preserve them unless "
"the user edits them away. Any non-visible whitespace such as the new line "
"character (<literal>\\n</literal>) are removed from the content. For "
"example, the value set above will be as follows when read from the field "
"with <methodname>getValue()</methodname>:"
msgstr ""
"上例中, 我们在初始的 HTML 内容中使用了内容相关的 tag, 比如 <literal>&lt;"
"h1&gt;</literal>. RichTextArea 组件不支持创建这类 tag, 只能创建格式化 tag, 但"
"它会保留内容中既有的这类 tag, 除非用户将这类 tag 编辑删除掉. 任何不可见的空白"
"字符, 比如换行符(<literal>\\n</literal>) 都会从内容中删除. 比如, 上例中设置的"
"值, 使用 <methodname>getValue()</methodname> 方法从 Field 中读取时, 结果会是:"

#. Tag: programlisting
#: chapter-components.xml:3117
#, no-c-format
msgid ""
"<![CDATA[<h1>Hello</h1> <p>This rich text area contains some text.</p>]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3122
#, no-c-format
msgid ""
"The user input from a <classname>RichTextArea</classname> is transmitted as "
"HTML from the browser to server-side and is not sanitized. As the entire "
"purpose of the <classname>RichTextArea</classname> component is to allow "
"input of formatted text, you can not sanitize it just by removing all HTML "
"tags. Also many attributes, such as <parameter>style</parameter>, should "
"pass through the sanitization."
msgstr ""
"用户使用 <classname>RichTextArea</classname> 输入的内容会以 HTML 的形式从浏览"
"器传输到服务器端, 其内容不会被过滤. 由于 <classname>RichTextArea</classname> "
"组件的目的是用于输入格式化的文本, 你过滤用户输入内容时, 不能简单地删除所有的 "
"HTML tag. 此外还有很多属性, 比如 <parameter>style</parameter>, 也"

#. Tag: para
#: chapter-components.xml:3131
#, no-c-format
msgid ""
"See <xref linkend=\"advanced.security.sanitizing\"/> for more details on "
"Cross-Site scripting vulnerabilities and sanitization of user input."
msgstr ""
"关于跨站脚本问题, 以及对用户输入的过滤问题, 详情请参见 <xref linkend="
"\"advanced.security.sanitizing\"/>."

#. Tag: title
#: chapter-components.xml:3138
#, no-c-format
msgid "Localizing RichTextArea Toolbars"
msgstr "对 RichTextArea 的工具条进行本地化翻译"

#. Tag: para
#: chapter-components.xml:3140
#, no-c-format
msgid ""
"The rich text area is one of the few components in Vaadin that contain "
"textual labels. The selection boxes in the toolbar are in English and "
"currently can not be localized in any other way than by inheriting or "
"reimplementing the client-side <classname>VRichTextToolbar</classname> "
"widget. The buttons can be localized simply with CSS by downloading a copy "
"of the toolbar background image, editing it, and replacing the default "
"toolbar. The toolbar is a single image file from which the individual button "
"icons are picked, so the order of the icons is different from the rendered. "
"The image file depends on the client-side implementation of the toolbar."
msgstr ""
"RichTextArea 是 Vaadin 中少数带有文本标签的组件之一. 工具条中的选择框语言是英"
"文, 目前没有任何其他方法本地化, 只能继承或重新实现客户端的 "
"<classname>VRichTextToolbar</classname> Widget. 按钮可以使用 CSS 简单地本地"
"化, 只需要下载工具条背景图, 编辑它的内容, 然后替换掉默认的工具条. 工具条是单"
"个图片文件, 各个工具条按钮从中取得自己的图片, 因此图标顺序与画面中的显示顺序"
"会不同. 具体的图片文件取决于工具条的客户端实现."

#. Tag: programlisting
#: chapter-components.xml:3153
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[\n"
".v-richtextarea-richtextexample .gwt-ToggleButton\n"
".gwt-Image {\n"
"  background-image: url(img/richtextarea-toolbar-fi.png)\n"
"                    !important;\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:3156
#, no-c-format
msgid "Regular English and a Localized Rich Text Area Toolbar"
msgstr "Rich Text Area 工具条通常的英文版, 以及本地化版"

#. Tag: programlisting
#: chapter-components.xml:3173
#, no-c-format
msgid ""
"<![CDATA[.v-richtextarea { }\n"
".v-richtextarea .gwt-RichTextToolbar { }\n"
".v-richtextarea .gwt-RichTextArea { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3175
#, no-c-format
msgid ""
"The rich text area consists of two main parts: the toolbar with overall "
"style <literal>.gwt-RichTextToolbar</literal> and the editor area with style "
"<literal>.gwt-RichTextArea</literal>. The editor area obviously contains all "
"the elements and their styles that the HTML content contains. The toolbar "
"contains buttons and drop-down list boxes with the following respective "
"style names:"
msgstr ""
"RichTextArea 包括两个主要部分: 工具条, 它的最上层样式是 <literal>.gwt-"
"RichTextToolbar</literal>, 以及编辑器, 样式是 <literal>.gwt-RichTextArea</"
"literal>. 编辑器部分显然包含 HTML 内容中的所有元素及其样式. 工具条则包含工具"
"按钮和下拉列表, 它们的样式名如下:"

#. Tag: programlisting
#: chapter-components.xml:3184
#, no-c-format
msgid ""
"<![CDATA[.gwt-ToggleButton { }\n"
".gwt-ListBox { }]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:3190
#, no-c-format
msgid "Date and Time Input with <classname>DateField</classname>"
msgstr "使用 <classname>DateField</classname> 输入日期和时间"

#. Tag: para
#: chapter-components.xml:3191
#, no-c-format
msgid ""
"The <classname>DateField</classname> component provides the means to display "
"and input date and time. The field comes in two variations: "
"<classname>PopupDateField</classname>, with a numeric input box and a popup "
"calendar view, and <classname>InlineDateField</classname>, with the calendar "
"view always visible. The <classname>DateField</classname> base class "
"defaults to the popup variation."
msgstr ""
"<classname>DateField</classname> 组件用于显示和输入日期/时间. 这个组件有两种"
"不同的形式: <classname>PopupDateField</classname>, 它包括一个数字输入框, 和一"
"个弹出式日历, <classname>InlineDateField</classname>, 直接显示日历. "
"<classname>DateField</classname> 基类默认为弹出式输入方式."

#. Tag: para
#: chapter-components.xml:3200
#, no-c-format
msgid ""
"The example below illustrates the use of the <classname>DateField</"
"classname> baseclass, which is equivalent to the <classname>PopupDateField</"
"classname>. We set the initial time of the date field to current time by "
"using the default constructor of the <classname>java.util.Date</classname> "
"class."
msgstr ""
"下面的例子演示如何使用 <classname>DateField</classname> 基类, 它与 "
"<classname>PopupDateField</classname> 是等价的. 我们将 DateField 的初始时刻设"
"置为当前时刻, 当前时刻使用<classname>java.util.Date</classname> 类的默认构造"
"函数得到 ."

#. Tag: programlisting
#: chapter-components.xml:3208
#, no-c-format
msgid ""
"<![CDATA[// Create a DateField with the default style\n"
"DateField date = new DateField();\n"
"        \n"
"// Set the date and time to present\n"
"date.setValue(new Date());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3210
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.datefield.basic\"/>."
msgstr "运行结果参见 <xref linkend=\"figure.components.datefield.basic\"/>."

#. Tag: title
#: chapter-components.xml:3215
#, no-c-format
msgid ""
"<classname>DateField</classname> (<classname>PopupDateField</classname>) for "
"Selecting Date and Time"
msgstr ""
"使用 <classname>DateField</classname> (<classname>PopupDateField</"
"classname>) 选择日期和时刻"

#. Tag: classname
#: chapter-components.xml:3227
#, no-c-format
msgid "PopupDateField"
msgstr ""

#. Tag: para
#: chapter-components.xml:3229
#, no-c-format
msgid ""
"The <classname>PopupDateField</classname> provides date input using a text "
"box for the date and time. As the <classname>DateField</classname> defaults "
"to this component, the use is exactly the same as described earlier. "
"Clicking the handle right of the date opens a popup view for selecting the "
"year, month, and day, as well as time. Also the <keycap>Down</keycap> key "
"opens the popup. Once opened, the user can navigate the calendar using the "
"cursor keys."
msgstr ""
"<classname>PopupDateField</classname> 通过一个文本框来输入日期和时间. 由于 "
"<classname>DateField</classname> 默认就是这个组件, 因此这个组件的使用方法与前"
"面的例子完全相同. 点击日期右侧的按钮会打开一个弹出窗口, 可用来选择年, 月, "
"日, 以及时间. 此外, <keycap>Down</keycap> 键也会打开这个弹出窗口. 弹出窗口打"
"开后, 用户可以使用方向键在日历中滚动."

#. Tag: para
#: chapter-components.xml:3239
#, no-c-format
msgid ""
"The date and time selected from the popup are displayed in the text box "
"according to the default date and time format of the current locale, or as "
"specified with <methodname>setDateFormat()</methodname>. The same format "
"definitions are used for parsing user input."
msgstr ""
"弹出窗口中选择的日期和时间会显示在文本框中, 使用目前语言环境的日期时刻格式, "
"或者使用 <methodname>setDateFormat()</methodname> 方法指定的日期时刻格式. 用"
"户输入的日期时刻字符串也使用同样的格式来解析."

#. Tag: title
#: chapter-components.xml:3247
#, no-c-format
msgid "Date and Time Format"
msgstr "日期和时间的格式"

#. Tag: para
#: chapter-components.xml:3249
#, no-c-format
msgid ""
"The date and time are normally displayed according to the default format for "
"the current locale (see <xref linkend=\"components.features.locale\"/>). You "
"can specify a custom format with <methodname>setDateFormat()</methodname>. "
"It takes a format string that follows the format of the "
"<classname>SimpleDateFormat</classname> in Java."
msgstr ""
"日期和时刻通常使用当前语言环境的格式来显示(参见 <xref linkend=\"components."
"features.locale\"/>). 你也可以使用 <methodname>setDateFormat()</methodname> "
"方法指定自定义格式. 这个方法接受的格式字符串遵循 Java 的 "
"<classname>SimpleDateFormat</classname> 中定义的规则."

#. Tag: programlisting
#: chapter-components.xml:3258
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Display only year, month, and day in ISO "
"format\n"
"date.setDateFormat(\"yyyy-MM-dd\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3260
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.datefield."
"popupdatefield.format\"/>."
msgstr ""
"运行结果参见 <xref linkend=\"figure.components.datefield.popupdatefield."
"format\"/>."

#. Tag: title
#: chapter-components.xml:3266
#, no-c-format
msgid "Custom Date Format for <classname>PopupDateField</classname>"
msgstr "<classname>PopupDateField</classname> 的自定义日期格式"

#. Tag: para
#: chapter-components.xml:3277
#, no-c-format
msgid ""
"The same format specification is also used for parsing user-input date and "
"time, as described later."
msgstr "用户输入日期和时刻的解析, 也使用相同的格式, 详情见后文."

#. Tag: title
#: chapter-components.xml:3284
#, no-c-format
msgid "Handling Malformed User Input"
msgstr "处理不规则的用户输入"

#. Tag: para
#: chapter-components.xml:3286
#, no-c-format
msgid ""
"A user can easily input a malformed or otherwise invalid date or time. "
"<classname>DateField</classname> has two validation layers: first on the "
"client-side and then on the server-side."
msgstr ""
"用户经常会输入格式不正确的, 或者无效的日期和时刻. <classname>DateField</"
"classname> 有两个层次的校验: 第 1 层在客户端, 第 2 层在服务器端."

#. Tag: para
#: chapter-components.xml:3292
#, no-c-format
msgid ""
"The validity of the entered date is first validated on the client-side, "
"immediately when the input box loses focus. If the date format is invalid, "
"the <literal>v-datefield-parseerror</literal> style is set. Whether this "
"causes a visible indication of a problem depends on the theme. The built-in "
"<literal>reindeer</literal> theme does not shown any indication by default, "
"making server-side handling of the problem more convenient."
msgstr ""
"输入的日期首先在客户端校验, 当输入框失去焦点时立刻进行校验. 如果日期格式无"
"效, 会给组件设置上 <literal>v-datefield-parseerror</literal> 样式. 这个样式是"
"否会显示一个可见的错误指示器, 由 theme 决定. 内建的 <literal>reindeer</"
"literal> theme 默认不会显示错误指示器, 使得服务器端处理这个问题变得更方便一"
"些."

#. Tag: programlisting
#: chapter-components.xml:3302
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[.mydate.v-datefield-parseerror .v-textfield {\n"
"    background: pink;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3304
#, no-c-format
msgid ""
"The <methodname>setLenient(true)</methodname> setting enables relaxed "
"interpretation of dates, so that invalid dates, such as February 30th or "
"March 0th, are wrapped to the next or previous month, for example."
msgstr ""
"<methodname>setLenient(true)</methodname> 可以将日期的解释设置为宽松模式, 所"
"以某些不正确的日期, 比如 2 月 30 日 或 3 月 0 日, 会被解释为下一月或前一月的"
"日期."

#. Tag: para
#: chapter-components.xml:3310
#, no-c-format
msgid ""
"The server-side validation phase occurs when the date value is sent to the "
"server. If the date field is set in immediate state, it occurs immediately "
"after the field loses focus. Once this is done and if the status is still "
"invalid, an error indicator is displayed beside the component. Hovering the "
"mouse pointer over the indicator shows the error message."
msgstr ""
"当日期值发生到服务器端时, 或发生服务器端校验. 如果日期 Field 被设置为立即模"
"式, 校验会在 Field 失去焦点后立刻发生. 校验完成后, 如果结果不正确, 组件的旁边"
"会出现错误指示器. 将鼠标指针移动到指示器上, 将显示错误信息."

#. Tag: para
#: chapter-components.xml:3319
#, no-c-format
msgid ""
"You can handle the errors by overriding the "
"<methodname>handleUnparsableDateString()</methodname> method. The method "
"gets the user input as a string parameter and can provide a custom parsing "
"mechanism, as shown in the following example."
msgstr ""
"你可以重载 <methodname>handleUnparsableDateString()</methodname> 方法来处理日"
"期的校验错误. 这个方法接受的参数是用户输入的日期字符串, 可以在这个方法内实现"
"你自定义的日期解析逻辑, 如下例所示."

#. Tag: programlisting
#: chapter-components.xml:3326
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a date field with a custom parsing "
"and a\n"
"// custom error message for invalid format\n"
"PopupDateField date = new PopupDateField(\"My Date\") {\n"
"    @Override\n"
"    protected Date handleUnparsableDateString(String dateString)\n"
"    throws Property.ConversionException {\n"
"        // Try custom parsing\n"
"        String fields[] = dateString.split(\"/\");\n"
"        if (fields.length >= 3) {\n"
"            try {\n"
"                int year  = Integer.parseInt(fields[0]);\n"
"                int month = Integer.parseInt(fields[1])-1;\n"
"                int day   = Integer.parseInt(fields[2]);\n"
"                GregorianCalendar c =\n"
"                    new GregorianCalendar(year, month, day);\n"
"                return c.getTime();\n"
"            } catch (NumberFormatException e) {\n"
"                throw new Property.\n"
"                    ConversionException(\"Not a number\");\n"
"            }\n"
"        }\n"
"        \n"
"        // Bad date\n"
"        throw new Property.\n"
"            ConversionException(\"Your date needs two slashes\");\n"
"    }\n"
"};\n"
"        \n"
"// Display only year, month, and day in slash-delimited format\n"
"date.setDateFormat(\"yyyy/MM/dd\");\n"
"\n"
"// Don't be too tight about the validity of dates\n"
"// on the client-side\n"
"date.setLenient(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3328
#, no-c-format
msgid ""
"The handler method must either return a parsed <classname>Date</classname> "
"object or throw a <classname>ConversionException</classname>. Returning "
"<parameter>null</parameter> will set the field value to <parameter>null</"
"parameter> and clear the input box."
msgstr ""
"上面的错误处理方法要么返回一个 <classname>Date</classname> 作为解析结果, 要么"
"抛出一个 <classname>ConversionException</classname> 异常代表解析失败. 返回 "
"<parameter>null</parameter> 会将 Field 值设置为 <parameter>null</parameter>, "
"并清空输入框中的文字."

#. Tag: title
#: chapter-components.xml:3338
#, no-c-format
msgid "Customizing the Error Message"
msgstr "自定义错误信息"

#. Tag: para
#: chapter-components.xml:3340
#, no-c-format
msgid ""
"In addition to customized parsing, overriding the handler method for "
"unparseable input is useful for internationalization and other customization "
"of the error message. You can also use it for another way for reporting the "
"errors, as is done in the example below:"
msgstr ""
"除了自定义日期解析之外, 重载上面说的错误处理方法还可以用于国际化, 以及错误信"
"息的定制化. 你也可以使用它作为另一种报告错误的手段, 如下例所示:"

#. Tag: programlisting
#: chapter-components.xml:3347
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a date field with a custom error "
"message for invalid format\n"
"PopupDateField date = new PopupDateField(\"My Date\") {\n"
"    @Override\n"
"    protected Date handleUnparsableDateString(String dateString)\n"
"    throws Property.ConversionException {\n"
"        // Have a notification for the error\n"
"        Notification.show(\n"
"                \"Your date needs two slashes\",\n"
"                Notification.TYPE_WARNING_MESSAGE);\n"
"        \n"
"        // A failure must always also throw an exception\n"
"        throw new Property.ConversionException(\"Bad date\");\n"
"    }\n"
"};]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3349
#, no-c-format
msgid ""
"If the input is invalid, you should always throw the exception; returning a "
"<parameter>null</parameter> value would make the input field empty, which is "
"probably undesired."
msgstr ""
"如果输入内容无效, 你应该抛出异常; 返回 <parameter>null</parameter> 值会清空输"
"入框文本, 这通常不是我们期待的结果."

#. Tag: title
#: chapter-components.xml:3357
#, no-c-format
msgid "Input Prompt"
msgstr "输入提示"

#. Tag: para
#: chapter-components.xml:3359
#, no-c-format
msgid ""
"Like other fields that have a text box, <classname>PopupDateField</"
"classname> allows an input prompt that is visible until the user has input a "
"value. You can set the prompt with <methodname>setInputPrompt</methodname>."
msgstr ""
"与拥有输入框的其他 Field 一样, <classname>PopupDateField</classname> 可以带有"
"一个输入提示, 输入提示会一直显示, 直到用户输入了值. 你可以使用 "
"<methodname>setInputPrompt</methodname> 方法来设置提示信息."

#. Tag: programlisting
#: chapter-components.xml:3366
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[PopupDateField date = new PopupDateField();\n"
"\n"
"// Set the prompt\n"
"date.setInputPrompt(\"Select a date\");\n"
"        \n"
"// Set width explicitly to accommodate the prompt\n"
"date.setWidth(\"10em\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3368
#, no-c-format
msgid ""
"The date field doesn't automatically scale to accommodate the prompt, so you "
"need to set it explicitly with <methodname>setWidth()</methodname>."
msgstr ""
"DateField 不会自动调整自己的大小来适应提示信息, 所以你需要使用 "
"<methodname>setWidth()</methodname> 方法来明确地设定宽度."

#. Tag: para
#: chapter-components.xml:3374
#, no-c-format
msgid ""
"The input prompt is not available in the <classname>DateField</classname> "
"superclass."
msgstr "输入提示信息在 <classname>DateField</classname> 基类中不可用."

#. Tag: programlisting
#: chapter-components.xml:3383
#, no-c-format
msgid ""
"<![CDATA[.v-datefield, v-datefield-popupcalendar {}\n"
"  .v-textfield, v-datefield-textfield {}\n"
"  .v-datefield-button {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3385
#, no-c-format
msgid ""
"The top-level element of <classname>DateField</classname> and all its "
"variants have <literal>v-datefield</literal> style. The base class and the "
"<classname>PopupDateField</classname> also have the <literal>v-datefield-"
"popupcalendar</literal> style."
msgstr ""
"<classname>DateField</classname> (以及它的所有子类)的顶级 HTML 元素带有 "
"<literal>v-datefield</literal> 样式. DateField 基类和 "
"<classname>PopupDateField</classname> 类还带有 <literal>v-datefield-"
"popupcalendar</literal> 样式."

#. Tag: para
#: chapter-components.xml:3392
#, no-c-format
msgid ""
"In addition, the top-level element has a style that indicates the "
"resolution, with <literal>v-datefield-</literal> basename and an extension, "
"which is one of <literal>full</literal>, <literal>day</literal>, "
"<literal>month</literal>, or <literal>year</literal>. The <literal>-full</"
"literal> style is enabled when the resolution is smaller than a day. These "
"styles are used mainly for controlling the appearance of the popup calendar."
msgstr ""
"此外, 顶级元素还带有一个代表时间粒度的样式, 样式名以 <literal>v-datefield-</"
"literal> 开头, 后面附带一个后缀, 后缀可以是 <literal>full</literal>, "
"<literal>day</literal>, <literal>month</literal>, 或 <literal>year</literal> "
"之一. 当时间粒度小于 1 日时使用 <literal>-full</literal> 样式. 这些样式主要用"
"于控制弹出式日历的画面表现."

#. Tag: para
#: chapter-components.xml:3402
#, no-c-format
msgid ""
"The text box has <literal>v-textfield</literal> and <literal>v-datefield-"
"textfield</literal> styles, and the calendar button <literal>v-datefield-"
"button</literal>."
msgstr ""
"文本输入框带有 <literal>v-textfield</literal> 和<literal>v-datefield-"
"textfield</literal> 样式, 日历按钮带有 <literal>v-datefield-button</literal> "
"样式."

#. Tag: para
#: chapter-components.xml:3408
#, no-c-format
msgid ""
"Once opened, the calendar popup has the following styles at the top level:"
msgstr "弹出式日历打开后带有以下样式:"

#. Tag: programlisting
#: chapter-components.xml:3413
#, no-c-format
msgid ""
"<![CDATA[.v-datefield-popup {}\n"
"  .v-popupcontent {}\n"
"    .v-datefield-calendarpanel {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3415
#, no-c-format
msgid ""
"The top-level element of the floating popup calendar has <literal>.v-"
"datefield-popup</literal> style. Observe that the popup frame is outside the "
"HTML structure of the component, hence it is not enclosed in the <literal>v-"
"datefield</literal> element and does not include any custom styles. The "
"content in the <literal>v-datefield-calendarpanel</literal> is the same as "
"in <classname>InlineDateField</classname>, as described in <xref linkend="
"\"components.datefield.calendar\"/>."
msgstr ""
"弹出式日历的顶级元素带有 <literal>.v-datefield-popup</literal> 样式. 注意, 弹"
"出框处于组件 HTML 结构之外, 因此它没有包括在 <literal>v-datefield</literal> "
"元素之内, 也不带有任何自定义的样式. <literal>v-datefield-calendarpanel</"
"literal> 之内的内容, 与 <classname>InlineDateField</classname> 相同, 详情请参"
"见 <xref linkend=\"components.datefield.calendar\"/>."

#. Tag: classname
#: chapter-components.xml:3432
#, no-c-format
msgid "InlineDateField"
msgstr ""

#. Tag: para
#: chapter-components.xml:3434
#, no-c-format
msgid ""
"The <classname>InlineDateField</classname> provides a date picker component "
"with a month view. The user can navigate months and years by clicking the "
"appropriate arrows. Unlike with the popup variant, the month view is always "
"visible in the inline field."
msgstr ""
"<classname>InlineDateField</classname> 提供一个日期选择组件, 表现为月历形式. "
"用户可以点击适当的箭头按钮在不同的年份和月份间跳转. 与弹出式日历不同, 这个日"
"历会永远显示在界面中."

#. Tag: programlisting
#: chapter-components.xml:3441
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create a DateField with the default style\n"
"InlineDateField date = new InlineDateField();\n"
"    \n"
"// Set the date and time to present\n"
"date.setValue(new java.util.Date());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3443
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.datefield."
"inlinedatefield\"/>."
msgstr ""
"运行结果参见 <xref linkend=\"figure.components.datefield.inlinedatefield\"/>."

#. Tag: title
#: chapter-components.xml:3449
#, no-c-format
msgid "Example of the <classname>InlineDateField</classname>"
msgstr "<classname>InlineDateField</classname> 示例"

#. Tag: para
#: chapter-components.xml:3460
#, no-c-format
msgid "The user can also navigate the calendar using the cursor keys."
msgstr "用户也可以使用方向键在日历中跳转."

#. Tag: programlisting
#: chapter-components.xml:3467
#, no-c-format
msgid ""
"<![CDATA[.v-datefield {}\n"
"  .v-datefield-calendarpanel {}\n"
"    .v-datefield-calendarpanel-header {}\n"
"      .v-datefield-calendarpanel-prevyear {}\n"
"      .v-datefield-calendarpanel-prevmonth {}\n"
"      .v-datefield-calendarpanel-month {}\n"
"      .v-datefield-calendarpanel-nextmonth {}\n"
"      .v-datefield-calendarpanel-nextyear {}\n"
"    .v-datefield-calendarpanel-body {}\n"
"      .v-datefield-calendarpanel-weekdays,\n"
"      .v-datefield-calendarpanel-weeknumbers {}\n"
"        .v-first {}\n"
"        .v-last {}\n"
"      .v-datefield-calendarpanel-weeknumber {}\n"
"      .v-datefield-calendarpanel-day {}\n"
"    .v-datefield-calendarpanel-time {}\n"
"      .v-datefield-time {}\n"
"        .v-select {}\n"
"        .v-label {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3469
#, no-c-format
msgid ""
"The top-level element has the <literal>v-datefield</literal> style. In "
"addition, the top-level element has a style name that indicates the "
"resolution of the calendar, with <literal>v-datefield-</literal> basename "
"and an extension, which is one of <literal>full</literal>, <literal>day</"
"literal>, <literal>month</literal>, or <literal>year</literal>. The "
"<literal>-full</literal> style is enabled when the resolution is smaller "
"than a day."
msgstr ""
"顶级元素带有 <literal>v-datefield</literal> 样式. 除此之外, 顶级元素还带有一"
"个代表时间粒度的样式, 样式名以 <literal>v-datefield-</literal> 开头, 后面附带"
"一个后缀, 后缀可以是 <literal>full</literal>, <literal>day</literal>, "
"<literal>month</literal>, 或 <literal>year</literal> 之一. 当时间粒度小于 1 "
"日时使用 <literal>-full</literal> 样式."

#. Tag: para
#: chapter-components.xml:3479
#, no-c-format
msgid ""
"The <literal>v-datefield-calendarpanel-weeknumbers</literal> and <literal>v-"
"datefield-calendarpanel-weeknumber</literal> styles are enabled when the "
"week numbers are enabled. The former controls the appearance of the weekday "
"header and the latter the actual week numbers."
msgstr ""
"当星期数的显示被打开时, 会出现 <literal>v-datefield-calendarpanel-"
"weeknumbers</literal> 和 <literal>v-datefield-calendarpanel-weeknumber</"
"literal> 样式. 其中前一个样式用来控制星期数的表头部分的表现, 后一个用来控制实"
"际的星期数."

#. Tag: para
#: chapter-components.xml:3487
#, no-c-format
msgid ""
"The other style names should be self-explanatory. For weekdays, the "
"<literal>v-first</literal> and <literal>v-last</literal> styles allow making "
"rounded endings for the weekday bar."
msgstr ""
"其他样式名称的含义非常明显. 对于 weekdays 来说, <literal>v-first</literal> "
"和 <literal>v-last</literal> 样式 allow making rounded endings for the "
"weekday bar. (译注: 这段不理解, 待校)"

#. Tag: title
#: chapter-components.xml:3496
#, no-c-format
msgid "Date and Time Resolution"
msgstr "日期与时间的粒度"

#. Tag: para
#: chapter-components.xml:3498
#, no-c-format
msgid ""
"In addition to display a calendar with dates, <classname>DateField</"
"classname> can also display the time in hours and minutes, or just the month "
"or year. The visibility of the input components is controlled by "
"<emphasis>time resolution</emphasis>, which you can set with "
"<methodname>setResolution()</methodname>. The method takes as its parameters "
"the lowest visible component, <parameter>DateField.Resolution.DAY</"
"parameter> for just dates and <parameter>DateField.Resolution.MIN</"
"parameter> for dates with time in hours and minutes. Please see the API "
"Reference for the complete list of resolution parameters."
msgstr ""
"除了显示日期单位的日历之外, <classname>DateField</classname> 也可以显示到时, "
"分, 或者只显示月或年. 各项目的可见度由 <emphasis>时间粒度</emphasis> 来控制, "
"时间粒度可以使用 <methodname>setResolution()</methodname> 方法来设置. 这个方"
"法接受的参数是界面中可见的最小项目, 对于日期来说, 一般使用 "
"<parameter>DateField.Resolution.DAY</parameter> , 对于日期加时分来说, 使用 "
"<parameter>DateField.Resolution.MIN</parameter> . 时间粒度参数的完整列表请参"
"见 API 文档."

#. Tag: title
#: chapter-components.xml:3513
#, no-c-format
msgid "DateField Locale"
msgstr "DateField 的本地化"

#. Tag: para
#: chapter-components.xml:3515
#, no-c-format
msgid ""
"The date and time are displayed according to the locale of the user, as "
"reported by the browser. You can set a custom locale with the "
"<methodname>setLocale()</methodname> method of <classname>AbstractComponent</"
"classname>, as described in <xref linkend=\"components.features.locale\"/>. "
"Only Gregorian calendar is supported."
msgstr ""
"日期和时间的显示格式遵循用户的语言环境, 语言环境由浏览器报告给服务器. 你可以"
"使用 <classname>AbstractComponent</classname> 的 <methodname>setLocale()</"
"methodname> 方法, 设定自定义的语言环境, 详情请参见 <xref linkend="
"\"components.features.locale\"/>. 注意, 只支持 Gregorian 日历."

#. Tag: classname
#: chapter-components.xml:3527
#, no-c-format
msgid "Button"
msgstr "Button"

#. Tag: para
#: chapter-components.xml:3529
#, no-c-format
msgid ""
"The <classname>Button</classname> component is normally used for initiating "
"some action, such as finalizing input in forms. When the user clicks a "
"button, a <classname>Button.ClickEvent</classname> is fired, which can be "
"handled with a <interfacename>Button.ClickListener</interfacename> in the "
"<methodname>buttonClick()</methodname> method."
msgstr ""
"<classname>Button</classname> 组件通常用于激发某种动作, 比如完成 Form 的输"
"入. 当用户点击按钮时, 会激发 <classname>Button.ClickEvent</classname> 事件, "
"这个事件可以通过 <interfacename>Button.ClickListener</interfacename> 监听器"
"的 <methodname>buttonClick()</methodname> 方法来处理  ."

#. Tag: para
#: chapter-components.xml:3537
#, no-c-format
msgid "You can handle button clicks with an anonymous class as follows:"
msgstr "你可以使用匿名类处理按钮的点击事件, 如下例所示:"

#. Tag: programlisting
#: chapter-components.xml:3542
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Button button = new Button(\"Do not press this "
"button\");\n"
"\n"
"button.addClickListener(new Button.ClickListener() {\n"
"    public void buttonClick(ClickEvent event) {\n"
"        Notification.show(\"Do not press this button again\");\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3544
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.component.button.basic\"/>. "
"The listener can also be given in the constructor, which is often perhaps "
"simpler."
msgstr ""
"运行结果参见 <xref linkend=\"figure.component.button.basic\"/>. 监听器也可以"
"在构造函数中指定, 这样通常可以使代码更简单一些."

#. Tag: title
#: chapter-components.xml:3550
#, no-c-format
msgid "An Example of a Button"
msgstr "Button 示例"

#. Tag: para
#: chapter-components.xml:3558
#, no-c-format
msgid ""
"If you handle several buttons in the same listener, you can differentiate "
"between them either by comparing the <classname>Button</classname> object "
"reference returned by the <methodname>getButton()</methodname> method of "
"<classname>Button.ClickEvent</classname> to a kept reference. For a detailed "
"description of these patterns together with some examples, please see <xref "
"linkend=\"architecture.events\"/>."
msgstr ""
"如果你在同一个监听器中处理多个按钮的事件, 你可以通过 <classname>Button."
"ClickEvent</classname> 的 <methodname>getButton()</methodname> 方法得到与事件"
"相关的 <classname>Button</classname> 对象, 然后确定激发事件的是哪个按钮. 详情"
"请参见 <xref linkend=\"architecture.events\"/>, 其中有详细的介绍和例子."

#. Tag: programlisting
#: chapter-components.xml:3570
#, no-c-format
msgid ""
"<![CDATA[.v-button { }\n"
"  .v-button-wrap { }\n"
"    .v-button-caption { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3572
#, no-c-format
msgid ""
"A button has an overall <literal>v-button</literal> style. The caption has "
"<literal>v-button-caption</literal> style. There is also an intermediate "
"wrap element, which may help in styling in some cases."
msgstr ""
"按钮的最外层样式是 <literal>v-button</literal>. 标签带有 <literal>v-button-"
"caption</literal> 样式. 这二者之间还存在一个封装元素, 某些情况下可以帮助控制"
"样式."

#. Tag: para
#: chapter-components.xml:3578
#, no-c-format
msgid ""
"Some built-in themes contain a small style, which you can enable by adding "
"<parameter>Reindeer.BUTTON_SMALL</parameter>, etc. The <classname>BaseTheme</"
"classname> also has a <parameter>BUTTON_LINK</parameter> style, which makes "
"the button look like a hyperlink."
msgstr ""
"某些内建的 theme 包含 small 样式, 你可以添加 <parameter>Reindeer."
"BUTTON_SMALL</parameter> 样式来使用它. <classname>BaseTheme</classname> 也带"
"有 <parameter>BUTTON_LINK</parameter> 样式, 可以让按钮的外观类似于超链接."

#. Tag: classname
#: chapter-components.xml:3589
#, no-c-format
msgid "CheckBox"
msgstr "CheckBox"

#. Tag: para
#: chapter-components.xml:3591
#, no-c-format
msgid ""
"<classname>CheckBox</classname> is a two-state selection component that can "
"be either checked or unchecked. The caption of the check box will be placed "
"right of the actual check box. Vaadin provides two ways to create check "
"boxes: individual check boxes with the <classname>CheckBox</classname> "
"component described in this section and check box groups with the "
"<classname>OptionGroup</classname> component in multiple selection mode, as "
"described in <xref linkend=\"components.optiongroup\"/>."
msgstr ""
"<classname>CheckBox</classname> 是一种两状态的选择组件, 可以处于选中或非选中"
"状态. CheckBox 的标题会放在真实的选择框的右侧. Vaadin 提供了两种方式创建 "
"CheckBox: 1,使用 <classname>CheckBox</classname> 组件, 创建独立的 CheckBox, "
"详情请见本节的介绍, 2,使用 <classname>OptionGroup</classname> 组件的多选模"
"式, 创建 CheckBox 组, 详情请参见 <xref linkend=\"components.optiongroup\"/>."

#. Tag: para
#: chapter-components.xml:3601
#, no-c-format
msgid ""
"Clicking on a check box will change its state. The state is a "
"<classname>Boolean</classname> property that you can set with the "
"<methodname>setValue()</methodname> method and obtain with the "
"<methodname>getValue()</methodname> method of the <classname>Property</"
"classname> interface. Changing the value of a check box will cause a "
"<classname>ValueChangeEvent</classname>, which can be handled by a "
"<classname>ValueChangeListener</classname>."
msgstr ""
"点击 CheckBox 将改变它的状态. 状态是 <classname>Boolean</classname> 类型属"
"性, 可以使用 <classname>Property</classname> 接口的 <methodname>setValue()</"
"methodname> 方法来设置, 使用 <methodname>getValue()</methodname> 方法得到. 改"
"变 CheckBox 的值将触发一个 <classname>ValueChangeEvent</classname> 事件, 这个"
"事件可以使用 <classname>ValueChangeListener</classname> 监听器来处理."

#. Tag: programlisting
#: chapter-components.xml:3611
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[CheckBox checkbox1 = new CheckBox(\"Box with no "
"Check\");\n"
"CheckBox checkbox2 = new CheckBox(\"Box with a Check\");\n"
"\n"
"checkbox2.setValue(true);\n"
"\n"
"checkbox1.addValueChangeListener(event -> // Java 8\n"
"    checkbox2.setValue(! checkbox1.getValue()));\n"
"\n"
"checkbox2.addValueChangeListener(event -> // Java 8\n"
"    checkbox1.setValue(! checkbox2.getValue()));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3613
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.components.checkbox.basic\"/>."
msgstr "运行结果参见 <xref linkend=\"figure.components.checkbox.basic\"/>."

#. Tag: title
#: chapter-components.xml:3618
#, no-c-format
msgid "An Example of a Check Box"
msgstr "Check Box 示例"

#. Tag: para
#: chapter-components.xml:3626
#, no-c-format
msgid ""
"For an example on the use of check boxes in a table, see <xref linkend="
"\"components.table\"/>."
msgstr ""
"关于在 Table 内使用 CheckBox 的例子, 请参见 <xref linkend=\"components.table"
"\"/>."

#. Tag: programlisting
#: chapter-components.xml:3634
#, no-c-format
msgid ""
"<![CDATA[.v-checkbox { }\n"
"  .v-checkbox > input { }\n"
"  .v-checkbox > label { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3636
#, no-c-format
msgid ""
"The top-level element of a <classname>CheckBox</classname> has the "
"<literal>v-checkbox</literal> style. It contains two sub-elements: the "
"actual check box <literal>input</literal> element and the <literal>label</"
"literal> element. If you want to have the label on the left, you can change "
"the positions with \"<literal>direction: rtl</literal>\" for the top element."
msgstr ""
"<classname>CheckBox</classname> 的顶级元素带有 <literal>v-checkbox</literal> "
"样式. 其中包含两个子元素: 1, 真实的选择框 <literal>input</literal> 元素, 2,"
"<literal>label</literal> 元素. 如果你希望标题显示在左侧, 你可以对顶级元素使"
"用 \"<literal>direction: rtl</literal>\" 来修改标题的位置."

#. Tag: classname
#: chapter-components.xml:3648
#, no-c-format
msgid "ComboBox"
msgstr ""

#. Tag: para
#: chapter-components.xml:3650
#, no-c-format
msgid ""
"<classname>ComboBox</classname> is a selection component allows selecting an "
"item from a drop-down list. The component also has a text field area, which "
"allows entering search text by which the items shown in the drop-down list "
"are filtered. Common selection component features are described in <xref "
"linkend=\"components.selection\"/>."
msgstr ""
"<classname>ComboBox</classname> 是一个选择组件, 它允许通过下拉列表来选择项"
"目. 这个组件也带有一个文本输入框, 允许输入查询文字, 通过这个查询文字来过滤下"
"拉列表中出现的项目. 关于选择组件的共通功能, 请参见 <xref linkend="
"\"components.selection\"/>."

#. Tag: title
#: chapter-components.xml:3659
#, no-c-format
msgid "The <classname>ComboBox</classname> Component"
msgstr "<classname>ComboBox</classname> 组件"

#. Tag: para
#: chapter-components.xml:3667
#, no-c-format
msgid ""
"<classname>ComboBox</classname> supports adding new items when the user "
"presses <keycap>Enter</keycap><phrase condition=\"web\">, as described in "
"<xref linkend=\"components.selection.newitems\"/>.</phrase>"
msgstr ""
"当用户按下 <keycap>Enter</keycap> 时, <classname>ComboBox</classname> 可以添"
"加新的选择项目 <phrase condition=\"web\">, 详情请参见 <xref linkend="
"\"components.selection.newitems\"/>.</phrase>"

#. Tag: title
#: chapter-components.xml:3674
#, no-c-format
msgid "Filtered Selection"
msgstr "被过滤的选择项"

#. Tag: para
#: chapter-components.xml:3676
#, no-c-format
msgid ""
"<classname>ComboBox</classname> allows filtering the items available for "
"selection in the drop-down list by the text entered in the input box."
msgstr ""
"<classname>ComboBox</classname> 允许在文本输入框中输入字符串来过滤下拉列表中"
"的可选项目."

#. Tag: title
#: chapter-components.xml:3683
#, no-c-format
msgid "Filtered Selection in <classname>ComboBox</classname>"
msgstr "在 <classname>ComboBox</classname> 中过滤可选项目"

#. Tag: para
#: chapter-components.xml:3691
#, no-c-format
msgid ""
"Pressing <keycap>Enter</keycap> will complete the item in the input box. "
"Pressing <keycap>Up</keycap>- and <keycap>Down</keycap>-arrows can be used "
"for selecting an item from the drop-down list. The drop-down list is paged "
"and clicking on the scroll buttons will change to the next or previous page. "
"The list selection can also be done with the arrow keys on the keyboard. The "
"shown items are loaded from the server as needed, so the number of items "
"held in the component can be quite large. The number of matching items is "
"displayed by the drop-down list."
msgstr ""
"按下 <keycap>Enter</keycap> 键可以完成文本的输入. 按下 <keycap>Up</keycap>- "
"和 <keycap>Down</keycap>-键可以从下拉列表中选择项目. 下拉列表内容是分页显示"
"的, 点击翻滚按钮可以滚动到下一页或前一页. 列表选择也可以通过键盘上的方向键来"
"实现(译注: 这句不理解, 待校). 界面中显示的项目只在需要的时候才从服务器端载"
"入, 因此这个组件内包含的选项数目可以非常大. 与过滤条件相匹配的项目数会显示在"
"下拉列表中."

#. Tag: para
#: chapter-components.xml:3702
#, no-c-format
msgid ""
"Filtering is enabled by setting a <emphasis>filtering mode</emphasis> with "
"<methodname>setFilteringMode()</methodname>."
msgstr ""
"通过 <methodname>setFilteringMode()</methodname> 方法设置一个 <emphasis>过滤"
"模式</emphasis>, 可以激活过滤功能 ."

#. Tag: programlisting
#: chapter-components.xml:3708
#, no-c-format
msgid ""
"<?pocket-size 85% ?><![CDATA[cb.setFilteringMode(FilteringMode.CONTAINS);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3710
#, no-c-format
msgid ""
"The modes defined in the <classname>FilteringMode</classname> enum are as "
"follows:"
msgstr "过滤模式定义在 <classname>FilteringMode</classname> 枚举型中. 如下:"

#. Tag: parameter
#: chapter-components.xml:3717
#, no-c-format
msgid "CONTAINS"
msgstr ""

#. Tag: para
#: chapter-components.xml:3719
#, no-c-format
msgid ""
"Matches any item that contains the string given in the text field part of "
"the component."
msgstr ""
"在组件的文本框中输入的文本为查询条件, 凡包含这串文本的项目都将匹配成功."

#. Tag: parameter
#: chapter-components.xml:3726
#, no-c-format
msgid "STARTSWITH"
msgstr ""

#. Tag: para
#: chapter-components.xml:3728
#, no-c-format
msgid "Matches only items that begin with the given string."
msgstr "只匹配以查询文字开头的项目"

#. Tag: term
#: chapter-components.xml:3734
#, no-c-format
msgid "<parameter>OFF</parameter> (default)"
msgstr "<parameter>OFF</parameter> (默认)"

#. Tag: para
#: chapter-components.xml:3736
#, no-c-format
msgid "Filtering is by default off and all items are shown all the time."
msgstr "默认情况下, 过滤功能是关闭的, 此时所有选项都会显示."

#. Tag: para
#: chapter-components.xml:3744
#, no-c-format
msgid ""
"The above example uses the containment filter that matches to all items "
"containing the input string. As shown in <xref linkend=\"figure.components."
"combobox.filter\"/> below, when we type some text in the input area, the "
"drop-down list will show all the matching items."
msgstr ""
"上例使用\"包含\"模式过滤, 匹配包含查询字符串的所有项目. 运行结果见下面的 "
"<xref linkend=\"figure.components.combobox.filter\"/>, 我们在文本输入框中输入"
"字符串时, 下拉列表将显示所有匹配成功的项目."

#. Tag: programlisting
#: chapter-components.xml:3756
#, no-c-format
msgid ""
"<![CDATA[.v-filterselect { }\n"
"  .v-filterselect-input { }\n"
"  .v-filterselect-button { }\n"
"\n"
"// Under v-overlay-container\n"
".v-filterselect-suggestpopup { }\n"
"  .popupContent { }\n"
"    .v-filterselect-prevpage,\n"
"      .v-filterselect-prevpage-off { }\n"
"    .v-filterselect-suggestmenu { }\n"
"      .gwt-MenuItem { }\n"
"    .v-filterselect-nextpage,\n"
"      .v-filterselect-nextpage-off { }\n"
"    .v-filterselect-status { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3758
#, no-c-format
msgid ""
"In its default state, only the input field of the <classname>ComboBox</"
"classname> component is visible. The entire component is enclosed in "
"<literal>v-filterselect</literal> style (a legacy remnant), the input field "
"has <literal>v-filterselect-input</literal> style and the button in the "
"right end that opens and closes the drop-down result list has <literal>v-"
"filterselect-button</literal> style."
msgstr ""
"在默认状态下, <classname>ComboBox</classname> 组件只有文本输入框是可见的. 整"
"个组件包含在 <literal>v-filterselect</literal> 样式的元素之内(这个样式名是旧"
"版本遗留下来的), 文本输入框带有 <literal>v-filterselect-input</literal> 样"
"式, 右侧负责打开和关闭下拉列表的按钮带有 <literal>v-filterselect-button</"
"literal> 样式."

#. Tag: para
#: chapter-components.xml:3768
#, no-c-format
msgid ""
"The drop-down result list has an overall <literal>v-filterselect-"
"suggestpopup</literal> style. It contains the list of suggestions with "
"<literal>v-filterselect-suggestmenu</literal> style. When there are more "
"items that fit in the menu, navigation buttons with <literal>v-filterselect-"
"prevpage</literal> and <literal>v-filterselect-nextpage</literal> styles are "
"shown. When they are not shown, the elements have <literal>-off</literal> "
"suffix. The status bar in the bottom that shows the paging status has "
"<literal>v-filterselect-status</literal> style."
msgstr ""
"选择项目的下拉列表最外层样式是 <literal>v-filterselect-suggestpopup</"
"literal>. 它包含一系列的选择项目, 样式为 <literal>v-filterselect-"
"suggestmenu</literal>. 当存在更多的项目, 无法一次显示完毕时, 会显示翻页导航按"
"钮, 样式为 <literal>v-filterselect-prevpage</literal> 和 <literal>v-"
"filterselect-nextpage</literal>. 翻页导航按钮不显示时, 对应的页面元素样式名将"
"带上 <literal>-off</literal> 后缀. 最底部的状态条会显示翻页状态, 样式为 "
"<literal>v-filterselect-status</literal>."

#. Tag: classname
#: chapter-components.xml:3783
#, no-c-format
msgid "ListSelect"
msgstr ""

#. Tag: para
#: chapter-components.xml:3785
#, no-c-format
msgid ""
"The <classname>ListSelect</classname> component is list box that shows the "
"selectable items in a vertical list. If the number of items exceeds the "
"height of the component, a scrollbar is shown. The component allows both "
"single and multiple selection modes, which you can set with "
"<methodname>setMultiSelect()</methodname>. It is visually identical in both "
"modes."
msgstr ""
"<classname>ListSelect</classname> 组件是一个列表框, 其中显示可选择的项目列"
"表, 垂直排列. 如果选择项目的数量超过了组件高度, 会显示滚动条. 这个组件支持单"
"选模式也支持多选模式, 可以通过 <methodname>setMultiSelect()</methodname> 方法"
"设置. 这两种模式的外观表现是完全一样的."

#. Tag: programlisting
#: chapter-components.xml:3794
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create the selection component\n"
"ListSelect select = new ListSelect(\"The List\");\n"
"        \n"
"// Add some items (here by the item ID as the caption)\n"
"select.addItems(\"Mercury\", \"Venus\", \"Earth\", ...);\n"
"\n"
"select.setNullSelectionAllowed(false);\n"
"\n"
"// Show 5 items and a scrollbar if there are more\n"
"select.setRows(5);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3796
#, no-c-format
msgid ""
"The number of visible items is set with <methodname>setRows()</methodname>."
msgstr ""
"组件中可见项目的数量可以使用 <methodname>setRows()</methodname> 方法设置."

#. Tag: title
#: chapter-components.xml:3802
#, no-c-format
msgid "The <classname>ListSelect</classname> Component"
msgstr "<classname>ListSelect</classname> 组件"

#. Tag: para
#: chapter-components.xml:3810 chapter-components.xml:3854
#: chapter-components.xml:4049 chapter-components.xml:4159
#, no-c-format
msgid ""
"Common selection component features are described in <xref linkend="
"\"components.selection\"/>."
msgstr ""
"关于选择组件的共通功能, 请参见 <xref linkend=\"components.selection\"/>."

#. Tag: programlisting
#: chapter-components.xml:3818
#, no-c-format
msgid ""
"<![CDATA[.v-select {}\n"
"  .v-select-select {}\n"
"    option {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3820
#, no-c-format
msgid ""
"The component has an overall <literal>v-select</literal> style. The native "
"<literal>&lt;select&gt;</literal> element has <literal>v-select-select</"
"literal> style. The items are represented as <literal>&lt;option&gt;</"
"literal> elements."
msgstr ""
"这个组件的最外层样式为 <literal>v-select</literal>. 浏览器原生的 "
"<literal>&lt;select&gt;</literal> 元素样式为 <literal>v-select-select</"
"literal>. 选择项目使用 <literal>&lt;option&gt;</literal> 元素来表示"

#. Tag: classname
#: chapter-components.xml:3830
#, no-c-format
msgid "NativeSelect"
msgstr ""

#. Tag: para
#: chapter-components.xml:3832
#, no-c-format
msgid ""
"<classname>NativeSelect</classname> is a drop-down selection component "
"implemented with the native selection input of web browsers, using the HTML "
"<literal>&lt;select&gt;</literal> element."
msgstr ""
"<classname>NativeSelect</classname> 是一个下拉选择组件, 使用 Web 浏览器原生的"
"(native) select 输入框实现, 也就是 HTML <literal>&lt;select&gt;</literal> 元"
"素."

#. Tag: programlisting
#: chapter-components.xml:3838
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create the selection component\n"
"NativeSelect select = new NativeSelect(\"Native Selection\");\n"
"        \n"
"// Add some items\n"
"select.addItems(\"Mercury\", \"Venus\", ...);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3840
#, no-c-format
msgid ""
"The <methodname>setColumns()</methodname> allows setting the width of the "
"list as \"columns\", which is a measure that depends on the browser."
msgstr ""
"<methodname>setColumns()</methodname> 方法可以设置列表的宽度, 单位为 \"列"
"(column)\", 具体尺寸由浏览器决定."

#. Tag: title
#: chapter-components.xml:3846
#, no-c-format
msgid "The <classname>NativeSelect</classname> Component"
msgstr "<classname>NativeSelect</classname> 组件"

#. Tag: programlisting
#: chapter-components.xml:3862
#, no-c-format
msgid ""
"<![CDATA[.v-select {}\n"
"  .v-select-select {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3864
#, no-c-format
msgid ""
"The component has a <literal>v-select</literal> overall style. The native "
"<literal>select</literal> element has <literal>v-select-select</literal> "
"style."
msgstr ""
"这个组件最外层样式为 <literal>v-select</literal>. 原生的 <literal>select</"
"literal> 元素的样式为 <literal>v-select-select</literal>."

#. Tag: classname
#: chapter-components.xml:3873
#, no-c-format
msgid "OptionGroup"
msgstr ""

#. Tag: para
#: chapter-components.xml:3875
#, no-c-format
msgid ""
"<classname>OptionGroup</classname> is a selection component that allows "
"selection from a group of radio buttons in single selection mode. In "
"multiple selection mode, the items show up as check boxes. The common "
"selection component features are described in <xref linkend=\"components."
"selection\"/>."
msgstr ""
"<classname>OptionGroup</classname> 是一个选择组件, 对于单选模式它使用一组 "
"Radio Button. 对于多选模式, 它使用一组 Check Box. 关于选择组件的共通功能, 请"
"参见 <xref linkend=\"components.selection\"/>."

#. Tag: title
#: chapter-components.xml:3883
#, no-c-format
msgid "Option Button Group in Single and Multiple Selection Mode"
msgstr "OptionGroup 的单选模式和多选模式"

#. Tag: para
#: chapter-components.xml:3891
#, no-c-format
msgid ""
"Option group is by default in single selection mode. Multiple selection is "
"enabled with <methodname>setMultiSelect()</methodname>."
msgstr ""
"Option group 默认为单选模式. 使用 <methodname>setMultiSelect()</methodname> "
"方法可以激活多选模式."

#. Tag: programlisting
#: chapter-components.xml:3896
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[// A single-select radio button group\n"
"OptionGroup single = new OptionGroup(\"Single Selection\");\n"
"single.addItems(\"Single\", \"Sola\", \"Yksi\");\n"
"\n"
"// A multi-select check box group\n"
"OptionGroup multi = new OptionGroup(\"Multiple Selection\");\n"
"multi.setMultiSelect(true);\n"
"multi.addItems(\"Many\", \"Muchos\", \"Monta\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3898
#, no-c-format
msgid ""
"shows the <classname>OptionGroup</classname> in both single and multiple "
"selection mode."
msgstr "展示了 <classname>OptionGroup</classname> 的单选和多选模式."

#. Tag: para
#: chapter-components.xml:3903
#, no-c-format
msgid ""
"You can also create check boxes individually using the <classname>CheckBox</"
"classname> class, as described in <xref linkend=\"components.checkbox\"/>. "
"The advantages of the <classname>OptionGroup</classname> component are that "
"as it maintains the individual check box objects, you can get an array of "
"the currently selected items easily, and that you can easily change the "
"appearance of a single component."
msgstr ""
"当然你也可以使用 <classname>CheckBox</classname> 类创建独立的 Check Box, 参"
"见 <xref linkend=\"components.checkbox\"/>. <classname>OptionGroup</"
"classname> 组件的优势在于它会维护 Check Box, 你可以很容易地得到当前选中项目的"
"数组, 而且你也可以容易地修改整个组件的外观表现."

#. Tag: title
#: chapter-components.xml:3914
#, no-c-format
msgid "Disabling Items"
msgstr "禁用项目"

#. Tag: para
#: chapter-components.xml:3916
#, no-c-format
msgid ""
"You can disable individual items in an <classname>OptionGroup</classname> "
"with <methodname>setItemEnabled()</methodname>. The user can not select or "
"deselect disabled items in multi-select mode, but in single-select mode the "
"use can change the selection from a disabled to an enabled item. The "
"selections can be changed programmatically regardless of whether an item is "
"enabled or disabled. You can find out whether an item is enabled with "
"<methodname>isItemEnabled()</methodname>."
msgstr ""
"你可以使用 <methodname>setItemEnabled()</methodname> 方法禁用 "
"<classname>OptionGroup</classname> 内的单个项目. 在多选模式下, 对于被禁用的项"
"目, 用户不能选中它, 也不能解除选中, 但在单选模式下, 用户可以将当前选项从一个"
"被禁用的项目变为另一个有效的项目. 选中项可以通过程序来变更, 无论项目是有效还"
"是禁用. 你可以使用 <methodname>isItemEnabled()</methodname> 方法检查某个项目"
"是有效还是禁用."

#. Tag: para
#: chapter-components.xml:3926
#, no-c-format
msgid ""
"The <methodname>setItemEnabled()</methodname> identifies the item to be "
"disabled by its item ID."
msgstr ""
"<methodname>setItemEnabled()</methodname> 使用项目的 ID 来指定它将要禁用或允"
"许的项目."

#. Tag: programlisting
#: chapter-components.xml:3931
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Have an option group with some items\n"
"OptionGroup group = new OptionGroup(\"My Disabled Group\");\n"
"group.addItems(\"One\", \"Two\", \"Three\");\n"
"\n"
"// Disable one item by its item ID\n"
"group.setItemEnabled(\"Two\", false);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3933
#, no-c-format
msgid ""
"The item IDs are also used for the captions in this example. The result is "
"shown in <xref linkend=\"figure.components.optiongroup.disabling\"/>."
msgstr ""
"上面的例子中, 项目 ID 也用作项目标题. 运行结果见 <xref linkend=\"figure."
"components.optiongroup.disabling\"/>."

#. Tag: title
#: chapter-components.xml:3940
#, no-c-format
msgid "<classname>OptionGroup</classname> with a Disabled Item"
msgstr "带有禁用项目的 <classname>OptionGroup</classname>"

#. Tag: para
#: chapter-components.xml:3948
#, no-c-format
msgid ""
"Setting an item as disabled turns on the <literal>v-disabled</literal> style "
"for it."
msgstr "将项目设置为禁用, 将使它带有 <literal>v-disabled</literal> 样式."

#. Tag: programlisting
#: chapter-components.xml:3957
#, no-c-format
msgid ""
"<![CDATA[.v-select-optiongroup {}\n"
"  .v-select-option.v-checkbox {}\n"
"  .v-select-option.v-radiobutton {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3959
#, no-c-format
msgid ""
"The <literal>v-select-optiongroup</literal> is the overall style for the "
"component. Each check box will have the <literal>v-checkbox</literal> style, "
"borrowed from the <classname>CheckBox</classname> component, and each radio "
"button the <literal>v-radiobutton</literal> style. Both the radio buttons "
"and check boxes will also have the <literal>v-select-option</literal> style "
"that allows styling regardless of the option type. Disabled items have "
"additionally the <literal>v-disabled</literal> style."
msgstr ""
"<literal>v-select-optiongroup</literal> 是这个组件的最外层样式. 各个 Check "
"Box 将带有 <literal>v-checkbox</literal> 样式, 借用自 <classname>CheckBox</"
"classname> 组件, 各个 Radio Button 带有 <literal>v-radiobutton</literal> 样"
"式. Radio button 和 Check Box 都带有 <literal>v-select-option</literal> 样"
"式, 无论组件是单选还是多选模式, 都可以使用这个样式进行样式控制. 禁用的项目将"
"额外带有 <literal>v-disabled</literal> 样式."

#. Tag: para
#: chapter-components.xml:3971
#, no-c-format
msgid ""
"The options are normally laid out vertically. You can use horizontal layout "
"by setting <literal>display: inline-block</literal> for the options. The "
"<literal>nowrap</literal> setting for the overall element prevents wrapping "
"if there is not enough horizontal space in the layout, or if the horizontal "
"width is undefined."
msgstr ""
"选择项目通常是垂直排列的. 你可以让它们变为水平排列, 方法是为其设置 "
"<literal>display: inline-block</literal> 样式. 如果布局组件在水平方向上空间不"
"足, 或者水平宽度未指定时, 选项通常会换行表示, 对最外层元素设置 "
"<literal>nowrap</literal> 样式可以禁止换行."

#. Tag: programlisting
#: chapter-components.xml:3979
#, no-c-format
msgid ""
"<![CDATA[/* Lay the options horizontally */\n"
".v-select-optiongroup-horizontal .v-select-option {\n"
"    display: inline-block;\n"
"}\n"
"\n"
"/* Avoid wrapping if the layout is too tight */\n"
".v-select-optiongroup-horizontal {\n"
"    white-space: nowrap;\n"
"}\n"
"\n"
"/* Some extra spacing is needed */\n"
".v-select-optiongroup-horizontal\n"
"  .v-select-option.v-radiobutton {\n"
"    padding-right: 10px;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:3981
#, no-c-format
msgid ""
"Use of the above rules requires setting a custom <literal>horizontal</"
"literal> style name for the component. The result is shown in <xref linkend="
"\"figure.components.optiongroup.horizontal\"/>."
msgstr ""
"要使用上面的样式规则, 需要对组件设置一个自定义的 <literal>horizontal</"
"literal> 样式名称. 运行结果见 <xref linkend=\"figure.components.optiongroup."
"horizontal\"/>."

#. Tag: title
#: chapter-components.xml:3989
#, no-c-format
msgid "Horizontal <classname>OptionGroup</classname>"
msgstr "水平排列的 <classname>OptionGroup</classname>"

#. Tag: classname
#: chapter-components.xml:4001
#, no-c-format
msgid "TwinColSelect"
msgstr ""

#. Tag: para
#: chapter-components.xml:4003
#, no-c-format
msgid ""
"The <classname>TwinColSelect</classname> field provides a multiple selection "
"component that shows two lists side by side, with the left column containing "
"unselected items and the right column the selected items. The user can "
"select items from the list on the left and click on the \"&gt;&gt;\" button "
"to move them to the list on the right. Items can be deselected by selecting "
"them in the right list and clicking on the \"&lt;&lt;\" button."
msgstr ""
"<classname>TwinColSelect</classname> 是一个多选组件, 它并列显示两个列表框, 左"
"侧是未选择的项目, 右侧是已选择的项目. 用户可以从左侧列表选择项目, 然后点击 "
"\"&gt;&gt;\" 按钮将它移动到右侧列表中. 取消选择一个项目, 可以在右侧列表选中"
"它, 然后点击 \"&lt;&lt;\" 按钮."

#. Tag: title
#: chapter-components.xml:4013
#, no-c-format
msgid "Twin Column Selection"
msgstr "双列选择组件"

#. Tag: para
#: chapter-components.xml:4021
#, no-c-format
msgid ""
"<classname>TwinColSelect</classname> is always in multi-select mode, so its "
"property value is always a collection of the item IDs of the selected items, "
"that is, the items in the right column."
msgstr ""
"<classname>TwinColSelect</classname> 永远是多选模式, 因此它的属性值永远是被选"
"中项目 ID 的集合, 也就是它右侧列表中项目的 ID 集合."

#. Tag: para
#: chapter-components.xml:4027
#, no-c-format
msgid ""
"The selection columns can have their own captions, separate from the overall "
"component caption, which is managed by the containing layout. You can set "
"the column captions with <methodname>setLeftColumnCaption()</methodname> and "
"<methodname>setRightColumnCaption()</methodname>."
msgstr ""
"除整个组件的标题(由所属的布局来管理)之外, 左侧和右侧选择列也可以有自己的标"
"题. 你可以使用 <methodname>setLeftColumnCaption()</methodname> 和 "
"<methodname>setRightColumnCaption()</methodname> 方法来设置选择列的标题."

#. Tag: programlisting
#: chapter-components.xml:4035
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[TwinColSelect select = new "
"TwinColSelect(\"Select Targets\");\n"
"\n"
"// Put some items in the select\n"
"select.addItems(\"Mercury\", \"Venus\", \"Earth\", \"Mars\",\n"
"        \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\");\n"
"\n"
"// Few items, so we can set rows to match item count\n"
"select.setRows(select.size());\n"
"\n"
"// Preselect a few items by creating a set\n"
"select.setValue(new HashSet<String>(\n"
"    Arrays.asList(\"Venus\", \"Earth\", \"Mars\")));\n"
"\n"
"// Handle value changes\n"
"select.addValueChangeListener(event -> // Java 8\n"
"    layout.addComponent(new Label(\"Selected: \" +\n"
"            event.getProperty().getValue())));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4037
#, no-c-format
msgid ""
"The resulting component is shown in <xref linkend=\"figure.components."
"twincolselect.basic\"/>."
msgstr ""
"运行结果参见 <xref linkend=\"figure.components.twincolselect.basic\"/>."

#. Tag: para
#: chapter-components.xml:4042
#, no-c-format
msgid ""
"The <methodname>setRows()</methodname> method sets the height of the "
"component by the number of visible items in the selection boxes. Setting the "
"height with <methodname>setHeight()</methodname> to a defined value "
"overrides the rows setting."
msgstr ""
"<methodname>setRows()</methodname> 方法设置组件的高度, 单位是选择框中可见项目"
"的数量. 使用 <methodname>setHeight()</methodname> 方法设置高度, 会覆盖掉行数"
"设定."

#. Tag: programlisting
#: chapter-components.xml:4057
#, no-c-format
msgid ""
"<![CDATA[.v-select-twincol {}\n"
"  .v-select-twincol-options-caption {}\n"
"  .v-select-twincol-selections-caption {}\n"
"  .v-select-twincol-options {}\n"
"  .v-select-twincol-buttons {}\n"
"    .v-button {}\n"
"      .v-button-wrap {}\n"
"        .v-button-caption {}\n"
"    .v-select-twincol-deco {}\n"
"  .v-select-twincol-selections {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4059
#, no-c-format
msgid ""
"The <classname>TwinColSelect</classname> component has an overall <literal>v-"
"select-twincol</literal> style. If set, the left and right column captions "
"have <literal>v-select-twincol-options-caption</literal> and <literal>v-"
"select-twincol-options-caption</literal> style names, respectively. The left "
"box, which displays the unselected items, has <literal>v-select-twincol-"
"options-caption</literal> style and the right box, which displays the "
"selected items, has <literal>v-select-twincol-options-selections</literal> "
"style. Between them is the button area, which has overall <literal>v-select-"
"twincol-buttons</literal> style; the actual buttons reuse the styles for the "
"<classname>Button</classname> component. Between the buttons is a divider "
"element with <literal>v-select-twincol-deco</literal> style."
msgstr ""
"<classname>TwinColSelect</classname> 组件的最外层样式为 <literal>v-select-"
"twincol</literal>. 如果左侧和右侧列表的标题有设定, 标题的样式将分别是 "
"<literal>v-select-twincol-options-caption</literal> 和 <literal>v-select-"
"twincol-options-caption</literal>. 左侧列表显示未选择的项目, 样式为 "
"<literal>v-select-twincol-options-caption</literal>, 右侧列表显示已选择的项"
"目, 样式为 <literal>v-select-twincol-options-selections</literal> . 这两个列"
"表之间是按钮栏, 其最外层样式为 <literal>v-select-twincol-buttons</literal>; "
"实际的按钮共用 <classname>Button</classname> 组件的样式. 按钮之间是分隔元素, "
"样式为 <literal>v-select-twincol-deco</literal>."

#. Tag: classname
#: chapter-components.xml:4083 chapter-components.xml:4086
#, no-c-format
msgid "Table"
msgstr "Table"

#. Tag: para
#: chapter-components.xml:4089
#, no-c-format
msgid ""
"The <classname>Table</classname> component is intended for presenting "
"tabular data organized in rows and columns. The <classname>Table</classname> "
"is one of the most versatile components in Vaadin. Table cells can include "
"text or arbitrary UI components. You can easily implement editing of the "
"table data, for example clicking on a cell could change it to a text field "
"for editing."
msgstr ""
"<classname>Table</classname> 组件的目的是以行和列的形式表现表格式的数据. "
"<classname>Table</classname> 是 Vaadin 中最通用的组件之一. Table 的单元格可以"
"包含文字, 或者任意的其他组件. 你可以很简便地实现 Table 内的数据编辑, 比如, 点"
"击一个单元格可以将它变为一个文本输入框, 然后就可以编辑这条数据."

#. Tag: para
#: chapter-components.xml:4097
#, no-c-format
msgid ""
"The data contained in a <classname>Table</classname> is managed using the "
"Data Model of Vaadin (see <xref linkend=\"datamodel\"/>), through the "
"<classname>Container</classname> interface of the <classname>Table</"
"classname>. This makes it possible to bind a table directly to a data "
"source, such as a database query. Only the visible part of the table is "
"loaded into the browser and moving the visible window with the scrollbar "
"loads content from the server. While the data is being loaded, a tooltip "
"will be displayed that shows the current range and total number of items in "
"the table. The rows of the table are <emphasis>items</emphasis> in the "
"container and the columns are <emphasis>properties</emphasis>. Each table "
"row (item) is identified with an <emphasis>item identifier</emphasis> (IID), "
"and each column (property) with a <emphasis>property identifier</emphasis> "
"(PID)."
msgstr ""
"<classname>Table</classname> 内包含的数据是使用 Vaadin 数据模型(参见 <xref "
"linkend=\"datamodel\"/>)来管理的, 具体来说是通过 <classname>Table</"
"classname> 类的 <classname>Container</classname> 接口. 因此 Table 可以直接绑"
"定到一个数据源, 比如一个数据库查询. 只有在 Table 内可见的部分会被装载进浏览器"
"中, 使用滚动条移动可见区域会从服务器端装载新的数据内容. 数据装载完毕后, 会显"
"示一个提示信息, 其中包括 Table 内项目的总件数, 以及当前显示的项目范围. Table "
"的行就是容器内的 <emphasis>项目(item)</emphasis> , Table 的列则是项目的 "
"<emphasis>属性(property)</emphasis>. Table 的各行(项目) 使用 <emphasis>项目 "
"ID(item identifier)</emphasis> (IID) 来区分, 各列(property) 使用 <emphasis>属"
"性 ID(property identifier)</emphasis> (PID) 来区分."

#. Tag: para
#: chapter-components.xml:4112
#, no-c-format
msgid ""
"When creating a table, you first need to define columns with "
"<methodname>addContainerProperty()</methodname>. This method comes in two "
"flavors. The simpler one takes the property ID of the column and uses it "
"also as the caption of the column. The more complex one allows differing PID "
"and header for the column. This may make, for example, internationalization "
"of table headers easier, because if a PID is internationalized, the "
"internationalization has to be used everywhere where the PID is used. The "
"complex form of the method also allows defining an icon for the column from "
"a resource. The \"default value\" parameter is used when new properties "
"(columns) are added to the table, to fill in the missing values. (This "
"default has no meaning in the usual case, such as below, where we add items "
"after defining the properties.)"
msgstr ""
"创建 Table 时, 你首先需要使用<methodname>addContainerProperty()</methodname> "
"方法定义列. 这个方法有两种使用形式. 较简单的形式接受列的属性 ID 作为参数, 并"
"且将属性 ID 用作列标题. 较复杂的形式可以将列的属性 ID 和标题区别开. 这可以使"
"得对 Table 的表头文字进行国际化更容易一些, 因为如果 PID 被国际化了, 那么这个 "
"PID 出现的一切地方都要进行同样的国际化. 这个方法的较复杂的形式还允许为列定义"
"图标资源. 当新的属性(列)添加到 Table 中时, 会使用 \"默认值\" 参数来填充未指定"
"的项目值. (通常情况下这个默认值并没有什么意义, 如下例所示, 我们在定义属性之后"
"再添加项目.)"

#. Tag: programlisting
#: chapter-components.xml:4127
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[Table table = new Table(\"The Brightest Stars"
"\");\n"
"\n"
"// Define two columns for the built-in container\n"
"table.addContainerProperty(\"Name\", String.class, null);\n"
"table.addContainerProperty(\"Mag\",  Float.class, null);\n"
"\n"
"// Add a row the hard way\n"
"Object newItemId = table.addItem();\n"
"Item row1 = table.getItem(newItemId);\n"
"row1.getItemProperty(\"Name\").setValue(\"Sirius\");\n"
"row1.getItemProperty(\"Mag\").setValue(-1.46f);\n"
"\n"
"// Add a few other rows using shorthand addItem()\n"
"table.addItem(new Object[]{\"Canopus\",        -0.72f}, 2);\n"
"table.addItem(new Object[]{\"Arcturus\",       -0.04f}, 3);\n"
"table.addItem(new Object[]{\"Alpha Centauri\", -0.01f}, 4);\n"
"\n"
"// Show exactly the currently contained rows (items)\n"
"table.setPageLength(table.size());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4129
#, no-c-format
msgid ""
"In this example, we used an increasing <classname>Integer</classname> object "
"as the Item Identifier, given as the second parameter to "
"<methodname>addItem()</methodname>. The actual rows are given simply as "
"object arrays, in the same order in which the properties were added. The "
"objects must be of the correct class, as defined in the "
"<methodname>addContainerProperty()</methodname> calls."
msgstr ""
"上面的例子中, 我们使用一个序列增长的 <classname>Integer</classname> 对象作为"
"项目 ID, 项目 ID 作为 <methodname>addItem()</methodname> 的第 2 个参数. 实际"
"的行以简单的对象数组的形式表达, 数组内数据的顺序与我们定义的属性顺序一致. 各"
"个数据对象的类型必须正确, 各属性的值数据类型通过 "
"<methodname>addContainerProperty()</methodname> 方法指定."

#. Tag: title
#: chapter-components.xml:4139
#, no-c-format
msgid "Basic Table Example"
msgstr "Table 的基本示例"

#. Tag: para
#: chapter-components.xml:4147
#, no-c-format
msgid ""
"Scalability of the <classname>Table</classname> is largely dictated by the "
"container. The default <classname>IndexedContainer</classname> is relatively "
"heavy and can cause scalability problems, for example, when updating the "
"values. Use of an optimized application-specific container is recommended. "
"Table does not have a limit for the number of items and is just as fast with "
"hundreds of thousands of items as with just a few. With the current "
"implementation of scrolling, there is a limit of around 500 000 rows, "
"depending on the browser and the pixel height of rows."
msgstr ""
"<classname>Table</classname> 的可扩展性(Scalability)很大程度上由容器决定. 默"
"认的 <classname>IndexedContainer</classname> 类相对来说比较重, 某些时候, 比如"
"更新数据值时, 可能导致可扩展性问题. 我们推荐你使用一种为你的应用程序专门优化"
"过的容器. Table 对于项目的数量没有限制, 对于几十万条数据, 它也和只有几条数据"
"时一样运行迅速. 如果使用滚动功能的当前实现, 会有大约 50 万行左右的数量限制, "
"具体数字取决于浏览器和各行的高度."

#. Tag: title
#: chapter-components.xml:4165
#, no-c-format
msgid "Selecting Items in a Table"
msgstr "在 Table 内选择项目"

#. Tag: para
#: chapter-components.xml:4167
#, no-c-format
msgid ""
"The <classname>Table</classname> allows selecting one or more items by "
"clicking them with the mouse. When the user selects an item, the IID of the "
"item will be set as the property of the table and a "
"<classname>ValueChangeEvent</classname> is triggered. To enable selection, "
"you need to set the table <emphasis>selectable</emphasis>. You will also "
"need to set it as <emphasis>immediate</emphasis> in most cases, as we do "
"below, because without it, the change in the property will not be "
"communicated immediately to the server."
msgstr ""
"在 <classname>Table</classname> 中可以通过鼠标点击来选择一个或多个项目. 当用"
"户选择一个项目时, 项目的 IID 会被设置为 Table 的属性值, 同时触发 "
"<classname>ValueChangeEvent</classname> 事件. 你需要将 Table 设置为 "
"<emphasis>可选择</emphasis>, 才能允许选择 Table 内的项目. 大多数情况下, 你还"
"需要将 Table 设置为 <emphasis>立即模式</emphasis>, 如下例所示, 因为如果不是立"
"即模式, 属性的变化不会立即发送到服务器端."

#. Tag: para
#: chapter-components.xml:4178
#, no-c-format
msgid ""
"The following example shows how to enable the selection of items in a "
"<classname>Table</classname> and how to handle <classname>ValueChangeEvent</"
"classname> events that are caused by changes in selection. You need to "
"handle the event with the <methodname>valueChange()</methodname> method of "
"the <classname>Property.ValueChangeListener</classname> interface."
msgstr ""
"下面的例子演示如何允许在 <classname>Table</classname> 内选择项目, 以及如何处"
"理由选择项变化造成的 <classname>ValueChangeEvent</classname> 事件. 你需要使"
"用 <classname>Property.ValueChangeListener</classname> 接口的 "
"<methodname>valueChange()</methodname> 方法来处理这个事件."

#. Tag: programlisting
#: chapter-components.xml:4187
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Allow selecting items from the table.\n"
"table.setSelectable(true);\n"
"\n"
"// Send changes in selection immediately to server.\n"
"table.setImmediate(true);\n"
"\n"
"// Shows feedback from selection.\n"
"final Label current = new Label(\"Selected: -\");\n"
"\n"
"// Handle selection change.\n"
"table.addValueChangeListener(new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        current.setValue(\"Selected: \" + table.getValue());\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:4190
#, no-c-format
msgid "Table Selection Example"
msgstr "Table 内项目选择的示例"

#. Tag: para
#: chapter-components.xml:4198
#, no-c-format
msgid ""
"If the user clicks on an already selected item, the selection will "
"deselected and the table property will have <parameter>null</parameter> "
"value. You can disable this behaviour by setting "
"<methodname>setNullSelectionAllowed(false)</methodname> for the table."
msgstr ""
"如果用户点击一个已经选中的项目, 那么这个项目会取消选中, Table 的属性值将成为 "
"<parameter>null</parameter>. 你可以通过 "
"<methodname>setNullSelectionAllowed(false)</methodname> 来禁止这种行为."

#. Tag: para
#: chapter-components.xml:4205
#, no-c-format
msgid ""
"The selection is the value of the table's property, so you can get it with "
"<methodname>getValue()</methodname>. You can get it also from a reference to "
"the table itself. In single selection mode, the value is the item identifier "
"of the selected item or <parameter>null</parameter> if no item is selected. "
"In multiple selection mode (see below), the value is a <classname>Set</"
"classname> of item identifiers. Notice that the set is unmodifiable, so you "
"can not simply change it to change the selection."
msgstr ""
"选中的项目就是 Table 的属性的值, 因此你可以通过 <methodname>getValue()</"
"methodname> 得到它. 你同样可以通过 Table 本身得到它. 单选模式下, 这个值是被选"
"中的项目的 ID, 如果没有项目被选中的话, 就是 <parameter>null</parameter>. 在多"
"选模式下(见下文), 属性值是项目 ID 组成的 <classname>Set</classname>. 注意这个"
"集合是不可修改的, 因此你不可以通过改变这个集合的内容来改变项目的选中状态."

#. Tag: title
#: chapter-components.xml:4216
#, no-c-format
msgid "Multiple Selection Mode"
msgstr "多选模式"

#. Tag: para
#: chapter-components.xml:4218
#, no-c-format
msgid ""
"A table can also be in <emphasis>multiselect</emphasis> mode, where a user "
"can select multiple items by clicking them with left mouse button while "
"holding the <keycap>Ctrl</keycap> key (or <keycap>Meta</keycap> key) "
"pressed. If <keycap>Ctrl</keycap> is not held, clicking an item will select "
"it and other selected items are deselected. The user can select a range by "
"selecting an item, holding the <keycap>Shift</keycap> key pressed, and "
"clicking another item, in which case all the items between the two are also "
"selected. Multiple ranges can be selected by first selecting a range, then "
"selecting an item while holding <keycap>Ctrl</keycap>, and then selecting "
"another item with both <keycap>Ctrl</keycap> and <keycap>Shift</keycap> "
"pressed."
msgstr ""
"Table 也可以处于 <emphasis>多选</emphasis> 模式, 这时用户可以按住 "
"<keycap>Ctrl</keycap> 键(或 <keycap>Meta</keycap> 键)不放, 然后鼠标点击多个项"
"目来选择它们. 如果 <keycap>Ctrl</keycap> 键不按下, 点击一个项目会选中它, 但其"
"他被选中的项目会被取消选中. 用户可以选择一个范围内的所有项目, 方法是先选中一"
"个项目, 按住 <keycap>Shift</keycap> 键不放, 然后点击另一个项目, 这两个项目之"
"间的所有项目都会被选中. 还可以选择多个范围, 方法是先选中一个范围, 然后按住 "
"<keycap>Ctrl</keycap> 键不放, 再同时按住 <keycap>Ctrl</keycap> 和 "
"<keycap>Shift</keycap> 键不放, 选择另一个项目."

#. Tag: para
#: chapter-components.xml:4233
#, no-c-format
msgid ""
"The multiselect mode is enabled with the <methodname>setMultiSelect()</"
"methodname> method of the <classname>AbstractSelect</classname> superclass "
"of <classname>Table</classname>. Setting table in multiselect mode does not "
"implicitly set it as <emphasis>selectable</emphasis>, so it must be set "
"separately."
msgstr ""
"使用 <classname>Table</classname> 的基类 <classname>AbstractSelect</"
"classname> 中的 <methodname>setMultiSelect()</methodname> 方法可以打开多选模"
"式. 将 Table 设为多选模式不会隐含地将它设置为 <emphasis>可选择</emphasis>, 因"
"此还必须设置 Table 为可选择."

#. Tag: para
#: chapter-components.xml:4242
#, no-c-format
msgid ""
"The <methodname>setMultiSelectMode()</methodname> property affects the "
"control of multiple selection: <parameter>MultiSelectMode.DEFAULT</"
"parameter> is the default behaviour, which requires holding the "
"<keycap>Ctrl</keycap> (or <keycap>Meta</keycap>) key pressed while selecting "
"items, while in <parameter>MultiSelectMode.SIMPLE</parameter> holding the "
"<keycap>Ctrl</keycap> key is not needed. In the simple mode, items can only "
"be deselected by clicking them."
msgstr ""
"<methodname>setMultiSelectMode()</methodname> 方法决定多选的控制模式: "
"<parameter>MultiSelectMode.DEFAULT</parameter> 是默认模式, 这种模式下选择项目"
"需要按住 <keycap>Ctrl</keycap> (或 <keycap>Meta</keycap>) 键不放, "
"<parameter>MultiSelectMode.SIMPLE</parameter> 模式下则不需要按住 "
"<keycap>Ctrl</keycap> 键. 在 simple 模式下, 要取消一个已选中的项目, 必须再次"
"点击它."

#. Tag: title
#: chapter-components.xml:4256
#, no-c-format
msgid "Table Features"
msgstr "Table 的功能"

#. Tag: title
#: chapter-components.xml:4259
#, no-c-format
msgid "Page Length and Scrollbar"
msgstr "页长与滚动条"

#. Tag: para
#: chapter-components.xml:4261
#, no-c-format
msgid ""
"The default style for <classname>Table</classname> provides a table with a "
"scrollbar. The scrollbar is located at the right side of the table and "
"becomes visible when the number of items in the table exceeds the page "
"length, that is, the number of visible items. You can set the page length "
"with <methodname>setPageLength()</methodname>."
msgstr ""
"<classname>Table</classname> 的默认风格是一个带滚动条的表格. 滚动条在表格的右"
"侧, 只在 Table 内项目的数量超过页长时才显示, 页长也就是可见项目的数量. 你可以"
"使用 <methodname>setPageLength()</methodname> 方法设置页长."

#. Tag: para
#: chapter-components.xml:4269
#, no-c-format
msgid ""
"Setting the page length to zero makes all the rows in a table visible, no "
"matter how many rows there are. Notice that this also effectively disables "
"buffering, as all the entire table is loaded to the browser at once. Using "
"such tables to generate reports does not scale up very well, as there is "
"some inevitable overhead in rendering a table with Ajax. For very large "
"reports, generating HTML directly is a more scalable solution."
msgstr ""
"将页长设置为 0 , 会显示 Table 内所有项目, 无论项目数量有多大. 注意, 这样的设"
"置也会导致缓冲功能失效, 因为 Tabel 内所有数据都必须一次性装载到浏览器端. 使用"
"这样的 Table 来生成报表不适用于大量数据的情况, 因为它会在使用 Ajax 描绘 "
"Table 时出现大量的数据传输. 对于大量数据的报表, 直接生成 HTML 内容会更高效一"
"些."

#. Tag: title
#: chapter-components.xml:4281 chapter-components.xml:4306
#, no-c-format
msgid "Resizing Columns"
msgstr "拖动列的宽度"

#. Tag: para
#: chapter-components.xml:4283
#, no-c-format
msgid ""
"You can set the width of a column programmatically from the server-side with "
"<methodname>setColumnWidth()</methodname>. The column is identified by the "
"property ID and the width is given in pixels."
msgstr ""
"你可以在服务器端程序中使用<methodname>setColumnWidth()</methodname> 方法设置"
"列的宽度 . 列通过对应的属性 ID 来标识, 宽度单位为像素."

#. Tag: para
#: chapter-components.xml:4289
#, no-c-format
msgid ""
"The user can resize table columns by dragging the resize handle between two "
"columns. Resizing a table column causes a <classname>ColumnResizeEvent</"
"classname>, which you can handle with a <classname>Table."
"ColumnResizeListener</classname>. The table must be set in immediate mode if "
"you want to receive the resize events immediately, which is typical."
msgstr ""
"用户也可以拖动两列之间的 resize 条来调整 Table 的列宽. 重新调整列宽会激发 "
"<classname>ColumnResizeEvent</classname> 事件, 这个事件可以通过 "
"<classname>Table.ColumnResizeListener</classname> 监听器来处理. 通常你会希望"
"立即收到列宽变化的事件, 这时 Table 必须设置为立即模式."

#. Tag: programlisting
#: chapter-components.xml:4298
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[table.addColumnResizeListener(new Table."
"ColumnResizeListener(){\n"
"    public void columnResize(ColumnResizeEvent event) {\n"
"        // Get the new width of the resized column\n"
"        int width = event.getCurrentWidth();\n"
"        \n"
"        // Get the property ID of the resized column\n"
"        String column = (String) event.getPropertyId();\n"
"\n"
"        // Do something with the information\n"
"        table.setColumnFooter(column, String.valueOf(width) + \"px\");\n"
"    }\n"
"});\n"
"        \n"
"// Must be immediate to send the resize events immediately\n"
"table.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4300
#, no-c-format
msgid ""
"See <xref linkend=\"figure.component.table.columnresize\"/> for a result "
"after the columns of a table has been resized."
msgstr ""
"<xref linkend=\"figure.component.table.columnresize\"/> 是 Table 的列宽被调整"
"过之后的结果."

#. Tag: title
#: chapter-components.xml:4316
#, no-c-format
msgid "Reordering Columns"
msgstr "拖动列的顺序"

#. Tag: para
#: chapter-components.xml:4318
#, no-c-format
msgid ""
"If <methodname>setColumnReorderingAllowed(true)</methodname> is set, the "
"user can reorder table columns by dragging them with the mouse from the "
"column header,"
msgstr ""
"如果设置了 <methodname>setColumnReorderingAllowed(true)</methodname>, 用户可"
"以调整 Table 内列的顺序, 方法是用鼠标拖动列头部分."

#. Tag: title
#: chapter-components.xml:4326 chapter-components.xml:4351
#, no-c-format
msgid "Collapsing Columns"
msgstr "将列收起"

#. Tag: para
#: chapter-components.xml:4328
#, no-c-format
msgid ""
"When <methodname>setColumnCollapsingAllowed(true)</methodname> is set, the "
"right side of the table header shows a drop-down list that allows selecting "
"which columns are shown. Collapsing columns is different than hiding columns "
"with <methodname>setVisibleColumns()</methodname>, which hides the columns "
"completely so that they can not be made visible (uncollapsed) from the user "
"interface."
msgstr ""
"如果设置了 <methodname>setColumnCollapsingAllowed(true)</methodname>, Table "
"头部的右侧会显示一个下拉列表框, 在这个列表框中可以选择显示哪些列. 将列收起, "
"与使用 <methodname>setVisibleColumns()</methodname> 方法将列隐藏起来是不同"
"的, 后一种方法会导致列完全被隐藏, 用户不能通过 UI 操作将这个列显示出来."

#. Tag: para
#: chapter-components.xml:4337
#, no-c-format
msgid ""
"You can collapse columns programmatically with "
"<methodname>setColumnCollapsed()</methodname>. Collapsing must be enabled "
"before collapsing columns with the method or it will throw an "
"<classname>IllegalAccessException</classname>."
msgstr ""
"你可以通过程序使用 <methodname>setColumnCollapsed()</methodname> 方法将列收"
"起. 将列收起之前, 必须用前面介绍的方法将 Table 设置为可收起模式, 否则将抛出 "
"<classname>IllegalAccessException</classname> 例外."

#. Tag: programlisting
#: chapter-components.xml:4344
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Allow the user to collapse and uncollapse "
"columns\n"
"table.setColumnCollapsingAllowed(true);\n"
"\n"
"// Collapse this column programmatically\n"
"try {\n"
"    table.setColumnCollapsed(\"born\", true);\n"
"} catch (IllegalAccessException e) {\n"
"    // Can't occur - collapsing was allowed above\n"
"    System.err.println(\"Something horrible occurred\");\n"
"}\n"
"        \n"
"// Give enough width for the table to accommodate the\n"
"// initially collapsed column later\n"
"table.setWidth(\"250px\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4346
#, no-c-format
msgid "See <xref linkend=\"figure.component.table.columncollapsing\"/>."
msgstr ""
"运行结果见 <xref linkend=\"figure.component.table.columncollapsing\"/>."

#. Tag: para
#: chapter-components.xml:4359
#, no-c-format
msgid ""
"If the table has undefined width, it minimizes its width to fit the width of "
"the visible columns. If some columns are initially collapsed, the width of "
"the table may not be enough to accomodate them later, which will result in "
"an ugly horizontal scrollbar. You should consider giving the table enough "
"width to accomodate columns uncollapsed by the user."
msgstr ""
"如果不指定 Table 的宽度, 它会将自己的宽度最小化到与可见的列相适应的程度. 如果"
"某些列初始化就是被收起的, 那么这些列再次展开之后, Table 的宽度可能会不足以显"
"示它们, 这时会出现一个难看的水平滚动条. 为了避免这种情况, 你需要考虑为 Table "
"设置足够的宽度, 以便显示被用户展开后的列."

#. Tag: title
#: chapter-components.xml:4370
#, no-c-format
msgid "Components Inside a Table"
msgstr "Table 内的组件"

#. Tag: para
#: chapter-components.xml:4372
#, no-c-format
msgid ""
"The cells of a <classname>Table</classname> can contain any user interface "
"components, not just strings. If the rows are higher than the row height "
"defined in the default theme, you have to define the proper row height in a "
"custom theme."
msgstr ""
"<classname>Table</classname> 内的单元格不仅可以显示字符串, 而且可以包含任意"
"的 UI 组件. 如果行的高度超过默认 theme 定义的行高, 那么你就需要使用自定义 "
"theme 来定义适当的行高."

#. Tag: para
#: chapter-components.xml:4379
#, no-c-format
msgid ""
"When handling events for components inside a <classname>Table</classname>, "
"such as for the <classname>Button</classname> in the example below, you "
"usually need to know the item the component belongs to. Components do not "
"themselves know about the table or the specific item in which a component is "
"contained. Therefore, the handling method must use some other means for "
"finding out the Item ID of the item. There are a few possibilities. Usually "
"the easiest way is to use the <methodname>setData()</methodname> method to "
"attach an arbitrary object to a component. You can subclass the component "
"and include the identity information there. You can also simply search the "
"entire table for the item with the component, although that solution may not "
"be so scalable."
msgstr ""
"对于 <classname>Table</classname> 内的组件, 比如下例中的 <classname>Button</"
"classname>, 当你处理它的事件时, 你需要知道这个组件所属的项目. 组件本身是不知"
"道 Table 的, 也不知道组件所属的项目. 因此, 事件处理代码需要使用其他手段来确定"
"当前项目 的 ID. 可能的方法有几种. 通常最简单的办法是使用 "
"<methodname>setData()</methodname> 方法将任意对象绑定到组件上. 你也可以继承组"
"件, 然后在子类中存放项目 ID 信息. 你也可以简单地在整个 Table 内搜索组件所属的"
"项目, 不过这种方案的可扩展性可能不太好."

#. Tag: para
#: chapter-components.xml:4395
#, no-c-format
msgid ""
"The example below includes table rows with a <classname>Label</classname> in "
"HTML content mode, a multiline <classname>TextField</classname>, a "
"<classname>CheckBox</classname>, and a <classname>Button</classname> that "
"shows as a link."
msgstr ""
"下联的例子在 Table 的行内嵌入一个 HTML 内容模式的 <classname>Label</"
"classname>, 一个多行的 <classname>TextField</classname>, 一个 "
"<classname>CheckBox</classname>, 以及一个显示为链接风格的 <classname>Button</"
"classname>."

#. Tag: programlisting
#: chapter-components.xml:4403
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a table and add a style to allow "
"setting the row height in theme.\n"
"final Table table = new Table();\n"
"table.addStyleName(\"components-inside\");\n"
"\n"
"/* Define the names and data types of columns.\n"
" * The \"default value\" parameter is meaningless here. */\n"
"table.addContainerProperty(\"Sum\",            Label.class,     null);\n"
"table.addContainerProperty(\"Is Transferred\", CheckBox.class,  null);\n"
"table.addContainerProperty(\"Comments\",       TextField.class, null);\n"
"table.addContainerProperty(\"Details\",        Button.class,    null);\n"
"\n"
"/* Add a few items in the table. */\n"
"for (int i=0; i<100; i++) {\n"
"    // Create the fields for the current table row\n"
"    Label sumField = new Label(String.format(\n"
"                   \"Sum is <b>$%04.2f</b><br/><i>(VAT incl.)</i>\",\n"
"                   new Object[] {new Double(Math.random()*1000)}),\n"
"                               ContentMode.HTML);\n"
"    CheckBox transferredField = new CheckBox(\"is transferred\");\n"
"    \n"
"    // Multiline text field. This required modifying the \n"
"    // height of the table row.\n"
"    TextField commentsField = new TextField();\n"
"    commentsField.setRows(3);\n"
"    \n"
"    // The Table item identifier for the row.\n"
"    Integer itemId = new Integer(i);\n"
"    \n"
"    // Create a button and handle its click. A Button does not\n"
"    // know the item it is contained in, so we have to store the\n"
"    // item ID as user-defined data.\n"
"    Button detailsField = new Button(\"show details\");\n"
"    detailsField.setData(itemId);\n"
"    detailsField.addClickListener(new Button.ClickListener() {\n"
"        public void buttonClick(ClickEvent event) {\n"
"            // Get the item identifier from the user-defined data.\n"
"            Integer iid = (Integer)event.getButton().getData();\n"
"            Notification.show(\"Link \" +\n"
"                              iid.intValue() + \" clicked.\");\n"
"        } \n"
"    });\n"
"    detailsField.addStyleName(\"link\");\n"
"    \n"
"    // Create the table row.\n"
"    table.addItem(new Object[] {sumField, transferredField,\n"
"                                commentsField, detailsField},\n"
"                  itemId);\n"
"}\n"
"\n"
"// Show just three rows because they are so high.\n"
"table.setPageLength(3);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4405
#, no-c-format
msgid ""
"The row height has to be set higher than the default with a style rule such "
"as the following:"
msgstr "行高必须设置为比默认高度更高一些, 方法是使用以下样式规则:"

#. Tag: programlisting
#: chapter-components.xml:4410
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/* Table rows contain three-row TextField "
"components. */\n"
".v-table-components-inside .v-table-cell-content {\n"
"        height: 54px;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4412
#, no-c-format
msgid ""
"The table will look as shown in <xref linkend=\"figure.components.table."
"components-inside\"/>."
msgstr ""
"上面示例的运行结果见 <xref linkend=\"figure.components.table.components-"
"inside\"/>."

#. Tag: title
#: chapter-components.xml:4418
#, no-c-format
msgid "Components in a Table"
msgstr "Table 内嵌的 UI 组件"

#. Tag: title
#: chapter-components.xml:4428
#, no-c-format
msgid "Iterating Over a Table"
msgstr "遍历一个 Table"

#. Tag: para
#: chapter-components.xml:4430
#, no-c-format
msgid ""
"As the items in a <classname>Table</classname> are not indexed, iterating "
"over the items has to be done using an iterator. The "
"<methodname>getItemIds()</methodname> method of the <classname>Container</"
"classname> interface of <classname>Table</classname> returns a "
"<classname>Collection</classname> of item identifiers over which you can "
"iterate using an <classname>Iterator</classname>. For an example about "
"iterating over a <classname>Table</classname>, please see <xref linkend="
"\"datamodel.container\"/>. Notice that you may not modify the "
"<classname>Table</classname> during iteration, that is, add or remove items. "
"Changing the data is allowed."
msgstr ""
"由于 <classname>Table</classname> 内的项目是无下标索引的, 因此要遍历所有的项"
"目必须使用 iterator. <classname>Table</classname> 类的 <classname>Container</"
"classname> 接口的 <methodname>getItemIds()</methodname> 方法返回一个 "
"<classname>Collection</classname>, 其中的内容是项目 ID, 你可以使用 "
"<classname>Iterator</classname> 来遍历这个 Collection. 遍历 "
"<classname>Table</classname> 的例子, 请参见 <xref linkend=\"datamodel."
"container\"/>. 注意, 在遍历过程中你不能修改 <classname>Table</classname> 内"
"容, 也就是说, 不能增加或删除项目. 但修改项目内的数据是允许的."

#. Tag: title
#: chapter-components.xml:4445
#, no-c-format
msgid "Filtering Table Contents"
msgstr "过滤 Table 内容"

#. Tag: para
#: chapter-components.xml:4447
#, no-c-format
msgid ""
"A table can be filtered if its container data source implements the "
"<classname>Filterable</classname> interface, as the default "
"<classname>IndexedContainer</classname> does. See <xref linkend=\"datamodel."
"container.filtered\"/>."
msgstr ""
"如果 Table 的容器数据源实现了 <classname>Filterable</classname> 接口, Table "
"内容可以过滤, 默认的 <classname>IndexedContainer</classname> 是实现了这个接口"
"的. 详情请参见 <xref linkend=\"datamodel.container.filtered\"/>."

#. Tag: primary
#: chapter-components.xml:4453
#, no-c-format
msgid "Container"
msgstr ""

#. Tag: secondary
#: chapter-components.xml:4453
#, no-c-format
msgid "Filterable"
msgstr ""

#. Tag: title
#: chapter-components.xml:4459
#, no-c-format
msgid "Editing the Values in a Table"
msgstr "在 Table 内编辑数据值"

#. Tag: para
#: chapter-components.xml:4461
#, no-c-format
msgid ""
"Normally, a <classname>Table</classname> simply displays the items and their "
"fields as text. If you want to allow the user to edit the values, you can "
"either put them inside components as we did earlier or simply call "
"<methodname>setEditable(true)</methodname>, in which case the cells are "
"automatically turned into editable fields."
msgstr ""
"<classname>Table</classname> 通常只是简单地以文本的方式显示项目中的各字段. 如"
"果你希望允许用户编辑数据值, 你可以象前面的例子一样将各字段放在组件内, 也可以"
"简单地调用 <methodname>setEditable(true)</methodname> 方法, 这时各单元格就会"
"自动地变为可编辑的字段."

#. Tag: para
#: chapter-components.xml:4469
#, no-c-format
msgid ""
"Let us begin with a regular table with a some columns with usual Java types, "
"namely a <classname>Date</classname>, <classname>Boolean</classname>, and a "
"<classname>String</classname>."
msgstr ""
"我们首先来看看一个通常的 Table, 其中包含几个列, 类型为通常的 Java 类型, 一个 "
"<classname>Date</classname>, 一个 <classname>Boolean</classname>, 以及一个 "
"<classname>String</classname>."

#. Tag: programlisting
#: chapter-components.xml:4475
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a table. It is by default not "
"editable.\n"
"final Table table = new Table();\n"
"\n"
"// Define the names and data types of columns.\n"
"table.addContainerProperty(\"Date\",     Date.class,  null);\n"
"table.addContainerProperty(\"Work\",     Boolean.class, null);\n"
"table.addContainerProperty(\"Comments\", String.class,  null);\n"
"\n"
"// Add a few items in the table.\n"
"for (int i=0; i<100; i++) {\n"
"    Calendar calendar = new GregorianCalendar(2008,0,1);\n"
"    calendar.add(Calendar.DAY_OF_YEAR, i);\n"
"    \n"
"    // Create the table row.\n"
"    table.addItem(new Object[] {calendar.getTime(),\n"
"                                new Boolean(false),\n"
"                                \"\"},\n"
"                  new Integer(i)); // Item identifier\n"
"}\n"
"\n"
"table.setPageLength(8);\n"
"layout.addComponent(table);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4477
#, no-c-format
msgid ""
"You could put the table in editable mode right away if you need to. We'll "
"continue the example by adding a mechanism to switch the <classname>Table</"
"classname> from and to the editable mode."
msgstr ""
"如果需要的话, 你立刻就可以将 Table 设置为可编辑模式. 我们下面扩展一下这个例"
"子, 为它增加某种机制, 可以将 <classname>Table</classname> 在可编辑/不可编辑模"
"式之间切换."

#. Tag: programlisting
#: chapter-components.xml:4483
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[final CheckBox switchEditable = new "
"CheckBox(\"Editable\");\n"
"switchEditable.addValueChangeListener(\n"
"        new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        table.setEditable(((Boolean)event.getProperty()\n"
"                             .getValue()).booleanValue());\n"
"    }\n"
"});\n"
"switchEditable.setImmediate(true);\n"
"layout.addComponent(switchEditable);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4485
#, no-c-format
msgid ""
"Now, when you check to checkbox, the components in the table turn into "
"editable fields, as shown in <xref linkend=\"figure.component.table.editable"
"\"/>."
msgstr ""
"现在, 如果你选中 CheckBox, Table 内的组件就会切换到可编辑模式, 见 <xref "
"linkend=\"figure.component.table.editable\"/>."

#. Tag: title
#: chapter-components.xml:4492
#, no-c-format
msgid "A Table in Normal and Editable Mode"
msgstr "处于正常的、可编辑模式的 Table"

#. Tag: title
#: chapter-components.xml:4504
#, no-c-format
msgid "Field Factories"
msgstr "Field 工厂"

#. Tag: para
#: chapter-components.xml:4506
#, no-c-format
msgid ""
"The field components that allow editing the values of particular types in a "
"table are defined in a field factory that implements the "
"<classname>TableFieldFactory</classname> interface. The default "
"implementation is <classname>DefaultFieldFactory</classname>, which offers "
"the following crude mappings:"
msgstr ""
"用于在 Table 内编辑某种特定类型数据的 Field 组件, 是由 Field 工厂创建的, "
"Field 工厂实现 <classname>TableFieldFactory</classname> 接口. 默认实现是 "
"<classname>DefaultFieldFactory</classname> 类, 它提供以下几种粗燥的对应:"

#. Tag: title
#: chapter-components.xml:4515
#, no-c-format
msgid "Type to Field Mappings in <classname>DefaultFieldFactory</classname>"
msgstr ""
"<classname>DefaultFieldFactory</classname> 中, 数据类型与 Field 组件的对应"

#. Tag: entry
#: chapter-components.xml:4519
#, no-c-format
msgid "Property Type"
msgstr "属性数据类型"

#. Tag: entry
#: chapter-components.xml:4520
#, no-c-format
msgid "Mapped to Field Class"
msgstr "对应的 Field 组件类"

#. Tag: classname
#: chapter-components.xml:4525
#, no-c-format
msgid "Date"
msgstr ""

#. Tag: entry
#: chapter-components.xml:4526
#, no-c-format
msgid "A <classname>DateField</classname>."
msgstr "<classname>DateField</classname> 组件."

#. Tag: classname
#: chapter-components.xml:4529
#, no-c-format
msgid "Boolean"
msgstr ""

#. Tag: entry
#: chapter-components.xml:4530
#, no-c-format
msgid "A <classname>CheckBox</classname>."
msgstr "<classname>CheckBox</classname> 组件."

#. Tag: classname
#: chapter-components.xml:4533
#, no-c-format
msgid "Item"
msgstr ""

#. Tag: entry
#: chapter-components.xml:4535
#, no-c-format
msgid ""
"A <classname>Form</classname> (deprecated in Vaadin 7). The fields of the "
"form are automatically created from the item's properties using a "
"<classname>FormFieldFactory</classname>. The normal use for this property "
"type is inside a <classname>Form</classname> and is less useful inside a "
"<classname>Table</classname>."
msgstr ""
"<classname>Form</classname> (Vaadin 7 中已废弃). Form 中的各个 Field 是使用 "
"<classname>FormFieldFactory</classname>, 根据项目各个属性来自动创建的. 这种属"
"性类型更常用于 <classname>Form</classname> 之内, 在 <classname>Table</"
"classname> 内的用途不大."

#. Tag: emphasis
#: chapter-components.xml:4544
#, no-c-format
msgid "other"
msgstr "其他"

#. Tag: entry
#: chapter-components.xml:4546
#, no-c-format
msgid ""
"A <classname>TextField</classname>. The text field manages conversions from "
"the basic types, if possible."
msgstr ""
"<classname>TextField</classname> 组件. 如果从原始数据类型到字符串之间可以正确"
"变换的话, 这个变换工作由 TextField 负责管理."

#. Tag: para
#: chapter-components.xml:4554
#, no-c-format
msgid ""
"Field factories are covered with more detail in <xref linkend=\"datamodel."
"itembinding\"/>. You could just implement the <classname>TableFieldFactory</"
"classname> interface, but we recommend that you extend the "
"<classname>DefaultFieldFactory</classname> according to your needs. In the "
"default implementation, the mappings are defined in the "
"<methodname>createFieldByPropertyType()</methodname> method (you might want "
"to look at the source code) both for tables and forms."
msgstr ""
"Field 工厂的详细介绍请参见 <xref linkend=\"datamodel.itembinding\"/>. 你也可"
"以仅仅实现 <classname>TableFieldFactory</classname> 接口, 但我们推荐你按照自"
"己的需要继承 <classname>DefaultFieldFactory</classname> 类. 在默认的实现类"
"中, 数据类型与 Field 组件之间的对应关系由 "
"<methodname>createFieldByPropertyType()</methodname> 方法决定(你可以会想看看"
"其中的源代码), 不论是对 Table 还是对 Form 都是如此."

#. Tag: title
#: chapter-components.xml:4566
#, no-c-format
msgid "Navigation in Editable Mode"
msgstr "在可编辑模式下跳转"

#. Tag: para
#: chapter-components.xml:4568
#, no-c-format
msgid ""
"In the editable mode, the editor fields can have focus. Pressing "
"<keycap>Tab</keycap> moves the focus to next column or, at the last column, "
"to the first column of the next item. Respectively, pressing "
"<keycombo><keycap>Shift</keycap><keycap>Tab</keycap></keycombo> moves the "
"focus backward. If the focus is in the last column of the last visible item, "
"the pressing <keycap>Tab</keycap> moves the focus outside the table. Moving "
"backward from the first column of the first item moves the focus to the "
"table itself. Some updates to the table, such as changing the headers or "
"footers or regenerating a column, can move the focus from an editor "
"component to the table itself."
msgstr ""
"在可编辑模式下, 编辑器 Field 组件可以拥有输入焦点. 按下 <keycap>Tab</keycap> "
"键可以将焦点移动到下一列, 如果目前已经是最后一列, 那么会移动到下一个项目的第"
"一列. 与此对应, 按下 <keycombo><keycap>Shift</keycap><keycap>Tab</keycap></"
"keycombo> 键会将焦点反向移动. 如果焦点在最后一个可见项目的最后一列, 按下 "
"<keycap>Tab</keycap> 贱会将焦点移动到 Table 之外. 从第一个项目的第一列反向移"
"动焦点, 会将焦点移动到 Table 自身. 对 Table 的某些变更, 比如变更表头, 表脚, "
"恢复一个列, 都可以将焦点从编辑器组件移动到 Table 自身."

#. Tag: para
#: chapter-components.xml:4581
#, no-c-format
msgid ""
"The default behaviour may be undesirable in many cases. For example, the "
"focus also goes through any read-only editor fields and can move out of the "
"table inappropriately. You can provide better navigation is to use event "
"handler for shortcut keys such as <keycap>Tab</keycap>, <keycap>Arrow Up</"
"keycap>, <keycap>Arrow Down</keycap>, and <keycap>Enter</keycap>."
msgstr ""
"很多情况下 Table 的默认行为可能不适应你的需求. 比如, 焦点还会跳转到只读的编辑"
"器组件上, 还会不适当地移出 Table 之外. 你可以实现更好的焦点跳转, 方法是用事件"
"监听器来处理某些快捷键, 比如 <keycap>Tab</keycap>, <keycap>Arrow Up</"
"keycap>, <keycap>Arrow Down</keycap>, 以及 <keycap>Enter</keycap>."

#. Tag: programlisting
#: chapter-components.xml:4590
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Keyboard navigation\n"
"class KbdHandler implements Handler {\n"
"    Action tab_next = new ShortcutAction(\"Tab\",\n"
"            ShortcutAction.KeyCode.TAB, null);\n"
"    Action tab_prev = new ShortcutAction(\"Shift+Tab\",\n"
"            ShortcutAction.KeyCode.TAB,\n"
"            new int[] {ShortcutAction.ModifierKey.SHIFT});\n"
"    Action cur_down = new ShortcutAction(\"Down\",\n"
"            ShortcutAction.KeyCode.ARROW_DOWN, null);\n"
"    Action cur_up   = new ShortcutAction(\"Up\",\n"
"            ShortcutAction.KeyCode.ARROW_UP,   null);\n"
"    Action enter   = new ShortcutAction(\"Enter\",\n"
"            ShortcutAction.KeyCode.ENTER,      null);\n"
"    public Action[] getActions(Object target, Object sender) {\n"
"        return new Action[] {tab_next, tab_prev, cur_down,\n"
"                             cur_up, enter};\n"
"    }\n"
"\n"
"    public void handleAction(Action action, Object sender,\n"
"                             Object target) {\n"
"        if (target instanceof TextField) {\n"
"            // Move according to keypress\n"
"            int itemid = (Integer) ((TextField) target).getData();\n"
"            if (action == tab_next || action == cur_down)\n"
"                itemid++;\n"
"            else if (action == tab_prev || action == cur_up)\n"
"                itemid--;\n"
"            // On enter, just stay where you were. If we did\n"
"            // not catch the enter action, the focus would be\n"
"            // moved to wrong place.\n"
"            \n"
"            if (itemid >= 0 && itemid < table.size()) {\n"
"                TextField newTF = valueFields.get(itemid);\n"
"                if (newTF != null)\n"
"                    newTF.focus();\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"// Panel that handles keyboard navigation\n"
"Panel navigator = new Panel();\n"
"navigator.addStyleName(Reindeer.PANEL_LIGHT);\n"
"navigator.addComponent(table);\n"
"navigator.addActionHandler(new KbdHandler());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4592
#, no-c-format
msgid ""
"The main issue in implementing keyboard navigation in an editable table is "
"that the editor fields do not know the table they are in. To find the parent "
"table, you can either look up in the component container hierarchy or simply "
"store a reference to the table with <methodname>setData()</methodname> in "
"the field component. The other issue is that you can not acquire a reference "
"to an editor field from the <classname>Table</classname> component. One "
"solution is to use some external collection, such as a <classname>HashMap</"
"classname>, to map item IDs to the editor fields."
msgstr ""
"在可编辑的 Table 中使用键盘来跳转焦点, 主要的问题在于编辑器组件意识不到它所在"
"的 Table. 要找出它所在的父 Table, 你可以通过组件的嵌套层次来向上查找, 或者简"
"单地使用 Field 组件的 <methodname>setData()</methodname> 方法来保存它所属的 "
"Table. 另一个问题是, 你无法从 <classname>Table</classname> 组件得到编辑器 "
"Field 组件. 一种解决方法是使用某种额外的 collection, 比如 "
"<classname>HashMap</classname>, 将项目 ID 与编辑器 Field 组件对应起来."

#. Tag: programlisting
#: chapter-components.xml:4604
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Can't access the editable components from "
"the table so\n"
"// must store the information\n"
"final HashMap<Integer,TextField> valueFields =\n"
"    new HashMap<Integer,TextField>();]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4606
#, no-c-format
msgid ""
"The map has to be filled in a <classname>TableFieldFactory</classname>, such "
"as in the following. You also need to set the reference to the table there "
"and you can also set the initial focus there."
msgstr ""
"向这个 Map 填充数据的是 <classname>TableFieldFactory</classname>, 如下例所"
"示. 在这里你还需要设置 table 的参照, 你还可以在这里设置焦点的初始位置."

#. Tag: programlisting
#: chapter-components.xml:4613
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[table.setTableFieldFactory(new "
"TableFieldFactory () {\n"
"    public Field createField(Container container, Object itemId,\n"
"            Object propertyId, Component uiContext) {\n"
"        TextField field = new TextField((String) propertyId);\n"
"        \n"
"        // User can only edit the numeric column\n"
"        if (\"Source of Fear\".equals(propertyId))\n"
"            field.setReadOnly(true);\n"
"        else { // The numeric column\n"
"            // The field needs to know the item it is in\n"
"            field.setData(itemId);\n"
"            \n"
"            // Remember the field\n"
"            valueFields.put((Integer) itemId, field);\n"
"            \n"
"            // Focus the first editable value\n"
"            if (((Integer)itemId) == 0)\n"
"                field.focus();\n"
"        }\n"
"        return field;\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4615
#, no-c-format
msgid ""
"The issues are complicated by the fact that the editor fields are not "
"generated for the entire table, but only for a cache window that includes "
"the visible items and some items above and below it. For example, if the "
"beginning of a big scrollable table is visible, the editor component for the "
"last item does not exist. This issue is relevant mostly if you want to have "
"wrap-around navigation that jumps from the last to first item and vice versa."
msgstr ""
"由于编辑器 Field 组件并没有对 Table 内的全部项目生成出来, 而只对可见项目及其"
"前后少部分项目生成, 因此问题变得更复杂了. 比如, 如果一个很大的可滚动的 Table "
"的最前面部分是可见的, 那么此时最后一个项目的编辑器组件是不存在的. 如果你希望"
"焦点循环滚动, 也就是从最后一个项目跳转到第一个项目, 反之亦然, 那么这个问题会"
"变得很重要."

#. Tag: title
#: chapter-components.xml:4629
#, no-c-format
msgid "Column Headers and Footers"
msgstr "列头和列脚"

#. Tag: para
#: chapter-components.xml:4631
#, no-c-format
msgid ""
"<classname>Table</classname> supports both column headers and footers; the "
"headers are enabled by default."
msgstr "<classname>Table</classname> 同时支持列头和列脚; 列头默认是有效的."

#. Tag: title
#: chapter-components.xml:4637
#, no-c-format
msgid "Headers"
msgstr "列头"

#. Tag: para
#: chapter-components.xml:4639
#, no-c-format
msgid ""
"The table header displays the column headers at the top of the table. You "
"can use the column headers to reorder or resize the columns, as described "
"earlier. By default, the header of a column is the property ID of the "
"column, unless given explicitly with <methodname>setColumnHeader()</"
"methodname>."
msgstr ""
"列头显示在 Table 的最顶端. 前面已经介绍过, 你可以使用列头来拖动列, 或改变列的"
"宽度. 默认情况下, 除非使用 <methodname>setColumnHeader()</methodname> 方法明"
"确地指定列头内容, 否则列头内容为列对应的属性 ID."

#. Tag: programlisting
#: chapter-components.xml:4647
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Define the properties\n"
"table.addContainerProperty(\"lastname\", String.class, null);\n"
"table.addContainerProperty(\"born\", Integer.class, null);\n"
"table.addContainerProperty(\"died\", Integer.class, null);\n"
"\n"
"// Set nicer header names\n"
"table.setColumnHeader(\"lastname\", \"Name\");\n"
"table.setColumnHeader(\"born\", \"Born\");\n"
"table.setColumnHeader(\"died\", \"Died\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4649
#, no-c-format
msgid ""
"The text of the column headers and the visibility of the header depends on "
"the <emphasis>column header mode</emphasis>. The header is visible by "
"default, but you can disable it with <methodname>setColumnHeaderMode(Table."
"COLUMN_HEADER_MODE_HIDDEN)</methodname>."
msgstr ""
"列头的文字以及列头是否可见 取决于 <emphasis>列头模式</emphasis>. 列头默认是可"
"见的, 但你可以使用 <methodname>setColumnHeaderMode(Table."
"COLUMN_HEADER_MODE_HIDDEN)</methodname> 方法禁用它."

#. Tag: title
#: chapter-components.xml:4658
#, no-c-format
msgid "Footers"
msgstr "列脚"

#. Tag: para
#: chapter-components.xml:4660
#, no-c-format
msgid ""
"The table footer can be useful for displaying sums or averages of values in "
"a column, and so on. The footer is not visible by default; you can enable it "
"with <methodname>setFooterVisible(true)</methodname>. Unlike in the header, "
"the column headers are empty by default. You can set their value with "
"<methodname>setColumnFooter()</methodname>. The columns are identified by "
"their property ID."
msgstr ""
"Table 的列脚可用来显示某列的合计或平均值, 等等信息. 列脚默认是不可见的; 你可"
"以使用 <methodname>setFooterVisible(true)</methodname> 方法显示它. 与列头不"
"同, 列头(译注: 原文如此, 应为\"列脚\")默认是空的. 你可以使用 "
"<methodname>setColumnFooter()</methodname> 方法为列脚设置值. 这个方法中, 列通"
"过对应的属性 ID 来指定."

#. Tag: para
#: chapter-components.xml:4670
#, no-c-format
msgid ""
"The following example shows how to calculate average of the values in a "
"column:"
msgstr "下例演示如何计算一个列的平均值:"

#. Tag: programlisting
#: chapter-components.xml:4675
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a table with a numeric column\n"
"Table table = new Table(\"Custom Table Footer\");\n"
"table.addContainerProperty(\"Name\", String.class, null);\n"
"table.addContainerProperty(\"Died At Age\", Integer.class, null);\n"
"        \n"
"// Insert some data\n"
"Object people[][] = {{\"Galileo\",  77},\n"
"                     {\"Monnier\",  83},\n"
"                     {\"Vaisala\",  79},\n"
"                     {\"Oterma\",   86}};\n"
"for (int i=0; i<people.length; i++)\n"
"    table.addItem(people[i], new Integer(i));\n"
"        \n"
"// Calculate the average of the numeric column\n"
"double avgAge = 0;\n"
"for (int i=0; i<people.length; i++)\n"
"    avgAge += (Integer) people[i][1];\n"
"avgAge /= people.length;\n"
"\n"
"// Set the footers\n"
"table.setFooterVisible(true);\n"
"table.setColumnFooter(\"Name\", \"Average\");\n"
"table.setColumnFooter(\"Died At Age\", String.valueOf(avgAge));\n"
"\n"
"// Adjust the table height a bit\n"
"table.setPageLength(table.size());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4677
#, no-c-format
msgid ""
"The resulting table is shown in <xref linkend=\"figure.components.table."
"headersfooters.footer\"/>."
msgstr ""
"运行结果见 <xref linkend=\"figure.components.table.headersfooters.footer\"/>."

#. Tag: title
#: chapter-components.xml:4683
#, no-c-format
msgid "A Table with a Footer"
msgstr "带列脚的 Table"

#. Tag: title
#: chapter-components.xml:4696
#, no-c-format
msgid "Handling Mouse Clicks on Headers and Footers"
msgstr "处理列头和列脚的鼠标点击事件"

#. Tag: para
#: chapter-components.xml:4698
#, no-c-format
msgid ""
"Normally, when the user clicks a column header, the table will be sorted by "
"the column, assuming that the data source is <classname>Sortable</classname> "
"and sorting is not disabled. In some cases, you might want some other "
"functionality when the user clicks the column header, such as selecting the "
"column in some way."
msgstr ""
"通常, 如果数据源是 <classname>Sortable</classname>, 并且排序功能未被禁止, 当"
"用户点击列头时, Table 将按照这个列进行排序. 某些情况下, 你可能希望在用户点击"
"列头时实现一些别的功能, 比如以某种方式选中整个列."

#. Tag: para
#: chapter-components.xml:4706
#, no-c-format
msgid ""
"Clicks in the header cause a <classname>HeaderClickEvent</classname>, which "
"you can handle with a <classname>Table.HeaderClickListener</classname>. "
"Click events on the table header (and footer) are, like button clicks, sent "
"immediately to server, so there is no need to set "
"<methodname>setImmediate()</methodname>."
msgstr ""
"点击列头会激发 <classname>HeaderClickEvent</classname> 事件, 你可以使用 "
"<classname>Table.HeaderClickListener</classname> 监听器来处理. 列头(以及列脚)"
"上的点击事件, 与按钮的点击一样, 会立即发送到服务器端, 因此不必使用 "
"<methodname>setImmediate()</methodname> 方法将 Table 设置为立即模式."

#. Tag: programlisting
#: chapter-components.xml:4715
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Handle the header clicks\n"
"table.addHeaderClickListener(new Table.HeaderClickListener() {\n"
"    public void headerClick(HeaderClickEvent event) {\n"
"        String column = (String) event.getPropertyId();\n"
"        Notification.show(\"Clicked \" + column +\n"
"                \"with \" + event.getButtonName());\n"
"    }\n"
"});\n"
"        \n"
"// Disable the default sorting behavior\n"
"table.setSortDisabled(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4717
#, no-c-format
msgid ""
"Setting a click handler does not automatically disable the sorting behavior "
"of the header; you need to disable it explicitly with "
"<methodname>setSortDisabled(true)</methodname>. Header click events are not "
"sent when the user clicks the column resize handlers to drag them."
msgstr ""
"设置一个点击事件监听器不会自动地将列头的排序动作禁止掉; 你需要调用 "
"<methodname>setSortDisabled(true)</methodname> 来明确地禁止它. 当用户点击列头"
"来调整列宽, 或拖动列的顺序时, 不会触发列头点击事件."

#. Tag: para
#: chapter-components.xml:4726
#, no-c-format
msgid ""
"The <classname>HeaderClickEvent</classname> object provides the identity of "
"the clicked column with <methodname>getPropertyId()</methodname>. The "
"<methodname>getButton()</methodname> reports the mouse button with which the "
"click was made: <parameter>BUTTON_LEFT</parameter>, <parameter>BUTTON_RIGHT</"
"parameter>, or <parameter>BUTTON_MIDDLE</parameter>. The "
"<methodname>getButtonName()</methodname> a human-readable button name in "
"English: \"<parameter>left</parameter>\", \"<parameter>right</parameter>\", "
"or \"<parameter>middle</parameter>\". The <methodname>isShiftKey()</"
"methodname>, <methodname>isCtrlKey()</methodname>, etc., methods indicate if "
"the <keycap>Shift</keycap>, <keycap>Ctrl</keycap>, <keycap>Alt</keycap> or "
"other modifier keys were pressed during the click."
msgstr ""
"<classname>HeaderClickEvent</classname> 对象通过 "
"<methodname>getPropertyId()</methodname> 方法提供被点击的列的 ID. "
"<methodname>getButton()</methodname> 方法报告点击时按下的鼠标键是哪一个: "
"<parameter>BUTTON_LEFT</parameter>, <parameter>BUTTON_RIGHT</parameter>, 或"
"者 <parameter>BUTTON_MIDDLE</parameter>. <methodname>getButtonName()</"
"methodname> 方法返回一个易读的鼠标键英文名: \"<parameter>left</parameter>\", "
"\"<parameter>right</parameter>\", 或者 \"<parameter>middle</parameter>\". "
"<methodname>isShiftKey()</methodname>, <methodname>isCtrlKey()</methodname>, "
"等方法判断 <keycap>Shift</keycap>, <keycap>Ctrl</keycap>, <keycap>Alt</"
"keycap> 等辅助案件在鼠标点击时是否有被按下."

#. Tag: para
#: chapter-components.xml:4744
#, no-c-format
msgid ""
"Clicks in the footer cause a <classname>FooterClickEvent</classname>, which "
"you can handle with a <classname>Table.FooterClickListener</classname>. "
"Footers do not have any default click behavior, like the sorting in the "
"header. Otherwise, handling clicks in the footer is equivalent to handling "
"clicks in the header."
msgstr ""
"点击列脚会激发 <classname>FooterClickEvent</classname> 事件, 你可以使用 "
"<classname>Table.FooterClickListener</classname> 监听器处理. 列头点击后默认会"
"排序, 但列脚点击后没有默认的处理动作. 除了这一点之外, 列脚点击事件的处理与列"
"头点击事件是完全一样的."

#. Tag: title
#: chapter-components.xml:4756
#, no-c-format
msgid "Generated Table Columns"
msgstr "动态生成的列"

#. Tag: para
#: chapter-components.xml:4758
#, no-c-format
msgid ""
"You might want to have a column that has values calculated from other "
"columns. Or you might want to format table columns in some way, for example "
"if you have columns that display currencies. The <classname>ColumnGenerator</"
"classname> interface allows defining custom generators for such columns."
msgstr ""
"你可能会希望某个列的内容由其他列计算而来. 或者你也可能希望用某种方式格式化某"
"个列, 比如, 如果某些列显示货币值的情况. <classname>ColumnGenerator</"
"classname> 接口可以用来为这样的列创建自定义的列生成器."

#. Tag: para
#: chapter-components.xml:4766
#, no-c-format
msgid ""
"You add new generated columns to a <classname>Table</classname> with "
"<methodname>addGeneratedColumn()</methodname>. It takes the column "
"identifier as its parameters. Usually you want to have a more user-friendly "
"and possibly internationalized column header. You can set the header and a "
"possible icon by calling <methodname>addContainerProperty()</methodname> "
"<emphasis>before</emphasis> adding the generated column."
msgstr ""
"你可以使用<methodname>addGeneratedColumn()</methodname> 方法将新生成的列添加"
"到 <classname>Table</classname> 中. 这个方法接受的参数是列 ID. 通常你会希望列"
"头内容更加用户友好一些, 最好能国际化. 在添加新生成的列<emphasis>之前</"
"emphasis>, 你可以使用<methodname>addContainerProperty()</methodname>方法设置"
"列头和图标."

#. Tag: programlisting
#: chapter-components.xml:4776
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Define table columns. \n"
"table.addContainerProperty(\n"
"    \"date\",     Date.class,   null, \"Date\",         null, null);\n"
"table.addContainerProperty(\n"
"    \"quantity\", Double.class, null, \"Quantity (l)\", null, null);\n"
"table.addContainerProperty(\n"
"    \"price\",    Double.class, null, \"Price (e/l)\",  null, null);\n"
"table.addContainerProperty(\n"
"    \"total\",    Double.class, null, \"Total (e)\",    null, null);\n"
"\n"
"// Define the generated columns and their generators.\n"
"table.addGeneratedColumn(\"date\",\n"
"                         new DateColumnGenerator());\n"
"table.addGeneratedColumn(\"quantity\",\n"
"                         new ValueColumnGenerator(\"%.2f l\"));\n"
"table.addGeneratedColumn(\"price\",\n"
"                         new PriceColumnGenerator());\n"
"table.addGeneratedColumn(\"total\",\n"
"                         new ValueColumnGenerator(\"%.2f e\"));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4778
#, no-c-format
msgid ""
"Notice that the <methodname>addGeneratedColumn()</methodname> always places "
"the generated columns as the last column, even if you defined some other "
"order previously. You will have to set the proper order with "
"<methodname>setVisibleColumns()</methodname>."
msgstr ""
"注意, 即使你事先定义了列的顺序, <methodname>addGeneratedColumn()</"
"methodname> 方法永远会将动态创建的列添加为最末列. 你必须使用 "
"<methodname>setVisibleColumns()</methodname> 方法来设置适当的列顺序."

#. Tag: programlisting
#: chapter-components.xml:4785
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[table.setVisibleColumns(new Object[] {\"date\", "
"\"quantity\", \"price\", \"total\"});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4787
#, no-c-format
msgid ""
"The generators are objects that implement the <classname>Table."
"ColumnGenerator</classname> interface and its <methodname>generateCell()</"
"methodname> method. The method gets the identity of the item and column as "
"its parameters, in addition to the table object. It has to return a "
"component object."
msgstr ""
"列生成器是实现了 <classname>Table.ColumnGenerator</classname> 接口及其中的"
"<methodname>generateCell()</methodname> 方法的对象. 这个方法接受的参数是项目 "
"ID, 列 ID, 以及 Table 对象. 方法必须返回一个组件对象."

#. Tag: para
#: chapter-components.xml:4795
#, no-c-format
msgid ""
"The following example defines a generator for formatting <classname>Double</"
"classname> valued fields according to a format string (as in <classname>java."
"util.Formatter</classname>)."
msgstr ""
"下例创建了一个列生成器, 它使用一个格式化字符串来格式化一个 "
"<classname>Double</classname> 值的 Field (与 <classname>java.util.Formatter</"
"classname> 一样)."

#. Tag: programlisting
#: chapter-components.xml:4801
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/** Formats the value in a column containing "
"Double objects. */\n"
"class ValueColumnGenerator implements Table.ColumnGenerator {\n"
"    String format; /* Format string for the Double values. */\n"
"\n"
"    /**\n"
"     * Creates double value column formatter with the given\n"
"     * format string.\n"
"     */\n"
"    public ValueColumnGenerator(String format) {\n"
"        this.format = format;\n"
"    }\n"
"\n"
"    /**\n"
"     * Generates the cell containing the Double value.\n"
"     * The column is irrelevant in this use case.\n"
"     */\n"
"    public Component generateCell(Table source, Object itemId,\n"
"                                  Object columnId) {\n"
"        // Get the object stored in the cell as a property\n"
"        Property prop =\n"
"            source.getItem(itemId).getItemProperty(columnId);\n"
"        if (prop.getType().equals(Double.class)) {\n"
"            Label label = new Label(String.format(format,\n"
"                    new Object[] { (Double) prop.getValue() }));\n"
"            \n"
"            // Set styles for the column: one indicating that it's\n"
"            // a value and a more specific one with the column\n"
"            // name in it. This assumes that the column name\n"
"            // is proper for CSS.\n"
"            label.addStyleName(\"column-type-value\");\n"
"            label.addStyleName(\"column-\" + (String) columnId);\n"
"            return label;\n"
"        }\n"
"        return null;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4810
#, no-c-format
msgid ""
"The generator is called for all the visible (or more accurately cached) "
"items in a table. If the user scrolls the table to another position in the "
"table, the columns of the new visible rows are generated dynamically. The "
"columns in the visible (cached) rows are also generated always when an item "
"has a value change. It is therefore usually safe to calculate the value of "
"generated cells from the values of different rows (items)."
msgstr ""
"对于 Table 内的所有可见项目(更准确的说, 应该是所有被缓存的项目), 列生成器都会"
"被调用. 如果用户在 Table 内滚动到另一个位置, 对于新的可见行, 会动态生成列内"
"容. 当某个项目的值发生变更时, 在可见(缓存)行中的列也会被自动生成. 因此使用不"
"同的行(项目)中的值来计算某个动态生成的单元格的值, 通常是安全的."

#. Tag: para
#: chapter-components.xml:4819
#, no-c-format
msgid ""
"When you set a table as <parameter>editable</parameter>, regular fields will "
"change to editing fields. When the user changes the values in the fields, "
"the generated columns will be updated automatically. Putting a table with "
"generated columns in editable mode has a few quirks. The editable mode of "
"<classname>Table</classname> does not affect generated columns. You have two "
"alternatives: either you generate the editing fields in the generator or, in "
"case of formatter generators, remove the generator in the editable mode. The "
"example below uses the latter approach."
msgstr ""
"当你将 Table 设置为 <parameter>可编辑</parameter>, 通常的 Field 会变为可编辑"
"的 Field. 当用户修改了 Field 内的值, 动态生成的列会被自动更新. 将一个包含动态"
"生成的列的 Table 设置为可编辑模式会有点怪异. <classname>Table</classname> 的"
"可编辑模式不会影响到动态生成的列. 你有两个选择: 要么在列生成器中生成可编辑的 "
"Field 组件, 或者, 对于使用列生成器来格式化列内容的情况, 可以在可编辑模式下删"
"除这个生成器. 下例使用后一种方案."

#. Tag: programlisting
#: chapter-components.xml:4830
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a check box that allows the user\n"
"// to make the quantity and total columns editable.\n"
"final CheckBox editable = new CheckBox(\n"
"    \"Edit the input values - calculated columns are regenerated\");\n"
"\n"
"editable.setImmediate(true);\n"
"editable.addClickListener(new ClickListener() {\n"
"    public void buttonClick(ClickEvent event) {\n"
"        table.setEditable(editable.booleanValue());\n"
"        \n"
"        // The columns may not be generated when we want to\n"
"        // have them editable.\n"
"        if (editable.booleanValue()) {\n"
"            table.removeGeneratedColumn(\"quantity\");\n"
"            table.removeGeneratedColumn(\"total\");\n"
"        } else { // Not editable\n"
"            // Show the formatted values.\n"
"            table.addGeneratedColumn(\"quantity\",\n"
"                new ValueColumnGenerator(\"%.2f l\"));\n"
"            table.addGeneratedColumn(\"total\",\n"
"                new ValueColumnGenerator(\"%.2f e\"));\n"
"        }\n"
"        // The visible columns are affected by removal\n"
"        // and addition of generated columns so we have\n"
"        // to redefine them.\n"
"        table.setVisibleColumns(new Object[] {\"date\", \"quantity\",\n"
"                 \"price\", \"total\", \"consumption\", \"dailycost\"});\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4832
#, no-c-format
msgid ""
"You will also have to set the editing fields in <parameter>immediate</"
"parameter> mode to have the update occur immediately when an edit field "
"loses the focus. You can set the fields in <parameter>immediate</parameter> "
"mode with the a custom <classname>TableFieldFactory</classname>, such as the "
"one given below, that just extends the default implementation to set the "
"mode:"
msgstr ""
"你还需要将 Field 编辑组件设置为 <parameter>立即</parameter> 模式, 这样才能在 "
"Field 编辑组件失去焦点时, 让数据值立即更新. 你可以使用定制的 "
"<classname>TableFieldFactory</classname>, 来将Field 编辑组件设置为 "
"<parameter>立即</parameter> 模式, 如下例所示, 我们在这里只是简单地继承默认实"
"现, 然后设置了编辑组件的模式:"

#. Tag: programlisting
#: chapter-components.xml:4841
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class ImmediateFieldFactory extends "
"DefaultFieldFactory {\n"
"    public Field createField(Container container,\n"
"                             Object itemId,\n"
"                             Object propertyId,\n"
"                             Component uiContext) {\n"
"        // Let the DefaultFieldFactory create the fields...\n"
"        Field field = super.createField(container, itemId,\n"
"                                        propertyId, uiContext);\n"
"        \n"
"        // ...and just set them as immediate.\n"
"        ((AbstractField)field).setImmediate(true);\n"
"        \n"
"        return field;\n"
"    }\n"
"}\n"
"...\n"
"table.setTableFieldFactory(new ImmediateFieldFactory());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4843
#, no-c-format
msgid ""
"If you generate the editing fields with the column generator, you avoid "
"having to use such a field factory, but of course have to generate the "
"fields for both normal and editable modes."
msgstr ""
"如果你使用列生成器来生成 Field 编辑组件, 你就没必要使用上面那样的 Field 工厂"
"了, 但是当然, 你必须为正常模式和可编辑模式两种情况生成 Field."

#. Tag: para
#: chapter-components.xml:4849
#, no-c-format
msgid ""
"shows a table with columns calculated (blue) and simply formatted (black) "
"with column generators."
msgstr ""
"展示了一个 Table, 其中带有计算生成的列(蓝色) 以及简单地格式化的列(黑色), 这两"
"种列使用列生成器动态创建."

#. Tag: title
#: chapter-components.xml:4856
#, no-c-format
msgid "Table with Generated Columns in Normal and Editable Mode"
msgstr "带有动态生成的列的 Table, 正常模式和可编辑模式"

#. Tag: title
#: chapter-components.xml:4871
#, no-c-format
msgid "Formatting Table Columns"
msgstr "列的格式控制"

#. Tag: para
#: chapter-components.xml:4873
#, no-c-format
msgid ""
"The displayed values of properties shown in a table are normally formatted "
"using the <methodname>toString()</methodname> method of each property. "
"Customizing the format of a column can be done in several ways:"
msgstr ""
"Table 内显示的属性值, 其输出格式通常使用各个属性的 <methodname>toString()</"
"methodname> 方法来控制. 自定义一个列的格式可以由以下几种方法实现:"

#. Tag: listitem
#: chapter-components.xml:4880
#, no-c-format
msgid ""
"Using <classname>ColumnGenerator</classname> to generate a second column "
"that is formatted. The original column needs to be set invisible. See <xref "
"linkend=\"components.table.columngenerator\"/>."
msgstr ""
"使用 <classname>ColumnGenerator</classname> 来生成新的、格式化的列. 原来的列"
"需要被设置为不可见. 详情请参见 <xref linkend=\"components.table."
"columngenerator\"/>."

#. Tag: listitem
#: chapter-components.xml:4885
#, no-c-format
msgid ""
"Using a <classname>PropertyFormatter</classname> as a proxy between the "
"table and the data property. This also normally requires using an mediate "
"container in the table."
msgstr ""
"使用 <classname>PropertyFormatter</classname> 作为Table 和数据属性之间的代"
"理. 这种方法通常需要在 Table 中使用一个间接的数据容器."

#. Tag: listitem
#: chapter-components.xml:4889
#, no-c-format
msgid ""
"Overriding the default <methodname>formatPropertyValue()</methodname> in "
"<classname>Table</classname>."
msgstr ""
"覆盖 <classname>Table</classname> 类默认的 "
"<methodname>formatPropertyValue()</methodname> 方法."

#. Tag: para
#: chapter-components.xml:4894
#, no-c-format
msgid ""
"As using a <classname>PropertyFormatter</classname> is generally much more "
"awkward than overriding the <methodname>formatPropertyValue()</methodname>, "
"its use is not described here."
msgstr ""
"一般来说, 使用 <classname>PropertyFormatter</classname> 要比覆盖"
"<methodname>formatPropertyValue()</methodname> 方法笨拙一些, 所以这里我们不详"
"细介绍这种方案."

#. Tag: para
#: chapter-components.xml:4901
#, no-c-format
msgid ""
"You can override <methodname>formatPropertyValue()</methodname> as is done "
"in the following example:"
msgstr "覆盖 <methodname>formatPropertyValue()</methodname> 方法的例子如下:"

#. Tag: programlisting
#: chapter-components.xml:4906
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a table that overrides the default\n"
"// property (column) format\n"
"final Table table = new Table(\"Formatted Table\") {\n"
"    @Override\n"
"    protected String formatPropertyValue(Object rowId,\n"
"            Object colId, Property property) {\n"
"        // Format by property type\n"
"        if (property.getType() == Date.class) {\n"
"            SimpleDateFormat df =\n"
"                new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\");\n"
"            return df.format((Date)property.getValue());\n"
"        }\n"
"\n"
"        return super.formatPropertyValue(rowId, colId, property);\n"
"    }\n"
"};\n"
"        \n"
"// The table has some columns\n"
"table.addContainerProperty(\"Time\", Date.class, null);\n"
"        \n"
"... Fill the table with data ...]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4908
#, no-c-format
msgid ""
"You can also distinguish between columns by the <parameter>colId</parameter> "
"parameter, which is the property ID of the column. <classname>DecimalFormat</"
"classname> is useful for formatting decimal values."
msgstr ""
"你可以使用 <parameter>colId</parameter> 参数来区分不同的列, 这个参数是列对应"
"的属性 ID. <classname>DecimalFormat</classname> 很适用于格式化十进制小数值."

#. Tag: programlisting
#: chapter-components.xml:4915
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[... in formatPropertyValue() ...\n"
"} else if (\"Value\".equals(pid)) {\n"
"    // Format a decimal value for a specific locale\n"
"    DecimalFormat df = new DecimalFormat(\"#.00\",\n"
"            new DecimalFormatSymbols(locale));\n"
"    return df.format((Double) property.getValue());\n"
"}\n"
"...\n"
"table.addContainerProperty(\"Value\", Double.class, null);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4917
#, no-c-format
msgid ""
"A table with the formatted date and decimal value columns is shown in <xref "
"linkend=\"figure.components.table.columnformatting\"/>."
msgstr ""
"带有格式化的日期列和格式化的十进制值列的 Table, 见 <xref linkend=\"figure."
"components.table.columnformatting\"/>."

#. Tag: title
#: chapter-components.xml:4923
#, no-c-format
msgid "Formatted Table Columns"
msgstr "Table 中格式化的列"

#. Tag: para
#: chapter-components.xml:4934
#, no-c-format
msgid ""
"You can use CSS for further styling of table rows, columns, and individual "
"cells by using a <classname>CellStyleGenerator</classname>. It is described "
"in <xref linkend=\"components.table.css\"/>."
msgstr ""
"你可以通过 <classname>CellStyleGenerator</classname>, 来以 CSS 的方式进一步控"
"制 Table 中各行, 各列, 各个独立的单元格的样式. 详情请参见 <xref linkend="
"\"components.table.css\"/>."

#. Tag: para
#: chapter-components.xml:4944
#, no-c-format
msgid ""
"Styling the overall style of a <classname>Table</classname> can be done with "
"the following CSS rules."
msgstr "<classname>Table</classname> 的样式规则如下."

#. Tag: programlisting
#: chapter-components.xml:4949
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[.v-table {}\n"
"  .v-table-header-wrap {}\n"
"    .v-table-header {}\n"
"      .v-table-header-cell {}\n"
"        .v-table-resizer {} /* Column resizer handle. */\n"
"        .v-table-caption-container {}\n"
"  .v-table-body {}\n"
"    .v-table-row-spacer {}\n"
"    .v-table-table {}\n"
"      .v-table-row {}\n"
"        .v-table-cell-content {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4951
#, no-c-format
msgid ""
"Notice that some of the widths and heights in a table are calculated "
"dynamically and can not be set in CSS."
msgstr "注意, Table 内某些元素的宽度和高度是动态计算的, 无法通过 CSS 来设置."

#. Tag: title
#: chapter-components.xml:4957
#, no-c-format
msgid "Setting Individual Cell Styles"
msgstr "设置独立的单元格样式"

#. Tag: para
#: chapter-components.xml:4959
#, no-c-format
msgid ""
"The <classname>Table.CellStyleGenerator</classname> interface allows you to "
"set the CSS style for each individual cell in a table. You need to implement "
"the <methodname>getStyle()</methodname>, which gets the row (item) and "
"column (property) identifiers as parameters and can return a style name for "
"the cell. The returned style name will be concatenated to prefix "
"\"<literal>v-table-cell-content-</literal>\"."
msgstr ""
"<classname>Table.CellStyleGenerator</classname> 接口允许你为 Table 内每一个独"
"立的单元格设置 CSS 样式. 你需要实现这个接口的 <methodname>getStyle()</"
"methodname> 方法, 这个方法接受的参数是行(项目)和列(属性)的 ID, 并为这个单元格"
"返回一个样式名称. 返回的样式名会被自动添加一个前缀字符串 \"<literal>v-table-"
"cell-content-</literal>\"."

#. Tag: para
#: chapter-components.xml:4968
#, no-c-format
msgid ""
"The <methodname>getStyle()</methodname> is called also for each row, so that "
"the <parameter>propertyId</parameter> parameter is <literal>null</literal>. "
"This allows setting a row style."
msgstr ""
"<methodname>getStyle()</methodname> 方法也会对每一行本身调用, 此时 "
"<parameter>propertyId</parameter> 参数为 <literal>null</literal>. 这种机制用"
"于为行本身设置样式."

#. Tag: para
#: chapter-components.xml:4974
#, no-c-format
msgid ""
"Alternatively, you can use a <classname>Table.ColumnGenerator</classname> "
"(see <xref linkend=\"components.table.columngenerator\"/>) to generate the "
"actual UI components of the cells and add style names to them."
msgstr ""
"或者, 你也可以使用 <classname>Table.ColumnGenerator</classname> (参见 <xref "
"linkend=\"components.table.columngenerator\"/>) 来为每个单元格生成 UI 组件, "
"并为这些 UI 组件添加样式."

#. Tag: programlisting
#: chapter-components.xml:4981
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Table table = new Table(\"Table with Cell Styles"
"\");\n"
"table.addStyleName(\"checkerboard\");\n"
"\n"
"// Add some columns in the table. In this example, the property\n"
"// IDs of the container are integers so we can determine the\n"
"// column number easily.\n"
"table.addContainerProperty(\"0\", String.class, null, \"\", null, null);\n"
"for (int i=0; i<8; i++)\n"
"    table.addContainerProperty(\"\"+(i+1), String.class, null,\n"
"                         String.valueOf((char) (65+i)), null, null);\n"
"\n"
"// Add some items in the table.\n"
"table.addItem(new Object[]{\n"
"    \"1\", \"R\", \"N\", \"B\", \"Q\", \"K\", \"B\", \"N\", \"R\"}, new "
"Integer(0));\n"
"table.addItem(new Object[]{\n"
"    \"2\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\"}, new "
"Integer(1));\n"
"for (int i=2; i<6; i++)\n"
"    table.addItem(new Object[]{String.valueOf(i+1), \n"
"                 \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"}, new "
"Integer(i));\n"
"table.addItem(new Object[]{\n"
"    \"7\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\", \"P\"}, new "
"Integer(6));\n"
"table.addItem(new Object[]{\n"
"    \"8\", \"R\", \"N\", \"B\", \"Q\", \"K\", \"B\", \"N\", \"R\"}, new "
"Integer(7));\n"
"table.setPageLength(8);\n"
"\n"
"// Set cell style generator\n"
"table.setCellStyleGenerator(new Table.CellStyleGenerator() {\n"
"    public String getStyle(Object itemId, Object propertyId) {\n"
"        // Row style setting, not relevant in this example.\n"
"        if (propertyId == null)\n"
"            return \"green\"; // Will not actually be visible\n"
"\n"
"        int row = ((Integer)itemId).intValue();\n"
"        int col = Integer.parseInt((String)propertyId);\n"
"        \n"
"        // The first column.\n"
"        if (col == 0)\n"
"            return \"rowheader\";\n"
"        \n"
"        // Other cells.\n"
"        if ((row+col)%2 == 0)\n"
"            return \"black\";\n"
"        else\n"
"            return \"white\";\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4983
#, no-c-format
msgid "You can then style the cells, for example, as follows:"
msgstr "然后你可以控制单元格的样式, 如下例:"

#. Tag: programlisting
#: chapter-components.xml:4987
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/* Center the text in header. */\n"
".v-table-header-cell {\n"
"    text-align: center;\n"
"}\n"
"\n"
"/* Basic style for all cells. */\n"
".v-table-checkerboard .v-table-cell-content {\n"
"    text-align: center;\n"
"    vertical-align: middle;\n"
"    padding-top: 12px;\n"
"    width: 20px;\n"
"    height: 28px;\n"
"}\n"
"\n"
"/* Style specifically for the row header cells. */\n"
".v-table-cell-content-rowheader {\n"
"        background: #E7EDF3\n"
"     url(../default/table/img/header-bg.png) repeat-x scroll 0 0;\n"
"}\n"
"\n"
"/* Style specifically for the \"white\" cells. */\n"
".v-table-cell-content-white {\n"
"    background: white;\n"
"    color: black;\n"
"}\n"
"\n"
"/* Style specifically for the \"black\" cells. */\n"
".v-table-cell-content-black {\n"
"    background: black;\n"
"    color: white;\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:4989
#, no-c-format
msgid ""
"The table will look as shown in <xref linkend=\"figure.components.table.cell-"
"style\"/>."
msgstr ""
"Table 的外观参见 <xref linkend=\"figure.components.table.cell-style\"/>."

#. Tag: title
#: chapter-components.xml:4995
#, no-c-format
msgid "Cell Style Generator for a Table"
msgstr "Table 的单元格样式生成器"

#. Tag: classname
#: chapter-components.xml:5013
#, no-c-format
msgid "Tree"
msgstr "Tree"

#. Tag: para
#: chapter-components.xml:5015
#, no-c-format
msgid ""
"The <classname>Tree</classname> component allows a natural way to represent "
"data that has hierarchical relationships, such as filesystems or message "
"threads. The <classname>Tree</classname> component in Vaadin works much like "
"the tree components of most modern desktop user interface toolkits, for "
"example in directory browsing."
msgstr ""
"<classname>Tree</classname> 组件以一种自然的方式来表现层级式关系的数据, 比如"
"文件系统, 或 BBS  上的消息主题. Vaadin 中的 <classname>Tree</classname> 组件"
"类似于大多数现代桌面 UI 开发工具中的 Tree 组件, 比如, 目录系统."

#. Tag: para
#: chapter-components.xml:5023
#, no-c-format
msgid ""
"The typical use of the <classname>Tree</classname> component is for "
"displaying a hierachical menu, like a menu on the left side of the screen, "
"as in <xref linkend=\"figure.components.tree\"/>, or for displaying "
"filesystems or other hierarchical datasets. The <parameter>menu</parameter> "
"style makes the appearance of the tree more suitable for this purpose."
msgstr ""
"<classname>Tree</classname> 组件的一种常见用途是现实层级式菜单, 类似于显示在"
"屏幕左侧的菜单, 参见 <xref linkend=\"figure.components.tree\"/>, 也可用于显示"
"文件系统或其他层级式的数据集. <parameter>menu</parameter> 样式可以使 Tree 的"
"显示风格更适合于这种目的."

#. Tag: programlisting
#: chapter-components.xml:5031
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[final Object[][] planets = new Object[][]{\n"
"        new Object[]{\"Mercury\"}, \n"
"        new Object[]{\"Venus\"},\n"
"        new Object[]{\"Earth\", \"The Moon\"},    \n"
"        new Object[]{\"Mars\", \"Phobos\", \"Deimos\"},\n"
"        new Object[]{\"Jupiter\", \"Io\", \"Europa\", \"Ganymedes\",\n"
"                                \"Callisto\"},\n"
"        new Object[]{\"Saturn\",  \"Titan\", \"Tethys\", \"Dione\",\n"
"                                \"Rhea\", \"Iapetus\"},\n"
"        new Object[]{\"Uranus\",  \"Miranda\", \"Ariel\", \"Umbriel\",\n"
"                                \"Titania\", \"Oberon\"},\n"
"        new Object[]{\"Neptune\", \"Triton\", \"Proteus\", \"Nereid\",\n"
"                                \"Larissa\"}};\n"
"        \n"
"Tree tree = new Tree(\"The Planets and Major Moons\");\n"
"\n"
"/* Add planets as root items in the tree. */\n"
"for (int i=0; i<planets.length; i++) {\n"
"    String planet = (String) (planets[i][0]);\n"
"    tree.addItem(planet);\n"
"    \n"
"    if (planets[i].length == 1) {\n"
"        // The planet has no moons so make it a leaf.\n"
"        tree.setChildrenAllowed(planet, false);\n"
"    } else {\n"
"        // Add children (moons) under the planets.\n"
"        for (int j=1; j<planets[i].length; j++) {\n"
"            String moon = (String) planets[i][j];\n"
"            \n"
"            // Add the item as a regular item.\n"
"            tree.addItem(moon);\n"
"            \n"
"            // Set it to be a child.\n"
"            tree.setParent(moon, planet);\n"
"            \n"
"            // Make the moons look like leaves.\n"
"            tree.setChildrenAllowed(moon, false);\n"
"        }\n"
"\n"
"        // Expand the subtree.\n"
"        tree.expandItemsRecursively(planet);\n"
"    }\n"
"}\n"
"\n"
"main.addComponent(tree);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5033
#, no-c-format
msgid "below shows the tree from the code example in a practical situation."
msgstr "是上面示例代码的运行结果."

#. Tag: title
#: chapter-components.xml:5039
#, no-c-format
msgid "A <classname>Tree</classname> Component as a Menu"
msgstr "使用 <classname>Tree</classname> 组件作为菜单"

#. Tag: para
#: chapter-components.xml:5050
#, no-c-format
msgid ""
"You can read or set the currently selected item by the value property of the "
"<classname>Tree</classname> component, that is, with <methodname>getValue()</"
"methodname> and <methodname>setValue()</methodname>. When the user clicks an "
"item on a tree, the tree will receive an <classname>ValueChangeEvent</"
"classname>, which you can catch with a <classname>ValueChangeListener</"
"classname>. To receive the event immediately after the click, you need to "
"set the tree as <classname>setImmediate(true)</classname>."
msgstr ""
"你可以使用<classname>Tree</classname> 组件的属性值来获得或设定当前选中的项"
"目, 也就是使用 <methodname>getValue()</methodname> 和 "
"<methodname>setValue()</methodname> 方法. 当用户点击 Tree 内某个项目时, Tree "
"会收到 <classname>ValueChangeEvent</classname> 事件, 你可以使用 "
"<classname>ValueChangeListener</classname> 监听器来处理这个事件. 如果要在用户"
"点击后立即接收这个事件, 你需要对 Tree 设置 <classname>setImmediate(true)</"
"classname>."

#. Tag: para
#: chapter-components.xml:5061
#, no-c-format
msgid ""
"The <classname>Tree</classname> component uses <classname>Container</"
"classname> data sources much like the <classname>Table</classname> "
"component, with the addition that it also utilizes hierarchy information "
"maintained by a <classname>HierarchicalContainer</classname>. The contained "
"items can be of any item type supported by the container. The default "
"container and its <methodname>addItem()</methodname> assume that the items "
"are strings and the string value is used as the item ID."
msgstr ""
"<classname>Tree</classname> 组件与 <classname>Table</classname> 组件类似, 使"
"用 <classname>Container</classname> 数据源, 不同的是, Tree 还需要获取数据之间"
"的层级信息, 这个信息由 <classname>HierarchicalContainer</classname> 管理. 容"
"器内的项目可以是容器所允许的任意类型. 默认的容器, 以及它的 "
"<methodname>addItem()</methodname> 方法假设项目是字符串类型, 并将这个字符串值"
"用作项目 ID."

#. Tag: classname
#: chapter-components.xml:5074
#, no-c-format
msgid "MenuBar"
msgstr "MenuBar"

#. Tag: para
#: chapter-components.xml:5076
#, no-c-format
msgid ""
"The <classname>MenuBar</classname> component allows creating horizontal "
"dropdown menus, much like the main menu in desktop applications."
msgstr ""
"<classname>MenuBar</classname> 组件用于创建水平排列的下拉菜单, 类似于桌面应用"
"程序中的主菜单."

#. Tag: title
#: chapter-components.xml:5082
#, no-c-format
msgid "Menu Bar"
msgstr ""

#. Tag: title
#: chapter-components.xml:5094
#, no-c-format
msgid "Creating a Menu"
msgstr "创建菜单"

#. Tag: para
#: chapter-components.xml:5096
#, no-c-format
msgid "The actual menu bar component is first created as follows:"
msgstr "MenuBar 组件的创建过程第一步如下:"

#. Tag: programlisting
#: chapter-components.xml:5100
#, no-c-format
msgid ""
"<![CDATA[MenuBar menubar = new MenuBar();\n"
"main.addComponent(menubar);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5102
#, no-c-format
msgid ""
"You insert the top-level menu items to the <classname>MenuBar</classname> "
"object with the <methodname>addItem()</methodname> method. It takes a string "
"label, an icon resource, and a command as its parameters. The icon and "
"command are not required and can be <parameter>null</parameter>. The "
"<methodname>addItem()</methodname> method returns a <classname>MenuBar."
"MenuItem</classname> object, which you can use to add sub-menu items. The "
"<classname>MenuItem</classname> has an identical <methodname>addItem()</"
"methodname> method."
msgstr ""
"然后你需要使用 <methodname>addItem()</methodname> 方法将最顶层菜单项添加到 "
"<classname>MenuBar</classname> 对象中. 这个方法接受的参数是一个字符串类型的标"
"题, 一个图标资源, 和一个对应的命令. 图标和命令不是必须参数, 可以为 "
"<parameter>null</parameter>. <methodname>addItem()</methodname> 方法返回一个 "
"<classname>MenuBar.MenuItem</classname> 对象, 你可以再向它添加子菜单项. "
"<classname>MenuItem</classname> 也有一个相同的 <methodname>addItem()</"
"methodname> 方法."

#. Tag: para
#: chapter-components.xml:5113
#, no-c-format
msgid "For example (the command is explained later):"
msgstr "示例 (关于命令的部分, 后文会解释):"

#. Tag: programlisting
#: chapter-components.xml:5117
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// A top-level menu item that opens a submenu\n"
"MenuItem drinks = barmenu.addItem(\"Beverages\", null, null);\n"
"\n"
"// Submenu item with a sub-submenu\n"
"MenuItem hots = drinks.addItem(\"Hot\", null, null);\n"
"hots.addItem(\"Tea\",\n"
"    new ThemeResource(\"icons/tea-16px.png\"),    mycommand);\n"
"hots.addItem(\"Coffee\",\n"
"    new ThemeResource(\"icons/coffee-16px.png\"), mycommand);\n"
"\n"
"// Another submenu item with a sub-submenu\n"
"MenuItem colds = drinks.addItem(\"Cold\", null, null);\n"
"colds.addItem(\"Milk\",      null, mycommand);\n"
"colds.addItem(\"Weissbier\", null, mycommand);\n"
"\n"
"// Another top-level item\n"
"MenuItem snacks = barmenu.addItem(\"Snacks\", null, null);\n"
"snacks.addItem(\"Weisswurst\", null, mycommand);\n"
"snacks.addItem(\"Bratwurst\",  null, mycommand);\n"
"snacks.addItem(\"Currywurst\", null, mycommand);\n"
"        \n"
"// Yet another top-level item\n"
"MenuItem servs = barmenu.addItem(\"Services\", null, null);\n"
"servs.addItem(\"Car Service\", null, mycommand);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5121
#, no-c-format
msgid "Handling Menu Selection"
msgstr "菜单选择的处理"

#. Tag: para
#: chapter-components.xml:5123
#, no-c-format
msgid ""
"Menu selection is handled by executing a <emphasis>command</emphasis> when "
"the user selects an item from the menu. A command is a call-back class that "
"implements the <classname>MenuBar.Command</classname> interface."
msgstr ""
"当用户在菜单中选中一个项目时, 菜单的选择以执行一个 <emphasis>命令</emphasis> "
"的方式来处理. 命令是一个回调类, 它实现 <classname>MenuBar.Command</"
"classname> 接口."

#. Tag: programlisting
#: chapter-components.xml:5129
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// A feedback component\n"
"final Label selection = new Label(\"-\");\n"
"main.addComponent(selection);\n"
"\n"
"// Define a common menu command for all the menu items.\n"
"MenuBar.Command mycommand = new MenuBar.Command() {\n"
"    public void menuSelected(MenuItem selectedItem) {\n"
"        selection.setValue(\"Ordered a \" +\n"
"                           selectedItem.getText() +\n"
"                           \" from menu.\");\n"
"    }  \n"
"};]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5133
#, no-c-format
msgid "Menu Items"
msgstr "菜单项"

#. Tag: para
#: chapter-components.xml:5135
#, no-c-format
msgid ""
"Menu items have properties such as a caption, icon, enabled, visible, and "
"description (tooltip). The meaning of these is the same as for components."
msgstr ""
"菜单项的属性包括标题, 图标, 是否有效, 是否可见, 以及描述信息(提示信息). 这些"
"属性的含义与组件中的属性相同."

#. Tag: para
#: chapter-components.xml:5140
#, no-c-format
msgid ""
"Submenus are created by adding sub-items to an item with "
"<methodname>addItem()</methodname> or <methodname>addItemBefore()</"
"methodname>."
msgstr ""
"使用 <methodname>addItem()</methodname> 或<methodname>addItemBefore()</"
"methodname> 方法向一个菜单项添加下级菜单项, 就创建出了子菜单."

#. Tag: para
#: chapter-components.xml:5146
#, no-c-format
msgid ""
"The <emphasis>command</emphasis> property is a <classname>MenuBar.Command</"
"classname> that is called when the particular menu item is selected. The "
"<methodname>menuSelected()</methodname> callback gets the clicked menu item "
"as its parameter."
msgstr ""
"<emphasis>command</emphasis> 属性是 <classname>MenuBar.Command</classname> 类"
"型的对象, 当对应的菜单项被选中时, 它会被调用. <methodname>menuSelected()</"
"methodname> 回调方法的参数是被点击的菜单项."

#. Tag: para
#: chapter-components.xml:5153
#, no-c-format
msgid ""
"Menus can have <emphasis>separators</emphasis>, which are defined before or "
"after an item with <methodname>addSeparatorBefore()</methodname> or "
"<methodname>addSeparator()</methodname> on the item, respectively."
msgstr ""
"菜单可以包含 <emphasis>分隔项</emphasis>, 在菜单项上使用 "
"<methodname>addSeparatorBefore()</methodname> 或 <methodname>addSeparator()</"
"methodname> 方法可以在菜单项之前或之后创建分隔项."

#. Tag: programlisting
#: chapter-components.xml:5159
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[MenuItem drinks = barmenu.addItem(\"Beverages"
"\", null, null);\n"
"...\n"
"\n"
"// A sub-menu item after a separator\n"
"drinks.addSeparator();\n"
"drinks.addItem(\"Quit Drinking\", null, null);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5162
#, no-c-format
msgid ""
"Enabling <emphasis>checkable</emphasis> on an menu item with "
"<methodname>setCheckable()</methodname> allows the user to switch between "
"checked and unchecked state by clicking on the item. You can set the checked "
"state with <methodname>setChecked()</methodname>. Note that if such an item "
"has a command, the checked state is not flipped automatically, but you need "
"to do it explicitly."
msgstr ""
"在菜单项上使用<methodname>setCheckable()</methodname> 方法, 允许这个菜单项 "
"<emphasis>checkable</emphasis>, 用户就可以点击这个菜单项, 使它在选中和非选中"
"状态之间切换. 你可以使用 <methodname>setChecked()</methodname> 方法设置选中状"
"态. 注意, 如果这个菜单项带有命令, 那么选中状态不会自动切换, 你需要在代码中明"
"确地切换选中状态."

#. Tag: para
#: chapter-components.xml:5171
#, no-c-format
msgid ""
"Menu items have various other properties as well, see the API documentation "
"for more details."
msgstr "菜单项还有其他一些属性, 详情请阅读 API 文档."

#. Tag: programlisting
#: chapter-components.xml:5180
#, no-c-format
msgid ""
"<![CDATA[.v-menubar { }\n"
"  .v-menubar-submenu { }\n"
"    .v-menubar-menuitem { }\n"
"      .v-menubar-menuitem-caption { }\n"
"    .v-menubar-menuitem-selected { }\n"
"    .v-menubar-submenu-indicator { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5182
#, no-c-format
msgid ""
"The menu bar has the overall style name <literal>.v-menubar</literal>. Each "
"menu item has <literal>.v-menubar-menuitem</literal> style normally and "
"additionally <literal>.v-menubar-selected</literal> when the item is "
"selected, that is, when the mouse pointer hovers over it. The item caption "
"is inside a <literal>v-menubar-menuitem-caption</literal>. In the top-level "
"menu bar, the items are directly under the component element."
msgstr ""
"MenuBar 的最外层样式是 <literal>.v-menubar</literal>. 每一个菜单项的样式通常"
"为 <literal>.v-menubar-menuitem</literal> , 如果菜单项被选中, 也就是鼠标指针"
"移动到它上方时, 还会额外带有一个 <literal>.v-menubar-selected</literal> 样"
"式. 项目标题包含在 <literal>v-menubar-menuitem-caption</literal> 之内. 最顶层"
"菜单条之内的菜单项, 直接位于组件的 HTML 元素之内."

#. Tag: para
#: chapter-components.xml:5192
#, no-c-format
msgid ""
"Submenus are floating <literal>v-menubar-submenu</literal> elements outside "
"the menu bar element. Therefore, you should not try to match on the "
"component element for the submenu popups. In submenus, any further submenu "
"levels are indicated with a <literal>v-menubar-submenu-indicator</literal>."
msgstr ""
"子菜单是浮动的 <literal>v-menubar-submenu</literal> 元素, 位于 MenuBar 的 "
"HTML 元素之外. 因此, 你不应该试图在MenuBar 的 HTML 元素之内匹配子菜单的弹出元"
"素. 在子菜单之下如果包含更下级子菜单, 则以一个指示器来表示, 指示器的样式为 "
"<literal>v-menubar-submenu-indicator</literal>."

#. Tag: title
#: chapter-components.xml:5200
#, no-c-format
msgid "Styling Menu Items"
msgstr "控制菜单项样式"

#. Tag: para
#: chapter-components.xml:5202
#, no-c-format
msgid ""
"You can set the CSS style name for the menu items with "
"<methodname>setStyleName()</methodname>, just like for components. The style "
"name will be prepended with <literal>v-menubar-menuitem-</literal>. As "
"<classname>MenuBar</classname> does not indicate the previous selection in "
"any way, you can do that by highlighting the previously selected item. "
"However, beware that the <literal>selected</literal> style for menu items, "
"that is, <literal>v-menubar-menuitem-selected</literal>, is reserved for "
"mouse-hover indication."
msgstr ""
"与其他组件一样, 你可以使用 <methodname>setStyleName()</methodname> 方法设置菜"
"单项的 CSS 样式名. 样式名会被自动添加 <literal>v-menubar-menuitem-</literal> "
"前缀. 由于<classname>MenuBar</classname> 不能以任何方式来指出前次选中的项目, "
"你可以高亮显示选中的项目, 来自行实现这个功能, 参见下例. 但是, 要注意菜单项的 "
"<literal>选中</literal> 样式, 也就是, <literal>v-menubar-menuitem-selected</"
"literal>, 这个样式已经被用于指示鼠标在菜单内的移动位置."

#. Tag: programlisting
#: chapter-components.xml:5215
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[MenuBar barmenu = new MenuBar();\n"
"barmenu.addStyleName(\"mybarmenu\");\n"
"layout.addComponent(barmenu);\n"
"        \n"
"// A feedback component\n"
"final Label selection = new Label(\"-\");\n"
"layout.addComponent(selection);\n"
"\n"
"// Define a common menu command for all the menu items\n"
"MenuBar.Command mycommand = new MenuBar.Command() {\n"
"    MenuItem previous = null;\n"
"\n"
"    public void menuSelected(MenuItem selectedItem) {\n"
"        selection.setValue(\"Ordered a \" +\n"
"                selectedItem.getText() +\n"
"                \" from menu.\");\n"
"\n"
"        if (previous != null)\n"
"            previous.setStyleName(null);\n"
"        selectedItem.setStyleName(\"highlight\");\n"
"        previous = selectedItem;\n"
"    }  \n"
"};\n"
"        \n"
"// Put some items in the menu\n"
"barmenu.addItem(\"Beverages\", null, mycommand);\n"
"barmenu.addItem(\"Snacks\", null, mycommand);\n"
"barmenu.addItem(\"Services\", null, mycommand);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5217
#, no-c-format
msgid "You could then style the highlighting in CSS as follows:"
msgstr "你可以使用下面的 CSS 来控制高亮部分的样式:"

#. Tag: programlisting
#: chapter-components.xml:5221
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[.mybarmenu .v-menubar-menuitem-highlight {\n"
"    background: #000040; /* Dark blue */\n"
"}]]>"
msgstr ""

#. Tag: classname
#: chapter-components.xml:5227
#, no-c-format
msgid "Upload"
msgstr "Upload"

#. Tag: para
#: chapter-components.xml:5229
#, no-c-format
msgid ""
"The <classname>Upload</classname> component allows a user to upload files to "
"the server. It displays a file name entry box, a file selection button, and "
"an upload submit button. The user can either write the filename in the text "
"area or click the <guibutton>Browse</guibutton> button to select a file. "
"After the file is selected, the user sends the file by clicking the upload "
"submit button."
msgstr ""
"<classname>Upload</classname> 组件可供用户上传文件到服务器端. 这个组件显示一"
"个文件名输入框, 一个文件选择按钮, 以及一个上传提交按钮. 用户可以在文件名输入"
"框中输入文件名, 也可以点击 <guibutton>浏览</guibutton> 按钮来选择文件. 选择文"
"件之后, 用户可以点击上传提交按钮将文件发送到服务器端."

#. Tag: para
#: chapter-components.xml:5238
#, no-c-format
msgid ""
"Uploading requires a receiver that implements <interfacename>Upload."
"Receiver</interfacename> to provide an output stream to which the upload is "
"written by the server."
msgstr ""
"上传的文件在服务器端需要一个接收器, 接收器需要实现 <interfacename>Upload."
"Receiver</interfacename> 接口, 并提供一个输出流, 文件内容将由服务器写入到这个"
"输出流中."

#. Tag: programlisting
#: chapter-components.xml:5244
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[Upload upload = new Upload(\"Upload it here\", "
"receiver);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5247
#, no-c-format
msgid "Upload Component"
msgstr "Upload 组件"

#. Tag: para
#: chapter-components.xml:5255
#, no-c-format
msgid ""
"You can set the text of the upload button with "
"<methodname>setButtonCaption()</methodname>. Note that it is difficult to "
"change the caption or look of the <guibutton>Browse</guibutton> button. This "
"is a security feature of web browsers. The language of the "
"<guibutton>Browse</guibutton> button is determined by the browser, so if you "
"wish to have the language of the <classname>Upload</classname> component "
"consistent, you will have to use the same language in your application."
msgstr ""
"你可以使用 <methodname>setButtonCaption()</methodname> 方法设置上传按钮的文"
"字. 注意, 修改 <guibutton>浏览</guibutton> 按钮的文字或外观是困难的. 这是浏览"
"器的安全特性. <guibutton>浏览</guibutton> 按钮的语言由浏览器决定, 因此, 如果"
"你希望 <classname>Upload</classname> 组件内的语言保持一致, 你可能必须使用与应"
"用程序相同的语言."

#. Tag: programlisting
#: chapter-components.xml:5265
#, no-c-format
msgid "<![CDATA[upload.setButtonCaption(\"Upload Now\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5267
#, no-c-format
msgid ""
"You can also hide the upload button with <literal>.v-upload .v-button "
"{display: none}</literal> in theme, have custom logic for starting the "
"upload, and call <methodname>startUpload()</methodname> to start it. If the "
"upload component has <methodname>setImmediate(true)</methodname> enabled, "
"uploading starts immediately after choosing the file."
msgstr ""
"你也可以在 theme 中使用 <literal>.v-upload .v-button {display: none}</"
"literal> 样式来隐藏上传按钮, 然后实现自定义的逻辑开始上传, 并调用 "
"<methodname>startUpload()</methodname> 方法来启动上传动作. 如果 Upload 组件被"
"设置为 <methodname>setImmediate(true)</methodname>, 文件被选中之后就会立即开"
"始上传."

#. Tag: title
#: chapter-components.xml:5279
#, no-c-format
msgid "Receiving Upload Data"
msgstr "接收上传的数据"

#. Tag: para
#: chapter-components.xml:5281
#, no-c-format
msgid ""
"The uploaded files are typically stored as files in a file system, in a "
"database, or as temporary objects in memory. The upload component writes the "
"received data to an <classname>java.io.OutputStream</classname> so you have "
"plenty of freedom in how you can process the upload content."
msgstr ""
"被上传的文件通常保存为文件系统中的文件, 或保存在数据库中, 或保存为内存中的临"
"时对象. Upload 组件将接收到的数据写入一个 <classname>java.io.OutputStream</"
"classname>, 因此你有很大的自由来决定如何处理上传的内容."

#. Tag: para
#: chapter-components.xml:5289
#, no-c-format
msgid ""
"To use the <classname>Upload</classname> component, you need to implement "
"the <classname>Upload.Receiver</classname> interface. The "
"<methodname>receiveUpload()</methodname> method of the receiver is called "
"when the user clicks the submit button. The method must return an "
"<classname>OutputStream</classname>. To do this, it typically creates a file "
"or a memory buffer to which the stream is written. The method gets the file "
"name and MIME type of the file, as reported by the browser."
msgstr ""
"要使用 <classname>Upload</classname> 组件, 你需要实现 <classname>Upload."
"Receiver</classname> 接口. 当用户按下提交按钮时, 接收器中的 "
"<methodname>receiveUpload()</methodname> 方法会被调用. 这个方法必须返回一个 "
"<classname>OutputStream</classname>. 为了实现这一点, 通常创建一个文件, 或者一"
"个内存中的缓冲区作为流的写入对象. 这个方法接受的参数是被上传文件的文件名和 "
"MIME 类型, 这些信息由浏览器报告给服务器."

#. Tag: para
#: chapter-components.xml:5299
#, no-c-format
msgid ""
"While uploading, the upload progress can be monitored with an "
"<interfacename>Upload.ProgressListener</interfacename>. The "
"<methodname>updateProgress()</methodname> method gets the number of read "
"bytes and the content length as parameters. The content length is reported "
"by the browser, is not reliable, and may be -1 if unknown. It is therefore "
"recommended to follow the upload progress and check the allowed size in a "
"progress listener. Upload can be terminated by calling "
"<methodname>interruptUpload()</methodname> on the upload component. You may "
"want to use a <classname>ProgressBar</classname> to visualize the progress, "
"and in indeterminate mode if the content length is not known."
msgstr ""
"在上传过程中, 可以通过 <interfacename>Upload.ProgressListener</"
"interfacename> 监听器来监视上传进度. 监听器的 <methodname>updateProgress()</"
"methodname> 方法接受的参数是已读入的字节数, 以及内容的总长度. 内容的总长度由"
"浏览器报告给服务器, 这个数字不一定是可靠的, 而且有可能为 -1, 代表长度未知. 因"
"此, 推荐在上传进度监听器中跟踪上传进度, 并检查文件大小. 上传可以中途停止, 方"
"法是在 Upload 组件上调用 <methodname>interruptUpload()</methodname> 方法. 你"
"也许会希望使用 <classname>ProgressBar</classname> 来显示上传进度, 如果上传内"
"容的长度未知, 可将进度条设置为模糊模式."

#. Tag: para
#: chapter-components.xml:5312
#, no-c-format
msgid ""
"When an upload is finished, successfully or unsuccessfully, the "
"<classname>Upload</classname> component will emit the <classname>Upload."
"FinishedEvent</classname> event, which you can handle with an "
"<classname>Upload.FinishedListener</classname> added to the upload "
"component. The event object will include the file name, MIME type, and final "
"length of the file. More specific <classname>Upload.FailedEvent</classname> "
"and <classname>Upload.SucceededEvent</classname> events will be called in "
"the cases where the upload failed or succeeded, respectively."
msgstr ""
"当上传结束后, 无论成功还是不成功, <classname>Upload</classname> 组件都会激发 "
"<classname>Upload.FinishedEvent</classname> 事件, 你可以使用 "
"<classname>Upload.FinishedListener</classname> 监听器来处理这个事件. 事件对象"
"中包含的信息有, 文件名, MIME 类型, 以及文件最终长度. <classname>Upload."
"FailedEvent</classname> 和 <classname>Upload.SucceededEvent</classname> 事件"
"更为详细一些, 分别会在上传失败或上传成功时被调用."

#. Tag: para
#: chapter-components.xml:5323
#, no-c-format
msgid ""
"The following example uploads images to <filename>/tmp/uploads</filename> "
"directory in (UNIX) filesystem (the directory must exist or the upload "
"fails). The component displays the uploaded image in an <classname>Image</"
"classname> component."
msgstr ""
"下例上传一个图片到(UNIX)文件系统的 <filename>/tmp/uploads</filename> 目录下 "
"(这个目录必须存在, 否则上传会失败). 然后将上传的图片显示在 <classname>Image</"
"classname> 组件中."

#. Tag: programlisting
#: chapter-components.xml:5331
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Show uploaded file in this placeholder\n"
"final Embedded image = new Embedded(\"Uploaded Image\");\n"
"image.setVisible(false);\n"
"\n"
"// Implement both receiver that saves upload in a file and\n"
"// listener for successful upload\n"
"class ImageUploader implements Receiver, SucceededListener {\n"
"    public File file;\n"
"    \n"
"    public OutputStream receiveUpload(String filename,\n"
"                                      String mimeType) {\n"
"        // Create upload stream\n"
"        FileOutputStream fos = null; // Stream to write to\n"
"        try {\n"
"            // Open the file for writing.\n"
"            file = new File(\"/tmp/uploads/\" + filename);\n"
"            fos = new FileOutputStream(file);\n"
"        } catch (final java.io.FileNotFoundException e) {\n"
"            new Notification(\"Could not open file<br/>\",\n"
"                             e.getMessage(),\n"
"                             Notification.Type.ERROR_MESSAGE)\n"
"                .show(Page.getCurrent());\n"
"            return null;\n"
"        }\n"
"        return fos; // Return the output stream to write to\n"
"    }\n"
"\n"
"    public void uploadSucceeded(SucceededEvent event) {\n"
"        // Show the uploaded file in the image viewer\n"
"        image.setVisible(true);\n"
"        image.setSource(new FileResource(file));\n"
"    }\n"
"};\n"
"ImageUploader receiver = new ImageUploader(); \n"
"\n"
"// Create the upload with a caption and set receiver later\n"
"Upload upload = new Upload(\"Upload Image Here\", receiver);\n"
"upload.setButtonCaption(\"Start Upload\");\n"
"upload.addSucceededListener(receiver);\n"
"        \n"
"// Put the components in a panel\n"
"Panel panel = new Panel(\"Cool Image Storage\");\n"
"Layout panelContent = new VerticalLayout();\n"
"panelContent.addComponents(upload, image);\n"
"panel.setContent(panelContent);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5333
#, no-c-format
msgid ""
"Note that the example does not check the type of the uploaded files in any "
"way, which will cause an error if the content is anything else but an image. "
"The program also assumes that the MIME type of the file is resolved "
"correctly based on the file name extension. After uploading an image, the "
"component will look as shown in <xref linkend=\"figure.ui.upload.example\"/>."
msgstr ""
"注意, 上例并没有检查上传文件的类型, 如果文件不是图片, 可能会导致错误. 例子程"
"序还假设通过文件扩展名能够正确地解析得到文件 MIME 类型. 图片上传完成后, 运行"
"结果类似于 <xref linkend=\"figure.ui.upload.example\"/>."

#. Tag: title
#: chapter-components.xml:5342
#, no-c-format
msgid "Image Upload Example"
msgstr "图片上传示例"

#. Tag: programlisting
#: chapter-components.xml:5354
#, no-c-format
msgid ""
"<![CDATA[.v-upload { }\n"
"  .gwt-FileUpload { }\n"
"  .v-button { }\n"
"    .v-button-wrap { }\n"
"      .v-button-caption { }]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5356
#, no-c-format
msgid ""
"The <classname>Upload</classname> component has an overall <literal>v-"
"upload</literal> style. The upload button has the same structure and style "
"as a regular <classname>Button</classname> component."
msgstr ""
"<classname>Upload</classname> 组件的最外层样式为 <literal>v-upload</"
"literal>. 上传按钮的 HTML 元素结构与样式都与通常的 <classname>Button</"
"classname> 组件一样."

#. Tag: classname
#: chapter-components.xml:5365
#, no-c-format
msgid "ProgressBar"
msgstr "ProgressBar"

#. Tag: para
#: chapter-components.xml:5367
#, no-c-format
msgid ""
"The <classname>ProgressBar</classname> component allows displaying the "
"progress of a task graphically. The progress is specified as a floating-"
"point value between 0.0 and 1.0."
msgstr ""
"<classname>ProgressBar</classname> 组件可用来显示某个任务的执行进度. 进度以 "
"0.0 和 1.0 之间的浮点数值来表示."

#. Tag: title
#: chapter-components.xml:5374
#, no-c-format
msgid "The Progress Bar Component"
msgstr "ProgressBar 组件"

#. Tag: para
#: chapter-components.xml:5382
#, no-c-format
msgid ""
"To display upload progress with the <classname>Upload</classname> component, "
"you can update the progress bar in a <interfacename>ProgressListener</"
"interfacename>."
msgstr ""
"要显示 <classname>Upload</classname> 组件上传文件的进度, 你可以在 "
"<interfacename>ProgressListener</interfacename> 监听器中更新 ProgressBar 的状"
"态."

#. Tag: para
#: chapter-components.xml:5388
#, no-c-format
msgid ""
"When the position of a progress bar is done in a background thread, the "
"change is not shown in the browser immediately. You need to use either "
"polling or server push to update the browser. You can enable polling with "
"<methodname>setPollInterval()</methodname> in the current UI instance. See "
"<xref linkend=\"advanced.push\"/> for instructions about using server push. "
"Whichever method you use to update the UI, it is important to lock the user "
"session by modifying the progress bar value inside <methodname>access()</"
"methodname> call, as illustrated in the following example and described in "
"<xref linkend=\"advanced.push.running\"/>."
msgstr ""
"如果在后台线程中变更了 ProgressBar 的进度位置, 这个变化不会立即显示到浏览器"
"中. 你需要使用客户端轮询技术或服务器端 PUSH 技术来更新浏览器端状态. 你可以使"
"用当前 UI 实例的 <methodname>setPollInterval()</methodname> 方法打开轮询功"
"能. 关于服务器端 PUSH 功能的使用方法, 详情请参见 <xref linkend=\"advanced."
"push\"/>. 无论你使用哪一种方法来更新 UI, 很重要的一个问题是要锁定用户 "
"Session, 方法是在 <methodname>access()</methodname> 调用之内修改 ProgressBar "
"的值, 如下例所示, 这个问题的详情请参见 <xref linkend=\"advanced.push.running"
"\"/>."

#. Tag: programlisting
#: chapter-components.xml:5400
#, no-c-format
msgid ""
"<![CDATA[final ProgressBar bar = new ProgressBar(0.0f);\n"
"layout.addComponent(bar);\n"
"        \n"
"layout.addComponent(new Button(\"Increase\",\n"
"    new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        float current = bar.getValue();\n"
"        if (current < 1.0f)\n"
"            bar.setValue(current + 0.10f);\n"
"    }\n"
"}));]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5403
#, no-c-format
msgid "Indeterminate Mode"
msgstr "模糊模式"

#. Tag: para
#: chapter-components.xml:5405
#, no-c-format
msgid ""
"In the indeterminate mode, a non-progressive indicator is displayed "
"continuously. The indeterminate indicator is a circular wheel in the built-"
"in themes. The progress value has no meaning in the indeterminate mode."
msgstr ""
"在模糊模式下, 会连续不断地显示一个进度不明的指示器. 在内建的 Theme 中, 模糊模"
"式的指示器是一个圆环形. 进度值在模糊模式下是无意义的."

#. Tag: programlisting
#: chapter-components.xml:5412
#, no-c-format
msgid ""
"<![CDATA[ProgressBar bar = new ProgressBar();\n"
"bar.setIndeterminate(true);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5415
#, no-c-format
msgid "Indeterminate Progress Bar"
msgstr "模糊模式下的 ProgressBar"

#. Tag: title
#: chapter-components.xml:5425
#, no-c-format
msgid "Doing Heavy Computation"
msgstr "高负荷计算"

#. Tag: para
#: chapter-components.xml:5427
#, no-c-format
msgid ""
"The progress indicator is often used to display the progress of a heavy "
"server-side computation task, often running in a background thread. The UI, "
"including the progress bar, can be updated either with polling or by using "
"server push. When doing so, you must ensure thread-safety, most easily by "
"updating the UI inside a <methodname>UI.access()</methodname> call in a "
"<interfacename>Runnable</interfacename>, as described in <xref linkend="
"\"advanced.push.running\"/>."
msgstr ""
"进度指示器常用来表示服务器端的高负荷计算工作的进度状况, 这个计算通常运行在后"
"台线程中. UI, 包括 ProgressBar, 可以使用客户端轮询技术或服务器端 PUSH 技术来"
"更新. 此时, 你必须确保线程安全, 最简单的方法是在 <interfacename>Runnable</"
"interfacename> 接口的发起的 <methodname>UI.access()</methodname> 调用之内更"
"新 UI, 详情请参见 <xref linkend=\"advanced.push.running\"/>."

#. Tag: para
#: chapter-components.xml:5437
#, no-c-format
msgid ""
"In the following example, we create a thread in the server to do some "
"\"heavy work\" and use polling to update the UI. All the thread needs to do "
"is to set the value of the progress bar with <methodname>setValue()</"
"methodname> and the current progress is displayed automatically when the "
"browser polls the server."
msgstr ""
"下例中, 我们在服务器端创建一个线程来进行某种 \"高负荷工作\", 并使用客户端轮询"
"方式来更新 UI. 线程所需要做的只是使用 <methodname>setValue()</methodname> 方"
"法设置 ProgressBar 的值, 当浏览器向服务器发起轮询时, 当前的进度就会自动显示出"
"来."

#. Tag: programlisting
#: chapter-components.xml:5445
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[HorizontalLayout barbar = new "
"HorizontalLayout();\n"
"layout.addComponent(barbar);\n"
"        \n"
"// Create the indicator, disabled until progress is started\n"
"final ProgressBar progress = new ProgressBar(new Float(0.0));\n"
"progress.setEnabled(false);\n"
"barbar.addComponent(progress);\n"
"        \n"
"final Label status = new Label(\"not running\");\n"
"barbar.addComponent(status);\n"
"\n"
"// A button to start progress\n"
"final Button button = new Button(\"Click to start\");\n"
"layout.addComponent(button);\n"
"\n"
"// A thread to do some work\n"
"class WorkThread extends Thread {\n"
"    // Volatile because read in another thread in access()\n"
"    volatile double current = 0.0;\n"
"\n"
"    @Override\n"
"    public void run() {\n"
"        // Count up until 1.0 is reached\n"
"        while (current < 1.0) {\n"
"            current += 0.01;\n"
"\n"
"            // Do some \"heavy work\"\n"
"            try {\n"
"                sleep(50); // Sleep for 50 milliseconds\n"
"            } catch (InterruptedException e) {}\n"
"\n"
"            // Update the UI thread-safely\n"
"            UI.getCurrent().access(new Runnable() {\n"
"                @Override\n"
"                public void run() {\n"
"                    progress.setValue(new Float(current));\n"
"                    if (current < 1.0)\n"
"                        status.setValue(\"\" +\n"
"                            ((int)(current*100)) + \"% done\");\n"
"                    else\n"
"                        status.setValue(\"all done\");\n"
"                }\n"
"            });\n"
"        }\n"
"        \n"
"        // Show the \"all done\" for a while\n"
"        try {\n"
"            sleep(2000); // Sleep for 2 seconds\n"
"        } catch (InterruptedException e) {}\n"
"\n"
"        // Update the UI thread-safely\n"
"        UI.getCurrent().access(new Runnable() {\n"
"            @Override\n"
"            public void run() {\n"
"                // Restore the state to initial\n"
"                progress.setValue(new Float(0.0));\n"
"                progress.setEnabled(false);\n"
"                        \n"
"                // Stop polling\n"
"                UI.getCurrent().setPollInterval(-1);\n"
"                \n"
"                button.setEnabled(true);\n"
"                status.setValue(\"not running\");\n"
"            }\n"
"        });\n"
"    }\n"
"}\n"
"\n"
"// Clicking the button creates and runs a work thread\n"
"button.addClickListener(new Button.ClickListener() {\n"
"    public void buttonClick(ClickEvent event) {\n"
"        final WorkThread thread = new WorkThread();\n"
"        thread.start();\n"
"\n"
"        // Enable polling and set frequency to 0.5 seconds\n"
"        UI.getCurrent().setPollInterval(500);\n"
"\n"
"        // Disable the button until the work is done\n"
"        progress.setEnabled(true);\n"
"        button.setEnabled(false);\n"
"\n"
"        status.setValue(\"running...\");\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5447
#, no-c-format
msgid ""
"The example is illustrated in <xref linkend=\"figure.components.progressbar."
"thread\"/>."
msgstr ""
"上例的运行结果见 <xref linkend=\"figure.components.progressbar.thread\"/>."

#. Tag: title
#: chapter-components.xml:5453
#, no-c-format
msgid "Doing Heavy Work"
msgstr "执行高负荷工作"

#. Tag: programlisting
#: chapter-components.xml:5465
#, no-c-format
msgid ""
"<![CDATA[.v-progressbar, v-progressbar-indeterminate {}\n"
"  .v-progressbar-wrapper {}\n"
"    .v-progressbar-indicator {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5467
#, no-c-format
msgid ""
"The progress bar has a <literal>v-progressbar</literal> base style. The "
"animation is the background of the element with <literal>v-progressbar-"
"wrapper</literal> style, by default an animated GIF image. The progress is "
"an element with <literal>v-progressbar-indicator</literal> style inside the "
"wrapper, and therefore displayed on top of it. When the progress element "
"grows, it covers more and more of the animated background."
msgstr ""
"ProgressBar 的最外层样式是 <literal>v-progressbar</literal>. 动画部分是 "
"<literal>v-progressbar-wrapper</literal> 样式元素的背景图, 默认是一个动画 "
"GIF 图片. 进度是 wrapper 内的一个 <literal>v-progressbar-indicator</literal> "
"样式的元素, 因此显示在 wrapper 的顶部. 当进度元素增长时, 它会越来越多地将背景"
"动画图片覆盖住."

#. Tag: para
#: chapter-components.xml:5477
#, no-c-format
msgid ""
"In the indeterminate mode, the top element also has the <literal>v-"
"progressbar-indeterminate</literal> style. The built-in themes simply "
"display the animated GIF in the top element and have the inner elements "
"disabled."
msgstr ""
"在模糊模式下, 顶层元素还带有 <literal>v-progressbar-indeterminate</literal> "
"样式. 内建的 Theme 只在顶层元素中简单地显示一个动画 GIF, 然后将下层元素全部禁"
"用."

#. Tag: classname
#: chapter-components.xml:5487
#, no-c-format
msgid "Slider"
msgstr "Slider"

#. Tag: para
#: chapter-components.xml:5489
#, no-c-format
msgid ""
"The <classname>Slider</classname> is a vertical or horizontal bar that "
"allows setting a numeric value within a defined range by dragging a bar "
"handle with the mouse. The value is shown when dragging the handle."
msgstr ""
"<classname>Slider</classname> 是一个垂直条或水平条, 用户可以使用鼠标拖动其中"
"的滑块, 即可在指定的范围之内设定一个数值. 鼠标拖动滑块时, 会显示对应的数值."

#. Tag: para
#: chapter-components.xml:5495
#, no-c-format
msgid ""
"<classname>Slider</classname> has a number of different constructors that "
"take a combination of the caption, <emphasis>minimum</emphasis> and "
"<emphasis>maximum</emphasis> value, <emphasis>resolution</emphasis>, and the "
"<emphasis>orientation</emphasis> of the slider."
msgstr ""
"<classname>Slider</classname> 有很多不同版本的构造器, 这些构造器接受以下参数"
"的组合: 标题, <emphasis>最小</emphasis>值, <emphasis>最大</emphasis> 值, "
"<emphasis>精度</emphasis>, 以及 slider 的 <emphasis>方向</emphasis>."

#. Tag: programlisting
#: chapter-components.xml:5502
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a vertical slider\n"
"final Slider vertslider = new Slider(1, 100);\n"
"vertslider.setOrientation(SliderOrientation.VERTICAL);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5505
#, no-c-format
msgid "Slider Properties"
msgstr "Slider 的属性"

#. Tag: emphasis
#: chapter-components.xml:5507
#, no-c-format
msgid "<emphasis>min</emphasis>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5509
#, no-c-format
msgid "Minimum value of the slider range. The default is 0.0."
msgstr "Slider 可选择的数值范围最小值. 默认为 0.0."

#. Tag: emphasis
#: chapter-components.xml:5515
#, no-c-format
msgid "<emphasis>max</emphasis>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5517
#, no-c-format
msgid "Maximum value of the slider range. The default is 100.0."
msgstr "Slider 可选择的数值范围最大值. 默认为 100.0."

#. Tag: emphasis
#: chapter-components.xml:5523
#, no-c-format
msgid "resolution"
msgstr ""

#. Tag: para
#: chapter-components.xml:5525
#, no-c-format
msgid "The number of digits after the decimal point. The default is 0."
msgstr "小数点后数字的位数. 默认为 0."

#. Tag: emphasis
#: chapter-components.xml:5531
#, no-c-format
msgid "orientation"
msgstr ""

#. Tag: para
#: chapter-components.xml:5533
#, no-c-format
msgid ""
"The orientation can be either horizontal (<parameter>SliderOrientation."
"HORIZONTAL</parameter>) or vertical (<parameter>SliderOrientation.VERTICAL</"
"parameter>). The default is horizontal."
msgstr ""
"方向可以是水平 (<parameter>SliderOrientation.HORIZONTAL</parameter>) 或垂直"
"(<parameter>SliderOrientation.VERTICAL</parameter>). 默认为水平."

#. Tag: para
#: chapter-components.xml:5543
#, no-c-format
msgid ""
"As the <classname>Slider</classname> is a field component, you can handle "
"value changes with a <classname>ValueChangeListener</classname>. The value "
"of the <classname>Slider</classname> field is a <classname>Double</"
"classname> object."
msgstr ""
"由于 <classname>Slider</classname> 是一个 Field 组件, 你可以使用 "
"<classname>ValueChangeListener</classname> 监听器来处理它的值变更事件. "
"<classname>Slider</classname> Field 的值是 <classname>Double</classname> 对"
"象."

#. Tag: programlisting
#: chapter-components.xml:5550
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Shows the value of the vertical slider\n"
"final Label vertvalue = new Label();\n"
"vertvalue.setSizeUndefined();\n"
"\n"
"// Handle changes in slider value.\n"
"vertslider.addValueChangeListener(\n"
"    new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        double value = (Double) vertslider.getValue();\n"
"\n"
"        // Use the value\n"
"        box.setHeight((float) value, Sizeable.UNITS_PERCENTAGE);\n"
"        vertvalue.setValue(String.valueOf(value));\n"
"    }\n"
"});\n"
"\n"
"// The slider has to be immediate to send the changes\n"
"// immediately after the user drags the handle.\n"
"vertslider.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5552
#, no-c-format
msgid ""
"You can set the value with the <methodname>setValue()</methodname> method "
"defined in <classname>Slider</classname> that takes the value as a native "
"double value. The setter can throw a <classname>ValueOutOfBoundsException</"
"classname>, which you must handle."
msgstr ""
"你可以使用 <classname>Slider</classname> 类的 <methodname>setValue()</"
"methodname> 方法来设置 Slider 的值, 方法参数为 double 类型值. 这个方法可能会"
"抛出 <classname>ValueOutOfBoundsException</classname> 异常, 你必须处理这个异"
"常."

#. Tag: programlisting
#: chapter-components.xml:5559
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Set the initial value. This has to be set "
"after the\n"
"// listener is added if we want the listener to handle\n"
"// also this value change.\n"
"try {\n"
"        vertslider.setValue(50.0);\n"
"} catch (ValueOutOfBoundsException e) {\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5561
#, no-c-format
msgid ""
"Alternatively, you can use the regular <methodname>setValue(Object)</"
"methodname>, which does not do bounds checking."
msgstr ""
"或者你也可以使用通常的 <methodname>setValue(Object)</methodname> 方法, 这个方"
"法不会进行值的上下边界检查."

#. Tag: para
#: chapter-components.xml:5566
#, no-c-format
msgid ""
"shows both vertical (from the code examples) and horizontal sliders that "
"control the size of a box. The slider values are displayed also in separate "
"labels."
msgstr ""
"显示了垂直(与上面的示例代码一致) 和水平的 Slider, 这两个 Slider 控制方框的尺"
"寸. Slider 的值也分别显示在 Label 组件中."

#. Tag: title
#: chapter-components.xml:5573
#, no-c-format
msgid "The <classname>Slider</classname> Component"
msgstr "<classname>Slider</classname> 组件"

#. Tag: programlisting
#: chapter-components.xml:5587
#, no-c-format
msgid ""
"<![CDATA[.v-slider {}\n"
".v-slider-base {}\n"
".v-slider-handle {}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5589
#, no-c-format
msgid ""
"The enclosing style for the <classname>Slider</classname> is <literal>v-"
"slider</literal>. The slider bar has style <literal>v-slider-base</literal>. "
"Even though the handle is higher (for horizontal slider) or wider (for "
"vertical slider) than the bar, the handle element is nevertheless contained "
"within the slider bar element. The appearance of the handle comes from a "
"background image defined in the <emphasis>background</emphasis> CSS property."
msgstr ""
"<classname>Slider</classname> 组件的最外层样式为 <literal>v-slider</"
"literal>. Slider 条的样式为 <literal>v-slider-base</literal>. 虽然滑块比 "
"Slider 条要更高(对于水平条情况)或更宽(对于垂直条的情况), 但滑块的 HTML 元素还"
"是包含在 Slider 条的 HTML 元素之内. 滑块的外观表现是通过它的 CSS 属性 "
"<emphasis>background</emphasis> 指定的背景图片来实现的."

#. Tag: classname
#: chapter-components.xml:5602
#, no-c-format
msgid "Calendar"
msgstr "Calendar"

#. Tag: para
#: chapter-components.xml:5604
#, no-c-format
msgid ""
"The <classname>Calendar</classname> component allows organizing and "
"displaying calendar events. The main features of the calendar include:"
msgstr ""
"<classname>Calendar</classname> 组件用于组织和显示日历上的事件. 日历的主要功"
"能包括:"

#. Tag: listitem
#: chapter-components.xml:5610
#, no-c-format
msgid "Monthly, weekly, and daily views"
msgstr "月单位, 周单位, 日单位的显示模式"

#. Tag: listitem
#: chapter-components.xml:5613
#, no-c-format
msgid "Two types of events: all-day events and events with a time range"
msgstr "支持两种事件: 全日事件, 和某个时间范围内的事件"

#. Tag: listitem
#: chapter-components.xml:5616
#, no-c-format
msgid ""
"Add events directly, from a <classname>Container</classname>, or with an "
"event provider"
msgstr ""
"所有事件, 直接来自于 <classname>Container</classname>, 或者由 Event Provider "
"提供."

#. Tag: listitem
#: chapter-components.xml:5619
#, no-c-format
msgid "Control the range of the visible dates"
msgstr "控制可见的日期范围"

#. Tag: listitem
#: chapter-components.xml:5622
#, no-c-format
msgid "Selecting and editing date or time range by dragging"
msgstr "通过鼠标拖动来选择或编辑日期/时刻的范围"

#. Tag: listitem
#: chapter-components.xml:5625
#, no-c-format
msgid "Drag and drop events to calendar"
msgstr "将事件拖放到日历中"

#. Tag: listitem
#: chapter-components.xml:5628
#, no-c-format
msgid "Support for localization and timezones"
msgstr "支持本地化和时区"

#. Tag: para
#: chapter-components.xml:5633
#, no-c-format
msgid ""
"User interaction with the calendar elements, such as date and week captions "
"as well as events, is handled with event listeners. Also date/time range "
"selections, event dragging, and event resizing can be listened by the "
"server. The weekly view has navigation buttons to navigate forward and "
"backward in time. These actions are also listened by the server. Custom "
"navigation can be implemented using event handlers<phrase condition=\"web"
"\">, as described in <xref linkend=\"components.calendar.customizing\"/></"
"phrase>."
msgstr ""
"日历中的元素, 比如日期和周的标题, 事件, 用户对它们的操作使用事件监听器来处"
"理. 此外, 日期/时间范围的选择, 事件的拖放, 以及事件长短的变更都可以在服务器端"
"监听. 周单位显示模式带有遍历按钮, 可以将时间向前或向后翻滚. 这些动作也由服务"
"器来监听. 可以使用事件处理器来实现自定义的遍历动作<phrase condition=\"web"
"\">, 详情请参见 <xref linkend=\"components.calendar.customizing\"/></phrase>."

#. Tag: para
#: chapter-components.xml:5643
#, no-c-format
msgid ""
"The data source of a calendar can be practically anything, as its events are "
"queried dynamically by the component. You can bind the calendar to a Vaadin "
"container, or to any other data source by implementing an <emphasis>event "
"provider</emphasis>."
msgstr ""
"日历的数据源实际上可以是任意的对象, 因为日历中的事件是有组件动态请求的. 你可"
"以将日历绑定到一个 Vaadin 容器, 或者实现 <emphasis>Event Provider</"
"emphasis>, 来将日历绑定到任意的数据源."

#. Tag: para
#: chapter-components.xml:5650
#, no-c-format
msgid ""
"The <classname>Calendar</classname> has undefined size by default and you "
"usually want to give it a fixed or relative size, for example as follows."
msgstr ""
"<classname>Calendar</classname> 默认尺寸为未定义, 你通常会希望指定一个固定尺"
"寸或相对尺寸, 如下例."

#. Tag: programlisting
#: chapter-components.xml:5655
#, no-c-format
msgid ""
"<![CDATA[Calendar cal = new Calendar(\"My Calendar\");\n"
"cal.setWidth(\"600px\");\n"
"cal.setHeight(\"300px\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5657
#, no-c-format
msgid ""
"After creating the calendar, you need to set a time range for it, which also "
"controls the view mode, and set up the data source for calendar events."
msgstr ""
"创建完日历后, 你需要为它设置时间范围, 时间范围同时也控制日历的显示模式, 你还"
"需要为日历中的事件设置数据源."

#. Tag: title
#: chapter-components.xml:5663
#, no-c-format
msgid "Date Range and View Mode"
msgstr "日期范围与显示模式"

#. Tag: para
#: chapter-components.xml:5665
#, no-c-format
msgid ""
"The Vaadin Calendar has two types of views that are shown depending on the "
"date range of the calendar. The <emphasis>weekly view</emphasis> displays a "
"week by default. It can show anything between one to seven days a week, and "
"is also used as a single-day view. The view mode is determined from the "
"<emphasis>date range</emphasis> of the calendar, defined by a start and an "
"end date. Calendar will be shown in a <emphasis>monthly view</emphasis> when "
"the date range is over than one week (seven days) long. The date range is "
"always calculated in an accuracy of one millisecond."
msgstr ""
"Vaadin Calendar 有两种显示模式, 显示哪一种取决于日历的日期范围. <emphasis>周"
"单位显示模式</emphasis> 默认显示一周. 它可以显示一周 7 天之内的信息, 而且它还"
"用作日单位显示. 显示模式由日历的 <emphasis>日期范围</emphasis> 来决定, 日期范"
"围是指日历的开始日期和结束日期. 如果日期范围超过 1 周(7 日), 日历将显示为 "
"<emphasis>月单位显示模式</emphasis>. 日期范围以毫秒为单位进行计算."

#. Tag: title
#: chapter-components.xml:5678
#, no-c-format
msgid "Monthly view with All-Day and Normal Events"
msgstr "月单位显示模式, 包含全日事件和通常事件"

#. Tag: para
#: chapter-components.xml:5689
#, no-c-format
msgid ""
"The monthly view, shown in <xref linkend=\"figure.components.calendar."
"daterange.monthly\"/>, can easily be used to control all types of events, "
"but it is best suited for events that last for one or more days. You can "
"drag the events to move them. In the figure, you can see two longer events "
"that are highlighted with a blue and green background color. Other markings "
"are shorter day events that last less than a 24 hours. These events can not "
"be moved by dragging in the monthly view."
msgstr ""
"月单位显示模式, 见 <xref linkend=\"figure.components.calendar.daterange."
"monthly\"/>, 可以很容易地控制所有类型的事件, 但它最适用于那些持续时间超过 1 "
"日或多日的事件. 你可以拖动事件来移动它. 在图中, 你可以看到两个较长的事件, 显"
"示为蓝色和绿色的高亮背景色. 其他几个标记代表较短的事件, 其持续时间不到 24 小"
"时. 在月单位显示模式中, 这样的事件不可以通过拖动来移动."

#. Tag: title
#: chapter-components.xml:5701
#, no-c-format
msgid "Weekly View"
msgstr "周单位显示模式"

#. Tag: para
#: chapter-components.xml:5712
#, no-c-format
msgid ""
"In <xref linkend=\"figure.components.calendar.daterange.weekly\"/>, you can "
"see four normal day events and also all-day events at the top of the time "
"line grid."
msgstr ""
"在 <xref linkend=\"figure.components.calendar.daterange.weekly\"/> 中, 你可以"
"看到 4 个通常的日事件, 在时间线表格上方还有全日事件."

#. Tag: para
#: chapter-components.xml:5718
#, no-c-format
msgid ""
"In the following, we set the calendar to show only one day, which is the "
"current day."
msgstr "下面, 我们将日历设置为只显示 1 日, 也就是当前日."

#. Tag: programlisting
#: chapter-components.xml:5723
#, no-c-format
msgid ""
"<![CDATA[cal.setStartDate(new Date());\n"
"cal.setEndDate(new Date());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5725
#, no-c-format
msgid ""
"Notice that although the range we set above is actually zero time long, the "
"calendar still renders the time from 00:00 to 23:59. This is normal, as the "
"Vaadin Calendar is guaranteed to render at least the date range provided, "
"but may expand it. This behaviour is important to notice when we implement "
"our own event providers."
msgstr ""
"注意, 我们上面设置的日期范围长度其实为 0, 但日历仍然会显示从 00:00 到 23:59 "
"的时间. 这是正常的, 因为 Vaadin Calendar 会保证至少显示你指定的日期范围, 但也"
"有可能显示更大的范围. 当我们实现自定义的 Event Provider 时, 一定要注意日历的"
"这种行为."

#. Tag: title
#: chapter-components.xml:5735
#, no-c-format
msgid "Calendar Events"
msgstr "日历中的事件"

#. Tag: para
#: chapter-components.xml:5737
#, no-c-format
msgid ""
"All occurrences in a calendar are represented as <emphasis>events</"
"emphasis>. You have three ways to manage the calendar events:"
msgstr ""
"在日历内发生的一切事情都表达为 <emphasis>事件(Event)</emphasis>. 你有三种方法"
"管理日历内的事件:"

#. Tag: listitem
#: chapter-components.xml:5744
#, no-c-format
msgid ""
"Add events directly to the <classname>Calendar</classname> object using the "
"<methodname>addEvent()</methodname>"
msgstr ""
"使用 <methodname>addEvent()</methodname> 方法将事件直接加入到 "
"<classname>Calendar</classname> 对象中"

#. Tag: listitem
#: chapter-components.xml:5749
#, no-c-format
msgid "Use a <interfacename>Container</interfacename> as a data source"
msgstr "使用一个 <interfacename>Container</interfacename> 作为数据源"

#. Tag: listitem
#: chapter-components.xml:5753
#, no-c-format
msgid "Use the <emphasis>event provider</emphasis> mechanism"
msgstr "使用 <emphasis>Event Provider</emphasis> 机制"

#. Tag: para
#: chapter-components.xml:5758
#, no-c-format
msgid ""
"You can add events with <methodname>addEvent()</methodname> and remove them "
"with the <methodname>removeEvent()</methodname>. These methods will use the "
"underlying event provider to write the modifications to the data source."
msgstr ""
"你可以使用 <methodname>addEvent()</methodname> 方法来添加事件, 使用 "
"<methodname>removeEvent()</methodname> 方法删除. 这些方法会使用底层隐含的 "
"Event Provider 来将变更写入到数据源中."

#. Tag: title
#: chapter-components.xml:5766
#, no-c-format
msgid "Event Interfaces and Providers"
msgstr "事件的接口和提供者"

#. Tag: para
#: chapter-components.xml:5768
#, no-c-format
msgid ""
"Events are handled though the <interfacename>CalendarEvent</interfacename> "
"interface. The concrete class of the event depends on the specific "
"<classname>CalendarEventProvider</classname> used in the calendar."
msgstr ""
"事件通过 <interfacename>CalendarEvent</interfacename> 接口来管理. 具体的 "
"Event 类是什么, 由日历的 <classname>CalendarEventProvider</classname> 来决定."

#. Tag: para
#: chapter-components.xml:5775
#, no-c-format
msgid ""
"By default, <classname>Calendar</classname> uses a "
"<classname>BasicEventProvider</classname> to provide events, which uses "
"<classname>BasicEvent</classname> instances."
msgstr ""
"默认情况下, <classname>Calendar</classname> 使用 "
"<classname>BasicEventProvider</classname> 来提供事件, 这个 Provider 使用 "
"<classname>BasicEvent</classname> 类."

#. Tag: para
#: chapter-components.xml:5781
#, no-c-format
msgid ""
"Calendar does not depend on any particular data source implementation. "
"Events are queried by the <classname>Calendar</classname> from the provider "
"that just has to implement the <interfacename>CalendarEventProvider</"
"interfacename> interface. It is up to the event provider that "
"<classname>Calendar</classname> gets the correct events."
msgstr ""
"日历并不依赖于任何特定的数据源实现类. 事件由 <classname>Calendar</classname> "
"向 Provider 请求取得, Provider 只需要实现 "
"<interfacename>CalendarEventProvider</interfacename> 接口. 由 Event Provider "
"负责保证 <classname>Calendar</classname> 得到正确的事件."

#. Tag: para
#: chapter-components.xml:5790
#, no-c-format
msgid ""
"You can bind any Vaadin <classname>Container</classname> to a calendar, in "
"which case a <classname>ContainerEventProvider</classname> is used "
"transparently. The container must be ordered by start date and time of the "
"events. See <xref linkend=\"datamodel.container\"/> for basic information "
"about containers."
msgstr ""
"你可以将任意的 Vaadin <classname>Container</classname> 绑定到日历, 这时会透明"
"地使用 <classname>ContainerEventProvider</classname>. 容器内的数据必须按事件"
"的开始日期/时刻排序. 关于容器, 详情请参见 <xref linkend=\"datamodel.container"
"\"/>."

#. Tag: title
#: chapter-components.xml:5801
#, no-c-format
msgid "Event Types"
msgstr "事件的类型"

#. Tag: para
#: chapter-components.xml:5803
#, no-c-format
msgid ""
"A calendar event requires a start time and an end time. These are the only "
"mandatory properties. In addition, an event can also be set as an all-day "
"event by setting the <literal>all-day</literal> property of the event. You "
"can also set the <literal>description</literal> of an event, which is "
"displayed as a tooltip in the user interface."
msgstr ""
"日历中的事件需要指定开始时刻和结束时刻. 这只是必须属性. 除此之外, 事件还可以"
"设置 <literal>全日(all-day)</literal> 属性而成为全日事件(All-Day Event). 你还"
"可以设置事件的 <literal>描述信息</literal>, 这个信息会在 UI 中显示为提示信息"
"(Tooltip)."

#. Tag: para
#: chapter-components.xml:5811
#, no-c-format
msgid ""
"If the <literal>all-day</literal> field of the event is <literal>true</"
"literal>, then the event is always rendered as an all-day event. In the "
"monthly view, this means that no start time is displayed in the user "
"interface and the event has an colored background. In the weekly view, all-"
"day events are displayed in the upper part of the screen, and rendered "
"similarly to the monthly view. In addition, when the time range of an event "
"is 24 hours or longer, it is rendered as an all-day event in the monthly "
"view."
msgstr ""
"如果事件的 <literal>all-day</literal> 属性为 <literal>true</literal>, 那么事"
"件会永远显示为全日事件. 在月单位显示模式下, 全日事件在 UI 中不会显示开始时"
"刻, 而且会有彩色的背景色. 在周单位显示模式下, 全日事件显示在画面的上部, 显示"
"方式与月单位显示模式类似. 此外, 如果一个事件的时间范围为 24 小时或更长, 它在"
"月单位显示模式下也会以全日事件的方式显示."

#. Tag: para
#: chapter-components.xml:5822
#, no-c-format
msgid ""
"When the time range of an event is equal or less than 24 hours, with the "
"accuracy of one millisecond, the event is considered as a normal day event. "
"Normal event has a start and end times that may be on different days."
msgstr ""
"如果事件的时间范围(以毫秒精度计算)等于或小于 24 小时, 这个事件会被认为是通常"
"的日事件. 通常事件有开始时刻和结束时刻, 这两个时刻可以属于不同的日."

#. Tag: title
#: chapter-components.xml:5831
#, no-c-format
msgid "Basic Events"
msgstr "基本事件"

#. Tag: para
#: chapter-components.xml:5833
#, no-c-format
msgid ""
"The easiest way to add and manage events in a calendar is to use the "
"<emphasis>basic event</emphasis> management API. Calendar uses by default a "
"<classname>BasicEventProvider</classname>, which keeps the events in memory "
"in an internal reprensetation."
msgstr ""
"在日历中添加和管理事件的最简单方法是使用 <emphasis>基本事件</emphasis> 的管"
"理 API. 日历默认使用 <classname>BasicEventProvider</classname>, 它将事件以某"
"种内部形式保存在内存中."

#. Tag: para
#: chapter-components.xml:5840
#, no-c-format
msgid ""
"For example, the following adds a two-hour event starting from the current "
"time. The standard Java <classname>GregorianCalendar</classname> provides "
"various ways to manipulate date and time."
msgstr ""
"比如, 下例添加一个 2 小时长的事件, 开始时刻为现在时刻. 标准的 Java "
"<classname>GregorianCalendar</classname> 类提供了几种方式来操中日期和时间."

#. Tag: programlisting
#: chapter-components.xml:5848
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Add a two-hour event\n"
"GregorianCalendar start = new GregorianCalendar();\n"
"GregorianCalendar end   = new GregorianCalendar();\n"
"end.add(java.util.Calendar.HOUR, 2);\n"
"calendar.addEvent(new BasicEvent(\"Calendar study\",\n"
"        \"Learning how to use Vaadin Calendar\",\n"
"        start.getTime(), end.getTime()));]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5851
#, no-c-format
msgid ""
"This adds a new event that lasts for 3 hours. As the BasicEventProvider and "
"BasicEvent implement some optional event interfaces provided by the calendar "
"package, there is no need to refresh the calendar. Just create events, set "
"their properties and add them to the Event Provider."
msgstr ""
"这段代码添加一个持续 3 小时(译注: 看代码貌似应该是 2 小时)的事件. 由于 "
"BasicEventProvider 和 BasicEvent 实现了日历包中的一些额外的事件接口, 因此我们"
"不需要刷新日历. 只需要创建事件, 设置它的属性, 然后添加到 Event Provider 中即"
"可."

#. Tag: title
#: chapter-components.xml:5861
#, no-c-format
msgid "Getting Events from a Container"
msgstr "从容器得到事件"

#. Tag: para
#: chapter-components.xml:5863
#, no-c-format
msgid ""
"You can use any Vaadin <interfacename>Container</interfacename> that "
"implements the <interfacename>Indexed</interfacename> interface as the data "
"source for calendar events. The <classname>Calendar</classname> will listen "
"to change events from the container as well as write changes to the "
"container. You can attach a container to a <classname>Calendar</classname> "
"with <methodname>setContainerDataSource()</methodname>."
msgstr ""
"你可以使用任意的 Vaadin <interfacename>Container</interfacename> 作为日历事件"
"的数据源, 但容器需要实现 <interfacename>Indexed</interfacename> 接口. "
"<classname>Calendar</classname> 会监听容器中的事件变化, 也会将变化写回到容"
"器. 你可以使用 <methodname>setContainerDataSource()</methodname> 方法将容器绑"
"定到 <classname>Calendar</classname>."

#. Tag: para
#: chapter-components.xml:5872
#, no-c-format
msgid ""
"In the following example, we bind a <classname>BeanItemContainer</classname> "
"that contains built-in <classname>BasicEvent</classname> events to a "
"calendar."
msgstr ""
"下例中, 我们为日历绑定一个 <classname>BeanItemContainer</classname>, 容器中包"
"含的是内建的 <classname>BasicEvent</classname> 事件类."

#. Tag: programlisting
#: chapter-components.xml:5879
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create the calendar\n"
"Calendar calendar = new Calendar(\"Bound Calendar\");\n"
"\n"
"// Use a container of built-in BasicEvents\n"
"final BeanItemContainer<BasicEvent> container =\n"
"    new BeanItemContainer<BasicEvent>(BasicEvent.class);        \n"
"\n"
"// Create a meeting in the container\n"
"container.addBean(new BasicEvent(\"The Event\", \"Single Event\",\n"
"            new GregorianCalendar(2012,1,14,12,00).getTime(),\n"
"            new GregorianCalendar(2012,1,14,14,00).getTime()));\n"
"\n"
"// The container must be ordered by the start time. You\n"
"// have to sort the BIC every time after you have added\n"
"// or modified events.\n"
"container.sort(new Object[]{\"start\"}, new boolean[]{true});\n"
"\n"
"calendar.setContainerDataSource(container, \"caption\",\n"
"    \"description\", \"start\", \"end\", \"styleName\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5881
#, no-c-format
msgid ""
"The container must either use the default property IDs for event data, as "
"defined in the <interfacename>CalendarEvent</interfacename> interface, or "
"provide them as parameters for the <methodname>setContainerDataSource()</"
"methodname> method, as we did in the example above."
msgstr ""
"容器必须对事件的各种数据使用默认的属性 ID, 这些属性 ID 应该与 "
"<interfacename>CalendarEvent</interfacename> 接口中的定义一致, 否则的话, 应该"
"像上面的示例代码那样, 在 <methodname>setContainerDataSource()</methodname> 方"
"法的参数中指定这些属性 ID."

#. Tag: title
#: chapter-components.xml:5890
#, no-c-format
msgid "Keeping the Container Ordered"
msgstr "保证容器内数据的顺序正确"

#. Tag: para
#: chapter-components.xml:5892
#, no-c-format
msgid ""
"The events in the container <emphasis>must</emphasis> be kept ordered by "
"their start date/time. Failing to do so may and will result in the events "
"not showing in the calendar properly."
msgstr ""
"容器内的事件 <emphasis>必须</emphasis> 按它们的开始日期/时刻排序. 如果排序不"
"正确, 会导致事件在日历中无法正确显示."

#. Tag: para
#: chapter-components.xml:5898
#, no-c-format
msgid ""
"Ordering depends on the container. With some containers, such as "
"<classname>BeanItemContainer</classname>, you have to sort the container "
"explicitly every time after you have added or modified events, usually with "
"the <methodname>sort()</methodname> method, as we did in the example above. "
"Some container, such as <classname>JPAContainer</classname>, keep the in "
"container automatically order if you provide a sorting rule."
msgstr ""
"排序是由容器决定的. 对于某些容器, 比如 <classname>BeanItemContainer</"
"classname>, 每次你添加事件或修改事件之后都必须明确地排序, 通常是使用 "
"<methodname>sort()</methodname> 方法, 像上面的示例代码那样. 某些容器, 比如 "
"<classname>JPAContainer</classname>, 如果你指定了排序规则, 容器会自动排序."

#. Tag: para
#: chapter-components.xml:5908
#, no-c-format
msgid ""
"For example, you could order a <classname>JPAContainer</classname> by the "
"following rule, assuming that the start date/time is held in the "
"<literal>startDate</literal> property:"
msgstr ""
"比如, 假设事件的开始日期/时刻保存在 <literal>startDate</literal> 属性中, 你可"
"以使用以下规则对 <classname>JPAContainer</classname> 排序:"

#. Tag: programlisting
#: chapter-components.xml:5915
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// The container must be ordered by start date. "
"For JPAContainer\n"
"// we can just set up sorting once and it will stay ordered.\n"
"container.sort(new String[]{\"startDate\"}, new boolean[]{true});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5920
#, no-c-format
msgid "Delegation of Event Management"
msgstr "事件管理的委托"

#. Tag: para
#: chapter-components.xml:5922
#, no-c-format
msgid ""
"Setting a container as the calendar data source with "
"<methodname>setContainerDataSource()</methodname> automatically switches to "
"<classname>ContainerEventProvider</classname>. You can manipulate the event "
"data through the API in <classname>Calendar</classname> and the user can "
"move and resize event through the user interface. The event provider "
"delegates all such calendar operations to the container."
msgstr ""
"使用 <methodname>setContainerDataSource()</methodname> 方法将容器设置为日历的"
"数据源, 会自动切换到 <classname>ContainerEventProvider</classname>. 你可以通"
"过 <classname>Calendar</classname> 类中的 API 来操纵事件数据, 用户也可以通过 "
"UI 来移动和拖动事件尺寸. Event Provider 负责将所有的这些日历操作代理到容器中."

#. Tag: para
#: chapter-components.xml:5931
#, no-c-format
msgid ""
"If you add events through the <classname>Calendar</classname> API, notice "
"that you may be unable to create events of the type held in the container or "
"adding them requires some container-specific operations. In such case, you "
"may need to customize the <methodname>addEvent()</methodname> method."
msgstr ""
"如果你使用 <classname>Calendar</classname> API 来添加事件, 注意你有可能无法创"
"建容器所要求的数据类型的事件对象, 对于那些需要特定操作的容器, 你也无法添加事"
"件. 这种情况下, 你可能需要定制 <methodname>addEvent()</methodname> 方法."

#. Tag: para
#: chapter-components.xml:5939
#, no-c-format
msgid ""
"For example, <classname>JPAContainer</classname> requires adding new items "
"with <methodname>addEntity()</methodname>. You could first add the entity to "
"the container or entity manager directly and then pass it to the "
"<methodname>addEvent()</methodname>. That does not, however, work if the "
"entity class does not implement <interfacename>CalendarEvent</"
"interfacename>. This is actually the case always if the property names "
"differ from the ones defined in the interface. You could handle creating the "
"underlying entity objects in the <methodname>addEvent()</methodname> as "
"follows:"
msgstr ""
"比如, <classname>JPAContainer</classname> 要求使用 <methodname>addEntity()</"
"methodname> 方法来创建新项目. 你可以先将项目直接添加到容器或其他的项目管理器"
"中, 然后再将它传递给 <methodname>addEvent()</methodname> 方法. 但是, 如果项目"
"类没有实现 <interfacename>CalendarEvent</interfacename> 接口的话, 这种方法是"
"行不通的. 如果数据项目类的属性名与 CalendarEvent 接口的定义不一致的话, 就总会"
"发生这个问题. 你可以在 <methodname>addEvent()</methodname> 方法内管理底层数据"
"对象的创建过程, 如下例所示:"

#. Tag: programlisting
#: chapter-components.xml:5951
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a JPAContainer\n"
"final JPAContainer<MyCalendarEvent> container =\n"
"    JPAContainerFactory.make(MyCalendarEvent.class,\n"
"                             \"book-examples\");\n"
"\n"
"// Customize the event provider for adding events\n"
"// as entities\n"
"ContainerEventProvider cep =\n"
"        new ContainerEventProvider(container) {\n"
"    @Override\n"
"    public void addEvent(CalendarEvent event) {\n"
"        MyCalendarEvent entity = new MyCalendarEvent(\n"
"            event.getCaption(), event.getDescription(),\n"
"            event.getStart(), event.getEnd(),\n"
"            event.getStyleName());\n"
"        container.addEntity(entity);\n"
"    }\n"
"}\n"
"\n"
"// Set the container as the data source\n"
"calendar.setEventProvider(cep);\n"
"        \n"
"// Now we can add events to the database through the calendar\n"
"BasicEvent event = new BasicEvent(\"The Event\", \"Single Event\",\n"
"    new GregorianCalendar(2012,1,15,12,00).getTime(),\n"
"    new GregorianCalendar(2012,1,15,14,00).getTime());\n"
"calendar.addEvent(event);]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:5956
#, no-c-format
msgid "Implementing an Event Provider"
msgstr "实现 Event Provider"

#. Tag: para
#: chapter-components.xml:5958
#, no-c-format
msgid ""
"If the two simple ways of storing and managing events for a calendar are not "
"enough, you may need to implement a custom event provider. It is the most "
"flexible way of providing events. You need to attach the event provider to "
"the <classname>Calendar</classname> using the "
"<methodname>setEventProvider()</methodname> method."
msgstr ""
"对于存储和管理日历中的事件, 如果上面介绍的两种简单方法不能满足你的需求的话, "
"你可能需要实现一个自定义的 Event Provider. 这是用来提供事件的最灵活方式. 你需"
"要使用 <methodname>setEventProvider()</methodname> 方法将 Event Provider 关联"
"到 <classname>Calendar</classname>."

#. Tag: para
#: chapter-components.xml:5966
#, no-c-format
msgid ""
"Event queries are done by asking the event provider for all the events "
"between two given dates. The range of these dates is guaranteed to be at "
"least as long as the start and end dates set for the component. The "
"component can, however, ask for a longer range to ensure correct rendering. "
"In particular, all start dates are expanded to the start of the day, and all "
"end dates are expanded to the end of the day."
msgstr ""
"日历会向 Event Provider 询问两个指定的日期之间的所有事件. 这两个日期的范围会"
"保证至少与日历组件的开始日期到结束日期一样长. 但是, 日历组件也可以查询更长的"
"范围, 以便保证自己的正常显示. 具体来说, 开始日期会被扩展到一日的最初时刻, 结"
"束日期会被扩展到一日的最终时刻."

#. Tag: title
#: chapter-components.xml:5976
#, no-c-format
msgid "Custom Events"
msgstr "自定义事件"

#. Tag: para
#: chapter-components.xml:5978
#, no-c-format
msgid ""
"An event provider could use the built-in <classname>BasicEvent</classname>, "
"but it is usually more proper to define a custom event type that is bound "
"directly to the data source. Custom events may be useful for some other "
"purposes as well, such as when you need to add extra information to an event "
"or customize how it is acquired."
msgstr ""
"Event Provider 可以使用内建的 <classname>BasicEvent</classname> 类型, 但通常"
"创建直接与数据源绑定的自定义事件类型会更适当一些. 自定义事件对于其他某些目的"
"也很便利, 比如, 如果你需要在事件中增加额外的信息, 或者希望自定义它的取得方式."

#. Tag: para
#: chapter-components.xml:5986
#, no-c-format
msgid ""
"Custom events must implement the <interfacename>CalendarEvent</"
"interfacename> interface or extend an existing event class. The built-in "
"<classname>BasicEvent</classname> class should serve as a good example of "
"implementing simple events. It keeps the data in member variables."
msgstr ""
"自定义事件必须实现 <interfacename>CalendarEvent</interfacename> 接口, 或继承"
"自某个已存在的事件类. 关于如何实现简单的事件类, 内建的 "
"<classname>BasicEvent</classname> 类是很好的例子. 这个类将相关数据都保存在成"
"员变量中."

#. Tag: programlisting
#: chapter-components.xml:5993
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class BasicEvent\n"
"       implements CalendarEventEditor, EventChangeNotifier {\n"
"   ...\n"
"\n"
"   public String getCaption() {\n"
"        return caption;\n"
"    }\n"
"\n"
"    public String getDescription() {\n"
"        return description;\n"
"    }\n"
"\n"
"    public Date getEnd() {\n"
"        return end;\n"
"    }\n"
"\n"
"    public Date getStart() {\n"
"        return start;\n"
"    }\n"
"\n"
"    public String getStyleName() {\n"
"        return styleName;\n"
"    }\n"
"\n"
"    public boolean isAllDay() {\n"
"        return isAllDay;\n"
"    }\n"
"\n"
"    public void setCaption(String caption) {\n"
"        this.caption = caption;\n"
"        fireEventChange();\n"
"    }\n"
"\n"
"    public void setDescription(String description) {\n"
"        this.description = description;\n"
"        fireEventChange();\n"
"    }\n"
"\n"
"    public void setEnd(Date end) {\n"
"        this.end = end;\n"
"        fireEventChange();\n"
"    }\n"
"\n"
"    public void setStart(Date start) {\n"
"        this.start = start;\n"
"        fireEventChange();\n"
"    }\n"
"\n"
"    public void setStyleName(String styleName) {\n"
"        this.styleName = styleName;\n"
"        fireEventChange();\n"
"    }\n"
"\n"
"    public void setAllDay(boolean isAllDay) {\n"
"        this.isAllDay = isAllDay;\n"
"        fireEventChange();\n"
"    }\n"
"\n"
"    public void addEventChangeListener(\n"
"            EventChangeListener listener) {\n"
"        ...\n"
"    }\n"
"    \n"
"    public void removeListener(EventChangeListener listener) {\n"
"        ...\n"
"    }\n"
"\n"
"    protected void fireEventChange() {...}\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:5995
#, no-c-format
msgid ""
"You may have noticed that there was some additional code in the "
"<classname>BasicEvent</classname> that was not in the "
"<interfacename>CalendarEvent</interfacename> interface. Namely "
"<classname>BasicEvent</classname> also implements two additional interfaces:"
msgstr ""
"你可能注意到了, 在 <classname>BasicEvent</classname> 类中还有一些与 "
"<interfacename>CalendarEvent</interfacename> 接口无关的代码. 也就是说, "
"<classname>BasicEvent</classname> 还实现了下面两个接口:"

#. Tag: interfacename
#: chapter-components.xml:6005
#, no-c-format
msgid "CalendarEditor"
msgstr ""

#. Tag: para
#: chapter-components.xml:6007
#, no-c-format
msgid ""
"This interface defines setters for all the fields, and is required for some "
"of the default handlers to work."
msgstr ""
"这个接口为所有 Field 定义了 Setter 方法, 对于日历中的某些默认的处理是必要的."

#. Tag: interfacename
#: chapter-components.xml:6014
#, no-c-format
msgid "EventChangeNotifier"
msgstr ""

#. Tag: para
#: chapter-components.xml:6016
#, no-c-format
msgid ""
"This interface adds the possibility to listen for changes in the event, and "
"enables the <classname>Calendar</classname> to render the changes "
"immediately."
msgstr ""
"这个接口可以监听事件的变更, <classname>Calendar</classname> 因此可以立即将这"
"些变更显示到画面上."

#. Tag: para
#: chapter-components.xml:6025
#, no-c-format
msgid ""
"The start time and end time are mandatory, but caption, description, and "
"style name are not. The style name is used as a part of the CSS class name "
"for the HTML DOM element of the event."
msgstr ""
"开始时刻和结束时刻是必须的属性, 但标题, 描述信息, 样式名不是必须的. 样式名会"
"被用作事件的 HTML DOM 元素的 CSS 类名的一部分."

#. Tag: para
#: chapter-components.xml:6031
#, no-c-format
msgid ""
"In addition to the basic event interfaces, you can enhance the functionality "
"of your event and event provider classes by using the "
"<classname>EventChange</classname> and <classname>EventSetChange</classname> "
"events. They let the <classname>Calendar</classname> component to know about "
"changes in events and update itself accordingly. The <classname>BasicEvent</"
"classname> and <classname>BasicEventProvider</classname> examples given "
"earlier include a simple implementation of these interfaces."
msgstr ""
"除基本的事件接口外, 你还可以使用 <classname>EventChange</classname> 和 "
"<classname>EventSetChange</classname> 事件来进一步扩充你的事件和 Event "
"Provider 的功能. 这些事件使得 <classname>Calendar</classname> 组件知道事件的"
"变更, 并对它自身做相应的更新. 前面给出的 <classname>BasicEvent</classname> "
"和 <classname>BasicEventProvider</classname> 例子包含了这些接口的简单实现."

#. Tag: title
#: chapter-components.xml:6045
#, no-c-format
msgid "Implementing the Event Provider"
msgstr "实现 Event Provider"

#. Tag: para
#: chapter-components.xml:6047
#, no-c-format
msgid ""
"An event provider needs to implement the "
"<interfacename>CalendarEventProvider</interfacename> interface. It has only "
"one method to be implemented. Whenever the calendar is painted, "
"<methodname>getEvents(Date, Date)</methodname> method is called and it must "
"return a list of events between the given start and end time."
msgstr ""
"Event Provider 需要实现 <interfacename>CalendarEventProvider</interfacename> "
"接口. 这个接口只有一个方法需要实现. 当日历显示在画面上时, "
"<methodname>getEvents(Date, Date)</methodname> 方法会被调用, 它必须返回指定的"
"开始日期到结束日期之间的所有事件的列表."

#. Tag: para
#: chapter-components.xml:6055
#, no-c-format
msgid ""
"The following example implementation returns only one example event. The "
"event starts from the current time and is five hours long."
msgstr ""
"下例中的实现只返回一个示例事件. 这个事件开始时刻是现在时刻, 并持续 5 小时长."

#. Tag: programlisting
#: chapter-components.xml:6060
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class MyEventProvider implements "
"CalendarEventProvider{\n"
"    public List<Event> getEvents(Date startDate, Date endDate){\n"
"        List<Event> events = new ArrayList<Event>();\n"
"        GregorianCalendar cal = new GregorianCalendar();\n"
"        cal.setTime(new Date());\n"
"\n"
"        Date start = cal.getTime();\n"
"        cal.add(GregorianCalendar.HOUR, 5);\n"
"        Date end = cal.getTime();\n"
"        BasicEvent event = new BasicEvent();\n"
"        event.setCaption(\"My Event\");\n"
"        event.setDescription(\"My Event Description\");\n"
"        event.setStart(start);\n"
"        event.setEnd(end);\n"
"        events.add(event);\n"
"\n"
"        return events;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6062
#, no-c-format
msgid ""
"It is important to notice that the <classname>Calendar</classname> may query "
"for dates beyond the range defined by start date and end date. Particularly, "
"it may expand the date range to make sure the user interface is rendered "
"correctly."
msgstr ""
"要注意, <classname>Calendar</classname> 向 Event Provider查询的日期范围, 可能"
"会比日历的开始日期到结束日期范围更大一些. 具体来说, 日历可能会扩张查询日期范"
"围, 以便保证日历的 UI 能够正确显示."

#. Tag: title
#: chapter-components.xml:6072
#, no-c-format
msgid "Styling a Calendar"
msgstr "控制日历的样式"

#. Tag: para
#: chapter-components.xml:6074
#, no-c-format
msgid ""
"Configuring the appearance of the Vaadin Calendar component is one of the "
"basic tasks. At the least, you need to consider its sizing in your user "
"interface. You also quite probably want to use some color or colors for "
"events."
msgstr ""
"控制 Vaadin Calendar 组件的画面表现是一个很基本的任务. 你至少需要考虑它在你"
"的 UI 中的尺寸. 你很可能还会希望为事件使用某些特别的颜色."

#. Tag: title
#: chapter-components.xml:6082
#, no-c-format
msgid "Sizing"
msgstr "尺寸"

#. Tag: para
#: chapter-components.xml:6084
#, no-c-format
msgid ""
"The Calendar supports component sizing as usual for defined (fixed or "
"relative) sizes. When using an undefined size for the calendar, all the "
"sizes come from CSS. In addition, when the height is undefined, a scrollbar "
"is displayed in the weekly view to better fit the cells to the user "
"interface."
msgstr ""
"Calendar 组件允许使用指定的尺寸(固定尺寸或相对尺寸都可以). 如果对日历使用未定"
"义的尺寸, 所有的尺寸都由 CSS 来决定. 此外, 如果高度未定义, 会在周单位显示模式"
"中出现一个滚动条, 以便在 UI 中更好地调控单元格."

#. Tag: para
#: chapter-components.xml:6092
#, no-c-format
msgid ""
"Below is a list of style rules that define the size of a Calendar with "
"undefined size (these are the defaults):"
msgstr ""
"对于未定义尺寸的日历, 用于定义它的各种尺寸的样式规则如下(这些都是默认值):"

#. Tag: programlisting
#: chapter-components.xml:6097
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[.v-calendar-month-sizedheight .v-calendar-month-"
"day {\n"
"        height: 100px;\n"
"}\n"
"\n"
".v-calendar-month-sizedwidth .v-calendar-month-day {\n"
"        width: 100px;\n"
"}\n"
"\n"
".v-calendar-header-month-Hsized .v-calendar-header-day {\n"
"        width: 101px;\n"
"}\n"
"\n"
"/* for IE */\n"
".v-ie6 .v-calendar-header-month-Hsized .v-calendar-header-day {\n"
"        width: 104px;\n"
"}\n"
"\n"
"/* for others */\n"
".v-calendar-header-month-Hsized td:first-child {\n"
"        padding-left: 21px;\n"
"}\n"
"\n"
".v-calendar-header-day-Hsized {\n"
"        width: 200px;\n"
"}\n"
"\n"
".v-calendar-week-numbers-Vsized .v-calendar-week-number {\n"
"        height: 100px;\n"
"        line-height: 100px;\n"
"}\n"
"\n"
".v-calendar-week-wrapper-Vsized {\n"
"        height: 400px;\n"
"        overflow-x: hidden !important;\n"
"}\n"
"\n"
".v-calendar-times-Vsized .v-calendar-time {\n"
"        height: 38px;\n"
"}\n"
"\n"
".v-calendar-times-Hsized .v-calendar-time {\n"
"        width: 42px;\n"
"}\n"
"\n"
".v-calendar-day-times-Vsized .v-slot,.v-calendar-day-times-Vsized .v-slot-"
"even {\n"
"        height: 18px;\n"
"}\n"
"\n"
".v-calendar-day-times-Hsized, .v-calendar-day-times-Hsized .v-slot,.v-"
"calendar-day-times-Hsized .v-slot-even {\n"
"        width: 200px;\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6101
#, no-c-format
msgid "Event Style"
msgstr "事件的样式"

#. Tag: para
#: chapter-components.xml:6103
#, no-c-format
msgid ""
"Events can be styled with CSS by setting them a <emphasis>style name suffix</"
"emphasis>. The suffix is retrieved with the <methodname>getStyleName()</"
"methodname> method in <interfacename>CalendarEvent</interfacename>. If you "
"use <classname>BasicEvent</classname> events, you can set the suffix with "
"<methodname>setStyleName()</methodname>."
msgstr ""
"可以对事件设置一个 <emphasis>样式名称后缀</emphasis> 来使用 CSS 控制事件的样"
"式. 这个后缀会通过 <interfacename>CalendarEvent</interfacename> 接口的 "
"<methodname>getStyleName()</methodname> 方法来取得. 如果你使用 "
"<classname>BasicEvent</classname> 事件, 你可以通过 "
"<methodname>setStyleName()</methodname> 方法来设置这个后缀."

#. Tag: programlisting
#: chapter-components.xml:6112
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[BasicEvent event = new BasicEvent(\"Wednesday "
"Wonder\", ... );\n"
"event.setStyleName(\"mycolor\");\n"
"calendar.addEvent(event);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6114
#, no-c-format
msgid ""
"Suffix <literal>mycolor</literal> would create <literal>v-calendar-event-"
"mycolor</literal> class for regular events and <literal>v-calendar-event-"
"mycolor-add-day</literal> for all-day events. You could style the events "
"with the following rules:"
msgstr ""
"后缀 <literal>mycolor</literal> 会为通常事件创建 <literal>v-calendar-event-"
"mycolor</literal> 样式, 为全日事件创建 <literal>v-calendar-event-mycolor-add-"
"day</literal> 样式. 你可以使用以下规则来控制事件样式:"

#. Tag: programlisting
#: chapter-components.xml:6121
#, no-c-format
msgid ""
"<?pocket-size 65% ?>.v-calendar .v-calendar-event-mycolor {}\n"
".v-calendar .v-calendar-event-mycolor-all-day {}\n"
".v-calendar .v-calendar-event-mycolor .v-calendar-event-caption {}\n"
".v-calendar .v-calendar-event-mycolor .v-calendar-event-content {}"
msgstr ""

#. Tag: title
#: chapter-components.xml:6127
#, no-c-format
msgid "Visible Hours and Days"
msgstr "可见的小时和日"

#. Tag: para
#: chapter-components.xml:6129
#, no-c-format
msgid ""
"As we saw in <xref linkend=\"components.calendar.daterange\"/>, you can set "
"the range of dates that are shown by the Calendar. But what if you wanted to "
"show the entire month but hide the weekends? Or show only hours from 8 to 16 "
"in the weekly view? The <methodname>setVisibleDays()</methodname> and "
"<methodname>setVisibleHours()</methodname> methods allow you to do that."
msgstr ""
"在 <xref linkend=\"components.calendar.daterange\"/> 中我们看到, 你可以设置日"
"历显示的日期范围. 但是如果你希望显示整个月, 但又隐藏周末, 该如何实现呢? 或者"
"如果希望在周单位显示模式下只显示 8 时到 16 时, 该如何实现? "
"<methodname>setVisibleDays()</methodname> 和 <methodname>setVisibleHours()</"
"methodname> 方法允许你进行这类设置."

#. Tag: programlisting
#: chapter-components.xml:6137
#, no-c-format
msgid ""
"<?pocket-size 75% ?>calendar.setVisibleDays(1,5);   // Monday to Friday\n"
"calendar.setVisibleHours(0,15); // Midnight until 4 pm"
msgstr ""

#. Tag: para
#: chapter-components.xml:6139
#, no-c-format
msgid ""
"After the above settings, only weekdays from Monday to Friday would be "
"shown. And when the calendar is in the weekly view, only the time range from "
"00:00 to 16:00 would be shown."
msgstr ""
"进行上面的设定后, 只有星期一到星期五会被显示. 而且, 当日历处于周单位显示模式"
"时, 只有从 00:00 到 16:00 时刻范围会被显示."

#. Tag: para
#: chapter-components.xml:6145
#, no-c-format
msgid ""
"Note that the excluded times are never shown so you should take care when "
"setting the date range. If the date range contains only dates / times that "
"are excluded, nothing will be displayed. Also note that even if a date is "
"not rendered because these settings, the event provider may still be queried "
"for events for that date."
msgstr ""
"注意, 被排除在外的时间范围永远不会显示, 因此你在设置日期范围时需要小心. 如果"
"日历的日期范围只包含被排除的日期/时间, 那么日历中就不会显示任何东西了. 还要注"
"意, 即使上面的设置导致一部分事件不在画面上显示, 但对于这些显示范围外的日期, "
"Event Provider 还是会被查询其中的事件."

#. Tag: title
#: chapter-components.xml:6155
#, no-c-format
msgid "Drag and Drop"
msgstr "拖放"

#. Tag: para
#: chapter-components.xml:6157
#, no-c-format
msgid ""
"Vaadin Calendar can act as a drop target for drag and drop, described in "
"<xref linkend=\"advanced.dragndrop\"/>. With the functionality, the user "
"could drag events, for example, from a table to a calendar."
msgstr ""
"Vaadin Calendar 可以在拖放操作中作为 Drop 动作的目标, 详情请参见 <xref "
"linkend=\"advanced.dragndrop\"/>. 使用这个功能, 用户可以拖动事件, 比如, 从一"
"个 Table 组件拖动到一个日历组件."

#. Tag: para
#: chapter-components.xml:6163
#, no-c-format
msgid ""
"To support dropping, a <classname>Calendar</classname> must have a drop "
"handler. When the drop handler is set, the days in the monthly view and the "
"time slots in the weekly view can receive drops. Other locations, such as "
"day names in the weekly view, can not currently receive drops."
msgstr ""
"要支持 Drop 动作, <classname>Calendar</classname> 需要有一个 Drop 处理器. 设"
"置好 Drop 处理器之后, 月单位显示模式中的日, 以及周单位显示模式中的时间条, 可"
"以接收 Drop 动作. 日历的其他位置, 比如周单位显示模式中的日名称, 目前还不能接"
"收 Drop 动作."

#. Tag: para
#: chapter-components.xml:6170
#, no-c-format
msgid ""
"Calendar uses its own implementation of <interfacename>TargetDetails</"
"interfacename>: <classname>CalendarTargetdetails</classname>. It holds "
"information about the the drop location, which in the context of "
"<classname>Calendar</classname> means the date and time. The drop target "
"location can be retrieved via the <methodname>getDropTime()</methodname> "
"method. If the drop is done in the monthly view, the returned date does not "
"have exact time information. If the drop happened in the weekly view, the "
"returned date also contains the start time of the slot."
msgstr ""
"日历使用它自己实现的 <interfacename>TargetDetails</interfacename>: "
"<classname>CalendarTargetdetails</classname>. 它会管理 Drop 位置信息, 对 "
"<classname>Calendar</classname> 来说也就意味着对应的日期和时间. Drop 动作的位"
"置可以通过 <methodname>getDropTime()</methodname> 方法取得. 如果 Drop 动作发"
"生在月单位显示模式中, 那么这个方法返回的日期值中不会包含具体的时间信息. 如果 "
"Drop 动作发生在周单位显示模式中, 返回的日期值会包含对应的时刻条的开始时间."

#. Tag: para
#: chapter-components.xml:6182
#, no-c-format
msgid ""
"Below is a short example of creating a drop handler and using the drop "
"information to create a new event:"
msgstr ""
"下面是一个简单的例子, 演示如何编写一个 Drop 处理器, 并使用 Drop 信息来创建新"
"的事件:"

#. Tag: programlisting
#: chapter-components.xml:6187
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[private Calendar createDDCalendar() {\n"
"  Calendar calendar = new Calendar();\n"
"  calendar.setDropHandler(new DropHandler() {\n"
"    public void drop(DragAndDropEvent event) {\n"
"      CalendarTargetDetails details = \n"
"              (CalendarTargetDetails) event.getTargetDetails();\n"
"      \n"
"      TableTransferable transferable = \n"
"              (TableTransferable) event.getTransferable();\n"
"\n"
"      createEvent(details, transferable);\n"
"      removeTableRow(transferable);\n"
"    }\n"
"\n"
"    public AcceptCriterion getAcceptCriterion() {\n"
"      return AcceptAll.get();\n"
"    }\n"
"\n"
"  });\n"
"\n"
"  return calendar;\n"
"}\n"
"\n"
"\n"
"protected void createEvent(CalendarTargetDetails details,\n"
"  TableTransferable transferable) {\n"
"  Date dropTime = details.getDropTime();\n"
"  java.util.Calendar timeCalendar = details.getTargetCalendar()\n"
"                                    .getInternalCalendar();\n"
"  timeCalendar.setTime(dropTime);\n"
"  timeCalendar.add(java.util.Calendar.MINUTE, 120);\n"
"  Date endTime = timeCalendar.getTime();\n"
"\n"
"  Item draggedItem = transferable.getSourceComponent().\n"
"                            getItem(transferable.getItemId());\n"
"\n"
"  String eventType = (String)draggedItem.\n"
"                            getItemProperty(\"type\").getValue();\n"
"\n"
"  String eventDescription = \"Attending: \"\n"
"             + getParticipantString(\n"
"                 (String[]) draggedItem.\n"
"                   getItemProperty(\"participants\").getValue());\n"
"\n"
"  BasicEvent newEvent = new BasicEvent();\n"
"  newEvent.setAllDay(!details.hasDropTime());\n"
"  newEvent.setCaption(eventType);\n"
"  newEvent.setDescription(eventDescription);\n"
"  newEvent.setStart(dropTime);\n"
"  newEvent.setEnd(endTime);\n"
"\n"
"  BasicEventProvider ep = (BasicEventProvider) details\n"
"                       .getTargetCalendar().getEventProvider();\n"
"  ep.addEvent(newEvent);\n"
"}]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6191
#, no-c-format
msgid "Using the Context Menu"
msgstr "使用上下文菜单"

#. Tag: para
#: chapter-components.xml:6193
#, no-c-format
msgid ""
"Vaadin Calendar allows the use of context menu (mouse right-click) to manage "
"events. As in other context menus in Vaadin, the menu items are handled in "
"Vaadin as <emphasis>actions</emphasis> by an <emphasis>action handler</"
"emphasis>. To enable a context menu, you have to implement a Vaadin "
"<interfacename>Action.Handler</interfacename> and add it to the calendar "
"with <methodname>addActionHandler()</methodname>."
msgstr ""
"Vaadin Calendar 允许使用上下文菜单(点击鼠标右键)来管理事件. 在 Vaadin 的其他"
"上下文菜单中, 菜单项是作为 Vaadin 的 <emphasis>动作(Action)</emphasis>, 由一"
"个 <emphasis>动作处理器(Action Handler)</emphasis> 负责处理的. 要启用上下文菜"
"单, 你必须实现 Vaadin 的 <interfacename>Action.Handler</interfacename> 接口, "
"然后使用 <methodname>addActionHandler()</methodname> 方法将它添加到日历中."

#. Tag: para
#: chapter-components.xml:6202
#, no-c-format
msgid ""
"An action handler must implement two methods: <methodname>getActions()</"
"methodname> and <methodname>handleAction()</methodname>. The "
"<methodname>getActions()</methodname> is called for each day displayed in "
"the calendar view. It should return a list of allowed actions for that day, "
"that is, the items of the context menu. The <parameter>target</parameter> "
"parameter is the context of the click - a <classname>CalendarDateRange</"
"classname> that spans over the day. The <parameter>sender</parameter> is the "
"<classname>Calendar</classname> object."
msgstr ""
"动作处理器必须实现两个方法: <methodname>getActions()</methodname> 和 "
"<methodname>handleAction()</methodname>. 对日历中显示的每一日都会调用 "
"<methodname>getActions()</methodname> 方法. 这个方法应该返回对于这一天所允许"
"执行的所有动作的一个列表, 这个列表就会成为上下文菜单中的菜单项. "
"<parameter>target</parameter> 参数代表点击的上下文环境 - 这里是横跨这一天的一"
"个 <classname>CalendarDateRange</classname>. <parameter>sender</parameter> 参"
"数是 <classname>Calendar</classname> 对象."

#. Tag: para
#: chapter-components.xml:6215
#, no-c-format
msgid ""
"The <methodname>handleActions()</methodname> receives the target context in "
"the <parameter>target</parameter>. If the context menu was opened on an "
"event, the target is the <interfacename>Event</interfacename> object, "
"otherwise it is a <classname>CalendarDateRange</classname>."
msgstr ""
"<methodname>handleActions()</methodname> 方法通过 <parameter>target</"
"parameter> 参数接受目标上下文. 如果上下文菜单在一个事件上打开, 目标上下文将"
"是 <interfacename>Event</interfacename> 对象, 否则它将是 "
"<classname>CalendarDateRange</classname> 对象."

#. Tag: title
#: chapter-components.xml:6224
#, no-c-format
msgid "Localization and Formatting"
msgstr "本地化与格式化"

#. Tag: title
#: chapter-components.xml:6227
#, no-c-format
msgid "Setting the Locale and Time Zone"
msgstr "设置语言环境(Locale)和时区(Time Zone)"

#. Tag: para
#: chapter-components.xml:6229
#, no-c-format
msgid ""
"Month and weekday names are shown in the language of the locale setting of "
"the <classname>Calendar</classname>. The translations are acquired from the "
"standard Java locale data. By default, <classname>Calendar</classname> uses "
"the system default locale for its internal calendar, but you can change it "
"with <methodname>setLocale(Locale locale)</methodname>. Setting the locale "
"will update also other location specific date and time settings, such as the "
"first day of the week, time zone, and time format. However, time zone and "
"time format can be overridden by settings in the <classname>Calendar</"
"classname>."
msgstr ""
"月和星期的名称使用 <classname>Calendar</classname> 的语言环境所规定的语言来显"
"示. 翻译需要使用标准的 Java 语言环境数据来进行. 默认情况下, "
"<classname>Calendar</classname> 使用系统默认的语言环境来处理内部的日期时刻, "
"但你可以使用 <methodname>setLocale(Locale locale)</methodname> 方法来改变语言"
"环境. 设置语言环境还会更新于语言环境相关的其他日期和时间设定, 比如周的起始"
"日, 时区, 以及时间的显示格式. 但是, 时区和时间格式可以在 "
"<classname>Calendar</classname> 中单独设置."

#. Tag: para
#: chapter-components.xml:6242
#, no-c-format
msgid "For example, the following would set the language to US English:"
msgstr "比如, 下例会将语言设置为美国英语:"

#. Tag: programlisting
#: chapter-components.xml:6246
#, no-c-format
msgid "<![CDATA[cal.setLocale(Locale.US);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6248
#, no-c-format
msgid ""
"The locale defines the default time zone. You can change it with the "
"<methodname>setTimeZone()</methodname> method, which takes a <classname>java."
"util.TimeZone</classname> object as its parameter. Setting timezone to null "
"will reset timezone to the locale default."
msgstr ""
"语言环境定义了默认的时区. 你可以使用 <methodname>setTimeZone()</methodname> "
"方法来改变时区设定, 这个方法接受的参数是 <classname>java.util.TimeZone</"
"classname> 对象. 将时区设置为 null 会将它重置为当前语言环境的默认时区."

#. Tag: para
#: chapter-components.xml:6255
#, no-c-format
msgid ""
"For example, the following would set the Finnish time zone, which is EET"
msgstr "比如, 下例将时区设置为芬兰时区, 也就是 EET (欧洲东部时间)"

#. Tag: programlisting
#: chapter-components.xml:6259
#, no-c-format
msgid "<![CDATA[cal.setTimeZone(TimeZone.getTimeZone(\"Europe/Helsinki\"));]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6263
#, no-c-format
msgid "Time and Date Caption Format"
msgstr "时间与日期标题格式"

#. Tag: para
#: chapter-components.xml:6265
#, no-c-format
msgid ""
"The time may be shown either in 24 or 12 hour format. The default format is "
"defined by the locale, but you can change it with the "
"<methodname>setTimeFormat()</methodname> method. Giving a <literal>null</"
"literal> setting will reset the time format to the locale default."
msgstr ""
"时间可以显示为 24 小时或 12 小时格式. 默认格式由语言环境决定, 但你可以使用 "
"<methodname>setTimeFormat()</methodname> 方法来设置格式. 格式设置为 "
"<literal>null</literal> 会将时间格式重置为语言环境的默认格式."

#. Tag: programlisting
#: chapter-components.xml:6273
#, no-c-format
msgid "<![CDATA[cal.setTimeFormat(TimeFormat.Format12H);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6275
#, no-c-format
msgid ""
"You can change the format of the date captions in the week view with the "
"<methodname>setWeeklyCaptionFormat(String dateFormatPattern)</methodname> "
"method. The date format pattern should follow the format of the standard "
"Java <classname>java.text.SimpleDateFormat</classname> class."
msgstr ""
"你可以使用 <methodname>setWeeklyCaptionFormat(String dateFormatPattern)</"
"methodname> 方法来修改周单位显示模式中的日期标题格式. 这个方法接受的日期格式"
"字符串需要遵守标准的 Java <classname>java.text.SimpleDateFormat</classname> "
"类中的格式规则."

#. Tag: para
#: chapter-components.xml:6283 chapter-components.xml:6604
#, no-c-format
msgid "For example:"
msgstr "示例"

#. Tag: programlisting
#: chapter-components.xml:6287
#, no-c-format
msgid "<![CDATA[cal.setWeeklyCaptionFormat(\"dd-MM-yyyy\");]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6292
#, no-c-format
msgid "Customizing the Calendar"
msgstr "定制日历"

#. Tag: para
#: chapter-components.xml:6294
#, no-c-format
msgid ""
"In this section, we give a tutorial for how to make various basic "
"customizations of the Vaadin Calendar. The event provider and styling was "
"described earlier, so now we concentrate on other features of the Calendar "
"API."
msgstr ""
"在本节中, 我们给出一段示例, 演示如何对 Vaadin 日历进行一些基本的定制. Event "
"Provider 和样式控制在前文已经介绍过了, 所以现在我们集中讨论日历 API 的其他功"
"能."

#. Tag: title
#: chapter-components.xml:6302
#, no-c-format
msgid "Overview of Handlers"
msgstr "事件处理器概览"

#. Tag: para
#: chapter-components.xml:6304
#, no-c-format
msgid ""
"Most of the handlers related to calendar events have sensible default "
"handlers. These are found in the <package>com.vaadin.ui.handler</package> "
"package. The default handlers and their functionalities are described below."
msgstr ""
"与日历事件相关的大多数处理器都已经有了不错的默认处理器. 这些默认处理器可以在 "
"<package>com.vaadin.ui.handler</package> 包中找到. 默认处理器及其功能介绍如"
"下."

#. Tag: listitem
#: chapter-components.xml:6312
#, no-c-format
msgid ""
"<classname>BasicBackwardHandler</classname>. Handles clicking the back-"
"button of the weekly view so that the viewed month is changed to the "
"previous one."
msgstr ""
"<classname>BasicBackwardHandler</classname>. 周单位显示模式下, 处理回退按钮的"
"点击事件, 此时日历中显示的时间范围会被切换为上一月(译注: 原文如此, 应为\"周"
"\")."

#. Tag: listitem
#: chapter-components.xml:6318
#, no-c-format
msgid ""
"<classname>BasicForwardHandler</classname>. Handles clicking the forward-"
"button of the weekly view so that the viewed month is changed to the next "
"one."
msgstr ""
"<classname>BasicForwardHandler</classname>. 周单位显示模式下, 处理前进按钮的"
"点击事件, 此时日历中显示的时间范围会被切换为下一月(译注: 原文如此, 应为\"周"
"\")."

#. Tag: listitem
#: chapter-components.xml:6324
#, no-c-format
msgid ""
"<classname>BasicWeekClickHandler</classname>. Handles clicking the week "
"numbers int the monthly view so that the viewable date range is changed to "
"the clicked week."
msgstr ""
"<classname>BasicWeekClickHandler</classname>. 月单位显示模式下, 处理周数字的"
"点击事件, 此时日历的显示范围会切换到被点击的那一周."

#. Tag: listitem
#: chapter-components.xml:6330
#, no-c-format
msgid ""
"<classname>BasicDateClickHandler</classname>. Handles clicking the dates on "
"both the monthly view and the weekly view. Changes the viewable date range "
"so that only the clicked day is visible."
msgstr ""
"<classname>BasicDateClickHandler</classname>. 在月单位和周单位两种显示模式"
"中, 处理日期的点击事件. 此时日历中的显示范围会变为只显示被点击的那一日."

#. Tag: listitem
#: chapter-components.xml:6336
#, no-c-format
msgid ""
"<classname>BasicEventMoveHandler</classname>. Handles moving the events in "
"both monthly view and the weekly view. Events can be moved and their start "
"and end dates are changed correctly, but only if the event implements "
"<classname>CalendarEventEditor</classname> (implemented by "
"<classname>BasicEvent</classname>)."
msgstr ""
"<classname>BasicEventMoveHandler</classname>. 在月单位和周单位两种显示模式"
"中, 处理事件的移动. 事件可以通过 UI 操作来移动, 它的开始日期结束日期会被正确"
"地更新, 但这一点只在事件实现了 <classname>CalendarEventEditor</classname> 接"
"口时才有效 (这个接口由 <classname>BasicEvent</classname> 类实现)."

#. Tag: listitem
#: chapter-components.xml:6345
#, no-c-format
msgid ""
"<classname>BasicEventResizeHandler</classname>. Handles resizing the events "
"in the weekly view. Events can be resized and their start and end dates are "
"changed correctly, but only if the event implements "
"<classname>CalendarEventEditor</classname> (implemented by the "
"<classname>BasicEvent</classname>)."
msgstr ""
"<classname>BasicEventResizeHandler</classname>. 周单位显示模式下, 处理事件被"
"鼠标拖动改变大小. Event 的大小可以通过鼠标拖动来改变, 它的开始日期结束日期会"
"被正确地更新, 但这一点只在事件实现了 <classname>CalendarEventEditor</"
"classname> 接口时才有效 (这个接口由 <classname>BasicEvent</classname> 类实"
"现)."

#. Tag: para
#: chapter-components.xml:6354
#, no-c-format
msgid ""
"All of these handlers are automatically set when creating a new "
"<classname>Calendar</classname>. If you wish to disable some of the default "
"functionality, you can simply set the corresponding handler to "
"<literal>null</literal>. This will prevent the functionality from ever "
"appearing on the user interface. For example, if you set the "
"<classname>EventMoveHandler</classname> to <literal>null</literal>, the user "
"will be unable to move events in the browser."
msgstr ""
"创建新的 <classname>Calendar</classname> 时, 会自动设置上述所有的处理器. 如果"
"你希望关闭某种默认功能, 你可以设定对应的事件处理器为 <literal>null</"
"literal>. 这样就可以阻止相关的功能, 被阻止的功能不会出现在 UI 中. 比如, 如果"
"你将 <classname>EventMoveHandler</classname> 设置为 <literal>null</literal>, "
"用户将不能在浏览器端移动日历中的事件."

#. Tag: title
#: chapter-components.xml:6366
#, no-c-format
msgid "Creating a Calendar"
msgstr "创建日历"

#. Tag: para
#: chapter-components.xml:6368
#, no-c-format
msgid ""
"Let us first create a new <classname>Calendar</classname> instance. Here we "
"use our own event provider, the <classname>MyEventProvider</classname> "
"described in <xref linkend=\"components.calendar.eventprovider.eventprovider"
"\"/>."
msgstr ""
"我们首先创建一个新的 <classname>Calendar</classname> 实例. 这里我们使用自己"
"的 Event Provider, <classname>MyEventProvider</classname>, 详情请参见 <xref "
"linkend=\"components.calendar.eventprovider.eventprovider\"/>."

#. Tag: programlisting
#: chapter-components.xml:6375
#, no-c-format
msgid "<![CDATA[Calendar cal = new Calendar(new MyEventProvider());]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6377
#, no-c-format
msgid ""
"This initializes the Calendar. To customize the viewable date range, we must "
"set a start and end date to it."
msgstr ""
"以上代码初始化了一个日历. 为了定制日历的可见日期范围, 我们必须设置它的开始日"
"期和结束日期."

#. Tag: para
#: chapter-components.xml:6382
#, no-c-format
msgid ""
"There is only one visible event in the timeline, starting from the current "
"time. That is what our event provider passes to the client."
msgstr ""
"在时间线中只有一个可见的事件, 这个事件的开始时间为当前时刻. 这就是我们的"
"Event Provider 向外提供的事件."

#. Tag: para
#: chapter-components.xml:6390
#, no-c-format
msgid ""
"It would be nice to also be able to control the navigation forward and "
"backward. The default navigation is provided by the default handlers, but "
"perhaps we want to restrict the users so they can only navigate dates in the "
"current year. Maybe we also want to pose some other restrictions to the "
"clicking week numbers and dates."
msgstr ""
"如果能控制日历中显示日期的前后跳转就好了. 默认的跳转行为是由默认的处理器实现"
"的, 但是我们也许会希望限制用户, 使他们只能在当前年份中跳转. 我们可能还希望对"
"星期数和日期的点击做出一些别的限制."

#. Tag: para
#: chapter-components.xml:6398
#, no-c-format
msgid ""
"These restrictions and other custom logic can be defined with custom "
"handlers. You can find the handlers in the <package>com.vaadin.addon."
"calendar.ui.handler</package> package and they can be easily extended. Note "
"that if you don not want to extend the default handlers, you are free to "
"implement your own. The interfaces are described in "
"<interfacename>CalendarComponentEvents</interfacename>."
msgstr ""
"这些限制, 以及其他自定义逻辑可以由自定义的处理器实现. 你可以在 <package>com."
"vaadin.addon.calendar.ui.handler</package> 包中找到这些默认的处理器, 也可以很"
"容易地继承它们. 注意, 如果你不希望继承默认的处理器, 你也完全可以自行实现. 相"
"关的接口请参见 <interfacename>CalendarComponentEvents</interfacename>."

#. Tag: title
#: chapter-components.xml:6411
#, no-c-format
msgid "Backward and Forward Navigation"
msgstr "日期的前方和后方跳转"

#. Tag: para
#: chapter-components.xml:6413
#, no-c-format
msgid ""
"Vaadin Calendar has only limited built-in navigation support. The weekly "
"view has navigation buttons in the top left and top right corners."
msgstr ""
"Vaadin 日历的日期跳转功能只有有限的内建支持. 周单位显示模式的左上角和右上角有"
"日期跳转的按钮."

#. Tag: para
#: chapter-components.xml:6420
#, no-c-format
msgid ""
"You can handle backward and forward navigation with a "
"<interfacename>BackwardListener</interfacename> and "
"<interfacename>ForwardListener</interfacename>."
msgstr ""
"你可以使用 <interfacename>BackwardListener</interfacename> 和 "
"<interfacename>ForwardListener</interfacename> 监听器, 来处理日期的前方和后方"
"跳转事件."

#. Tag: programlisting
#: chapter-components.xml:6426
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicBackwardHandler() {\n"
"  protected void setDates(BackwardEvent event,\n"
"                          Date start, Date end) {\n"
"\n"
"      java.util.Calendar calendar = event.getComponent()\n"
"                                    .getInternalCalendar();\n"
"      if (isThisYear(calendar, end) \n"
"           && isThisYear(calendar, start)) {\n"
"        super.setDates(event, start, end);\n"
"      }\n"
"  }});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6428
#, no-c-format
msgid ""
"The forward navigation handler can be implemented in the same way. The "
"example handler restricts the dates to the current year."
msgstr ""
"向前跳转的处理器可以用与上例相同的方式来实现. 上例中的处理器限制只能在当前年"
"份内跳转."

#. Tag: title
#: chapter-components.xml:6435
#, no-c-format
msgid "Date Click Handling"
msgstr "处理日期的点击"

#. Tag: para
#: chapter-components.xml:6437
#, no-c-format
msgid ""
"By default, clicking a date either in month or week view switches to single-"
"day view. The date click event is handled by a "
"<interfacename>DateClickHandler</interfacename>."
msgstr ""
"默认情况下, 在月单位或周单位显示模式下点击一个日期, 会切换到单日显示模式. 日"
"期的点击事件由 <interfacename>DateClickHandler</interfacename> 来处理."

#. Tag: para
#: chapter-components.xml:6443
#, no-c-format
msgid ""
"The following example handles click events so that when the user clicks the "
"date header in the weekly view, it will switch to single-day view, and in "
"the single-day view switch back to the weekly view."
msgstr ""
"下例演示如何处理点击事件, 在周单位显示模式下点击日期, 会切换到单日显示模式, "
"在单日显示模式下再次点击日期, 会切换回到周单位显示模式."

#. Tag: programlisting
#: chapter-components.xml:6449
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicDateClickHandler() {\n"
"  public void dateClick(DateClickEvent event) {\n"
"    Calendar cal = event.getComponent();\n"
"    long currentCalDateRange = cal.getEndDate().getTime()\n"
"                               - cal.getStartDate().getTime();\n"
"    \n"
"    if (currentCalDateRange < VCalendar.DAYINMILLIS) {\n"
"      // Change the date range to the current week\n"
"      cal.setStartDate(cal.getFirstDateForWeek(event.getDate()));\n"
"      cal.setEndDate(cal.getLastDateForWeek(event.getDate()));\n"
"\n"
"    } else {\n"
"      // Default behaviour, change date range to one day\n"
"      super.dateClick(event);\n"
"    }\n"
"  }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6453
#, no-c-format
msgid "Handling Week Clicks"
msgstr "处理周的点击"

#. Tag: para
#: chapter-components.xml:6455
#, no-c-format
msgid ""
"The monthly view displays week numbers for each week row on the left side of "
"the date grid. The week number are clickable and you can handle the click "
"events by setting a <interfacename>WeekClickHandler</interfacename> for the "
"<classname>Calendar</classname> object. The default handler changes the date "
"range to be the clicked week."
msgstr ""
"月单位显示模式会为每一个周的行, 在日期表格的左侧显示周数字. 周数字是可以点击"
"的, 你可以为 <classname>Calendar</classname> 对象设置一个 "
"<interfacename>WeekClickHandler</interfacename> 来处理这个点击事件. 默认的处"
"理器会将日历显示的日期范围切换为被点击的那一周."

#. Tag: para
#: chapter-components.xml:6463
#, no-c-format
msgid ""
"In the following example, we add a week click handler that changes the date "
"range of the calendar to one week only if the start and end dates of the "
"week are in the current month."
msgstr ""
"下例中, 我们添加一个周点击事件处理器, 它会将日历的日期范围切换到被点击的周, "
"但要求这一周的开始日和结束日都属于当前月份."

#. Tag: programlisting
#: chapter-components.xml:6469
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicWeekClickHandler() {\n"
"    protected void setDates(WeekClick event,\n"
"                          Date start, Date end) {\n"
"        java.util.Calendar calendar = event.getComponent()\n"
"                                  .getInternalCalendar();\n"
"        if (isThisMonth(calendar, start) \n"
"            && isThisMonth(calendar,  end)) {\n"
"            super.setDates(event, start, end);\n"
"        }\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6473
#, no-c-format
msgid "Handling Event Clicks"
msgstr "处理事件的点击"

#. Tag: para
#: chapter-components.xml:6475
#, no-c-format
msgid ""
"The calendar events in all views are are clickable. There is no default "
"handler. Just like the date and week click handlers, event click handling is "
"enabled by setting an <interfacename>EventClickHandler</interfacename> for "
"the <classname>Calendar</classname> object."
msgstr ""
"在任何一种显示模式下, 日历内的事件都是可以点击的. 事件的点击没有默认的处理"
"器. 与日期和周的点击处理器一样, 设置事件点击处理器的方法是, 为 "
"<classname>Calendar</classname> 对象设置一个 "
"<interfacename>EventClickHandler</interfacename>."

#. Tag: para
#: chapter-components.xml:6483
#, no-c-format
msgid ""
"You can get hold of the clicked event by the <methodname>getCalendarEvent()</"
"methodname> method in the <classname>EventClick</classname> object passed to "
"the handler, as shown in the following example."
msgstr ""
"在传递给处理器的 <classname>EventClick</classname> 对象参数中, 使用 "
"<methodname>getCalendarEvent()</methodname> 方法, 可以得到被点击的事件, 如下"
"例所示."

#. Tag: programlisting
#: chapter-components.xml:6490
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[cal.setHandler(new EventClickHandler() {\n"
"    public void eventClick(EventClick event) {\n"
"        BasicEvent e = (BasicEvent) event.getCalendarEvent();\n"
"\n"
"        // Do something with it\n"
"        new Notification(\"Event clicked: \" + e.getCaption(),\n"
"            e.getDescription()).show(Page.getCurrent());\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6494
#, no-c-format
msgid "Event Dragging"
msgstr "事件的拖动"

#. Tag: para
#: chapter-components.xml:6496
#, no-c-format
msgid ""
"The user can drag an event to change its position in time. The default "
"handler sets the start and end time of the event accordingly. You can do "
"many things with a custom move handler, such as restrict moving events."
msgstr ""
"用户可以在 UI 中拖动一个事件, 改变事件在时间线上的位置. 默认处理器会相应的设"
"置事件的开始时间和结束时间. 你可以使用自定义的处理器来做更多的事情, 比如, 限"
"制事件的移动范围."

#. Tag: para
#: chapter-components.xml:6502
#, no-c-format
msgid ""
"In the following example, we add a <interfacename>EventMoveHandler</"
"interfacename> to a <classname>Calendar</classname>. The event handler "
"updates the new position to the datasource, but only if the new dates are in "
"the current month. This requires making some changes to the event provider "
"class."
msgstr ""
"下例中, 我们为 <classname>Calendar</classname> 添加了一个 "
"<interfacename>EventMoveHandler</interfacename>. 这个事件处理器会将新的位置更"
"新到数据源中, 但要求新的日期必须属于当前月份. 为完成这个功能, 需要对 Event "
"Provider 类做一些修改."

#. Tag: programlisting
#: chapter-components.xml:6510
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicEventMoveHandler() {\n"
"  private java.util.Calendar javaCalendar;\n"
"\n"
"  public void eventMove(MoveEvent event) {\n"
"    javaCalendar = event.getComponent().getInternalCalendar();\n"
"    super.eventMove(event);\n"
"  }\n"
"  \n"
"  protected void setDates(CalendarEventEditor event,\n"
"                          Date start, Date end) {\n"
"    if (isThisMonth(javaCalendar, start)\n"
"        && isThisMonth(javaCalendar, end)) {\n"
"      super.setDates(event, start, end);\n"
"    }\n"
"  }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6512
#, no-c-format
msgid ""
"For the above example to work, the example event provider presented earlier "
"needs to be changed slightly so that it doesn't always create a new event "
"when <methodname>getEvents()</methodname> is called."
msgstr ""
"为了让上面的示例代码工作起来, 前面我们讨论过的 Event Provider 例子需要略作修"
"改, 让它在 <methodname>getEvents()</methodname> 被调用时, 不要永远创建新的事"
"件."

#. Tag: programlisting
#: chapter-components.xml:6518
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public static class MyEventProvider\n"
"              implements CalendarEventProvider {\n"
"  private List<CalendarEvent> events =\n"
"        new ArrayList<CalendarEvent>();\n"
"\n"
"  public MyEventProvider() {\n"
"    events = new ArrayList<CalendarEvent>();\n"
"    GregorianCalendar cal = new GregorianCalendar();\n"
"    cal.setTime(new Date());\n"
"\n"
"    Date start = cal.getTime();\n"
"    cal.add(GregorianCalendar.HOUR, 5);\n"
"    Date end = cal.getTime();\n"
"    BasicEvent event = new BasicEvent();\n"
"    event.setCaption(\"My Event\");\n"
"    event.setDescription(\"My Event Description\");\n"
"    event.setStart(start);\n"
"    event.setEnd(end);\n"
"    events.add(event);\n"
"  }\n"
"\n"
"  public void addEvent(CalendarEvent BasicEvent) {\n"
"    events.add(BasicEvent);\n"
"  }\n"
"\n"
"  public List<CalendarEvent> getEvents(Date startDate, \n"
"                                       Date endDate) {\n"
"    return events;\n"
"  }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6520
#, no-c-format
msgid ""
"After these changes, the user can move events around as earlier, but "
"dropping an event, the start and end dates are checked by the server. Note "
"that as the server-side must move the event in order for it to render to the "
"place it was dropped. The server can also reject moves by not doing anything "
"when the event is received."
msgstr ""
"经过上面的修改后, 用户就可以移动事件了, 但拖放一个事件时, 事件的开始日期和结"
"束日期会被服务器端检查. 注意, 服务器端必须将事件移动到适当的位置, 这样才能将"
"事件显示在它被拖放的位置. 服务器端也可以拒绝移动事件, 方法是收到移动事件后不"
"作任何处理."

#. Tag: title
#: chapter-components.xml:6530
#, no-c-format
msgid "Handling Drag Selection"
msgstr "处理拖动式选择(Drag Selection)"

#. Tag: para
#: chapter-components.xml:6532
#, no-c-format
msgid ""
"Drag selection works both in the monthly and weekly views. To listen for "
"drag selection, you can add a <interfacename>RangeSelectListener</"
"interfacename> to the <classname>Calendar</classname>. There is no default "
"handler for range select."
msgstr ""
"在月单位和周单位两种显示模式下, 拖动式选择(Drag Selection)都是有效的. 为了监"
"听拖动式选择事件, 你可以为 <classname>Calendar</classname> 添加一个 "
"<interfacename>RangeSelectListener</interfacename> 监听器. 对于范围选择, 没有"
"默认的处理器."

#. Tag: para
#: chapter-components.xml:6540
#, no-c-format
msgid ""
"In the code example below, we create an new event when any date range is "
"selected. Drag selection opens a window where the user is asked for a "
"caption for the new event. After confirming, the new event is be passed to "
"the event provider and calendar is updated. Note that as our example event "
"provider and event classes do not implement the event change interface, we "
"must refresh the <classname>Calendar</classname> manually after changing the "
"events."
msgstr ""
"下例中, 当用户选中任何一个日期范围时, 我们创建一个新的事件. 拖动选择时会打开"
"一个新的窗口, 要求用户在这个窗口中为新的事件输入一个标题. 输入完成后, 新事件"
"会被传递给Event Provider, 并且日历的显示会被更新. 注意, 我们的示例 Event "
"Provider 和 Event 类没有实现事件变更的接口, 因此我们变更事件之后必须手动刷新 "
"<classname>Calendar</classname> ."

#. Tag: programlisting
#: chapter-components.xml:6550
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[cal.setHandler(new RangeSelectHandler() {\n"
"  public void rangeSelect(RangeSelectEvent event) {\n"
"    BasicEvent calendarEvent = new BasicEvent();\n"
"    calendarEvent.setStart(event.getStart());\n"
"    calendarEvent.setEnd(event.getEnd());\n"
"\n"
"    // Create popup window and add a form in it.\n"
"    VerticalLayout layout = new VerticalLayout();\n"
"    layout.setMargin(true);\n"
"    layout.setSpacing(true);\n"
"\n"
"    final Window w = new Window(null, layout);\n"
"    ...\n"
"\n"
"    // Wrap the calendar event to a BeanItem \n"
"    // and pass it to the form\n"
"    final BeanItem<CalendarEvent> item = \n"
"                         new BeanItem<CalendarEvent>(myEvent);\n"
"\n"
"    final Form form = new Form();\n"
"    form.setItemDataSource(item);\n"
"    ...\n"
"\n"
"    layout.addComponent(form);\n"
"\n"
"    HorizontalLayout buttons = new HorizontalLayout();\n"
"    buttons.setSpacing(true);\n"
"    buttons.addComponent(new Button(\"OK\", new ClickListener() {\n"
"\n"
"        public void buttonClick(ClickEvent event) {\n"
"            form.commit();\n"
"\n"
"            // Update event provider's data source\n"
"            provider.addEvent(item.getBean());\n"
"\n"
"            UI.getCurrent().removeWindow(w);\n"
"        }\n"
"    }));\n"
"\n"
"    ...\n"
"  }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6554
#, no-c-format
msgid "Resizing Events"
msgstr "变更事件的长度"

#. Tag: para
#: chapter-components.xml:6556
#, no-c-format
msgid ""
"The user can resize an event by dragging from both ends to change its start "
"or end time. This offers a convenient way to change event times without the "
"need to type anything. The default resize handler sets the start and end "
"time of the event according to the resize."
msgstr ""
"用户可以在 UI 中拖动事件的左侧或右侧来改变事件的长度, 同时也改变事件的开始事"
"件或结束时间. 这个功能提供了一种改变事件时间的便利方式, 不必进行任何键盘输"
"入. 事件长度变更的默认处理器会根据长度的变化对应的设置事件的开始时间和结束时"
"间."

#. Tag: para
#: chapter-components.xml:6563
#, no-c-format
msgid ""
"In the example below, we set a custom handler for resize events. The handler "
"prevents any event to be resized over 12 hours in length. Note that this "
"does not prevent the user from resizing an event over 12 hours in the "
"client. The resize will just be corrected by the server."
msgstr ""
"下例中, 我们对事件的长度变化设置一个自定义的处理器. 这个处理器禁止事件长度超"
"过 12 小时. 注意, 这个限制不会阻止用户在客户端将事件拉到 12 小时以上. 事件长"
"度的变更只会在服务器端被矫正."

#. Tag: programlisting
#: chapter-components.xml:6570
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[cal.setHandler(new BasicEventResizeHandler() {\n"
"  private static final long twelveHoursInMs = 12*60*60*1000;\n"
"\n"
"  protected void setDates(CalendarEventEditor event, \n"
"                          Date start, Date end) {\n"
"    long eventLength = end.getTime() - start.getTime();\n"
"    if (eventLength <= twelveHoursInMs) {\n"
"      super.setDates(event, start, end);\n"
"    }\n"
"  }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6575
#, no-c-format
msgid "Composition with <classname>CustomComponent</classname>"
msgstr "使用 <classname>CustomComponent</classname> 创造复合组件"

#. Tag: para
#: chapter-components.xml:6579
#, no-c-format
msgid ""
"The ease of making new user interface components is one of the core features "
"of Vaadin. Typically, you simply combine existing built-in components to "
"produce composite components. In many applications, such composite "
"components make up the majority of the user interface."
msgstr ""
"能够简便地创建新 UI 组件是 Vaadin 的核心功能之一. 通常你只需要简单地将已有的"
"内建组合起来, 就可以创造出复合组件. 在很多应用程序中, 大多数 UI 是由这样的复"
"合组件构成的."

#. Tag: para
#: chapter-components.xml:6586
#, no-c-format
msgid ""
"As described earlier in <xref linkend=\"application.architecture.composition"
"\"/>, you have two basic ways to create a composite - either by using a "
"layout component or the <classname>CustomComponent</classname>, which "
"typically wraps around a layout component. The benefit of wrapping a layout "
"composite in <classname>CustomComponent</classname> is mainly encapsulation "
"- hiding the implementation details of the composition. Otherwise, a user of "
"the composite might rely on the internal implementation details, such as the "
"layout class."
msgstr ""
"在 <xref linkend=\"application.architecture.composition\"/> 中我们曾介绍过, "
"有两种基本的方法来创建复合组件 - 可以使用布局组件, 或者使用 "
"<classname>CustomComponent</classname> 组件, <classname>CustomComponent</"
"classname> 之内通常也会封装一个布局组件. 将布局组件封装在 "
"<classname>CustomComponent</classname> 之内的好处主要在于信息的封装性 - 能够"
"隐藏复合组件的内部实现细节. 否则, 复合组件的使用者编写的代码, 可能会依赖于其"
"内部的实现细节, 比如具体的布局组件类."

#. Tag: para
#: chapter-components.xml:6597
#, no-c-format
msgid ""
"To create a composite, you need to inherit the <classname>CustomComponent</"
"classname> and set the <emphasis>composition root</emphasis> component in "
"the constructor. The composition root is typically a layout component that "
"contains other components."
msgstr ""
"要创建一个复合组件, 你需要继承 <classname>CustomComponent</classname> 类, 并"
"在构造方法中设置 <emphasis>复合组件的根组件</emphasis>. 复合组件的根组件通常"
"是一个布局管理组件, 并在其中包含其他组件."

#. Tag: programlisting
#: chapter-components.xml:6609
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyComposite extends CustomComponent {\n"
"    public MyComposite(String message) {\n"
"        // A layout structure used for composition\n"
"        Panel panel = new Panel(\"My Custom Component\");\n"
"        panel.setContent(new VerticalLayout());\n"
"        \n"
"        // Compose from multiple components\n"
"        Label label = new Label(message);\n"
"        label.setSizeUndefined(); // Shrink\n"
"        panel.addComponent(label);\n"
"        panel.addComponent(new Button(\"Ok\"));\n"
"\n"
"        // Set the size as undefined at all levels\n"
"        panel.getContent().setSizeUndefined();\n"
"        panel.setSizeUndefined();\n"
"        setSizeUndefined();\n"
"\n"
"        // The composition root MUST be set\n"
"        setCompositionRoot(panel);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6611
#, no-c-format
msgid ""
"Take note of the sizing when trying to make a customcomponent that shrinks "
"to fit the contained components. You have to set the size as undefined at "
"all levels; the sizing of the composite component and the composition root "
"are separate."
msgstr ""
"如果想要让自定义组件的大小收缩到与它内含的子组件相适应, 需要注意尺寸问题. 你"
"需要在组件层级关系的每一层都将尺寸设置为未定义; 复合组件的尺寸与根组件的尺寸"
"是不同的."

#. Tag: para
#: chapter-components.xml:6618
#, no-c-format
msgid "You can use the component as follows:"
msgstr "你可以象下例这样使用这个自定义组件:"

#. Tag: programlisting
#: chapter-components.xml:6622
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[MyComposite mycomposite = new "
"MyComposite(\"Hello\");]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6624
#, no-c-format
msgid ""
"The rendered component is shown in <xref linkend=\"figure.components."
"customcomponent\"/>."
msgstr ""
"自定义组件的画面表现, 见 <xref linkend=\"figure.components.customcomponent\"/"
">."

#. Tag: title
#: chapter-components.xml:6630
#, no-c-format
msgid "A Custom Composite Component"
msgstr "自定义的复合组件"

#. Tag: para
#: chapter-components.xml:6638
#, no-c-format
msgid ""
"You can also inherit any other components, such as layouts, to attain "
"similar composition. <indexterm><primary>Google Web Toolkit</primary></"
"indexterm> Even further, you can create entirely new low-level components, "
"by integrating pure client-side components or by extending the client-side "
"functionality of built-in components. Development of new components is "
"covered in <xref linkend=\"gwt\"/>."
msgstr ""
"你也可以继承其他组件, 比如布局管理组件, 来实现类似的组件组合工作. "
"<indexterm><primary>Google Web Toolkit</primary></indexterm> 甚至, 你还可以创"
"建全新的低阶组件, 方法是集成纯客户端组件, 或扩展内建组件的客户端功能. 开发新"
"组件的方法, 请参见 <xref linkend=\"gwt\"/>."

#. Tag: title
#: chapter-components.xml:6652
#, no-c-format
msgid "Composite Fields with <classname>CustomField</classname>"
msgstr "使用 <classname>CustomField</classname> 组合 Field 组件"

#. Tag: para
#: chapter-components.xml:6654
#, no-c-format
msgid ""
"The <classname>CustomField</classname> is a way to create composite "
"components like with <classname>CustomComponent</classname>, except that it "
"implements the <interfacename>Field</interfacename> interface and inherit "
"<classname>AbstractField</classname>, described in <xref linkend="
"\"components.fields\"/>. A field allows editing a property value in the "
"Vaadin data model, and can be bound to data with field groups, as described "
"in <xref linkend=\"datamodel.itembinding\"/>. The field values are buffered "
"and can be validated with validators."
msgstr ""
"<classname>CustomField</classname> 与 <classname>CustomComponent</classname> "
"类似, 也是一种创建复合组件的方式, 但是他实现了 <interfacename>Field</"
"interfacename> 方法, 并继承了 <classname>AbstractField</classname> 类, 参见 "
"<xref linkend=\"components.fields\"/>. Field 组件可以编辑 Vaadin 数据模型中的"
"属性值, 也可以使用 Field Group 绑定到数据上, 参见 <xref linkend=\"datamodel."
"itembinding\"/>. Field 值会被缓存起来, 可以使用校验器来校验."

#. Tag: para
#: chapter-components.xml:6665
#, no-c-format
msgid ""
"A composite field class must implement the <methodname>getType()</"
"methodname> and <methodname>initContent()</methodname> methods. The latter "
"should return the content composite of the field. It is typically a layout "
"component, but can be any component."
msgstr ""
"复合的 Field 类必须实现 <methodname>getType()</methodname> 和 "
"<methodname>initContent()</methodname> 方法. 后一个方法应该返回 Field 中的内"
"容的组合. 通常是一个布局管理组件, 但也可以是任何别的组件."

#. Tag: para
#: chapter-components.xml:6674
#, no-c-format
msgid ""
"It is also possible to override <methodname>validate()</methodname>, "
"<methodname>setInternalValue()</methodname>, <methodname>commit()</"
"methodname>, <methodname>setPropertyDataSource</methodname>, "
"<methodname>isEmpty()</methodname> and other methods to implement different "
"functionalities in the field. Methods overriding "
"<methodname>setInternalValue()</methodname> should call the superclass "
"method."
msgstr ""
"也可以覆盖 <methodname>validate()</methodname>, "
"<methodname>setInternalValue()</methodname>, <methodname>commit()</"
"methodname>, <methodname>setPropertyDataSource</methodname>, "
"<methodname>isEmpty()</methodname> 和其他方法, 以便在 Field 中实现各种不同功"
"能. 覆盖 <methodname>setInternalValue()</methodname> 方法时, 应该调用基类中的"
"方法."

#. Tag: title
#: chapter-components.xml:6686
#, no-c-format
msgid "Embedded Resources"
msgstr "内嵌资源"

#. Tag: para
#: chapter-components.xml:6688
#, no-c-format
msgid ""
"You can embed images in Vaadin UIs with the <classname>Image</classname> "
"component, Adobe Flash graphics with <classname>Flash</classname>, and other "
"web content with <classname>BrowserFrame</classname>. There is also a "
"generic <classname>Embedded</classname> component for embedding other object "
"types. The embedded content is referenced as <emphasis>resources</emphasis>, "
"as described in <xref linkend=\"application.resources\"/>."
msgstr ""
"在 Vaadin UI 中, 你可以使用<classname>Image</classname> 组件嵌入图像, 使用 "
"<classname>Flash</classname> 嵌入 Adobe Flash 动画, 还可以使用 "
"<classname>BrowserFrame</classname> 来嵌入其他的 Web 内容. 还有通用的 "
"<classname>Embedded</classname> 组件可以嵌入其他类型的对象. 嵌入内容通过 "
"<emphasis>resources</emphasis> 来引用, 详情请参见<xref linkend=\"application."
"resources\"/>."

#. Tag: para
#: chapter-components.xml:6697
#, no-c-format
msgid ""
"The following example displays an image as a class resource loaded with the "
"class loader:"
msgstr "下例演示如何使用类记载器装载一个类资源, 并将它显示为图片:"

#. Tag: programlisting
#: chapter-components.xml:6702
#, no-c-format
msgid ""
"<![CDATA[Image image = new Image(\"Yes, logo:\",\n"
"    new ClassResource(\"vaadin-logo.png\"));\n"
"main.addComponent(image);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6704
#, no-c-format
msgid ""
"The caption can be given as null to disable it. An empty string displays an "
"empty caption which takes a bit space. The caption is managed by the "
"containing layout."
msgstr ""
"将标题设置为 null 可以删除标题. 如果将标题设置为空字符串的话, 会显示一个空的"
"标题, 仍然会占据一点点空间. 标题由组件所属的布局负责管理."

#. Tag: para
#: chapter-components.xml:6710
#, no-c-format
msgid ""
"You can set an altenative text for an embedded resource with "
"<methodname>setAlternateText()</methodname>, which can be shown if images "
"are disabled in the browser for some reason. The text can be used for "
"accessibility purposes, such as for text-to-speech generation."
msgstr ""
"你可以使用<methodname>setAlternateText()</methodname> 方法为内嵌资源设置一个"
"替代文字, 如果出于某种原因, 图片被浏览器禁用, 那么就会显示这个替代文字. 这个"
"文字还可用来提高界面对残障人士的易用性, 比如, 可以使用自动语音合成技术来朗读"
"它."

#. Tag: title
#: chapter-components.xml:6718
#, no-c-format
msgid "Embedded <classname>Image</classname>"
msgstr "内嵌的 <classname>Image</classname>"

#. Tag: para
#: chapter-components.xml:6720
#, no-c-format
msgid ""
"The <classname>Image</classname> component allows embedding an image "
"resource in a Vaadin UI."
msgstr ""
"<classname>Image</classname> 组件可用来在 Vaadin UI 中嵌入一个图像资源."

#. Tag: programlisting
#: chapter-components.xml:6725
#, no-c-format
msgid ""
"<![CDATA[// Serve the image from the theme\n"
"Resource res = new ThemeResource(\"img/myimage.png\");\n"
"\n"
"// Display the image without caption\n"
"Image image = new Image(null, res);\n"
"layout.addComponent(image);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6728
#, no-c-format
msgid ""
"The <classname>Image</classname> component has by default undefined size in "
"both directions, so it will automatically fit the size of the embedded "
"image. <indexterm><primary>scroll bars</primary></indexterm> If you want "
"scrolling with scroll bars, you can put the image inside a <classname>Panel</"
"classname> that has a defined size to enable scrolling, as described in "
"<xref linkend=\"layout.panel.scrolling\"/>. You can also put it inside some "
"other component container and set the <literal>overflow: auto</literal> CSS "
"property for the container element in a theme to enable automatic scrollbars."
msgstr ""
"<classname>Image</classname> 组件在长宽方向上默认都为未定义尺寸, 因此它会自动"
"适应图片的尺寸. <indexterm><primary>scroll bars</primary></indexterm> 如果你"
"希望使用滚动条来滚动, 你可以将 Image 放置在 <classname>Panel</classname> 之"
"内, 为 Panel 设置固定的尺寸, 并允许滚动, 详情请参见 <xref linkend=\"layout."
"panel.scrolling\"/>. 你也可以将 Image 放在其他组件容器内, 并在 Theme 中为容器"
"的 HTML 元素设置 CSS 属性为: <literal>overflow: auto</literal>, 这样就可以自"
"动出现滚动条."

#. Tag: indexterm
#: chapter-components.xml:6740
#, no-c-format
msgid "overflow CSS property"
msgstr ""

#. Tag: title
#: chapter-components.xml:6746
#, no-c-format
msgid "Generating and Reloading Images"
msgstr "图片的生成和重新装载"

#. Tag: para
#: chapter-components.xml:6748
#, no-c-format
msgid ""
"You can also generate the image content dynamically using a "
"<classname>StreamResource</classname>, as described in <xref linkend="
"\"application.resources.stream\"/>, or with a <classname>RequestHandler</"
"classname>."
msgstr ""
"你也可以使用 <classname>StreamResource</classname> 来动态生成图片内容, 详情请"
"参见 <xref linkend=\"application.resources.stream\"/>, 也可以使用 "
"<classname>RequestHandler</classname>."

#. Tag: para
#: chapter-components.xml:6755
#, no-c-format
msgid ""
"If the image changes, the browser needs to reload it. Simply updating the "
"stream resource is not enough. Because of how caching is handled in some "
"browsers, you can cause a reload easiest by renaming the filename of the "
"resource with a unique name, such as one including a timestamp. You should "
"set cache time to zero with <methodname>setCacheTime()</methodname> for the "
"resource object when you create it."
msgstr ""
"如果图片内容发生了变化, 浏览器需要重新装载它. 简单的更新流资源是不够的. 由于"
"某些浏览器端对缓存的管理方式, 让图片重新装载的最简便方法是用一个唯一文件名来"
"重命名资源文件名, 比如, 使用时间戳作为文件名的一部分. 创建资源时, 你应该使用 "
"<methodname>setCacheTime()</methodname> 方法将资源的缓存时间设置为 0 ."

#. Tag: programlisting
#: chapter-components.xml:6767
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create the stream resource with some initial "
"filename\n"
"StreamResource imageResource =\n"
"    new StreamResource(imageSource, \"initial-filename.png\");\n"
"\n"
"// Instruct browser not to cache the image\n"
"imageResource.setCacheTime(0);\n"
"\n"
"// Display the image\n"
"Image image = new Image(null, imageResource);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6769
#, no-c-format
msgid ""
"When refreshing, you also need to call <methodname>markAsDirty()</"
"methodname> for the <classname>Image</classname> object."
msgstr ""
"刷新时, 你还需要对 <classname>Image</classname> 对象调用 "
"<methodname>markAsDirty()</methodname> 方法."

#. Tag: programlisting
#: chapter-components.xml:6775
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// This needs to be done, but is not "
"sufficient\n"
"image.markAsDirty();\n"
"\n"
"// Generate a filename with a timestamp\n"
"SimpleDateFormat df = new SimpleDateFormat(\"yyyyMMddHHmmssSSS\");\n"
"String filename = \"myfilename-\" + df.format(new Date()) + \".png\";\n"
"\n"
"// Replace the filename in the resource\n"
"imageResource.setFilename(makeImageFilename());]]>"
msgstr ""

#. Tag: title
#: chapter-components.xml:6780
#, no-c-format
msgid "Adobe <classname>Flash</classname> Graphics"
msgstr "Adobe <classname>Flash</classname> 动画"

#. Tag: para
#: chapter-components.xml:6782
#, no-c-format
msgid ""
"The <classname>Flash</classname> component allows embedding Adobe Flash "
"animations in Vaadin UIs."
msgstr ""
"<classname>Flash</classname> 组件可用来在 Vaadin UI 中嵌入 Adobe Flash 动画."

#. Tag: programlisting
#: chapter-components.xml:6787
#, no-c-format
msgid ""
"<![CDATA[Flash flash = new Flash(null,\n"
"    new ThemeResource(\"img/vaadin_spin.swf\"));\n"
"layout.addComponent(flash);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6789
#, no-c-format
msgid ""
"You can set Flash parameters with <methodname>setParameter()</methodname>, "
"which takes a parameter's name and value as strings. You can also set the "
"<parameter>codeBase</parameter>, <parameter>archive</parameter>, and "
"<parameter>standBy</parameter> attributes for the Flash object element in "
"HTML."
msgstr ""
"你可以使用 <methodname>setParameter()</methodname> 方法设置 Flash 参数 , 这个"
"方法接受的参数是 Flash 参数名和参数值, 类型都是字符串. 你还可以为 HTML 中的 "
"Flash 对象元素设置 <parameter>codeBase</parameter>, <parameter>archive</"
"parameter>, 以及 <parameter>standBy</parameter> 属性."

#. Tag: classname
#: chapter-components.xml:6799
#, no-c-format
msgid "BrowserFrame"
msgstr ""

#. Tag: para
#: chapter-components.xml:6801
#, no-c-format
msgid ""
"The <classname>BrowserFrame</classname> allows embedding web content inside "
"an HTML <tag>&lt;iframe&gt;</tag> element. You can refer to an external URL "
"with <classname>ExternalResource</classname>."
msgstr ""
"<classname>BrowserFrame</classname> 可用于在 HTML <tag>&lt;iframe&gt;</tag> "
"元素内嵌入 Web 内容. 你可以使用 <classname>ExternalResource</classname> 来引"
"用一个外部 URL."

#. Tag: para
#: chapter-components.xml:6807
#, no-c-format
msgid ""
"As the <classname>BrowserFrame</classname> has undefined size by default, it "
"is critical that you define a meaningful size for it, either fixed or "
"relative."
msgstr ""
"由于 <classname>BrowserFrame</classname> 默认未定义尺寸, 因此你必须为它指定一"
"个有意义的尺寸, 固定尺寸或相对尺寸都可以."

#. Tag: programlisting
#: chapter-components.xml:6813
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[BrowserFrame browser = new "
"BrowserFrame(\"Browser\",\n"
"    new ExternalResource(\"http://demo.vaadin.com/sampler/\"));\n"
"browser.setWidth(\"600px\");\n"
"browser.setHeight(\"400px\");\n"
"layout.addComponent(browser);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6815
#, no-c-format
msgid ""
"Notice that web pages can prevent embedding them in an <tag>&lt;iframe&gt;</"
"tag>."
msgstr "注意, Web 页面本身有可能会阻止自己嵌入到 <tag>&lt;iframe&gt;</tag> 中."

#. Tag: title
#: chapter-components.xml:6821
#, no-c-format
msgid "Generic <classname>Embedded</classname> Objects"
msgstr "通用的 <classname>Embedded</classname> 对象"

#. Tag: para
#: chapter-components.xml:6823
#, no-c-format
msgid ""
"The generic <classname>Embedded</classname> component allows embedding all "
"sorts of objects, such as SVG graphics, Java applets, and PDF documents, in "
"addition to the images, Flash graphics, and browser frames which you can "
"embed with the specialized components."
msgstr ""
"除了使用特定的组件来嵌入图像, Flash 动画, 浏览器 Frame 之外, 还可以使用通用"
"的 <classname>Embedded</classname> 组件来嵌入任何类型的对象, 比如 SVG 图像, "
"Java Applet, 以及 PDF 文档."

#. Tag: para
#: chapter-components.xml:6830
#, no-c-format
msgid "For example, to display a Flash animation:"
msgstr "比如, 下例显示一个 Flash 动画:"

#. Tag: programlisting
#: chapter-components.xml:6834
#, no-c-format
msgid ""
"<![CDATA[// A resource reference to some object\n"
"Resource res = new ThemeResource(\"img/vaadin_spin.swf\");\n"
"\n"
"// Display the object\n"
"Embedded object = new Embedded(\"My Object\", res);\n"
"layout.addComponent(object);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6836
#, no-c-format
msgid "Or an SVG image:"
msgstr "下例显示 SVG 图片"

#. Tag: programlisting
#: chapter-components.xml:6840
#, no-c-format
msgid ""
"<![CDATA[// A resource reference to some object\n"
"Resource res = new ThemeResource(\"img/reindeer.svg\");\n"
"\n"
"// Display the object\n"
"Embedded object = new Embedded(\"My SVG\", res);\n"
"object.setMimeType(\"image/svg+xml\"); // Unnecessary\n"
"layout.addComponent(object);]]>"
msgstr ""

#. Tag: para
#: chapter-components.xml:6842
#, no-c-format
msgid ""
"The MIME type of the objects is usually detected automatically from the "
"filename extension with the <classname>FileTypeResolver</classname> utility "
"in Vaadin. If not, you can set it explicitly with <methodname>setMimeType()</"
"methodname>, as was done in the example above (where it was actually "
"unnecessary)."
msgstr ""
"对象的 MIME 类型通常由 Vaadin 中的工具类 <classname>FileTypeResolver</"
"classname> 根据文件扩展名来自动判定. 如果无法自动判定, 你可以使用 "
"<methodname>setMimeType()</methodname> 方法来明确的设定它, 如上例所示(在上例"
"中其实是不必明确设定的)."

#. Tag: para
#: chapter-components.xml:6850
#, no-c-format
msgid ""
"Some embeddable object types may require special support in the browser. You "
"should make sure that there is a proper fallback mechanism if the browser "
"does not support the embedded type."
msgstr ""
"某些内嵌对象类型可能需要浏览器端的特殊支持. 如果浏览器不支持这种内嵌类型, 你"
"需要确定存在一个适当的 fallback 机制来处理这种异常情况."
