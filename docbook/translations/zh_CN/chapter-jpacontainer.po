# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: \n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2014-11-07 16:53+0000\n"
"PO-Revision-Date: 2014-11-08 02:05+0900\n"
"Last-Translator: \n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"X-Generator: Poedit 1.6.5\n"

#. Tag: title
#: chapter-jpacontainer.xml:11
#, no-c-format
msgid "<title>Vaadin JPAContainer</title>"
msgstr ""

#. Tag: primary
#: chapter-jpacontainer.xml:14
#, no-c-format
msgid "JPAContainer"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:17
#, no-c-format
msgid "This chapter describes the use of the Vaadin JPAContainer add-on."
msgstr "本章介绍 Vaadin JPAContainer add-on 的使用."

#. Tag: title
#: chapter-jpacontainer.xml:22
#, no-c-format
msgid "Overview"
msgstr "概述"

#. Tag: para
#: chapter-jpacontainer.xml:24
#, no-c-format
msgid ""
"Vaadin JPAContainer add-on makes it possible to bind user interface "
"components to a database easily using the Java Persistence API (JPA). It is "
"an implementation of the <interfacename>Container</interfacename> interface "
"described in <xref linkend=\"datamodel.container\"/>. It supports a typical "
"three-layer application architecture with an intermediate <emphasis>domain "
"model</emphasis> between the user interface and the data access layer."
msgstr ""
"使用 Vaadin JPAContainer add-on, 可以很便利地通过 Java Persistence API (JPA) "
"来实现 UI 组件与数据库的绑定. JPAContainer 是 <interfacename>Container</"
"interfacename> 接口的一个实现, 关于这个接口参见 <xref linkend=\"datamodel."
"container\"/>. JPAContainer 支持典型的三层应用程序架构, 它是用户界面层与数据"
"访问层之间的 <emphasis>业务数据模型</emphasis>."

#. Tag: title
#: chapter-jpacontainer.xml:36
#, no-c-format
msgid "Three-Layer Architecture Using JPAContainer And JPA"
msgstr "使用 JPAContainer 和 JPA 的三层架构"

#. Tag: para
#: chapter-jpacontainer.xml:47
#, no-c-format
msgid ""
"The role of Java Persistence API is to handle persisting the domain model in "
"the database. The database is typically a relational database. Vaadin "
"JPAContainer binds the user interface components to the domain model and "
"handles database access with JPA transparently."
msgstr ""
"Java Persistence API 的角色是负责处理业务数据模型在数据库中的持久化存储. 数据"
"库通常是关系型数据库. Vaadin JPAContainer 将 UI 组件绑定到业务数据模型上, 并"
"负责使用 JPA 来透明地处理数据库访问."

#. Tag: para
#: chapter-jpacontainer.xml:54
#, no-c-format
msgid ""
"JPA is really just an API definition and has many alternative "
"implementations. Vaadin JPAContainer supports especially EclipseLink, which "
"is the reference implementation of JPA, and Hibernate. Any other compliant "
"implementation should work just as well. The architecture of an application "
"using JPAContainer is shown in <xref linkend=\"figure.jpacontainer.overview."
"detailed-architecture\"/>."
msgstr ""
"JPA 本身仅仅只是一个 API 定义, 存在很多不同的 JPA 实现. Vaadin JPAContainer "
"特别支持的是 EclipseLink(JPA 的参考实现) 和 Hibernate. 其它的兼容实现也应该能"
"正常工作. 使用 JPAContainer 的应用程序的架构参见 <xref linkend=\"figure."
"jpacontainer.overview.detailed-architecture\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:64
#, no-c-format
msgid "JPAContainer Architecture"
msgstr "JPAContainer 架构"

#. Tag: para
#: chapter-jpacontainer.xml:75
#, no-c-format
msgid ""
"Vaadin JPAContainer also plays together with the Vaadin support for Java "
"Bean Validation (JSR 303)."
msgstr ""
"Vaadin JPAContainer 还整合了 Vaadin 支持的 Java Bean Validation (JSR 303)."

#. Tag: title
#: chapter-jpacontainer.xml:81
#, no-c-format
msgid "Java Persistence API"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:83
#, no-c-format
msgid ""
"Java Persistence API (JPA) is an API for object-relational mapping (ORM) of "
"Java objects to a relational database. In JPA and entity-relationship "
"modeling in general, a Java class is considered an <emphasis>entity</"
"emphasis>. Class (or entity) instances correspond with a row in a database "
"table and member variables of a class with columns. Entities can also have "
"relationships with other entities."
msgstr ""
"Java Persistence API (JPA) 是一组 Object-Relational Mapping (ORM) API, 用于实"
"现 Java 对象到关系型数据库之间的映射. 在 JPA 中, 更一般地说, 在实体-关系模型"
"中, Java 类被看作 <emphasis>实体</emphasis>. 类(或者说实体)的实例对应到数据库"
"表中的一行, 类的成员变量对应到数据库表中的列. 实体与其他实体之间也可以存在关"
"联关系."

#. Tag: para
#: chapter-jpacontainer.xml:92
#, no-c-format
msgid ""
"The object-relational mapping is illustrated in <xref linkend=\"figure."
"jpacontainer.overview.jpa.orm\"/> with two entities with a one-to-many "
"relationship."
msgstr ""
"对象-关系映射请参见 <xref linkend=\"figure.jpacontainer.overview.jpa.orm\"/"
">, 图中存在 两个实体, 它们之间存在一对多关系."

#. Tag: title
#: chapter-jpacontainer.xml:99
#, no-c-format
msgid "Object-Relational Mapping"
msgstr "对象(Object)-关系(Relational) 映射"

#. Tag: para
#: chapter-jpacontainer.xml:110
#, no-c-format
msgid ""
"The entity relationships are declared with metadata. With Vaadin "
"JPAContainer, you provide the metadata with annotations in the entity "
"classes. The JPA implementation uses reflection to read the annotations and "
"defines a database model automatically from the class definitions. "
"Definition of the domain model and the annotations are described in <xref "
"linkend=\"jpacontainer.domain-model.annotation\"/>."
msgstr ""
"实体之间的关系是使用元数据来声明的. 使用 Vaadin JPAContainer, 你可以在实体类"
"中通过注解来提供元数据. JPA 实现库会使用反射来读取注解, 并根据类定义自动产生"
"对应的数据库模型. 业务数据模型的定义及相关注解, 请参见 <xref linkend="
"\"jpacontainer.domain-model.annotation\"/>."

#. Tag: para
#: chapter-jpacontainer.xml:119
#, no-c-format
msgid ""
"The main interface in JPA is the <interfacename>EntityManager</"
"interfacename>, which allows making different kinds of queries either with "
"the Java Persistence Query Language (JPQL), native SQL, or the Criteria API "
"in JPA 2.0. You can always use the interface directly as well, using Vaadin "
"JPAContainer only for binding the data to the user interface."
msgstr ""
"JPA 中的主要接口是 <interfacename>EntityManager</interfacename>, 通过它可以发"
"起各种查询, 查询语言可以使用 Java Persistence Query Language (JPQL), 原生 "
"SQL, 或者 JPA 2.0 的 Criteria API. 你可以直接使用这个接口, 同时只使用 Vaadin "
"JPAContainer 来实现数据与 UI 的绑定."

#. Tag: para
#: chapter-jpacontainer.xml:128
#, no-c-format
msgid ""
"Vaadin JPAContainer supports JPA 2.0 (JSR 317). It is available under the "
"Apache License 2.0."
msgstr ""
"Vaadin JPAContainer 支持 JPA 2.0 (JSR 317). 它的许可协议是 Apache License "
"2.0."

#. Tag: title
#: chapter-jpacontainer.xml:135
#, no-c-format
msgid "JPAContainer Concepts"
msgstr "JPAContainer 中的基本概念"

#. Tag: para
#: chapter-jpacontainer.xml:137
#, no-c-format
msgid ""
"The <classname>JPAContainer</classname> is an implementation of the Vaadin "
"<interfacename>Container</interfacename> interface that you can bind to user "
"interface components such as <classname>Table</classname>, "
"<classname>ComboBox</classname>, etc."
msgstr ""
"<classname>JPAContainer</classname> 是 Vaadin <interfacename>Container</"
"interfacename> 接口的一个实现, 因此你可以将它绑定到 UI 组件, 比如 "
"<classname>Table</classname>, <classname>ComboBox</classname>, 等等."

#. Tag: para
#: chapter-jpacontainer.xml:144
#, no-c-format
msgid ""
"The data access to the persistent entities is handled with a "
"<emphasis>entity provider</emphasis>, as defined in the "
"<interfacename>EntityProvider</interfacename> interface. JPAContainer "
"provides a number of different entity providers for different use cases and "
"optimizations. The built-in providers are described in <xref linkend="
"\"jpacontainer.entityprovider\"/>."
msgstr ""
"对持久化实体类的数据访问由 <emphasis>实体提供者(entity provider)</emphasis> "
"负责处理, 定义在 <interfacename>EntityProvider</interfacename> 接口中. "
"JPAContainer 为各种不同的使用场景和优化目的提供了多种不同的entity provider. "
"关于内建的entity provider 请参见 <xref linkend=\"jpacontainer.entityprovider"
"\"/>."

#. Tag: para
#: chapter-jpacontainer.xml:153
#, no-c-format
msgid ""
"<classname>JPAContainer</classname> is by default <emphasis>unbuffered</"
"emphasis>, so that any entity property changes are written immediately to "
"the database when you call <methodname>setValue()</methodname> for a "
"property, or when a user edits a bound field. A container can be set as "
"<emphasis>buffered</emphasis>, so that changes are written on calling "
"<methodname>commit()</methodname>. Buffering can be done both at item level, "
"such as when updating item property values, or at container level, such as "
"when adding or deleting items. Only <emphasis>batchable</emphasis> "
"containers, that is, containers with a batchable entity provider, can be "
"buffered. Note that buffering is recommended for situations where two users "
"could update the same entity simultaneously, and when this would be a "
"problem. In an unbuffered container, the entity is refreshed before writing "
"an update, so the last write wins and a conflicting simultaneous update "
"written before it is lost. A buffered container throws an "
"<classname>OptimisticLockException</classname> when two users edit the same "
"item (an unbuffered container never throws it), thereby allowing to handle "
"the situation with application logic."
msgstr ""
"<classname>JPAContainer</classname> 默认是 <emphasis>无缓冲的</emphasis>, 因"
"此当你对一个属性调用 <methodname>setValue()</methodname> 方法时, 或者当用户编"
"辑了一个与它绑定的 Field 组件时, 实体的属性变更会立即写入数据库中. 容器可以被"
"设置为 <emphasis>有缓冲的</emphasis>, 这时数据变更会在调用 "
"<methodname>commit()</methodname> 方法时写入数据库. 缓冲可以发生在元素(Item)"
"级别, 比如对元素属性值的更新进行缓冲, 也可以发生在容器级别, 比如对元素的增加"
"和删除进行缓冲. 只有 <emphasis>可以批量处理的</emphasis> 容器, 也就是, 使用可"
"以批量处理的 entity provider 的容器, 才可以进行缓冲. 注意, 如果两个用户可以同"
"时更新同一个实体, 并可能导致问题时, 推荐使用缓冲功能. 在无缓冲的容器中, 在写"
"入更新之前会先刷新实体, 因此后一次写会胜利, 并且同时更新冲突会被写入, 然后会"
"发生数据丢失(译注: 此段意义不明, 待校). 当两个用户编辑同一个元素时, 有缓冲的"
"容器会抛出 <classname>OptimisticLockException</classname> 异常, (而无缓冲的容"
"器则不会抛出这个异常), 因此可以使用应用程序逻辑来处理这种异常状况."

#. Tag: title
#: chapter-jpacontainer.xml:176
#, no-c-format
msgid "Documentation and Support"
msgstr "文档与支持"

#. Tag: para
#: chapter-jpacontainer.xml:178
#, no-c-format
msgid ""
"In addition to this chapter in the book, the installation package includes "
"the following documentation about JPAContainer:"
msgstr "除本书的这一章之外, 安装包中还包含了关于 JPAContainer 的以下文档:"

#. Tag: para
#: chapter-jpacontainer.xml:184
#, no-c-format
msgid "API Documentation"
msgstr "API 文档"

#. Tag: para
#: chapter-jpacontainer.xml:185
#, no-c-format
msgid "JPAContainer Tutorial"
msgstr "JPAContainer 教程"

#. Tag: para
#: chapter-jpacontainer.xml:186
#, no-c-format
msgid "JPAContainer AddressBook Demo"
msgstr "JPAContainer AddressBook 示例程序"

#. Tag: para
#: chapter-jpacontainer.xml:187
#, no-c-format
msgid "JPAContainer Demo"
msgstr "JPAContainer 示例程序"

#. Tag: title
#: chapter-jpacontainer.xml:193
#, no-c-format
msgid "Installing"
msgstr "安装"

#. Tag: para
#: chapter-jpacontainer.xml:195
#, no-c-format
msgid ""
"Vaadin JPAContainer can be installed either as an installation package, "
"downloaded from the Vaadin Directory, or as a Maven dependency. You can also "
"create a new JPAContainer-enabled Vaadin project using a Maven archetype."
msgstr ""
"Vaadin JPAContainer 可以使用安装包进行安装, 安装包可通过 Vaadin Directory 下"
"载, 也可以作为 Maven 依赖项目进行安装. 你可以使用 Maven archetype 来创建一个"
"新的、支持 JPAContainer 的 Vaadin 工程."

#. Tag: title
#: chapter-jpacontainer.xml:202
#, no-c-format
msgid "Downloading the Package"
msgstr "下载安装包"

#. Tag: para
#: chapter-jpacontainer.xml:204
#, no-c-format
msgid ""
"Vaadin JPAContainer is available for download from the <link xlink:href="
"\"http://vaadin.com/directory\">Vaadin Directory</link>. Please see <xref "
"linkend=\"addons.downloading\"/> for basic instructions for downloading from "
"Directory. The download page also gives the dependency declaration needed "
"for retrieving the library with Maven."
msgstr ""
"Vaadin JPAContainer 可从 <link xlink:href=\"http://vaadin.com/directory"
"\">Vaadin Directory</link> 下载. 从 Vaadin Directory 下载安装包的基本操作请参"
"见 <xref linkend=\"addons.downloading\"/> . 下载页面中还列出了使用 Maven 来取"
"得这个库时需要使用的依赖项声明."

#. Tag: para
#: chapter-jpacontainer.xml:212
#, no-c-format
msgid ""
"JPAContainer is a purely server-side component, so it does not include a "
"widget set that you would need to compile."
msgstr ""
"JPAContainer 是一个纯服务器端组件, 因此其中不包括需要你编译的 Widget Set."

#. Tag: title
#: chapter-jpacontainer.xml:219
#, no-c-format
msgid "Installation Package Content"
msgstr "安装包的内容"

#. Tag: para
#: chapter-jpacontainer.xml:222
#, no-c-format
msgid ""
"Once extracted to a local folder, the contents of the installation directory "
"are as follows:"
msgstr "解开到本地文件夹之后, 安装目录中的内容如下:"

#. Tag: filename
#: chapter-jpacontainer.xml:229
#, no-c-format
msgid "README"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:231
#, no-c-format
msgid "A readme file describing the package contents."
msgstr "Readme 文件, 描述安装包的内容."

#. Tag: filename
#: chapter-jpacontainer.xml:237
#, no-c-format
msgid "LICENSE"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:239
#, no-c-format
msgid "The full license text for the library."
msgstr "本库完整的许可协议文本."

#. Tag: filename
#: chapter-jpacontainer.xml:245
#, no-c-format
msgid "vaadin-jpacontainer-3.x.x.jar"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:247
#, no-c-format
msgid "The actual Vaadin JPAContainer library."
msgstr "Vaadin JPAContainer 库文件."

#. Tag: filename
#: chapter-jpacontainer.xml:265
#, no-c-format
msgid "vaadin-jpacontainer-3.x.x-sources.jar"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:267
#, no-c-format
msgid ""
"Source JAR for the library. You can use it for example in Eclipse by "
"associating the JavaDoc JAR with the JPAContainer JAR in the build path "
"settings of your project."
msgstr ""
"本库源代码的 JAR 文件. 比如在 Eclipse 中, 你可以在你的工程的编译路径设定中, "
"将这个 JAR 文件与 JPAContainer JAR 文件关联在一起."

#. Tag: filename
#: chapter-jpacontainer.xml:286
#, no-c-format
msgid "jpacontainer-tutorial.pdf"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:288
#, no-c-format
msgid "The tutorial in PDF format."
msgstr "PDF 格式的教程."

#. Tag: filename
#: chapter-jpacontainer.xml:294
#, no-c-format
msgid "jpacontainer-tutorial-html"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:296
#, no-c-format
msgid "The tutorial in HTML format."
msgstr "HTML 格式的教程."

#. Tag: filename
#: chapter-jpacontainer.xml:302
#, no-c-format
msgid "jpacontainer-addressbook-demo"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:304
#, no-c-format
msgid ""
"The JPAContainer AddressBook Demo project covered in this tutorial. You can "
"compile and package the application as a WAR with \"<command>mvn</command> "
"<parameter>package</parameter>\" or launch it in the Jetty web browser with "
"\"<command>mvn</command> <parameter>jetty:run</parameter>\". You can also "
"import the demo project in Eclipse."
msgstr ""
"本教程中将要介绍的 JPAContainer AddressBook 示例程序工程. 你可以使用 "
"\"<command>mvn</command> <parameter>package</parameter>\" 命令编译这个工程并"
"打包为一个 WAR, 也可以使用 \"<command>mvn</command> <parameter>jetty:run</"
"parameter>\" 命令在 Jetty Web 服务器中执行它 . 你也可以将这个示例工程导入到 "
"Eclipse 中."

#. Tag: title
#: chapter-jpacontainer.xml:318
#, no-c-format
msgid "Downloading with Maven"
msgstr "使用 Maven 下载"

#. Tag: para
#: chapter-jpacontainer.xml:320
#, no-c-format
msgid ""
"The <link xlink:href=\"http://vaadin.com/directory\">download page in Vaadin "
"Directory</link> gives the dependency declaration needed for retrieving the "
"Vaadin JPAContainer library with Maven."
msgstr ""
"<link xlink:href=\"http://vaadin.com/directory\">Vaadin Directory 中的下载页"
"面</link> 给出了使用 Maven 来取得 Vaadin JPAContainer 库时需要的依赖项声明 ."

#. Tag: programlisting
#: chapter-jpacontainer.xml:326
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<dependency>\n"
"   <groupId>com.vaadin.addon</groupId>\n"
"   <artifactId>jpacontainer-addon</artifactId>\n"
"   <version>3.1.0</version>\n"
"</dependency>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:328
#, no-c-format
msgid ""
"Use the <literal>LATEST</literal> version tag to automatically download the "
"latest stable release or use a specific version number as done above."
msgstr ""
"使用 <literal>LATEST</literal> 版本标记可以自动下载最新的稳定发布版本, 也可以"
"向上例一样使用某个指定的版本号."

#. Tag: para
#: chapter-jpacontainer.xml:333
#, no-c-format
msgid ""
"See <xref linkend=\"addons.maven\"/> for detailed instructions for using a "
"Vaadin add-on with Maven."
msgstr ""
"关于如何通过 Maven 使用 Vaadin add-on, 详情请参见 <xref linkend=\"addons."
"maven\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:339
#, no-c-format
msgid "Using the Maven Archetype"
msgstr "使用 Maven Archetype"

#. Tag: para
#: chapter-jpacontainer.xml:341
#, no-c-format
msgid ""
"If you wish to create a new JPAContainer-enabled Vaadin project with Maven, "
"you can use the <literal>vaadin-archetype-jpacontainer</literal> archetype. "
"Please see <xref linkend=\"getting-started.maven\"/> for details on creating "
"a Vaadin project with a Maven archetype."
msgstr ""
"如果你希望通过 Maven 来创建新的使用 JPAContainer 的 Vaadin 工程, 你可以使用 "
"<literal>vaadin-archetype-jpacontainer</literal> archetype. 关于如何使用 "
"Maven archetype 来创建 Vaadin 工程, 详情请参见 <xref linkend=\"getting-"
"started.maven\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:352
#, no-c-format
msgid "Including Libraries in Your Project"
msgstr "将库添加到你的工程中"

#. Tag: para
#: chapter-jpacontainer.xml:354
#, no-c-format
msgid ""
"The Vaadin JPAContainer JAR must be included in the library folder of the "
"web application. It is located in <filename>WEB-INF/lib</filename> path in a "
"web application. In a normal Eclipse web projects the path is "
"<filename>WebContent/WEB-INF/lib</filename>. In Maven projects the JARs are "
"automatically included in the folder, as long as the dependencies are "
"defined correctly."
msgstr ""
"Vaadin JPAContainer JAR 必须包括在 Web 应用程序的库目录中. 这个目录也就是 "
"Web 应用程序中的 <filename>WEB-INF/lib</filename> 目录. 在通常的 Eclipse Web "
"工程中, 路径为 <filename>WebContent/WEB-INF/lib</filename>. 在 Maven 工程中, "
"只要正确地定义了依赖项目, JAR 文件就会被自动包含到目录中."

#. Tag: para
#: chapter-jpacontainer.xml:365
#, no-c-format
msgid "You will need the following JARs:"
msgstr "你将需要以下 JAR 文件:"

#. Tag: para
#: chapter-jpacontainer.xml:370
#, no-c-format
msgid "Vaadin Framework Library"
msgstr "Vaadin Framework 库"

#. Tag: para
#: chapter-jpacontainer.xml:371
#, no-c-format
msgid "<para>Vaadin JPAContainer</para>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:372
#, no-c-format
msgid "Java Persistence API 2.0 (javax.persistence package)"
msgstr "Java Persistence API 2.0 (javax.persistence 包)"

#. Tag: para
#: chapter-jpacontainer.xml:373
#, no-c-format
msgid "JPA implementation (EclipseLink, Hibernate, ...)"
msgstr "JPA 实现库(EclipseLink, Hibernate, ...)"

#. Tag: para
#: chapter-jpacontainer.xml:374
#, no-c-format
msgid "Database driver or embedded engine (H2, HSQLDB, MySQL, PostgreSQL, ...)"
msgstr "数据库驱动, 或内嵌式数据库 (H2, HSQLDB, MySQL, PostgreSQL, ...)"

#. Tag: para
#: chapter-jpacontainer.xml:377
#, no-c-format
msgid ""
"If you use Eclipse, the Vaadin Framework library is automatically downloaded "
"and updated by the Vaadin Plugin for Eclipse."
msgstr ""
"如果你使用 Eclipse, Vaadin Plugin for Eclipse 会帮助你自动下载并更新 Vaadin "
"Framework 库."

#. Tag: para
#: chapter-jpacontainer.xml:382
#, no-c-format
msgid ""
"To use bean validation, you need an implementation of the Bean Validation, "
"such as Hibernate Validator."
msgstr ""
"为了使用 bean 校验功能, 你需要 Bean Validation 的实现库, 比如 Hibernate "
"Validator."

#. Tag: title
#: chapter-jpacontainer.xml:389
#, no-c-format
msgid "Persistence Configuration"
msgstr "持久化配置"

#. Tag: para
#: chapter-jpacontainer.xml:391
#, no-c-format
msgid ""
"Persistence configuration is done in a <filename>persistence.xml</filename> "
"file. In a regular Eclipse project, it should be located in "
"<filename>WebContent/WEB-INF/classes/META-INF</filename>. In a Maven "
"project, it should be in <filename>src/main/resources/META-INF</filename>. "
"The configuration includes the following:"
msgstr ""
"持久化配置由 <filename>persistence.xml</filename> 文件实现. 在通常的 Eclipse "
"工程中, 这个文件应该在 <filename>WebContent/WEB-INF/classes/META-INF</"
"filename> 目录中. 在 Maven 工程中, 它应该在 <filename>src/main/resources/"
"META-INF</filename> 目录中. 配置包含以下内容:"

#. Tag: para
#: chapter-jpacontainer.xml:402
#, no-c-format
msgid "The persistence unit"
msgstr "持久化单元(persistence unit)"

#. Tag: para
#: chapter-jpacontainer.xml:403
#, no-c-format
msgid "The persistence provider"
msgstr "持久化提供者(persistence provider)"

#. Tag: para
#: chapter-jpacontainer.xml:404
#, no-c-format
msgid "The database driver and connection"
msgstr "数据库驱动程序及连接配置"

#. Tag: para
#: chapter-jpacontainer.xml:405
#, no-c-format
msgid "Logging"
msgstr "日志"

#. Tag: para
#: chapter-jpacontainer.xml:408
#, no-c-format
msgid ""
"The <filename>persistence.xml</filename> file is packaged as <filename>WEB-"
"INF/classes/META-INF/persistence.xml</filename> in the WAR. This is done "
"automatically in a Maven build at the package phase."
msgstr ""
"<filename>persistence.xml</filename> 文件在 WAR 中会被打包为 <filename>WEB-"
"INF/classes/META-INF/persistence.xml</filename>. 在 Maven 编译的打包阶段会自"
"动进行这个工作."

#. Tag: title
#: chapter-jpacontainer.xml:415
#, no-c-format
msgid "Persistence XML Schema"
msgstr "持久化配置 XML 文件的 Schema"

#. Tag: para
#: chapter-jpacontainer.xml:417
#, no-c-format
msgid ""
"The beginning of a <filename>persistence.xml</filename> file defines the "
"used schema and namespaces:"
msgstr ""
"<filename>persistence.xml</filename> 文件的开始部分定义所使用的 schema 和 "
"namespace:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:422
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<persistence\n"
"    xmlns=\"http://java.sun.com/xml/ns/persistence\"\n"
"    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"    xsi:schemaLocation=\"\n"
"      http://java.sun.com/xml/ns/persistence\n"
"      http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd\"\n"
"    version=\"2.0\">]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:426
#, no-c-format
msgid "Defining the Persistence Unit"
msgstr "定义持久化单元(Persistence Unit)"

#. Tag: para
#: chapter-jpacontainer.xml:428
#, no-c-format
msgid ""
"The root element of the persistence definition is persistence-unit. The name "
"of the persistence unit is needed for creating <classname>JPAContainer</"
"classname> instances from a <classname>JPAContainerFactory</classname>, as "
"described in <xref linkend=\"jpacontainer.usage.jpacontainerfactory\"/> or "
"when creating a JPA entity manager."
msgstr ""
"持久化定义的根元素是 persistence-unit. 为了通过 "
"<classname>JPAContainerFactory</classname> 创建 <classname>JPAContainer</"
"classname> 实例, 需要定义持久化单元的名称. 详情请参见 <xref linkend="
"\"jpacontainer.usage.jpacontainerfactory\"/>.  创建 JPA 实体管理器时, 也需要"
"持久化单元的名称."

#. Tag: programlisting
#: chapter-jpacontainer.xml:437
#, no-c-format
msgid "<?pocket-size 75% ?><![CDATA[<persistence-unit name=\"addressbook\">]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:440
#, no-c-format
msgid ""
"Persistence provider is the JPA provider implementation used. For example, "
"the JPAContainer AddressBook demo uses the EclipseLink JPA, which is defined "
"as follows:"
msgstr ""
"持久化提供者(Persistence provider) 是指所使用的 JPA 提供者实现类. 比如, "
"JPAContainer AddressBook 示例程序使用 EclipseLink JPA, 定义如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:446
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<provider>\n"
"    org.eclipse.persistence.jpa.PersistenceProvider\n"
"</provider>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:449
#, no-c-format
msgid ""
"The persistent classes need to be listed with a <literal>&lt;class&gt;</"
"literal> element. Alternatively, you can allow including unlisted classes "
"for persistence by overriding the <literal>exclude-unlisted-classes</"
"literal> default as follows:"
msgstr ""
"持久化类需要使用 <literal>&lt;class&gt;</literal> 元素列出. 或者, 你也可以在"
"持久化中允许包含未列出的类, 方法是覆盖 <literal>exclude-unlisted-classes</"
"literal> 的默认设定, 如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:456
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<exclude-unlisted-classes>false</exclude-"
"unlisted-classes>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:459
#, no-c-format
msgid ""
"JPA provider specific parameters are given under the <literal>properties</"
"literal> element."
msgstr "各 JPA 提供者专有的参数在 <literal>properties</literal> 元素中给出."

#. Tag: programlisting
#: chapter-jpacontainer.xml:464
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<properties>\n"
"   ...]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:466
#, no-c-format
msgid ""
"In the following section we give parameters for the EclipseLink JPA and H2 "
"database used in the JPAContainer AddressBook Demo. Please refer to the "
"documentation of the JPA provider you use for a complete reference of "
"parameters."
msgstr ""
"后续小节中我们将给出 JPAContainer AddressBook 示例程序所使用的 EclipseLink "
"JPA 和 H2 的相关参数. 关于完整的参数细节, 详情请参见你使用的 JPA 提供者的文"
"档."

#. Tag: title
#: chapter-jpacontainer.xml:475
#, no-c-format
msgid "Database Connection"
msgstr "数据库连接"

#. Tag: para
#: chapter-jpacontainer.xml:478
#, no-c-format
msgid ""
"EclipseLink allows using JDBC for database connection. For example, if we "
"use the the H2 database, we define its driver here as follows:"
msgstr ""
"EclipseLink 允许使用 JDBC 作为数据库连接. 比如, 如果我们使用 H2 数据库, 驱动"
"程序定义如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:483
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[<property name=\"eclipselink.jdbc.platform\"\n"
" value=\"org.eclipse.persistence.platform.database.H2Platform\"/>\n"
"<property name=\"eclipselink.jdbc.driver\"\n"
"          value=\"org.h2.Driver\" />]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:486
#, no-c-format
msgid ""
"Database connection is specified with a URL. For example, using an embedded "
"H2 database stored in the home directory it would be as follows:"
msgstr ""
"数据库连接以 URL 形式指定. 比如, 使用嵌入式 H2 数据库, 数据存储在 home 目录, "
"数据库连接 URL 定义如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:492
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.jdbc.url\"\n"
"          value=\"jdbc:h2:~/my-app-h2db\"/>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:494
#, no-c-format
msgid ""
"A hint: when using an embedded H2 database while developing a Vaadin "
"application in Eclipse, you may want to add <literal>;FILE_LOCK=NO</literal> "
"to the URL to avoid locking issues when redeploying."
msgstr ""
"提示: 在 Eclipse 中开发 Vaadin 应用程序时, 如果使用嵌入式 H2 数据库, 你可能会"
"希望在数据库连接 URL 中添加 <literal>;FILE_LOCK=NO</literal> 设定, 以避免在重"
"部署时发生文件锁定问题."

#. Tag: para
#: chapter-jpacontainer.xml:502
#, no-c-format
msgid "We can just use the default user name and password for the H2 database:"
msgstr "我们为 H2 数据库使用默认的用户名和密码:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:507
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.jdbc.user\" value="
"\"sa\"/>\n"
"<property name=\"eclipselink.jdbc.password\" value=\"sa\"/>]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:511
#, no-c-format
msgid "Logging Configuration"
msgstr "日志配置"

#. Tag: para
#: chapter-jpacontainer.xml:514
#, no-c-format
msgid ""
"JPA implementations as well as database engines like to produce logs and "
"they should be configured in the persistence configuration. For example, if "
"using EclipseLink JPA, you can get log that includes all SQL statements with "
"the <literal>FINE</literal> logging level:"
msgstr ""
"JPA 实现库, 以及数据库引擎都会输出日志, 日志也需要在持久化配置中进行设置. 比"
"如, 如果使用 EclipseLink JPA, 你可以使用 <literal>FINE</literal> 日志级别, 得"
"到包含所有 SQL 语句的日志:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:521
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.logging.level\" \n"
"          value=\"FINE\" />]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:525
#, no-c-format
msgid "Other Settings"
msgstr "其他设置"

#. Tag: para
#: chapter-jpacontainer.xml:527
#, no-c-format
msgid ""
"The rest is some Data Definition Language settings for EclipseLink. During "
"development, when we use generated example data, we want EclipseLink to drop "
"tables before trying to create them. In production environments, you should "
"use <literal>create-tables</literal>."
msgstr ""
"剩下的是 EclipseLink 的一些数据定义语言设置. 在开发过程中, 当我们使用自动产生"
"的示例数据时, 我们会希望 EclipseLink 在尝试创建数据库表之前, 首先删除已存在的"
"表. 但在生产环境中, 你应该使用 <literal>create-tables</literal>."

#. Tag: programlisting
#: chapter-jpacontainer.xml:535
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.ddl-generation\" \n"
"          value=\"drop-and-create-tables\" />]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:537
#, no-c-format
msgid ""
"And there is no need to generate SQL files, just execute them directly to "
"the database."
msgstr "而且, 不需要产生 SQL 文件, 只需要在数据库中直接执行它们."

#. Tag: programlisting
#: chapter-jpacontainer.xml:542
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<property name=\"eclipselink.ddl-generation."
"output-mode\"\n"
"          value=\"database\"/>\n"
"          </properties>\n"
" </persistence-unit>\n"
"</persistence>]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:547
#, no-c-format
msgid "Troubleshooting"
msgstr "故障诊断"

#. Tag: para
#: chapter-jpacontainer.xml:549
#, no-c-format
msgid ""
"Below are some typical errors that you might get when using JPA. These are "
"not specific to JPAContainer."
msgstr "下面是使用 JPA 时可能遇到的一些常见错误. 这些错误与 JPAContainer 无关."

#. Tag: term
#: chapter-jpacontainer.xml:556
#, no-c-format
msgid ""
"<classname>javax.persistence.PersistenceException</classname>: No "
"Persistence provider for EntityManager"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:558
#, no-c-format
msgid ""
"The most typical cases for this error are that the persistence unit name is "
"wrong in the source code or in the <filename>persistence.xml</filename> "
"file, or that the <filename>persistence.xml</filename> is at a wrong place "
"or has some other problem. Make sure that the persistence unit name matches "
"and the <filename>persistence.xml</filename> is in <filename>WEB-INF/classes/"
"META-INF</filename> folder in the deployment."
msgstr ""
"这个错误最常见的原因是, 源代码中或 <filename>persistence.xml</filename> 配置"
"文件中的持久化单元名称不正确,  或者 <filename>persistence.xml</filename> 所在"
"的位置不正确, 或者发生了其他问题. 请确认持久化单元名称是一致的, 并确认 "
"<filename>persistence.xml</filename> 在发布后的环境中的 <filename>WEB-INF/"
"classes/META-INF</filename> 文件夹下."

#. Tag: term
#: chapter-jpacontainer.xml:571
#, no-c-format
msgid ""
"<classname>java.lang.IllegalArgumentException</classname>: The class is not "
"an entity"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:573
#, no-c-format
msgid ""
"The class is missing from the set of persistent entities. If the "
"<filename>persistence.xml</filename> does not have <parameter>exclude-"
"unlisted-classes</parameter> defined as <literal>false</literal>, the "
"persistent entity classes should be listed with <literal>&lt;class&gt;</"
"literal> elements."
msgstr ""
"持久化实体集合中缺少这个类. 如果 <filename>persistence.xml</filename> 配置文"
"件中 <parameter>exclude-unlisted-classes</parameter> 没有定义为 "
"<literal>false</literal>, 那么持久化类必须使用 <literal>&lt;class&gt;</"
"literal> 元素列出."

#. Tag: title
#: chapter-jpacontainer.xml:587
#, no-c-format
msgid "Defining a Domain Model"
msgstr "定义业务数据模型(Domain Model)"

#. Tag: para
#: chapter-jpacontainer.xml:589
#, no-c-format
msgid ""
"Developing a persistent application begins with defining a domain model. A "
"domain model consists of a number of entities (classes) and relationships "
"between them."
msgstr ""
"开发一个持久化应用程序的首先需要定义业务数据模型(domain model). 业务数据模型"
"包括多个实体(类), 以及这些实体之间的关系."

#. Tag: para
#: chapter-jpacontainer.xml:595
#, no-c-format
msgid ""
"illustrates a simple domain model as a UML class diagram. It has two "
"entities: <classname>Country</classname> and <classname>Person</classname>. "
"They have a \"country has persons\" relationship. This is a <emphasis>one-to-"
"many relationship</emphasis> with one country having many persons, each of "
"which belongs to just one country."
msgstr ""
"以 URL 类图的形式展示了一个简单的业务数据模型. 其中有两个实体: "
"<classname>Country</classname> 和 <classname>Person</classname>. 它们之间存在"
"一种关系: \"国家拥有人\". 这是一个 <emphasis>一对多关系</emphasis>, 一个国家"
"中存在多个人, 每个人都只属于一个国家."

#. Tag: title
#: chapter-jpacontainer.xml:605
#, no-c-format
msgid "A Domain Model"
msgstr "一个业务数据模型"

#. Tag: para
#: chapter-jpacontainer.xml:617
#, no-c-format
msgid "Realized in Java, the classes are as follows:"
msgstr "使用 Java 来实现, 类的代码如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:621
#, no-c-format
msgid ""
"<![CDATA[public class Country {\n"
"    private Long   id;\n"
"    private String name;\n"
"    private Set<Person> persons;\n"
"\n"
"    ... setters and getters ...\n"
"}\n"
"\n"
"public class Person {\n"
"    private Long    id;\n"
"    private String  name;\n"
"    private Integer age;\n"
"    private Country country;\n"
"\n"
"    ... setters and getters ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:623
#, no-c-format
msgid ""
"You should make the classes proper beans by defining a default constructor "
"and implementing the <interfacename>Serializable</interfacename> interface. "
"A default constructor is required by the JPA entity manager for "
"instantiating entities. Having the classes serializable is not required but "
"often useful for other reasons."
msgstr ""
"你应该将实体类设计为正确的 Java Bean, 为它定义默认的构造函数, 并实现 "
"<interfacename>Serializable</interfacename> 接口. JPA 实体管理器创建实体类的"
"实例时需要默认构造函数. 让实体类可序列化不是必需的要求, 但由于其他一些原因, "
"常常是有用的."

#. Tag: para
#: chapter-jpacontainer.xml:631
#, no-c-format
msgid ""
"After you have a basic domain model, you need to define the entity "
"relationship metadata by annotating the classes."
msgstr "有了基本的业务数据模型后, 你需要对类使用注解来定义实体关系元数据."

#. Tag: title
#: chapter-jpacontainer.xml:637
#, no-c-format
msgid "Persistence Metadata"
msgstr "持久化元数据"

#. Tag: para
#: chapter-jpacontainer.xml:639
#, no-c-format
msgid ""
"The entity relationships are defined with metadata. The metadata can be "
"defined in an XML metadata file or with Java annotations defined in the "
"<package>javax.persistence</package> package. With Vaadin JPAContainer, you "
"need to provide the metadata as annotations."
msgstr ""
"实体之间的关系通过元数据来定义. 元数据可以定义在 XML 元数据文件中, 也可以使"
"用 <package>javax.persistence</package> 包中的 Java 注解来定义. 使用 Vaadin "
"JPAContainer 时, 你需要以注解的方式定义元数据."

#. Tag: para
#: chapter-jpacontainer.xml:646
#, no-c-format
msgid ""
"For example, if we look at the Person class in the JPAContainer AddressBook "
"Demo, we define various database-related metadata for the member variables "
"of a class:"
msgstr ""
"比如, 看看 JPAContainer AddressBook 示例程序中的 Person 类, 我们对类中成员变"
"量定义了与数据库相关的元数据, 如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:652
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[@Entity\n"
"public class Person {\n"
"    @Id\n"
"    @GeneratedValue(strategy = GenerationType.AUTO)\n"
"    private Long    id;\n"
"\n"
"    private String  name;\n"
"    private Integer age;\n"
"\n"
"    @ManyToOne\n"
"    private Country country;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:654
#, no-c-format
msgid ""
"The JPA implementation uses reflection to read the annotations and defines a "
"database model automatically from the class definitions."
msgstr "JPA 实现库使用反射来读取注解, 并根据类的定义自动地定义数据库模型."

#. Tag: para
#: chapter-jpacontainer.xml:659
#, no-c-format
msgid ""
"Let us look at some of the basic JPA metadata annotations. The annotations "
"are defined in the <package>javax.persistence</package> package. Please "
"refer to JPA reference documentation for the complete list of possible "
"annotations."
msgstr ""
"下面我们来看看一些基本的 JPA 元数据注解. 这些注解定义在 <package>javax."
"persistence</package> 包中. 关于所有可用注解的完整列表, 请参见 JPA 文档."

#. Tag: title
#: chapter-jpacontainer.xml:667
#, no-c-format
msgid "Annotation: <literal>@Entity</literal>"
msgstr "注解: <literal>@Entity</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:669
#, no-c-format
msgid ""
"Each class that is enabled as a persistent entity must have the "
"<literal>@Entity</literal> annotation."
msgstr "每个可作为持久化实体的类, 都必须带有 <literal>@Entity</literal> 注解."

#. Tag: programlisting
#: chapter-jpacontainer.xml:674
#, no-c-format
msgid ""
"<![CDATA[@Entity\n"
"public class Country {]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:678
#, no-c-format
msgid "Annotation: <literal>@Id</literal>"
msgstr "注解: <literal>@Id</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:680
#, no-c-format
msgid ""
"Entities must have an identifier that is used as the primary key for the "
"table. It is used for various purposes in database queries, most commonly "
"for joining tables."
msgstr ""
"实体必须有一个标识符(identifier), 标识符将被用作数据库表中的主键(primary "
"key). 标识符在数据库查询中被用作多种用途, 最常见的是用来做表之间的结合."

#. Tag: programlisting
#: chapter-jpacontainer.xml:686
#, no-c-format
msgid ""
"<![CDATA[@Id\n"
"@GeneratedValue(strategy = GenerationType.AUTO)\n"
"private Long id;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:688
#, no-c-format
msgid ""
"The identifier is generated automatically in the database. The strategy for "
"generating the identifier is defined with the <literal>@GeneratedValue</"
"literal> annotation. Any generation type should work."
msgstr ""
"标识符的值会在数据库中自动生成. 标识符的生成策略通过 "
"<literal>@GeneratedValue</literal> 注解来定义. 使用任何一种生成策略都可以."

#. Tag: title
#: chapter-jpacontainer.xml:697
#, no-c-format
msgid "Annotation: <literal>@OneToOne</literal>"
msgstr "注解: <literal>@OneToOne</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:699
#, no-c-format
msgid ""
"The <literal>@OneToOne</literal> annotation describes a one-to-one "
"relationship where each entity of one type is associated with exactly one "
"entity of another type. For example, the postal address of a person could be "
"given as such."
msgstr ""
"<literal>@OneToOne</literal> 注解描述一个一对一关系, 某个类型的一个实体关联到"
"另一个类型的一个(并且只有一个)实体. 比如, 一个人的邮政地址与一个人就可以通过"
"一对一关系来描述."

#. Tag: programlisting
#: chapter-jpacontainer.xml:706
#, no-c-format
msgid ""
"<![CDATA[@OneToOne\n"
"private Address address;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:708
#, no-c-format
msgid ""
"When using the JPAContainer <classname>FieldFactory</classname> to "
"automatically create fields for a form, the <literal>@OneToOne</literal> "
"relationship generates a nested <classname>Form</classname> to edit the "
"data. See <xref linkend=\"jpacontainer.fieldfactory\"/> for more details."
msgstr ""
"使用 JPAContainer 的 <classname>FieldFactory</classname> 来为 Form 自动创建 "
"Field 时, <literal>@OneToOne</literal> 关系会生成一个嵌套的 <classname>Form</"
"classname> 来编辑数据. 详情请参见 <xref linkend=\"jpacontainer.fieldfactory"
"\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:718
#, no-c-format
msgid "Annotation: <literal>@Embedded</literal>"
msgstr "注解: <literal>@Embedded</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:720
#, no-c-format
msgid ""
"Just as with the <literal>@OneToOne</literal> annotation, "
"<literal>@Embedded</literal> describes a one-to-one relationship, but says "
"that the referenced entity should be stored as columns in the same table as "
"the referencing entity."
msgstr ""
"与 <literal>@OneToOne</literal> 注解类似, <literal>@Embedded</literal> 也描述"
"一对一关系, 但被引用的实体不是单独的数据库表, 而是存在于引用它的实体的同一个"
"表的列中."

#. Tag: programlisting
#: chapter-jpacontainer.xml:727
#, no-c-format
msgid ""
"<![CDATA[@Embedded\n"
"private Address address;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:729
#, no-c-format
msgid ""
"The referenced entity class must have <literal>@Embeddable</literal> "
"annotation."
msgstr "被引用的类必须带有 <literal>@Embeddable</literal> 注解."

#. Tag: para
#: chapter-jpacontainer.xml:734
#, no-c-format
msgid ""
"The JPAContainer <classname>FieldFactory</classname> generates a nested "
"<classname>Form</classname> for <literal>@Embedded</literal>, just as with "
"<literal>@OneToOne</literal>."
msgstr ""
"与 <literal>@OneToOne</literal> 一样, JPAContainer 的 "
"<classname>FieldFactory</classname> 会为 <literal>@Embedded</literal> 生成一"
"个嵌套的 <classname>Form</classname>."

#. Tag: title
#: chapter-jpacontainer.xml:742
#, no-c-format
msgid "Annotation: <literal>@OneToMany</literal>"
msgstr "注解: <literal>@OneToMany</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:744
#, no-c-format
msgid ""
"The <classname>Country</classname> entity in the domain model has a "
"<emphasis>one-to-many</emphasis> relationship with the <classname>Person</"
"classname> entity (\"country has persons\"). This relationship is "
"represented with the <literal>@OneToMany</literal> annotation. The "
"<parameter>mappedBy</parameter> parameter names the corresponding back-"
"reference in the <classname>Person</classname> entity."
msgstr ""
"业务数据模型中的 <classname>Country</classname> 实体中存在一个 <emphasis>one-"
"to-many</emphasis> 关系, 指向 <classname>Person</classname> 实体 (也就是说 "
"\"国家拥有人\"). 这个关系通过 <literal>@OneToMany</literal> 注解来表达. "
"<parameter>mappedBy</parameter> 参数指定在 <classname>Person</classname> 实体"
"中反向参照到<classname>Country</classname> 实体的属性名."

#. Tag: programlisting
#: chapter-jpacontainer.xml:754
#, no-c-format
msgid ""
"<![CDATA[@OneToMany(mappedBy = \"country\")\n"
"private Set<Person> persons;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:756
#, no-c-format
msgid ""
"When using the JPAContainer <classname>FieldFactory</classname> to "
"automatically create fields for a form, the <literal>@OneToMany</literal> "
"relationship generates a <classname>MasterDetailEditor</classname> for "
"editing the items. See <xref linkend=\"jpacontainer.fieldfactory\"/> for "
"more details."
msgstr ""
"当使用 JPAContainer 的 <classname>FieldFactory</classname> 来为 Form 自动创"
"建 Field 时, <literal>@OneToMany</literal> 关系会产生一个 "
"<classname>MasterDetailEditor</classname> 来编辑数据元素. 详情请参见 <xref "
"linkend=\"jpacontainer.fieldfactory\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:766
#, no-c-format
msgid "Annotation: <literal>@ElementCollection</literal>"
msgstr "注解: <literal>@ElementCollection</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:768
#, no-c-format
msgid ""
"The <literal>@ElementCollection</literal> annotation can be used for one-to-"
"many relationships to a collection of basic values such as "
"<classname>String</classname> or <classname>Integer</classname>, or to "
"entities annotated as <literal>@Embeddable</literal>. The referenced "
"entities are stored in a separate table defined with a "
"<literal>@CollectionTable</literal> annotation."
msgstr ""
"<literal>@ElementCollection</literal> 注解也可以用来定义一对多关系, 区别是 "
"collection 中的元素是基本数据类型, 比如 <classname>String</classname> 或 "
"<classname>Integer</classname>, 或者是带有 <literal>@Embeddable</literal> 注"
"解的实体类. 被引用的实体类存储在一个独立的数据库表中, 表名通过 "
"<literal>@CollectionTable</literal> 注解来定义."

#. Tag: programlisting
#: chapter-jpacontainer.xml:777
#, no-c-format
msgid ""
"<![CDATA[@ElementCollection\n"
"@CollectionTable(\n"
"    name=\"OLDPEOPLE\",\n"
"    joinColumns=@JoinColumn(name=\"COUNTRY_ID\"))\n"
"private Set<Person> persons;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:779
#, no-c-format
msgid ""
"JPAContainer <classname>FieldFactory</classname> generates a "
"<classname>MasterDetailEditor</classname> for the "
"<literal>@ElementCollection</literal> relationship, just as with "
"<literal>@OneToMany</literal>."
msgstr ""
"与 <literal>@OneToMany</literal> 一样, JPAContainer 的 "
"<classname>FieldFactory</classname> 会为 <literal>@ElementCollection</"
"literal> 关系生成 <classname>MasterDetailEditor</classname>."

#. Tag: title
#: chapter-jpacontainer.xml:788
#, no-c-format
msgid "Annotation: <literal>@ManyToOne</literal>"
msgstr "注解: <literal>@ManyToOne</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:790
#, no-c-format
msgid ""
"Many people can live in the same country. This would be represented with the "
"<literal>@ManyToOne</literal> annotation in the <classname>Person</"
"classname> class."
msgstr ""
"很多人可以居住在同一个国家. 这个关系应该在 <classname>Person</classname> 类中"
"使用 <literal>@ManyToOne</literal> 注解来表达."

#. Tag: programlisting
#: chapter-jpacontainer.xml:796
#, no-c-format
msgid ""
"<![CDATA[@ManyToOne\n"
"private Country country;]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:798
#, no-c-format
msgid ""
"JPAContainer <classname>FieldFactory</classname> generates a "
"<classname>NativeSelect</classname> for selecting an item from the "
"collection. You can do so yourself as well in a custom field factory. Doing "
"so you need to pay notice not to confuse the container between the "
"referenced entity and its ID, which could even result in insertion of false "
"entities in the database in some cases. You can handle conversion between an "
"entity and the entity ID using the <classname>SingleSelectConverter</"
"classname> as follows:"
msgstr ""
"JPAContainer 的 <classname>FieldFactory</classname> 会生成一个 "
"<classname>NativeSelect</classname>, 用来从列表中选择一个项目. 你也可以在自定"
"义的 Field 工厂中自行实现同样的功能. 这时你需要注意, 不要混淆了被引用的实体和"
"它的 ID, 否则某些情况下甚至可能会导致向数据库插入错误的值. 你可以使用 "
"<classname>SingleSelectConverter</classname> 在实体和实体 ID 之间进行转换, 如"
"下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:809
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[\n"
"@Override\n"
"public <T extends Field> T createField(Class<?> dataType,\n"
"                                       Class<T> fieldType) {\n"
"    if (dataType == Country.class) {\n"
"       JPAContainer<Country> countries =\n"
"           JPAContainerFactory.make(Country.class, \"mypunit\");\n"
"       ComboBox cb = new ComboBox(null, countries);\n"
"       cb.setConverter(new SingleSelectConverter<Country>(cb));\n"
"       return (T) cb;\n"
"    }\n"
"    return super.createField(dataType, fieldType);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:811
#, no-c-format
msgid ""
"The JPAContainer <classname>FieldFactory</classname> uses the translator "
"internally, so using it also avoids the problem."
msgstr ""
"JPAContainer 的 <classname>FieldFactory</classname> 内部会使用这个转换器, 因"
"此建议你也使用它来避免上面提到的问题."

#. Tag: title
#: chapter-jpacontainer.xml:818
#, no-c-format
msgid "Annotation: <literal>@Transient</literal>"
msgstr "注解: <literal>@Transient</literal>"

#. Tag: para
#: chapter-jpacontainer.xml:820
#, no-c-format
msgid ""
"JPA assumes that all entity properties are persisted. Properties that should "
"not be persisted should be marked as transient with the <literal>@Transient</"
"literal> annotation."
msgstr ""
"JPA 假定实体中所有的属性都需要持久化. 不需要持久化的属性应该使用 "
"<literal>@Transient</literal> 注解, 标记为暂态属性."

#. Tag: programlisting
#: chapter-jpacontainer.xml:826
#, no-c-format
msgid ""
"<![CDATA[@Transient\n"
"private Boolean superDepartment;\n"
"...\n"
"@Transient\n"
"public String getHierarchicalName() {\n"
"...]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:832
#, no-c-format
msgid "Basic Use of JPAContainer"
msgstr "JPAContainer 的基本使用"

#. Tag: para
#: chapter-jpacontainer.xml:834
#, no-c-format
msgid ""
"Vaadin JPAContainer offers a highly flexible API that makes things easy in "
"simple cases while allowing extensive flexibility in demanding cases. To "
"begin with, it is a <classname>Container</classname>, as described in <xref "
"linkend=\"datamodel.container\"/>."
msgstr ""
"Vaadin JPAContainer 提供了一组高度灵活的 API, 对于简单的问题可以非常容易地实"
"现, 对于复杂的需求也提供了高度的灵活性. 首先, 它是一种 <classname>Container</"
"classname>, 关于容器, 详情请参见 <xref linkend=\"datamodel.container\"/>."

#. Tag: para
#: chapter-jpacontainer.xml:841
#, no-c-format
msgid ""
"In this section, we look how to create and use <classname>JPAContainer</"
"classname> instances. We assume that you have defined a domain model with "
"JPA annotations, as described in the previous section."
msgstr ""
"在这一节中, 我们来看看如何创建和使用 <classname>JPAContainer</classname> 实"
"例. 我们假定你象前一节中介绍的那样, 已经使用 JPA 注解定义了业务数据模型."

#. Tag: title
#: chapter-jpacontainer.xml:848
#, no-c-format
msgid ""
"Creating <classname>JPAContainer</classname> with "
"<classname>JPAContainerFactory</classname>"
msgstr ""
"使用 <classname>JPAContainerFactory</classname> 创建 "
"<classname>JPAContainer</classname>"

#. Tag: para
#: chapter-jpacontainer.xml:850
#, no-c-format
msgid ""
"The <classname>JPAContainerFactory</classname> is the easy way to create "
"<classname>JPAContainer</classname>s. It provides a set of <emphasis>make..."
"()</emphasis> factory methods for most cases that you will likely meet. Each "
"factory method uses a different type of entity provider, which are described "
"in <xref linkend=\"jpacontainer.entityprovider\"/>."
msgstr ""
"<classname>JPAContainerFactory</classname> 是用来创建 "
"<classname>JPAContainer</classname> 的简便方法. 它针对你通常会遇到的大多数情"
"况, 提供了一组 <emphasis>make...()</emphasis> 工厂方法. 每个工厂方法使用一种"
"不同类型的 Entity Provider, 关于 Entity Provider, 详情请参见 <xref linkend="
"\"jpacontainer.entityprovider\"/>."

#. Tag: para
#: chapter-jpacontainer.xml:859
#, no-c-format
msgid ""
"The factory methods take the class type of the entity class as the first "
"parameter. The second parameter is either a persistence unit name "
"(persistence context) or an <classname>EntityManager</classname> instance."
msgstr ""
"工厂方法的第一个参数是实体类的类型. 第二个参数是持久化单元的名称(持久化环境上"
"下文 persistence context), 或者一个 <classname>EntityManager</classname> 实"
"例."

#. Tag: programlisting
#: chapter-jpacontainer.xml:866
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a persistent person container\n"
"JPAContainer<Person> persons =\n"
"    JPAContainerFactory.make(Person.class, \"book-examples\");\n"
"\n"
"// You can add entities to the container as well\n"
"persons.addEntity(new Person(\"Marie-Louise Meilleur\", 117));\n"
"\n"
"// Set up sorting if the natural order is not appropriate\n"
"persons.sort(new String[]{\"age\", \"name\"},\n"
"             new boolean[]{false, false});\n"
"\n"
"// Bind it to a component\n"
"Table personTable = new Table(\"The Persistent People\", persons);\n"
"personTable.setVisibleColumns(new String[]{\"id\",\"name\",\"age\"});\n"
"layout.addComponent(personTable);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:868
#, no-c-format
msgid ""
"It's that easy. In fact, if you run the above code multiple times, you'll be "
"annoyed by getting a new set of persons for each run - that's how persistent "
"the container is. The basic <methodname>make()</methodname> uses a "
"<classname>CachedMutableLocalEntityProvider</classname>, which allows "
"modifying the container and its entities, as we do above by adding new "
"entities."
msgstr ""
"就这么简单. 实际上, 如果你将上面的代码运行几次, 你就会厌烦了, 因为每次运行都"
"会得到一个新的 Person 集合 - 这就是持久化容器的运行方式. 基本的 "
"<methodname>make()</methodname> 方法使用的 Entity Provider 是 "
"<classname>CachedMutableLocalEntityProvider</classname>, 它允许修改容器及其中"
"的实体, 我们在上例中向容器添加了新的实体."

#. Tag: para
#: chapter-jpacontainer.xml:877
#, no-c-format
msgid ""
"When using just the persistence unit name, the factory creates an instance "
"of <classname>EntityManagerFactory</classname> for the persistence unit and "
"uses it to build entity managers. You can also create the entity managers "
"yourself, as described later."
msgstr ""
"如果只使用持久化单元名称, 工厂类为持久化单元会创建 "
"<classname>EntityManagerFactory</classname> 的实例, 并使用它来构建实体管理"
"器. 你也可以自行创建实体管理器, 详情将在后文中介绍."

#. Tag: para
#: chapter-jpacontainer.xml:885
#, no-c-format
msgid ""
"The entity providers associated with the different factory methods are as "
"follows:"
msgstr "各个工厂方法分别对应如下各种 Entity Provider :"

#. Tag: title
#: chapter-jpacontainer.xml:891
#, no-c-format
msgid "<classname>JPAContainerFactory</classname> Methods"
msgstr "<classname>JPAContainerFactory</classname> 的方法"

#. Tag: methodname
#: chapter-jpacontainer.xml:895
#, no-c-format
msgid "make()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:896 chapter-jpacontainer.xml:1304
#, no-c-format
msgid "CachingMutableLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:899
#, no-c-format
msgid "makeReadOnly()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:900 chapter-jpacontainer.xml:1283
#, no-c-format
msgid "CachingLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:903
#, no-c-format
msgid "makeBatchable()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:904 chapter-jpacontainer.xml:1270
#, no-c-format
msgid "BatchableLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:907
#, no-c-format
msgid "makeNonCached()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:908 chapter-jpacontainer.xml:1248
#, no-c-format
msgid "MutableLocalEntityProvider"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:911
#, no-c-format
msgid "makeNonCachedReadOnly()"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:912 chapter-jpacontainer.xml:1233
#, no-c-format
msgid "LocalEntityProvider"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:918
#, no-c-format
msgid ""
"<classname>JPAContainerFactory</classname> holds a cache of entity manager "
"factories for the different persistence units, making sure that any entity "
"manager factory is created only once, as it is a heavy operation. You can "
"access the cache to get a new entity manager with the "
"<methodname>createEntityManagerForPersistenceUnit()</methodname> method."
msgstr ""
"<classname>JPAContainerFactory</classname> 内部针对不同的持久化单元保持一个实"
"体管理器工厂的缓存, 以便确保每个实体管理器工厂只创建一次, 因为实体管理器工厂"
"的创建是一个很笨重的工作. 你可以通过 "
"<methodname>createEntityManagerForPersistenceUnit()</methodname> 方法来访问这"
"个缓存, 得到新的实体管理器."

#. Tag: programlisting
#: chapter-jpacontainer.xml:927
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Get an entity manager\n"
"EntityManager em = JPAContainerFactory.\n"
"    createEntityManagerForPersistenceUnit(\"book-examples\");\n"
"\n"
"// Do a query\n"
"em.getTransaction().begin();\n"
"em.createQuery(\"DELETE FROM Person p\").executeUpdate();\n"
"em.persist(new Person(\"Jeanne Calment\", 122));\n"
"em.persist(new Person(\"Sarah Knauss\", 119));\n"
"em.persist(new Person(\"Lucy Hannah\", 117));\n"
"em.getTransaction().commit();\n"
"\n"
"...]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:929
#, no-c-format
msgid ""
"Notice that if you use update the persistent data with an entity manager "
"outside a <classname>JPAContainer</classname> bound to the data, you need to "
"refresh the container as described in <xref linkend=\"jpacontainer.usage."
"entitites\"/>."
msgstr ""
"注意, 如果你在与数据绑定的 <classname>JPAContainer</classname> 之外, 使用实体"
"管理器来更新持久化数据, 你需要刷新容器, 详情请参见 <xref linkend="
"\"jpacontainer.usage.entitites\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:937
#, no-c-format
msgid "Creating <classname>JPAContainer</classname> Manually"
msgstr "手动创建 <classname>JPAContainer</classname>"

#. Tag: para
#: chapter-jpacontainer.xml:939
#, no-c-format
msgid ""
"While it is normally easiest to use a <classname>JPAContainerFactory</"
"classname> to create <classname>JPAContainer</classname> instances, you may "
"need to create them manually. It is necessary, for example, when you need to "
"use a custom entity provider or extend <classname>JPAContainer</classname>."
msgstr ""
"通常最简单的方法是使用 <classname>JPAContainerFactory</classname> 来创建 "
"<classname>JPAContainer</classname> 实例, 但你也有可能会需要手动创建 "
"<classname>JPAContainer</classname>. 比如, 当你需要使用自定义的 Entity "
"Provider 时, 或者需要扩展 <classname>JPAContainer</classname> 时, 手动创建就"
"是必须的."

#. Tag: para
#: chapter-jpacontainer.xml:947
#, no-c-format
msgid ""
"First, we need to create an entity manager and then the entity provider, "
"which we bind to a <classname>JPAContainer</classname>."
msgstr ""
"首先, 我们需要创建一个实体管理器. 然后创建 Entity Provider, 然后将 Entity "
"Provider 绑定到一个 <classname>JPAContainer</classname> 上."

#. Tag: programlisting
#: chapter-jpacontainer.xml:953
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// We need a factory to create entity manager\n"
"EntityManagerFactory emf =\n"
"    Persistence.createEntityManagerFactory(\"book-examples\");\n"
"\n"
"// We need an entity manager to create entity provider\n"
"EntityManager em = emf.createEntityManager();\n"
"\n"
"// We need an entity provider to create a container        \n"
"CachingMutableLocalEntityProvider<Person> entityProvider =\n"
"    new CachingMutableLocalEntityProvider<Person>(Person.class,\n"
"                                                  em);\n"
"\n"
"// And there we have it\n"
"JPAContainer<Person> persons =\n"
"        new JPAContainer<Person> (Person.class);\n"
"persons.setEntityProvider(entityProvider);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:955
#, no-c-format
msgid ""
"You could save the first step by asking the entity manager from the "
"<classname>JPAContainerFactory</classname>."
msgstr ""
"如果通过 <classname>JPAContainerFactory</classname> 获取实体管理器, 那么上例"
"中的第一步可以省去."

#. Tag: title
#: chapter-jpacontainer.xml:963
#, no-c-format
msgid "Creating and Accessing Entities"
msgstr "创建和访问实体"

#. Tag: para
#: chapter-jpacontainer.xml:965
#, no-c-format
msgid ""
"JPAContainer integrates with the JPA entity manager, which you would "
"normally use to create and access entities with JPA. You can use the entity "
"manager for any purposes you may have, and then <classname>JPAContainer</"
"classname> to bind entities to user interface components such as "
"<classname>Table</classname>, <classname>Tree</classname>, any selection "
"components, or a <classname>Form</classname>."
msgstr ""
"JPAContainer 与 JPA 实体管理器集成在一起, 实体管理器通常用来通过 JPA 创建和访"
"问实体. 也可以将实体管理器用于你需要的其他用途. <classname>JPAContainer</"
"classname> 用来将实体与 UI 组件绑定在一起, 比如 <classname>Table</"
"classname>, <classname>Tree</classname>, 选择组件, 或者 <classname>Form</"
"classname>."

#. Tag: para
#: chapter-jpacontainer.xml:975
#, no-c-format
msgid ""
"You can add new entities to a <classname>JPAContainer</classname> with the "
"<methodname>addEntity()</methodname> method. It returns the item ID of the "
"new entity."
msgstr ""
"你可以使用 <methodname>addEntity()</methodname> 方法来向 "
"<classname>JPAContainer</classname> 添加新的实体. 这个方法将返回新实体的 "
"Item ID."

#. Tag: programlisting
#: chapter-jpacontainer.xml:981
#, no-c-format
msgid ""
"<![CDATA[Country france = new Country(\"France\");\n"
"Object itemId = countries.addEntity(france);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:983
#, no-c-format
msgid ""
"The item ID used by <classname>JPAContainer</classname> is the value of the "
"ID property (column) defined with the <literal>@Id</literal> annotation. In "
"our <classname>Country</classname> entity, it would have <classname>Long</"
"classname> type. It is generated by the entity manager when the entity is "
"persisted and set with the setter for the ID proeprty."
msgstr ""
"<classname>JPAContainer</classname> 使用的 Item ID 是由 <literal>@Id</"
"literal> 注解定义的 ID 属性(列) 的值. 在我们的 <classname>Country</"
"classname> 实体中, 它的类型是 <classname>Long</classname>. 当实体被持久化时, "
"ID 的值会由实体管理器生成, 然后通过 set 方法设置给 ID 属性."

#. Tag: para
#: chapter-jpacontainer.xml:991
#, no-c-format
msgid ""
"Notice that the <methodname>addEntity()</methodname> method does "
"<emphasis>not</emphasis> attach the entity instance given as the parameter. "
"Instead, it creates a new instance. If you need to use the entity for some "
"purpose, you need to get the actual managed entity from the container. You "
"can get it with the item ID returned by <methodname>addEntity()</methodname>."
msgstr ""
"注意, <methodname>addEntity()</methodname> 方法 <emphasis>不会</emphasis> 关"
"联参数中给定的那个实体实例. 它会创建新的实例. 如果你需要使用实体, 你需要从容"
"器中取得实际被它管理的实体. 你可以通过得到 <methodname>addEntity()</"
"methodname> 方法返回的 Item ID 得到对应的实体."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1000
#, no-c-format
msgid ""
"<![CDATA[// Create a new entity and add it to a container\n"
"Country france = new Country(\"France\");\n"
"Object itemId = countries.addEntity(france);\n"
"\n"
"// Get the managed entity\n"
"france = countries.getItem(itemId).getEntity();\n"
"\n"
"// Use the managed entity in entity references\n"
"persons.addEntity(new Person(\"Jeanne Calment\", 122, france));]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1003
#, no-c-format
msgid "Entity Items"
msgstr "实体的 Item"

#. Tag: para
#: chapter-jpacontainer.xml:1005
#, no-c-format
msgid ""
"The <methodname>getItem()</methodname> method is defined in the normal "
"Vaadin <interfacename>Container</interfacename> interface. It returns an "
"<classname>EntityItem</classname>, which is a wrapper over the actual entity "
"object. You can get the entity object with <methodname>getEntity()</"
"methodname>."
msgstr ""
"在通常的 Vaadin <interfacename>Container</interfacename> 接口中定义了 "
"<methodname>getItem()</methodname> 方法. 在 <classname>JPAContainer</"
"classname> 中, 这个方法会返回一个 <classname>EntityItem</classname>, 这个对象"
"内封装了一个实际的实体对象. 你可以通过 <methodname>getEntity()</methodname> "
"方法得到实体对象."

#. Tag: para
#: chapter-jpacontainer.xml:1013
#, no-c-format
msgid ""
"An <classname>EntityItem</classname> can have a number of states: "
"persistent, modified, dirty, and deleted. The dirty and deleted states are "
"meaningful when using <emphasis>container buffering</emphasis>, while the "
"modified state is meaningful when using <emphasis>item buffering</emphasis>. "
"Both levels of buffering can be used together - user input is first written "
"to the item buffer, then to the entity instance, and finally to the database."
msgstr ""
"<classname>EntityItem</classname> 可以有一系列状态: 已持久化(persistent), 已"
"修改(modified), 脏(dirty), 以及已删除(deleted). 脏状态和已删除状态只有在"
"<emphasis>容器级缓存</emphasis> 功能时才是有意义的, 已修改状态只有在"
"<emphasis>元素级缓存</emphasis> 功能时才是有意义的. 这两个缓存级别可以同时使"
"用 - 用户输入首先写入到元素的缓存中, 然后再写入到实体实例中, 最后才写入到数据"
"库中."

#. Tag: para
#: chapter-jpacontainer.xml:1023
#, no-c-format
msgid ""
"The <methodname>isPersistent()</methodname> method tells if the item is "
"actually persistent, that is, fetched from a persistent storage, or if it is "
"just a transient entity created and buffered by the container."
msgstr ""
"<methodname>isPersistent()</methodname> 方法检测 Item 是否已被持久化, 也就是"
"说, 是否是从持久化存储中取得的, 或者仅仅是一个由容器创建并缓冲的暂态实体"
"(transient entity)."

#. Tag: para
#: chapter-jpacontainer.xml:1029
#, no-c-format
msgid ""
"The <methodname>isModified()</methodname> method checks whether the "
"<classname>EntityItem</classname> has changes that are not yet committed to "
"the entity instance. It is only relevant if the item buffering is enabled "
"with <methodname>setBuffered(true)</methodname> for the item."
msgstr ""
"<methodname>isModified()</methodname> 方法检查 <classname>EntityItem</"
"classname> 中是否存在还未提交到实体实例中去的修改. 只有通过 "
"<methodname>setBuffered(true)</methodname> 方法对 Item 启动缓存功能后, 这个功"
"能才有效."

#. Tag: para
#: chapter-jpacontainer.xml:1037
#, no-c-format
msgid ""
"The <methodname>isDirty()</methodname> method checks whether the entity "
"object has been modified after it was fetched from the entity provider. The "
"dirty state is possible only when buffering is enabled for the container."
msgstr ""
"<methodname>isDirty()</methodname> 方法检查实体对象从 Entity Provider 中取得"
"之后, 是否被修改过. 只有在容器的缓冲功能启用后, 脏状态才有可能发生."

#. Tag: para
#: chapter-jpacontainer.xml:1044
#, no-c-format
msgid ""
"The <methodname>isDeleted()</methodname> method checks whether the item has "
"been marked for deletion with <methodname>removeItem()</methodname> in a "
"buffered container."
msgstr ""
"<methodname>isDeleted()</methodname> 方法检查在一个有缓冲功能的容器中, Item "
"是否被 <methodname>removeItem()</methodname> 方法标记为已删除."

#. Tag: title
#: chapter-jpacontainer.xml:1052
#, no-c-format
msgid "Refreshing JPAContainer"
msgstr "刷新 JPAContainer"

#. Tag: para
#: chapter-jpacontainer.xml:1054
#, no-c-format
msgid ""
"In cases where you change <classname>JPAContainer</classname> items outside "
"the container, for example by through an <interfacename>EntityManager</"
"interfacename>, or when they change in the database, you need to refresh the "
"container."
msgstr ""
"万一你在容器之外修改了 <classname>JPAContainer</classname> Item, 比如通过 "
"<interfacename>EntityManager</interfacename>, 或者数据库之内的数据发生了变"
"化, 你需要刷新容器."

#. Tag: para
#: chapter-jpacontainer.xml:1061
#, no-c-format
msgid ""
"The <interfacename>EntityContainer</interfacename> interface implemented by "
"<classname>JPAContainer</classname> provides two methods to refresh a "
"container. The <methodname>refresh()</methodname> discards all container "
"caches and buffers and refreshes all loaded items in the container. All "
"changes made to items provided by the container are discarded. The "
"<methodname>refreshItem()</methodname> refreshes a single item."
msgstr ""
"<classname>JPAContainer</classname> 实现了 <interfacename>EntityContainer</"
"interfacename> 接口, 这个接口提供了两个方法来刷新容器. "
"<methodname>refresh()</methodname> 会抛弃容器内的所有缓存, 然后刷新容器内已装"
"载的所有 Item. 对容器中所有 Item 所做的一切更新都将被废弃. "
"<methodname>refreshItem()</methodname> 方法只刷新单个 Item."

#. Tag: title
#: chapter-jpacontainer.xml:1074 chapter-jpacontainer.xml:1102
#, no-c-format
msgid "Nested Properties"
msgstr "嵌套属性"

#. Tag: para
#: chapter-jpacontainer.xml:1076
#, no-c-format
msgid ""
"If you have a one-to-one or many-to-one relationship, you can define the "
"properties of the referenced entity as <emphasis>nested</emphasis> in a "
"<classname>JPAContainer</classname>. This way, you can access the properties "
"directly through the container of the first entity type as if they were its "
"properties. The interface is the same as with <classname>BeanContainer</"
"classname> described in <xref linkend=\"datamodel.container.beancontainer\"/"
">. You just need to add each nested property with "
"<methodname>addNestedContainerProperty()</methodname> using dot-separated "
"path to the property."
msgstr ""
"如果你有一对一或者多对一关系, 你可以在 <classname>JPAContainer</classname> 中"
"将被引用的实体定义为 <emphasis>嵌套属性</emphasis>. 通过这种方式, 你可以通过"
"第一个实体类型的容器直接访问属性, 就好象这些属性是它的属性一样. 相关接口与 "
"<xref linkend=\"datamodel.container.beancontainer\"/> 中介绍过的 "
"<classname>BeanContainer</classname> 一样. 你只需要通过 "
"<methodname>addNestedContainerProperty()</methodname> 方法添加所有的嵌套属"
"性, 嵌套属性的名称使用点号分隔."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1089
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a persistent container\n"
"JPAContainer<Person> persons =\n"
"    JPAContainerFactory.make(Person.class, \"book-examples\");\n"
"\n"
"// Add a nested property to a many-to-one property\n"
"persons.addNestedContainerProperty(\"country.name\");\n"
"        \n"
"// Show the persons in a table, except the \"country\" column,\n"
"// which is an object - show the nested property instead\n"
"Table personTable = new Table(\"The Persistent People\", persons);\n"
"personTable.setVisibleColumns(new String[]{\"name\",\"age\",\n"
"                                           \"country.name\"});\n"
"\n"
"// Have a nicer caption for the country.name column\n"
"personTable.setColumnHeader(\"country.name\", \"Nationality\");]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1091
#, no-c-format
msgid ""
"The result is shown in <xref linkend=\"figure.jpacontainer.usage.nested-"
"properties\"/>. Notice that the <literal>country</literal> property in the "
"container remains after adding the nested property, so we had to make that "
"column invisible. Alternatively, we could have redefined the "
"<methodname>toString()</methodname> method in the country object to show the "
"name instead of an object reference."
msgstr ""
"上例的运行结果见 <xref linkend=\"figure.jpacontainer.usage.nested-properties"
"\"/>. 注意, 添加嵌套属性后, 容器中的 <literal>country</literal> 属性仍然会被"
"保留, 因此我们必须将这个属性对应的列设置为不可见. 另外一个方法是, 我们可以重"
"定义 country 对象的 <methodname>toString()</methodname> 方法, 让它显示国家的"
"名称, 而不是一个对象引用."

#. Tag: para
#: chapter-jpacontainer.xml:1110
#, no-c-format
msgid ""
"You can use the <literal>*</literal> wildcard to add all properties in a "
"nested item, for example, \"<literal>country.*</literal>\"."
msgstr ""
"你可以使用 <literal>*</literal> 通配符, 来添加嵌套 Item 中的所有属性, 比如, "
"\"<literal>country.*</literal>\"."

#. Tag: title
#: chapter-jpacontainer.xml:1117
#, no-c-format
msgid "Hierarchical Container"
msgstr "层级数据容器"

#. Tag: para
#: chapter-jpacontainer.xml:1119
#, no-c-format
msgid ""
"<classname>JPAContainer</classname> implements the <interfacename>Container."
"Hierarchical</interfacename> interface and can be bound to hierarchical "
"components such as a <classname>Tree</classname> or <classname>TreeTable</"
"classname>. The feature requires that the hierarchy is represented with a "
"<emphasis>parent</emphasis> property that refers to the parent item. At "
"database level, this would be a column with IDs."
msgstr ""
"<classname>JPAContainer</classname> 实现了 <interfacename>Container."
"Hierarchical</interfacename> 接口, 因此可以绑定到层级式组件, 比如 "
"<classname>Tree</classname> 或 <classname>TreeTable</classname>. 这个功能要求"
"数据之间的层级关系通过一个 <emphasis>parent</emphasis> 属性表达, 这个属性应该"
"引用到一个父 Item. 在数据库层面, 层级关系应该对应到一个列, 它指向其他表的 ID."

#. Tag: para
#: chapter-jpacontainer.xml:1128
#, no-c-format
msgid "The representation would be as follows:"
msgstr "如下例:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1133
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Entity\n"
"public class CelestialBody implements Serializable {\n"
"    @Id\n"
"    @GeneratedValue(strategy = GenerationType.IDENTITY)\n"
"    private Long    id;\n"
"    \n"
"    private String  name;\n"
"\n"
"    @ManyToOne\n"
"    private CelestialBody parent;\n"
"    ...\n"
"} ...\n"
"\n"
"// Create some entities\n"
"CelestialBody sun     = new CelestialBody(\"The Sun\", null);\n"
"CelestialBody mercury = new CelestialBody(\"Mercury\", sun);\n"
"CelestialBody venus   = new CelestialBody(\"Venus\", sun); \n"
"CelestialBody earth   = new CelestialBody(\"Earth\", sun);\n"
"CelestialBody moon    = new CelestialBody(\"The Moon\", earth);\n"
"CelestialBody mars    = new CelestialBody(\"Mars\", sun);\n"
"...]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1135
#, no-c-format
msgid ""
"You set up a <classname>JPAContainer</classname> to have hierarchy by "
"calling <methodname>setParentProperty()</methodname> with the name of the "
"property that refers to the parent. Coincidentally, it is named "
"\"<literal>parent</literal>\" in the example:"
msgstr ""
"你应该调用 <methodname>setParentProperty()</methodname> 方法将 "
"<classname>JPAContainer</classname> 设置为级层容器. 方法参数是引用到父 Item "
"的那个属性名称. 在我们的示例中, 这个属性的名字恰巧就是 \"<literal>parent</"
"literal>\" :"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1143
#, no-c-format
msgid ""
"<?pocket-size 65%?><![CDATA[// Create the container\n"
"JPAContainer<CelestialBody> bodies =\n"
"    JPAContainerFactory.make(CelestialBody.class, \"my-unit\");\n"
"\n"
"// Set it up for hierarchical representation\n"
"bodies.setParentProperty(\"parent\");\n"
"\n"
"// Bind it to a hierarhical component\n"
"Tree tree = new Tree(\"Celestial Bodies\", bodies);\n"
"tree.setItemCaptionMode(Tree.ITEM_CAPTION_MODE_PROPERTY);\n"
"tree.setItemCaptionPropertyId(\"name\");]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1145
#, no-c-format
msgid ""
"You can use the <methodname>rootItemIds()</methodname> to acquire the item "
"IDs of the root elements with no parent."
msgstr ""
"你可以使用 <methodname>rootItemIds()</methodname> 方法来获取(不存在父节点的)"
"根节点元素所对应的 Item ID."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1150
#, no-c-format
msgid ""
"<![CDATA[// Expand the tree\n"
"for (Object rootId: bodies.rootItemIds())\n"
"    tree.expandItemsRecursively(rootId);]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1153
#, no-c-format
msgid "Unsupported Hierarchical Features"
msgstr "不支持的层级功能"

#. Tag: para
#: chapter-jpacontainer.xml:1155
#, no-c-format
msgid ""
"Using <methodname>setParent()</methodname> in the container to define "
"parenthood is not supported."
msgstr ""
"在容器中使用 <methodname>setParent()</methodname> 方法来定义数据间的父子关"
"系, 这个功能是不支持的."

#. Tag: para
#: chapter-jpacontainer.xml:1160
#, no-c-format
msgid ""
"Also, the current implementation does not support "
"<emphasis>setChildrenAllowed()</emphasis>, which controls whether the user "
"can expand a node by clicking a toggle. The toggle is by default visible for "
"all nodes, even if they have no children. The method is not supported "
"because it would require storing the information outside the entities. You "
"can override <methodname>areChildrenAllowed()</methodname> to implement the "
"functionality using a custom logic."
msgstr ""
"而且, 目前的实现库不支持 <emphasis>setChildrenAllowed()</emphasis> 方法, 这个"
"方法控制用户能否点击开关来展开一个节点. 展开/收起开关默认对所有节点都是可见"
"的, 即使某些节点之下不存在子节点. 不支持这个方法, 是因为它需要在实体之外保存"
"一部分信息. 你也可以重载 <methodname>areChildrenAllowed()</methodname> 方法, "
"使用你的自定义逻辑来实现这个功能."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1172
#, no-c-format
msgid ""
"<?pocket-size 65%?><![CDATA[// Customize JPAContainer to define the logic "
"for\n"
"// displaying the node expansion indicator\n"
"JPAContainer<CelestialBody> bodies =\n"
"        new JPAContainer<CelestialBody>(CelestialBody.class) {\n"
"    @Override\n"
"    public boolean areChildrenAllowed(Object itemId) {\n"
"        // Some simple logic\n"
"        return getChildren(itemId).size() > 0;\n"
"    }\n"
"};\n"
"bodies.setEntityProvider(\n"
"    new CachingLocalEntityProvider<CelestialBody>(\n"
"        CelestialBody.class, em));]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1179
#, no-c-format
msgid "Entity Providers"
msgstr "实体提供者(Entity Provider)"

#. Tag: para
#: chapter-jpacontainer.xml:1181
#, no-c-format
msgid ""
"Entity providers provide access to entities persisted in a data store. They "
"are essentially wrappers over a JPA entity manager with optimizations and "
"other features important when binding persistent data to a user interface."
msgstr ""
"实体持久化存储到数据存储中, Entity provider 实现对实体的访问功能. Entity "
"provider 本质上就是对 JPA 实体管理器的包装, 并进行了优化, 另外还提供了一些重"
"要功能, 用于将持久化数据绑定到 UI 组件."

#. Tag: para
#: chapter-jpacontainer.xml:1187
#, no-c-format
msgid ""
"The choice and use of entity providers is largely invisible if you create "
"your <classname>JPAContainer</classname> instances with the "
"<classname>JPAContainerFactory</classname>, which hides such details."
msgstr ""
"如果你使用 <classname>JPAContainerFactory</classname> 来创建你的 "
"<classname>JPAContainer</classname> 实例, 那么 Entity Provider 的选择和使用很"
"大程度上是不可见的, 因为工厂类隐藏了这些细节."

#. Tag: para
#: chapter-jpacontainer.xml:1193
#, no-c-format
msgid ""
"JPAContainer entity providers can be customized, which is necessary for some "
"purposes. Entity providers can be Enterprise JavaBeans (EJBs), which is "
"useful when you use them in a Java EE application server."
msgstr ""
"JPAContainer 的 Entity Provider 可以定制, 对于某些目的来说定制是必须的. "
"Entity Provider 可以是 Enterprise JavaBean(EJB), 在 Java EE 应用程序服务器中"
"使用它会很有用."

#. Tag: title
#: chapter-jpacontainer.xml:1200
#, no-c-format
msgid "Built-In Entity Providers"
msgstr "内建的 Entity Provider"

#. Tag: para
#: chapter-jpacontainer.xml:1202
#, no-c-format
msgid ""
"JPAContainer includes various kinds of built-in entity providers: caching "
"and non-caching, read-write and read-only, and batchable."
msgstr ""
"JPAContainer 包含多种不同的内建 Entity Provider: 有缓存的和无缓存的, 可读写的"
"和只读的, 以及支持批量处理的."

#. Tag: para
#: chapter-jpacontainer.xml:1207
#, no-c-format
msgid ""
"<emphasis>Caching</emphasis> is useful for performance, but takes some "
"memory for the cache and makes the provider stateful. <emphasis>Batching</"
"emphasis>, that is, running updates in larger batches, can also enhance "
"performance and be used together with caching. It is stateless, but doing "
"updates is a bit more complex than otherwise."
msgstr ""
"<emphasis>缓存</emphasis> 对于提高性能是十分有效的, 但会消耗一些内存, 并会导"
"致 Entity Provider 变成有状态的. <emphasis>批量处理(Batching)</emphasis>, 也"
"就是在很大的批处理中运行多个更新处理, 也可以提高性能, 会与缓存同时使用. 它是"
"无状态的, 但执行更新处理会比其他模式略为复杂一些."

#. Tag: para
#: chapter-jpacontainer.xml:1216
#, no-c-format
msgid ""
"Using a <emphasis>read-only</emphasis> container is preferable if read-write "
"capability is not needed."
msgstr ""
"如果写入功能不是必须的, 那么比较适当的选择是使用 <emphasis>只读</emphasis> 容"
"器."

#. Tag: para
#: chapter-jpacontainer.xml:1221
#, no-c-format
msgid ""
"All built-in providers are <emphasis>local</emphasis> in the sense that they "
"provide access to entities using a local JPA entity manager."
msgstr ""
"所有的内建 Entity Provider 都是 <emphasis>局部的(local)</emphasis>, 也就是"
"说, 它们都使用局部的 JPA 实体管理器来访问实体."

#. Tag: para
#: chapter-jpacontainer.xml:1226
#, no-c-format
msgid ""
"The <classname>CachingMutableLocalEntityProvider</classname> is usually "
"recommended as the first choise for read-write access and "
"<classname>CachingLocalEntityProvider</classname> for read-only access."
msgstr ""
"通常推荐使用 <classname>CachingMutableLocalEntityProvider</classname> 来实现"
"可读写的数据访问, 推荐使用 <classname>CachingLocalEntityProvider</classname> "
"实现只读访问."

#. Tag: para
#: chapter-jpacontainer.xml:1235
#, no-c-format
msgid ""
"A read-only, lazy loading entity provider that does not perform caching and "
"reads its data directly from an entity manager."
msgstr ""
"这是一个只读, 延迟装载(lazy loading)的 Entity Provider, 它没有缓存功能, 直接"
"从实体管理器读取数据."

#. Tag: para
#: chapter-jpacontainer.xml:1240
#, no-c-format
msgid ""
"You can create the provider with <methodname>makeNonCachedReadOnly()</"
"methodname> method in <classname>JPAContainerFactory</classname>."
msgstr ""
"你可以使用 <classname>JPAContainerFactory</classname> 的 "
"<methodname>makeNonCachedReadOnly()</methodname> 方法来创建这个 Entity "
"Provider."

#. Tag: para
#: chapter-jpacontainer.xml:1250
#, no-c-format
msgid ""
"Extends <classname>LocalEntityProvider</classname> with write support. All "
"changes are directly sent to the entity manager."
msgstr ""
"这个 Entity Provider 继承自 <classname>LocalEntityProvider</classname>, 增加"
"了数据写入功能. 所有的更新都会直接发送给实体管理器."

#. Tag: para
#: chapter-jpacontainer.xml:1256
#, no-c-format
msgid ""
"Transactions can be handled either internally by the provider, which is the "
"default, or by the container. In the latter case, you can extend the class "
"and annotate it, for example, as described in <xref linkend=\"jpacontainer."
"entityprovider.built-in\"/>."
msgstr ""
"事务可以由 Entity Provider 内部处理, 默认就是如此, 也可以由容器负责处理. 后一"
"种情况下, 你可以继承类, 并使用注解来标记它, 例子可参见 <xref linkend="
"\"jpacontainer.entityprovider.built-in\"/>."

#. Tag: para
#: chapter-jpacontainer.xml:1263
#, no-c-format
msgid ""
"The provider can notify about updates to entities through the "
"<interfacename>EntityProviderChangeNotifier</interfacename> interface."
msgstr ""
"Entity Provider 可以使用<interfacename>EntityProviderChangeNotifier</"
"interfacename> 接口, 将更新通知发送给实体."

#. Tag: para
#: chapter-jpacontainer.xml:1272
#, no-c-format
msgid ""
"A simple non-caching implementation of the "
"<interfacename>BatchableEntityProvider</interfacename> interface. It extends "
"<classname>MutableLocalEntityProvider</classname> and simply passes itself "
"to the <methodname>batchUpdate()</methodname> callback method. This will "
"work properly if the entities do not contain any references to other "
"entities that are managed by the same container."
msgstr ""
"这是 <interfacename>BatchableEntityProvider</interfacename> 接口的一个无缓存"
"的简单实现. 它继承自 <classname>MutableLocalEntityProvider</classname>, 并简"
"单地将自己传递给 <methodname>batchUpdate()</methodname> 回调方法. 如果实体中"
"不包含对同一个容器所管理的任何其他实体的引用, 那么这种方式将会正常工作."

#. Tag: para
#: chapter-jpacontainer.xml:1285
#, no-c-format
msgid ""
"A read-only, lazy loading entity provider that caches both entities and "
"query results for different filter/sortBy combinations. When the cache gets "
"full, the oldest entries in the cache are removed. The maximum number of "
"entities and entity IDs to cache for each filter/sortBy combination can be "
"configured in the provider. The cache can also be manually flushed. When the "
"cache grows full, the oldest items are removed."
msgstr ""
"这是一个只读, 延迟加载的 Entity Provider, 它既缓存实体, 也针对过滤器/排序的不"
"同组合缓存查询结果. 缓存满后, 缓存中最老的实体将被移除. 实体的最大数目, 以及"
"针过滤/排序的每一种组合的被缓存的实体 ID, 都可以在 Entity Provider 进行配置. "
"缓存也可以手动刷新(flush). 当缓存满时, 最老的项目会被移除."

#. Tag: para
#: chapter-jpacontainer.xml:1296
#, no-c-format
msgid ""
"You can create the provider with <methodname>makeReadOnly()</methodname> "
"method in <classname>JPAContainerFactory</classname>."
msgstr ""
"你可以使用 <classname>JPAContainerFactory</classname> 的 "
"<methodname>makeReadOnly()</methodname> 方法创建这个 Entity Provider."

#. Tag: para
#: chapter-jpacontainer.xml:1306
#, no-c-format
msgid ""
"Just like <classname>CachingLocalEntityProvider</classname>, but with read-"
"write access. For read access, caching works just like in the read-only "
"provider. When an entity is added or updated, the cache is flushed in order "
"to make sure the added or updated entity shows up correctly when using "
"filters and/or sorting. When an entity is removed, only the filter/sortBy-"
"caches that actually contain the item are flushed."
msgstr ""
"这个 Entity Provider 与 <classname>CachingLocalEntityProvider</classname> 类"
"似, 但有数据写入功能. 对于数据的读, 缓存功能与只读 Entity Provider 中的工作模"
"式一样. 当实体被添加或被修改后, 缓存会被刷新(flush), 以便确保使用过滤或排序功"
"能时, 添加或更新的实体能够正确显示. 当实体被删除时, 只有包含这个实体的过滤/排"
"序缓存会被刷新."

#. Tag: para
#: chapter-jpacontainer.xml:1316
#, no-c-format
msgid ""
"This is perhaps the most commonly entity provider that you should consider "
"using for most tasks. You can create it with the <methodname>make()</"
"methodname> method in <classname>JPAContainerFactory</classname>."
msgstr ""
"对于大多数使用场合来说, 这可能是最常用的 Entity Provider. 你可以使用 "
"<classname>JPAContainerFactory</classname> 的 <methodname>make()</"
"methodname> 方法创建这个 Entity Provider."

#. Tag: classname
#: chapter-jpacontainer.xml:1325
#, no-c-format
msgid "CachingBatchableLocalEntityProvider"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1327
#, no-c-format
msgid ""
"This provider supports making updates in <emphasis>batches</emphasis>. You "
"need to implement a <interfacename>BatchUpdateCallback</interfacename> that "
"does all the updates and execute the batch by calling "
"<methodname>batchUpdate()</methodname> on the provider."
msgstr ""
"这个 Entity Provider 支持通过 <emphasis>批量处理</emphasis> 来进行更新. 你需"
"要实现一个 <interfacename>BatchUpdateCallback</interfacename> 来执行更新, 并"
"对 Entity Provider 调用 <methodname>batchUpdate()</methodname> 方法来执行批处"
"理."

#. Tag: para
#: chapter-jpacontainer.xml:1335
#, no-c-format
msgid ""
"The provider is an extension of the "
"<classname>CachingMutableLocalEntityProvider</classname> that implements the "
"<interfacename>BatchableEntityProvider</interfacename> interface. This will "
"work properly if the entities do not contain any references to other "
"entities that are managed by the same container."
msgstr ""
"这个 Entity Provider 继承自 <classname>CachingMutableLocalEntityProvider</"
"classname>, 这个父类实现了 <interfacename>BatchableEntityProvider</"
"interfacename> 接口. 如果实体中不包含对同一个容器所管理的任何其他实体的引用, "
"那么这种方式将会正常工作."

#. Tag: para
#: chapter-jpacontainer.xml:1345
#, no-c-format
msgid ""
"You can create the provider with <methodname>makeBatchable()</methodname> "
"method in <classname>JPAContainerFactory</classname>."
msgstr ""
"你可以使用 <classname>JPAContainerFactory</classname> 的 "
"<methodname>makeBatchable()</methodname> 方法创建这个 Entity Provider."

#. Tag: title
#: chapter-jpacontainer.xml:1354
#, no-c-format
msgid "Using JNDI Entity Providers in JEE6 Environment"
msgstr "在 JEE6 环境中使用 JNDI Entity Provider"

#. Tag: para
#: chapter-jpacontainer.xml:1356
#, no-c-format
msgid ""
"JPAContainer 2.0 introduced a new set of entity providers specifically for "
"working in a <literal>JEE6</literal> environment. In a JEE environment, you "
"should use an entity manager provided by the application server and, "
"usually, <literal>JTA</literal> transactions instead of transactions "
"provided by JPA. Entity providers in <package>com.vaadin.addon.jpacontainer."
"provider.jndijta</package> package work mostly the same way as the normal "
"providers discussed earlier, but use JNDI lookups to get reference to an "
"<interfacename>EntityManager</interfacename> and to a JTA transaction."
msgstr ""
"JPAContainer 2.0 引入的一组新的, 适合于在 <literal>JEE6</literal> 环境中工作"
"的 Entity Provider. 在 JEE 环境中, 你应该使用应用程序服务器提供的实体管理器, "
"而且通常应该使用 <literal>JTA</literal> 事务, 而不是 JPA 提供的事务. "
"<package>com.vaadin.addon.jpacontainer.provider.jndijta</package> 包中的 "
"Entity provider 的工作方式与前面讨论过的那些普通的 Entity Provider 基本一致, "
"不同之处是, 它们使用 JNDI 来查找得到 <interfacename>EntityManager</"
"interfacename> 和 JTA 事务."

#. Tag: para
#: chapter-jpacontainer.xml:1368
#, no-c-format
msgid ""
"The JNDI providers work with almost no special configuration at all. The "
"<classname>JPAContainerFactory</classname> has factory methods for creating "
"various JNDI provider types. The only thing that you commonly need to do is "
"to expose the <interfacename>EntityManager</interfacename> to a JNDI "
"address. By default, the JNDI providers look for the "
"<interfacename>EntityManager</interfacename> from \"<uri>java:comp/env/"
"persistence/em</uri>\". This can be done with the following snippet in "
"<filename>web.xml</filename> or with similar configuration with annotations."
msgstr ""
"JNDI Entity Provider 几乎不需要任何特殊的配置. "
"<classname>JPAContainerFactory</classname> 中带有工厂方法, 可以创建各种类型"
"的 JNDI Entity Provider. 通常你只需要将一个 <interfacename>EntityManager</"
"interfacename> 公布到一个 JNDI 地址上. 默认情况下, JNDI Entity Provider 会在 "
"\"<uri>java:comp/env/persistence/em</uri>\" 地址上查找 "
"<interfacename>EntityManager</interfacename>. 这个配置可以通过下例中的 "
"<filename>web.xml</filename> 代码片段来实现, 也可以使用注解来实现类似的配置."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1380
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[<persistence-context-ref>\n"
"  <persistence-context-ref-name>\n"
"    persistence/em\n"
"  </persistence-context-ref-name>\n"
"  <persistence-unit-name>MYPU</persistence-unit-name>\n"
"</persistence-context-ref>]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1382
#, no-c-format
msgid ""
"The \"<literal>MYPU</literal>\" is the identifier of your persistence unit "
"defined in your <filename>persistence.xml</filename> file."
msgstr ""
"\"<literal>MYPU</literal>\" 就是你的 <filename>persistence.xml</filename> 文"
"件中定义的持久化单元的标识符."

#. Tag: para
#: chapter-jpacontainer.xml:1387
#, no-c-format
msgid ""
"If you choose to annotate your servlets (instead of using the <filename>web."
"xml</filename> file as described above), you can simply add the following "
"annotation to your servlet."
msgstr ""
"如果你选择使用注解来配置你的 Servlet (而不是向上例一样使用 <filename>web."
"xml</filename> 文件), 你只需要向你的 Servlet 添加以下这段注解."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1393
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[@PersistenceContext(name=\"persistence/em\","
"unitName=\"MYPU\")]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1395
#, no-c-format
msgid ""
"If you wish to use another address for the persistence context, you can "
"define them with the <methodname>setJndiAddresses()</methodname> method. You "
"can also define the location for the JTA <classname>UserTransaction</"
"classname>, but that should be always accessible from \"<uri>java:comp/"
"UserTransaction</uri>\" by the JEE6 specification."
msgstr ""
"如果你希望为你的持久化上下文使用其他地址, 你可以使用 "
"<methodname>setJndiAddresses()</methodname> 方法来定义 JNDI 地址. 你还可以 "
"JTA <classname>UserTransaction</classname> 的位置, 但根据 JEE6 规范, 它必须可"
"以通过 \"<uri>java:comp/UserTransaction</uri>\" 地址来访问."

#. Tag: title
#: chapter-jpacontainer.xml:1406
#, no-c-format
msgid "Entity Providers as Enterprise Beans"
msgstr "EJB 形式的 Entity Provider"

#. Tag: para
#: chapter-jpacontainer.xml:1408
#, no-c-format
msgid ""
"Entity providers can be Enterprise JavaBeans (EJB). This may be useful if "
"you use JPAContainer in a Java EE application server. In such case, you need "
"to implement a custom entity provider that allows the server to inject the "
"entity manager."
msgstr ""
"Entity provider 可以是 Enterprise JavaBean (EJB). 当你在 Java EE 应用程序服务"
"器中使用 JPAContainer 时, 这种方式会很有用. 这种情况下, 你需要实现一个自定义"
"的 Entity Provider, 允许服务器将实体管理器注入进来."

#. Tag: para
#: chapter-jpacontainer.xml:1415
#, no-c-format
msgid ""
"For example, if you need to use Java Transaction API (JTA) for JPA "
"transactions, you can implement such entity provider as follows. Just extend "
"a built-in entity provider of your choise and annotate the entity manager "
"member as <literal>@PersistenceContext</literal>. Entity providers can be "
"either stateless or stateful session beans. If you extend a caching entity "
"provider, it has to be stateful."
msgstr ""
"比如, 如果你需要使用 Java Transaction API (JTA) 来管理 JPA 事务, 你可以通过如"
"下方式实现这样的 Entity Provider. 只需要选择一个内建的 Entity Provider, 继承"
"它, 然后对其中的实体管理器成员变量添加 <literal>@PersistenceContext</"
"literal> 注解. Entity Provider 可以是无状态的, 也可以是有状态的 Session "
"Bean. 如果你继承的是有缓存功能的 Entity Provider, 那么它必须是有状态的."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1424
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[@Stateless\n"
"@TransactionManagement\n"
"public class MyEntityProviderBean extends\n"
"    MutableLocalEntityProvider<MyEntity> {\n"
"\n"
"    @PersistenceContext\n"
"    private EntityManager em;\n"
"\n"
"    protected LocalEntityProviderBean() {\n"
"        super(MyEntity.class);\n"
"        setTransactionsHandledByProvider(false);\n"
"    }\n"
"\n"
"    @Override\n"
"    @TransactionAttribute(TransactionAttributeType.REQUIRED)\n"
"    protected void runInTransaction(Runnable operation) {\n"
"        super.runInTransaction(operation);\n"
"    }\n"
"\n"
"    @PostConstruct\n"
"    public void init() {\n"
"        setEntityManager(em);\n"
"        /*\n"
"         * The entity manager is transaction-scoped, which means\n"
"         * that the entities will be automatically detached when\n"
"         * the transaction is closed. Therefore, we do not need\n"
"         * to explicitly detach them.\n"
"         */\n"
"        setEntitiesDetached(false);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1426
#, no-c-format
msgid ""
"If you have more than one EJB provider, you might want to create an abstract "
"super class of the above and only define the entity type in implementations. "
"You can implement an entity provider as a managed bean in Spring Framefork "
"the same way."
msgstr ""
"如果你有多个 EJB Provider, 你可能会希望为上例中的类创建一个抽象的父类, 然后将"
"实体类型只定义在实现类中. 你也可以通过同样的方式, 在 Spring Framefork 中将 "
"Entity Provider 实现为一个被管理的 Bean."

#. Tag: title
#: chapter-jpacontainer.xml:1437
#, no-c-format
msgid "Filtering <classname>JPAContainer</classname>"
msgstr "在 <classname>JPAContainer</classname> 中过滤"

#. Tag: para
#: chapter-jpacontainer.xml:1439
#, no-c-format
msgid ""
"Normally, a <classname>JPAContainer</classname> contains all instances of a "
"particular entity type in the persistence context. Hence, it is equivalent "
"to a database table or query. Just like with database queries, you often "
"want to narrow the results down. <classname>JPAContainer</classname> "
"implements the <interfacename>Filterable</interfacename> interface in Vaadin "
"containers, described in <xref linkend=\"datamodel.container.filtered\"/>. "
"All filtering is done at the database level with queries, not in the "
"container."
msgstr ""
"通常, 一个 <classname>JPAContainer</classname> 包含某个实体类型在持久化上下文"
"中的所有实例. 因此, 它等同于一个数据库表或查询. 与数据库查询一样, 你经常会希"
"望介绍查询结果的数目. <classname>JPAContainer</classname> 实现了 Vaadin 容器"
"的 <interfacename>Filterable</interfacename> 接口, 关于这个接口, 详情请参见 "
"<xref linkend=\"datamodel.container.filtered\"/>. 所有的过滤处理都会以查询的"
"方式在数据库级别实现, 而不是在容器内部."

#. Tag: para
#: chapter-jpacontainer.xml:1450
#, no-c-format
msgid "For example, let us filter all the people older than 117:"
msgstr "比如, 让我们来过滤年龄为 117 岁以上的人:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1455
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[Filter filter = new Compare.Greater(\"age\", "
"117);\n"
"persons.addContainerFilter(filter);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1458
#, no-c-format
msgid "This would create a JPQL query somewhat as follows:"
msgstr "以上代码产生的 JPQL 查询, 大致如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1462
#, no-c-format
msgid "<?pocket-size 75% ?><![CDATA[SELECT id FROM Person WHERE (AGE > 117)]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1464
#, no-c-format
msgid ""
"The filtering implementation uses the JPA 2.0 Criteria API transparently. As "
"the filtering is done at the database-level, custom filters that use the "
"<interfacename>Filterable</interfacename> API do not work."
msgstr ""
"查询使用 JPA 2.0 Criteria API 透明地实现. 由于过滤是在数据库级别上实现的, 使"
"用 <interfacename>Filterable</interfacename> API 的自定义过滤将无法工作."

#. Tag: para
#: chapter-jpacontainer.xml:1472
#, no-c-format
msgid ""
"When using Hibernate, note that it does not support implicit joins. See "
"<xref linkend=\"jpacontainer.hibernate.joins\"/> for more details."
msgstr ""
"使用 Hibernate 时, 注意它不支持隐含的表连接(join). 详情请参见 <xref linkend="
"\"jpacontainer.hibernate.joins\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:1479
#, no-c-format
msgid "Querying with the Criteria API"
msgstr "使用 Criteria API 进行查询"

#. Tag: para
#: chapter-jpacontainer.xml:1481
#, no-c-format
msgid ""
"When the <interfacename>Filterable</interfacename> API is not enough and you "
"need to have more control, you can make queries directly with the JPA "
"Criteria API. You may also need to customize sorting or joins, or otherwise "
"modify the query in some way. To do so, you need to implement a "
"<interfacename>QueryModifierDelegate</interfacename> that the JPAContainer "
"entity provider calls when making a query. The easiest way to do this is to "
"extend <classname>DefaultQueryModifierDelegate</classname>, which has empty "
"implementations of all the methods so that you can only override the ones "
"you need."
msgstr ""
"如果 <interfacename>Filterable</interfacename> API 不能适应你的需求, 你需要更"
"多控制时, 你可以直接使用 JPA Criteria API 来创建查询. 你还可能需要对排序或表"
"的连接(join)进行定制, 或者对查询进行其他修改. 为了实现这一点, 你需要实现 "
"<interfacename>QueryModifierDelegate</interfacename> 接口, JPAContainer 的 "
"Entity Provider 创建查询时会调用这个接口. 最简单的方法是继承 "
"<classname>DefaultQueryModifierDelegate</classname>, 其中包含了所有方法的空实"
"现, 因此你可以只重载你需要的方法."

#. Tag: para
#: chapter-jpacontainer.xml:1493
#, no-c-format
msgid ""
"The entity provider calls specific <interfacename>QueryModifierDelegate</"
"interfacename> methods at different stages while making a query. The stages "
"are:"
msgstr ""
"Entity Provider 在创建查询的各个阶段, 会调用 "
"<interfacename>QueryModifierDelegate</interfacename> 的不同方法. 这些阶段包"
"括:"

#. Tag: para
#: chapter-jpacontainer.xml:1500
#, no-c-format
msgid "Start building a query"
msgstr "开始构建查询"

#. Tag: para
#: chapter-jpacontainer.xml:1501
#, no-c-format
msgid "Add \"<literal>ORDER BY</literal>\" expression"
msgstr "添加 \"<literal>ORDER BY</literal>\" 表达式"

#. Tag: para
#: chapter-jpacontainer.xml:1502
#, no-c-format
msgid "Add \"<literal>WHERE</literal>\" expression (filter)"
msgstr "添加 \"<literal>WHERE</literal>\" 表达式(过滤)"

#. Tag: para
#: chapter-jpacontainer.xml:1503
#, no-c-format
msgid "Finish building a query"
msgstr "结束查询的构建"

#. Tag: para
#: chapter-jpacontainer.xml:1507
#, no-c-format
msgid ""
"Methods where you can modify the query are called before and after each "
"stage as listed in the following table:"
msgstr "在各个阶段之前和之后会被调用, 你可以用来修改查询的方法, 见下表:"

#. Tag: title
#: chapter-jpacontainer.xml:1513
#, no-c-format
msgid "<classname>QueryModifierDelegate</classname> Methods"
msgstr "<classname>QueryModifierDelegate</classname> 的方法"

#. Tag: methodname
#: chapter-jpacontainer.xml:1517
#, no-c-format
msgid "queryWillBeBuilt()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1520
#, no-c-format
msgid "orderByWillBeAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1523
#, no-c-format
msgid "orderByWasAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1526
#, no-c-format
msgid "filtersWillBeAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1529
#, no-c-format
msgid "filtersWereAdded()"
msgstr ""

#. Tag: methodname
#: chapter-jpacontainer.xml:1532
#, no-c-format
msgid "queryHasBeenBuilt()"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1538
#, no-c-format
msgid ""
"All the methods get two parameters. The <interfacename>CriteriaBuilder</"
"interfacename> is a builder that you can use to build queries. The "
"<interfacename>CriteriaQuery</interfacename> is the query being built."
msgstr ""
"所有方法都会收到两个参数. <interfacename>CriteriaBuilder</interfacename> 参数"
"是构建器, 你可以用来构建查询. <interfacename>CriteriaQuery</interfacename> 参"
"数是正在被构建的查询."

#. Tag: para
#: chapter-jpacontainer.xml:1545
#, no-c-format
msgid ""
"You can use the <methodname>getRoots().iterator().next()</methodname> in "
"<interfacename>CriteriaQuery</interfacename> to get the \"root\" that is "
"queried, for example, the <literal>PERSON</literal> table, etc."
msgstr ""
"你可以使用 <interfacename>CriteriaQuery</interfacename> 的 "
"<methodname>getRoots().iterator().next()</methodname> 方法来得到被查询的 \"根"
"\", 比如, <literal>PERSON</literal> 表, 等等."

#. Tag: title
#: chapter-jpacontainer.xml:1552
#, no-c-format
msgid "Filtering the Query"
msgstr "对查询进行过滤"

#. Tag: para
#: chapter-jpacontainer.xml:1554
#, no-c-format
msgid ""
"Let us consider a case where we modify the query for a <classname>Person</"
"classname> container so that it includes only people over 116. This trivial "
"example is identical to the one given earlier using the "
"<classname>Filterable</classname> interface."
msgstr ""
"我们来考虑一种情况, 我们需要修改 <classname>Person</classname> 容器的查询, 使"
"容器只包含 116 岁以上的人. 这个简单的例子与前面使用 <classname>Filterable</"
"classname> 接口实现的例子是一样的."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1562
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[\n"
"persons.getEntityProvider().setQueryModifierDelegate(\n"
"        new DefaultQueryModifierDelegate () {\n"
"    @Override\n"
"    public void filtersWillBeAdded(\n"
"            CriteriaBuilder criteriaBuilder,\n"
"            CriteriaQuery<?> query,\n"
"            List<Predicate> predicates) {\n"
"        Root<?> fromPerson = query.getRoots().iterator().next();\n"
"\n"
"        // Add a \"WHERE age > 116\" expression\n"
"        Path<Integer> age = fromPerson.<Integer>get(\"age\");\n"
"        predicates.add(criteriaBuilder.gt(age, 116));\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: title
#: chapter-jpacontainer.xml:1566
#, no-c-format
msgid "Compatibility"
msgstr "兼容性"

#. Tag: para
#: chapter-jpacontainer.xml:1568
#, no-c-format
msgid ""
"When building queries, you should consider the capabilities of the different "
"JPA implementations. Regarding Hibernate, see <xref linkend=\"jpacontainer."
"hibernate.joins\"/>."
msgstr ""
"构建查询时, 你应该考虑不同的 JPA 实现之间的兼容性问题. 关于 Hibernate, 请参"
"见 <xref linkend=\"jpacontainer.hibernate.joins\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:1577
#, no-c-format
msgid "Automatic Form Generation"
msgstr "Form 的自动生成"

#. Tag: para
#: chapter-jpacontainer.xml:1579
#, no-c-format
msgid ""
"The JPAContainer <classname>FieldFactory</classname> is an implementation of "
"the <interfacename>FormFieldFactory</interfacename> and "
"<interfacename>TableFieldFactory</interfacename> interfaces that can "
"generate fields based on JPA annotations in a POJO. It goes further than the "
"<classname>DefaultFieldFactory</classname>, which only creates simple fields "
"for the basic data types. This way, you can easily create forms to input "
"entities or enable editing in tables."
msgstr ""
"JPAContainer 的 <classname>FieldFactory</classname> 实现了 "
"<interfacename>FormFieldFactory</interfacename> 接口和 "
"<interfacename>TableFieldFactory</interfacename> 接口, 它可以根据 POJO 类中"
"的 JPA 注解来生成 Field. 它的功能比 <classname>DefaultFieldFactory</"
"classname> 更强, <classname>DefaultFieldFactory</classname> 只能为基本数据类"
"型生成简单的 Field. 使用这种方式, 你可以简单地创建 Form 来输入实体数据, 也可"
"以实现表内的编辑功能."

#. Tag: para
#: chapter-jpacontainer.xml:1590
#, no-c-format
msgid "The generated defaults are as follows:"
msgstr "默认生成的 Field 组件如下:"

#. Tag: para
#: chapter-jpacontainer.xml:1598
#, no-c-format
msgid "Annotation"
msgstr "注解"

#. Tag: para
#: chapter-jpacontainer.xml:1599
#, no-c-format
msgid "Class Mapping"
msgstr "对应的 Field 组件类"

#. Tag: literal
#: chapter-jpacontainer.xml:1604
#, no-c-format
msgid "@ManyToOne"
msgstr ""

#. Tag: classname
#: chapter-jpacontainer.xml:1605
#, no-c-format
msgid "NativeSelect"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1608
#, no-c-format
msgid "<literal>@OneToOne</literal>, <literal>@Embedded</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1609
#, no-c-format
msgid "Nested <classname>Form</classname>"
msgstr "嵌套的 <classname>Form</classname>"

#. Tag: para
#: chapter-jpacontainer.xml:1612
#, no-c-format
msgid "<literal>@OneToMany</literal>, <literal>@ElementCollection</literal>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1613
#, no-c-format
msgid "<classname>MasterDetailEditor</classname> (see below)"
msgstr "<classname>MasterDetailEditor</classname> (详情见后文)"

#. Tag: literal
#: chapter-jpacontainer.xml:1616
#, no-c-format
msgid "@ManyToMany"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1617
#, no-c-format
msgid "Selectable <classname>Table</classname>"
msgstr "可选择的 <classname>Table</classname>"

#. Tag: para
#: chapter-jpacontainer.xml:1625
#, no-c-format
msgid ""
"The field factory is recusive, so that you can edit a complex object tree "
"with one form."
msgstr ""
"Field Factory 是递归的, 因此你可以在一个 Form 之内编辑一个复杂的对象树."

#. Tag: title
#: chapter-jpacontainer.xml:1631
#, no-c-format
msgid "Configuring the Field Factory"
msgstr "配置 Field Factory"

#. Tag: para
#: chapter-jpacontainer.xml:1633
#, no-c-format
msgid ""
"The <classname>FieldFactory</classname> is highly configurable with various "
"configuration settings and by extending."
msgstr ""
"<classname>FieldFactory</classname> 是可以高度配置的, 可以使用各种配置设定, "
"也可以扩展继承它."

#. Tag: para
#: chapter-jpacontainer.xml:1639
#, no-c-format
msgid ""
"The <methodname>setMultiSelectType()</methodname> and "
"<methodname>setSingleSelectType()</methodname> allow you to specify a "
"selection component that is used instead of the default for a field with "
"<literal>@ManyToMany</literal> and <literal>@ManyToOne</literal> annotation, "
"respectively. The first parameter is the class type of the field, and the "
"second parameter is the class type of a selection component. It must be a "
"sub-class of <classname>AbstractSelect</classname>."
msgstr ""
"<methodname>setMultiSelectType()</methodname> 方法和 "
"<methodname>setSingleSelectType()</methodname> 方法允许你指定选择组件, 代替默"
"认的选择组件, 用于被注解为 <literal>@ManyToMany</literal> 和 "
"<literal>@ManyToOne</literal> 的 Field. 第一个参数是 Field 组件的类型, 第二个"
"参数是选择组件的类型. 它必须是 <classname>AbstractSelect</classname> 的子类."

#. Tag: para
#: chapter-jpacontainer.xml:1650
#, no-c-format
msgid ""
"The <methodname>setVisibleProperties()</methodname> controls which "
"properties (fields) are visible in generated forms, subforms, and tables. "
"The first paramater is the class type for which the setting should be made, "
"followed by the IDs of the visible properties."
msgstr ""
"<methodname>setVisibleProperties()</methodname> 控制在生成的 Form, 子 Form, "
"以及 Table 中, 哪些属性(Field) 可见. 第一个参数是这个设置适用的数据类型, 第二"
"个参数是可见属性的 ID ."

#. Tag: para
#: chapter-jpacontainer.xml:1657
#, no-c-format
msgid ""
"The configuration should be done before binding the form to a data source as "
"that is when the field generation is done."
msgstr "将 Form 绑定到数据源时就会创建 Field 组件, 因此应该在绑定之前进行设置."

#. Tag: para
#: chapter-jpacontainer.xml:1662
#, no-c-format
msgid ""
"Further configuration must be done by extending the many protected methods. "
"Please see the API documentation for the complete list."
msgstr ""
"更多的配置必须通过继承这个类并覆盖其中的 protected 方法来实现. 详细的方法列表"
"请参见 API 文档."

#. Tag: title
#: chapter-jpacontainer.xml:1669
#, no-c-format
msgid "Using the Field Factory"
msgstr "使用 Field Factory"

#. Tag: para
#: chapter-jpacontainer.xml:1672
#, no-c-format
msgid ""
"The most basic use case for the JPAContainer <classname>FieldFactory</"
"classname> is with a <classname>Form</classname> bound to a container item:"
msgstr ""
"JPAContainer <classname>FieldFactory</classname> 的最基本的使用场景是用于一"
"个 绑定到容器中元素上的 <classname>Form</classname>:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1679
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a persistent container\n"
"final JPAContainer<Country> countries =\n"
"    JPAContainerFactory.make(Country.class, \"book-examples\");\n"
"\n"
"// For selecting an item to edit\n"
"final ComboBox countrySelect =\n"
"    new ComboBox(\"Select a Country\", countries);\n"
"countrySelect.setItemCaptionMode(Select.ITEM_CAPTION_MODE_PROPERTY);\n"
"countrySelect.setItemCaptionPropertyId(\"name\");\n"
"\n"
"// Country Editor\n"
"final Form  countryForm  = new Form();\n"
"countryForm.setCaption(\"Country Editor\");\n"
"countryForm.addStyleName(\"bordered\"); // Custom style\n"
"countryForm.setWidth(\"420px\");\n"
"countryForm.setBuffered(true);\n"
"countryForm.setEnabled(false);\n"
"\n"
"// When an item is selected from the list...\n"
"countrySelect.addValueChangeListener(new ValueChangeListener(){\n"
"    @Override\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        // Get the item to edit in the form\n"
"        Item countryItem =\n"
"            countries.getItem(event.getProperty().getValue());\n"
"        \n"
"        // Use a JPAContainer field factory\n"
"        //  - no configuration is needed here\n"
"        final FieldFactory fieldFactory = new FieldFactory();\n"
"        countryForm.setFormFieldFactory(fieldFactory);\n"
"\n"
"        // Edit the item in the form\n"
"        countryForm.setItemDataSource(countryItem);\n"
"        countryForm.setEnabled(true);\n"
"        \n"
"        // Handle saves on the form\n"
"        final Button save = new Button(\"Save\");\n"
"        countryForm.getFooter().removeAllComponents();\n"
"        countryForm.getFooter().addComponent(save);\n"
"        save.addClickListener(new ClickListener() {\n"
"            @Override\n"
"            public void buttonClick(ClickEvent event) {\n"
"                try {\n"
"                    countryForm.commit();\n"
"                    countryForm.setEnabled(false);\n"
"                } catch (InvalidValueException e) {\n"
"                }\n"
"            }\n"
"        });\n"
"    }\n"
"});\n"
"countrySelect.setImmediate(true);\n"
"countrySelect.setNullSelectionAllowed(false);]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1681
#, no-c-format
msgid ""
"This would create a form shown in <xref linkend=\"figure.jpacontainer."
"fieldfactory.using\"/>."
msgstr ""
"以上代码将产生一个 Form,  见 <xref linkend=\"figure.jpacontainer."
"fieldfactory.using\"/>."

#. Tag: title
#: chapter-jpacontainer.xml:1687
#, no-c-format
msgid "Using FieldFactory with One-to-Many Relationship"
msgstr "对一对多关系使用 FieldFactory"

#. Tag: para
#: chapter-jpacontainer.xml:1695
#, no-c-format
msgid ""
"If you use Hibernate, you also need to pass an "
"<classname>EntityManagerPerRequestHelper</classname>, either for the "
"constructor or with <methodname>setEntityManagerPerRequestHelper()</"
"methodname><phrase condition=\"web\">, as described in <xref linkend="
"\"jpacontainer.hibernate.em-per-request\"/></phrase>."
msgstr ""
"如果你使用 Hibernate, 你还需要指定一个 "
"<classname>EntityManagerPerRequestHelper</classname>, 可以通过构造函数参数来"
"指定, 也可以使用 <methodname>setEntityManagerPerRequestHelper()</methodname> "
"方法来指定. <phrase condition=\"web\">, 详情请参见 <xref linkend="
"\"jpacontainer.hibernate.em-per-request\"/></phrase>."

#. Tag: title
#: chapter-jpacontainer.xml:1706
#, no-c-format
msgid "Master-Detail Editor"
msgstr "主-从(Master-Detail)数据编辑器"

#. Tag: para
#: chapter-jpacontainer.xml:1708
#, no-c-format
msgid ""
"The <classname>MasterDetailEditor</classname> is a field component that "
"allows editing an item property that has one-to-many relationship. The item "
"can be a row in a table or bound to a form. It displays the referenced "
"collection as an editable <classname>Table</classname> and allows adding and "
"removing items in it."
msgstr ""
"<classname>MasterDetailEditor</classname> 是一种 Field 组件, 可以编辑带一对多"
"关系的元素属性. 元素可以是表中的一行, 也可以绑定到 Form 上. 这个组件使用一个"
"可编辑的 <classname>Table</classname> 来显示主数据关联的详细数据, 并允许在 "
"<classname>Table</classname> 中添加和删除数据."

#. Tag: para
#: chapter-jpacontainer.xml:1716
#, no-c-format
msgid ""
"You can use the <classname>MasterDetailEditor</classname> manually, or "
"perhaps more commonly use a JPAContainer <classname>FieldFactory</classname> "
"to create it automatically. As shown in the example in <xref linkend="
"\"figure.jpacontainer.fieldfactory.using\"/>, the factory creates a "
"<classname>MasterDetailEditor</classname> for all properties with a "
"<literal>@OneToMany</literal> or an <literal>@ElementCollection</literal> "
"annotation."
msgstr ""
"你可以手动地使用 <classname>MasterDetailEditor</classname>, 更常见的方法是使"
"用 JPAContainer <classname>FieldFactory</classname> 来自动创建它. 在 <xref "
"linkend=\"figure.jpacontainer.fieldfactory.using\"/> 例子中已经展示过, "
"Factory 对所有带有 <literal>@OneToMany</literal> 注解或 "
"<literal>@ElementCollection</literal> 注解的属性, 都创建了 "
"<classname>MasterDetailEditor</classname>."

#. Tag: title
#: chapter-jpacontainer.xml:1732
#, no-c-format
msgid "Using JPAContainer with Hibernate"
msgstr "JPAContainer 与 Hibernate 的结合使用"

#. Tag: para
#: chapter-jpacontainer.xml:1734
#, no-c-format
msgid "Hibernate needs special handling in some cases."
msgstr "某些情况下, Hibernate 需要特别的处理."

#. Tag: title
#: chapter-jpacontainer.xml:1739
#, no-c-format
msgid "Lazy loading"
msgstr "延迟装载(Lazy loading)"

#. Tag: para
#: chapter-jpacontainer.xml:1741
#, no-c-format
msgid ""
"In order for lazy loading to work automatically, an entity must be attached "
"to an entity manager. Unfortunately, Hibernate can not keep entity managers "
"for long without problems. To work around the problem, you need to use a "
"special lazy loading delegate for Hibernate."
msgstr ""
"为了让延迟装载能够自动工作, 实体必须绑定到实体管理器上. 不幸的是, Hibernate "
"无法长期保持一个实体管理器. 为了绕过这个问题, 你必须对 Hibernate 使用一种特别"
"的延迟装载代理(delegate)."

#. Tag: para
#: chapter-jpacontainer.xml:1748
#, no-c-format
msgid ""
"JPAContainer entity providers handle lazy loading in delegates defined by "
"the <interfacename>LazyLoadingDelegate</interfacename> interface. The "
"default implementation for Hibernate is defined in "
"<classname>HibernateLazyLoadingDelegate</classname>. You can instantiate one "
"and use it in an entity provider with <methodname>setLazyLoadingDelegate()</"
"methodname>."
msgstr ""
"JPAContainer 的 Entity Provider 使用代理来处理延迟装载, 代理由 "
"<interfacename>LazyLoadingDelegate</interfacename> 接口定义. 针对 Hibernate "
"的默认实现定义在 <classname>HibernateLazyLoadingDelegate</classname>. 你可以"
"创建一个实例, 并通过 Entity Provider 的 "
"<methodname>setLazyLoadingDelegate()</methodname> 方法来使用它."

#. Tag: para
#: chapter-jpacontainer.xml:1757
#, no-c-format
msgid ""
"The default implementation works so that whenever a lazy property is "
"accessed through the Vaadin <interface>Property</interface> interface, the "
"value is retrieved with a separate (JPA Criteria API) query using the "
"currently active entity manager. The value is then manually attached to the "
"entity instance, which is detached from the entity manager. If this default "
"implementation is not good enough, you may need to make your own "
"implementation."
msgstr ""
"默认实现是可以工作的, 因此当通过 Vaadin <interface>Property</interface> 来访"
"问一个延迟装载的属性时, 属性值会使用当前活动的实体管理器, 通过一个独立的 "
"(JPA Criteria API) 查询来取得. 然后属性值会被手动关联到实体实例上, 而实体实例"
"会与实体管理器脱离关联(译注: 此句意义不明, 待校). 如果这种默认实现不能满足你"
"的需要, 你可能需要创建你自己的实现."

#. Tag: title
#: chapter-jpacontainer.xml:1769
#, no-c-format
msgid "The EntityManager-Per-Request pattern"
msgstr "每个请求一个实体管理器(EntityManager-Per-Request)模式"

#. Tag: para
#: chapter-jpacontainer.xml:1771
#, no-c-format
msgid ""
"One issue with Hibernate is that it is designed for short-lived sessions, "
"but the lifetime of an entity manager is normally roughly that of a user "
"session. The problem is that if an error occurs in a session or an entity "
"manager, the manager becomes unuseable. This causes big problems with long-"
"lived sessions that would work fine with EclipseLink."
msgstr ""
"使用 Hibernate 时的一个问题是, 它是设计用于短期 session 的, 但一个实体管理器"
"的生存周期通常大致等于一个用户 session. 问题是, 如果在 session 或实体管理器中"
"发生了错误, 实体管理器将处于不可用状态. 这就导致了长生存期 session 的问题, 而"
"在 EclipseLink 中不会出现这种问题."

#. Tag: para
#: chapter-jpacontainer.xml:1779
#, no-c-format
msgid ""
"The recommended solution is to use the <emphasis>EntityManager-per-Request</"
"emphasis> pattern. It is highly recommended always when using Hibernate."
msgstr ""
"推荐的解决方法是使用 <emphasis>每个请求一个实体管理器(EntityManager-per-"
"Request)</emphasis> 模式. 使用 Hibernate 时强烈推荐一定要使用这种模式."

#. Tag: para
#: chapter-jpacontainer.xml:1785
#, no-c-format
msgid ""
"An entity manager can only be open during the request-response cycle of the "
"Vaadin servlet, so that one is created at the beginning of the request and "
"closed at the end."
msgstr ""
"实体管理器只能在 Vaadin Servlet 的一次请求-相应周期之间打开, 因此实体管理器的"
"实例会在请求开始时创建, 并在请求结束时关闭."

#. Tag: title
#: chapter-jpacontainer.xml:1792
#, no-c-format
msgid "Storing an Entity Manager"
msgstr "保存实体管理器"

#. Tag: para
#: chapter-jpacontainer.xml:1794
#, no-c-format
msgid ""
"You first need to implement an <interfacename>EntityManagerProvider</"
"interfacename> that returns a stored <interfacename>EntityManager</"
"interfacename> with <methodname>getEntityManager()</methodname>. The entity "
"manager must be stored in a <classname>ThreadLocal</classname> variable."
msgstr ""
"你首先需要实现 <interfacename>EntityManagerProvider</interfacename> 接口, 它"
"通过 <methodname>getEntityManager()</methodname> 方法返回一个保存的 "
"<interfacename>EntityManager</interfacename>. 实体管理器必须保存在 "
"<classname>ThreadLocal</classname> 变量中."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1802
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class "
"LazyHibernateEntityManagerProvider\n"
"       implements EntityManagerProvider {\n"
"    private static ThreadLocal<EntityManager>\n"
"        entityManagerThreadLocal =\n"
"            new ThreadLocal<EntityManager>();\n"
"\n"
"    @Override\n"
"    public EntityManager getEntityManager() {\n"
"        return entityManagerThreadLocal.get();\n"
"    }\n"
"\n"
"    public static void setCurrentEntityManager(\n"
"                               EntityManager em) {\n"
"        entityManagerThreadLocal.set(em);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1804
#, no-c-format
msgid ""
"You need to create and store the per-request instance at the beginning of "
"each request with <methodname>setCurrentEntityManager()</methodname> and "
"clear it at the end by setting it as <literal>null</literal>."
msgstr ""
"在请求开始时, 你需要使用 <methodname>setCurrentEntityManager()</methodname> "
"方法创建并保存各个请求对应的实体管理器实例, 并在请求结束时将其设置为 "
"<literal>null</literal> 来清除它."

#. Tag: title
#: chapter-jpacontainer.xml:1813
#, no-c-format
msgid "Creating Entity Managers in a Servlet Filter"
msgstr "在 Servlet Filter 中创建实体管理器"

#. Tag: para
#: chapter-jpacontainer.xml:1815
#, no-c-format
msgid ""
"You can create the entity managers for each request either by extending "
"<classname>VaadinServlet</classname> and overriding the "
"<methodname>service()</methodname> method or by implementing a servlet "
"filter. In the following, we describe how to implement a servlet filter to "
"do the task, but overriding the servlet could be even easier."
msgstr ""
"你可以为各个请求创建实体管理器, 方法可以是继承 <classname>VaadinServlet</"
"classname> 并覆盖 <methodname>service()</methodname> 方法, 也可以实现一个 "
"Servlet Filter. 下例中, 我们介绍如何实现一个 Servlet Filter 来实现这个任务, "
"但覆盖 Servlet 会更简单."

#. Tag: programlisting
#: chapter-jpacontainer.xml:1824
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[public class LazyHibernateServletFilter\n"
"       implements Filter {\n"
"\n"
"    private EntityManagerFactory entityManagerFactory;\n"
"\n"
"    @Override\n"
"    public void init(FilterConfig filterConfig)\n"
"            throws ServletException {\n"
"        entityManagerFactory = Persistence\n"
"            .createEntityManagerFactory(\"lazyhibernate\");\n"
"    }\n"
"\n"
"    @Override\n"
"    public void doFilter(ServletRequest servletRequest,\n"
"                         ServletResponse servletResponse,\n"
"                         FilterChain filterChain)\n"
"            throws IOException, ServletException {\n"
"        try {\n"
"            // Create and set the entity manager\n"
"            LazyHibernateEntityManagerProvider\n"
"                .setCurrentEntityManager(\n"
"                    entityManagerFactory\n"
"                        .createEntityManager());\n"
"\n"
"            // Handle the request\n"
"            filterChain.doFilter(servletRequest,\n"
"                                 servletResponse);\n"
"        } finally {\n"
"            // Reset the entity manager\n"
"            LazyHibernateEntityManagerProvider\n"
"                    .setCurrentEntityManager(null);\n"
"        }\n"
"    }\n"
"\n"
"    @Override\n"
"    public void destroy() {\n"
"        entityManagerFactory = null;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1826
#, no-c-format
msgid ""
"You need to define the servlet filter in the <filename>web.xml</filename> "
"deployment descriptor as follows:"
msgstr ""
"你需要在部署描述文件 <filename>web.xml</filename> 中定义这个 Servlet "
"Filter  , 如下:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1831
#, no-c-format
msgid ""
"<?pocket-size 65% ?>&lt;filter&gt;\n"
"    &lt;filter-name&gt;<emphasis role=\"bold\">LazyHibernateServletFilter</"
"emphasis>&lt;/filter-name&gt;\n"
"    &lt;filter-class&gt;<emphasis role=\"bold\">com.example."
"LazyHibernateServletFilter</emphasis>&lt;/filter-class&gt;\n"
"&lt;/filter&gt;\n"
"&lt;filter-mapping&gt;\n"
"    &lt;filter-name&gt;<emphasis role=\"bold\">LazyHibernateServletFilter</"
"emphasis>&lt;/filter-name&gt;\n"
"    &lt;url-pattern&gt;<emphasis role=\"bold\">/*</emphasis>&lt;/url-"
"pattern&gt;\n"
"&lt;/filter-mapping&gt;"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1833
#, no-c-format
msgid ""
"The <literal>url-pattern</literal> must match the pattern for your Vaadin "
"servlet."
msgstr ""
"其中的 <literal>url-pattern</literal> 设置必须与你的 Vaadin servlet 对应的 "
"url-pattern 一致."

#. Tag: title
#: chapter-jpacontainer.xml:1841
#, no-c-format
msgid "Joins in Hibernate vs EclipseLink"
msgstr "Hibernate 与 EclipseLink 中的表连接(Join)对比"

#. Tag: para
#: chapter-jpacontainer.xml:1843
#, no-c-format
msgid ""
"EclipseLink supports implicit joins, while Hibernate requires explicit "
"joins. In SQL terms, an explicit join is a \"<literal>FROM a INNER JOIN b ON "
"a.bid = b.id</literal>\" expression, while an implicit join is done in a "
"WHERE clause, such as: \"<literal>FROM a,b WHERE a.bid = b.id</literal>\"."
msgstr ""
"EclipseLink 支持隐式表连接(join), 而 Hibernate 需要显式连接. 用 SQL 的术语来"
"说, 显式的连接也就是 \"<literal>FROM a INNER JOIN b ON a.bid = b.id</literal>"
"\" 表达式, 而隐式连接则在 WHERE 子句中实现, 比如: \"<literal>FROM a,b WHERE "
"a.bid = b.id</literal>\"."

#. Tag: para
#: chapter-jpacontainer.xml:1850
#, no-c-format
msgid ""
"In a JPAContainer filter with EclipseLink, an implicit join would have form:"
msgstr "使用 EclipseLink 时, JPAContainer 过滤中, 隐式连接可以是如下形式:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1855
#, no-c-format
msgid "<?pocket-size 65% ?><![CDATA[new Equal(\"skills.skill\", s)]]>"
msgstr ""

#. Tag: para
#: chapter-jpacontainer.xml:1857
#, no-c-format
msgid ""
"In Hibernate you would need to use <classname>JoinFilter</classname> for the "
"explicit join:"
msgstr ""
"在 Hibernate 中, 你需要使用 <classname>JoinFilter</classname> 来进行显式连接:"

#. Tag: programlisting
#: chapter-jpacontainer.xml:1862
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[new JoinFilter(\"skills\", new Equal(\"skill\", "
"s))]]>"
msgstr ""
