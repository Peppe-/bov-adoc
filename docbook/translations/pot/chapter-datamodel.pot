# SOME DESCRIPTIVE TITLE.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: http://bugs.kde.org\n"
"POT-Creation-Date: 2013-11-13 16:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <kde-i18n-doc@kde.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Tag: title
#: chapter-datamodel.xml:11
#, no-c-format
msgid "Binding Components to Data"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:14
#, no-c-format
msgid "<primary>Vaadin Data Model</primary>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:17
#, no-c-format
msgid "This chapter describes the Vaadin Data Model and shows how you can use it to bind components directly to data sources, such as database queries."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:23
#, no-c-format
msgid "Overview"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:25
#, no-c-format
msgid "The Vaadin Data Model is one of the core concepts of the library. To allow the view (user interface components) to access the data model of an application directly, we have introduced a standard data interface."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:31
#, no-c-format
msgid "The model allows binding user interface components directly to the data that they display and possibly allow to edit. There are three nested levels of hierarchy in the data model: <emphasis>property</emphasis>, <emphasis>item</emphasis>, and <emphasis>container</emphasis>. Using a spreadsheet application as an analogy, these would correspond to a cell, a row, and a table, respectively."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:41
#, no-c-format
msgid "<title>Vaadin Data Model</title>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:52
#, no-c-format
msgid "The Data Model is realized as a set of interfaces in the <classname>com.vaadin.data</classname> package. The package contains the <classname>Property</classname>, <classname>Item</classname>, and <classname>Container</classname> interfaces, along with a number of more specialized interfaces and classes."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:60
#, no-c-format
msgid "Notice that the Data Model does not define data representation, but only interfaces. This leaves the representation fully to the implementation of the containers. The representation can be almost anything, such as a plain old Java object (POJO) structure, a filesystem, or a database query."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:67
#, no-c-format
msgid "The Data Model is used heavily in the core user interface components of Vaadin, especially the field components, that is, components that implement the <classname>Field</classname> interface or more typically extend <classname>AbstractField</classname>, which defines many common features. A key feature of all the built-in field components is that they can either maintain their data by themselves or be bound to an external data source. The value of a field is always available through the <classname>Property</classname> interface. As more than one component can be bound to the same data source, it is easy to implement various viewer-editor patterns."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:80
#, no-c-format
msgid "The relationships of the various interfaces are shown in <xref linkend=\"figure.datamodel.overview.relationships\"/>; the value change event and listener interfaces are shown only for the <classname>Property</classname> interface, while the notifier interfaces are omitted altogether."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:88
#, no-c-format
msgid "Interface Relationships in Vaadin Data Model"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:99
#, no-c-format
msgid "The Data Model has many important and useful features, such as support for change notification. Especially containers have many helper interfaces, including ones that allow indexing, ordering, sorting, and filtering the data. Also <classname>Field</classname> components provide a number of features involving the data model, such as buffering, validation, and lazy loading."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:108
#, no-c-format
msgid "Vaadin provides a number of built-in implementations of the data model interfaces. The built-in implementations are used as the default data models in many field components."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:114
#, no-c-format
msgid "In addition to the built-in implementations, many data model implementations, such as containers, are available as add-ons, either from the Vaadin Directory or from independent sources. Both commercial and free implementations exist. The JPAContainer, described in <xref linkend=\"jpacontainer\"/>, is the most often used conmmercial container add-on. The installation of add-ons is described in <xref linkend=\"addons\"/>. Notice that unlike with most regular add-on components, you do not need to compile a widget set for add-ons that include just data model implementations."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:127
#, no-c-format
msgid "Properties"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:129
#, no-c-format
msgid "The <interfacename>Property</interfacename> interface is the base of the Vaadin Data Model. It provides a standardized API for a single data value object that can be read (get) and written (set). A property is always typed, but can optionally support data type conversions. The type of a property can be any Java class. Optionally, properties can provide value change events for following their changes."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:138
#, no-c-format
msgid "You can set the value of a property with <methodname>setValue()</methodname> and read with <methodname>getValue()</methodname>."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:143
#, no-c-format
msgid "In the following, we set and read the property value from a <classname>TextField</classname> component, which implements the <interfacename>Property</interfacename> interface to allow accessing the field value."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:151
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[final TextField tf = new TextField(\"Name\");\n"
"        \n"
"// Set the value\n"
"tf.setValue(\"The text field value\");\n"
"        \n"
"// When the field value is edited by the user\n"
"tf.addValueChangeListener(\n"
"    new Property.ValueChangeListener() {\n"
"    public void valueChange(ValueChangeEvent event) {\n"
"        // Do something with the new value\n"
"        layout.addComponent(new Label(tf.getValue()));\n"
"    }\n"
"});]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:153
#, no-c-format
msgid "Changes in the property value usually fire a <classname>ValueChangeEvent</classname>, which can be handled with a <classname>ValueChangeListener</classname>. The event object provides reference to the property with <methodname>getProperty()</methodname>. Note that its <methodname>getValue()</methodname> method returns the value with <classname>Object</classname> type, so you need to cast it to the proper type."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:163
#, no-c-format
msgid "Properties are in themselves unnamed. They are collected in <emphasis>items</emphasis>, which associate the properties with names: the <emphasis>Property Identifiers</emphasis> or <emphasis>PID</emphasis>s. Items can be further contained in containers and are identified with <emphasis>Item Identifiers</emphasis> or <emphasis>IID</emphasis>s. In the spreadsheet analogy, <emphasis>Property Identifiers</emphasis> would correspond to column names and <emphasis>Item Identifiers</emphasis> to row names. The identifiers can be arbitrary objects, but must implement the <methodname>equals(Object)</methodname> and <methodname>hashCode()</methodname> methods so that they can be used in any standard Java <classname>Collection</classname>."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:177
#, no-c-format
msgid "The <classname>Property</classname> interface can be utilized either by implementing the interface or by using some of the built-in property implementations. Vaadin includes a <classname>Property</classname> interface implementation for arbitrary function pairs and bean properties, with the <classname>MethodProperty</classname> class, and for simple object properties, with the <classname>ObjectProperty</classname> class, as described later."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:186
#, no-c-format
msgid "In addition to the simple components, many selection components such as <classname>Select</classname>, <classname>Table</classname>, and <classname>Tree</classname> provide their current selection through the <classname>Property</classname> property. In single selection mode, the property is a single item identifier, while in multiple selection mode it is a set of item identifiers. Please see the documentation of the selection components for further details."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:196
#, no-c-format
msgid "Components that can be bound to a property have an internal default data source object, typically a <classname>ObjectProperty</classname>, which is described later. As all such components are viewers or editors, also described later, so you can rebind a component to any data source with <methodname>setPropertyDataSource()</methodname>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:205
#, no-c-format
msgid "Property Viewers and Editors"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:207
#, no-c-format
msgid "The most important function of the <classname>Property</classname> as well as of the other data model interfaces is to connect classes implementing the interface directly to editor and viewer classes. This means connecting a data source (model) to a user interface component (views) to allow editing or viewing the data model."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:215
#, no-c-format
msgid "A property can be bound to a component implementing the <classname>Viewer</classname> interface with <methodname>setPropertyDataSource()</methodname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:221
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a data model\n"
"ObjectProperty property =\n"
"    new ObjectProperty(\"Hello\", String.class);\n"
"        \n"
"// Have a component that implements Viewer\n"
"Label viewer = new Label();\n"
"        \n"
"// Bind it to the data\n"
"viewer.setPropertyDataSource(property);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:223
#, no-c-format
msgid "You can use the same method in the <classname>Editor</classname> interface to bind a component that allows editing a particular property type to a property."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:229
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a data model\n"
"ObjectProperty property =\n"
"    new ObjectProperty(\"Hello\", String.class);\n"
"        \n"
"// Have a component that implements Viewer\n"
"TextField editor = new TextField(\"Edit Greeting\");\n"
"        \n"
"// Bind it to the data\n"
"editor.setPropertyDataSource(property);\n"
"]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:231
#, no-c-format
msgid "As all field components implement the <classname>Property</classname> interface, you can bind any component implementing the <classname>Viewer</classname> interface to any field, assuming that the viewer is able the view the object type of the field. Continuing from the above example, we can bind a <classname>Label</classname> to the <classname>TextField</classname> value:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:240
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Label viewer = new Label();\n"
"viewer.setPropertyDataSource(editor);\n"
"\n"
"// The value shown in the viewer is updated immediately\n"
"// after editing the value in the editor (once it\n"
"// loses the focus)\n"
"editor.setImmediate(true);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:242
#, no-c-format
msgid "If a field has validators, as described in <xref linkend=\"components.fields.validation\"/>, the validators are executed before writing the value to the property data source, or by calling the <methodname>validate()</methodname> or <methodname>commit()</methodname> for the field."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:252
#, no-c-format
msgid "<classname>ObjectProperty</classname> Implementation"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:254
#, no-c-format
msgid "The <classname>ObjectProperty</classname> class is a simple implementation of the <classname>Property</classname> interface that allows storing an arbitrary Java object."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:260
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a component that implements Viewer interface\n"
"final TextField tf = new TextField(\"Name\");\n"
"        \n"
"// Have a data model with some data\n"
"String myObject = \"Hello\";\n"
"        \n"
"// Wrap it in an ObjectProperty\n"
"ObjectProperty property =\n"
"    new ObjectProperty(myObject, String.class);\n"
"        \n"
"// Bind the property to the component\n"
"tf.setPropertyDataSource(property);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:265
#, no-c-format
msgid "Converting Between Property Type and Representation"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:267
#, no-c-format
msgid "Fields allow editing a certain type, such as a <classname>String</classname> or <classname>Date</classname>. The bound property, on the other hand, could have some entirely different type. Conversion between a representation edited by the field and the model defined in the property is handler with a converter that implements the <interfacename>Converter</interfacename> interface."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:276
#, no-c-format
msgid "Most common type conversions, such as between string and integer, are handled by the default converters. They are created in a converter factory global in the application."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:283
#, no-c-format
msgid "Basic Use of Converters"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:285
#, no-c-format
msgid "The <methodname>setConverter(<interfacename>Converter</interfacename>)</methodname> method sets the converter for a field. The method is defined in <classname>AbstractField</classname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:292
#, no-c-format
msgid ""
"<![CDATA[// Have an integer property\n"
"final ObjectProperty<Integer> property =\n"
"        new ObjectProperty<Integer>(42); \n"
"        \n"
"// Create a TextField, which edits Strings\n"
"final TextField tf = new TextField(\"Name\");\n"
"\n"
"// Use a converter between String and Integer\n"
"tf.setConverter(new StringToIntegerConverter());\n"
"\n"
"// And bind the field\n"
"tf.setPropertyDataSource(property);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:294
#, no-c-format
msgid "The built-in converters are the following:"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:299
#, no-c-format
msgid "Built-in Converters"
msgstr ""

#. Tag: entry
#: chapter-datamodel.xml:306
#, no-c-format
msgid "Converter"
msgstr ""

#. Tag: entry
#: chapter-datamodel.xml:307
#, no-c-format
msgid "Representation"
msgstr ""

#. Tag: entry
#: chapter-datamodel.xml:308
#, no-c-format
msgid "Model"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:313
#, no-c-format
msgid "StringToIntegerConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:314 chapter-datamodel.xml:319
#: chapter-datamodel.xml:324 chapter-datamodel.xml:329
#: chapter-datamodel.xml:334
#, no-c-format
msgid "String"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:315
#, no-c-format
msgid "Integer"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:318
#, no-c-format
msgid "StringToDoubleConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:320
#, no-c-format
msgid "Double"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:323
#, no-c-format
msgid "StringToNumberConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:325
#, no-c-format
msgid "Number"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:328
#, no-c-format
msgid "StringToBooleanConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:330
#, no-c-format
msgid "Boolean"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:333
#, no-c-format
msgid "StringToDateConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:335 chapter-datamodel.xml:339
#, no-c-format
msgid "Date"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:338
#, no-c-format
msgid "DateToLongConverter"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:340
#, no-c-format
msgid "Long"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:346
#, no-c-format
msgid "In addition, there is a <classname>ReverseConverter</classname> that takes a converter as a parameter and reverses the conversion direction."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:352
#, no-c-format
msgid "If a converter already exists for a type, the <methodname>setConverter(<interfacename>Class</interfacename>)</methodname> retrieves the converter for the given type from the converter factory, and then sets it for the field. This method is used implicitly when binding field to a property data source."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:362
#, no-c-format
msgid "Implementing a Converter"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:364
#, no-c-format
msgid "A conversion always occurs between a <emphasis>representation type</emphasis>, edited by the field component, and a <emphasis>model type</emphasis>, that is, the type of the property data source. Converters implement the <interfacename>Converter</interfacename> interface defined in the <package>com.vaadin.data.util.converter</package> package."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:373
#, no-c-format
msgid "For example, let us assume that we have a simple <classname>Complex</classname> type for storing complex values."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:378
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[public class ComplexConverter\n"
"       implements Converter<String, Complex> {\n"
"    @Override\n"
"    public Complex convertToModel(String value, Locale locale)\n"
"            throws ConversionException {\n"
"        String parts[] =\n"
"            value.replaceAll(\"[\\\\(\\\\)]\", \"\").split(\",\");\n"
"        if (parts.length != 2)\n"
"            throw new ConversionException(\n"
"                    \"Unable to parse String to Complex\");\n"
"        return new Complex(Double.parseDouble(parts[0]),\n"
"                           Double.parseDouble(parts[1]));\n"
"    }\n"
"\n"
"    @Override\n"
"    public String convertToPresentation(Complex value,\n"
"                                        Locale locale)\n"
"            throws ConversionException {\n"
"        return \"(\"+value.getReal()+\",\"+value.getImag()+\")\";\n"
"    }\n"
"\n"
"    @Override\n"
"    public Class<Complex> getModelType() {\n"
"        return Complex.class;\n"
"    }\n"
"\n"
"    @Override\n"
"    public Class<String> getPresentationType() {\n"
"        return String.class;\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:380
#, no-c-format
msgid "The conversion methods get the locale for the conversion as a parameter."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:387
#, no-c-format
msgid "Converter Factory"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:389
#, no-c-format
msgid "If a field does not directly allow editing a property type, a default converter is attempted to create using an application-global converter factory. If you define your own converters that you wish to include in the converter factory, you need to implement one yourself. While you could implement the <interfacename>ConverterFactory</interfacename> interface, it is usually easier to just extend <classname>DefaultConverterFactory</classname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:399
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyConverterFactory extends DefaultConverterFactory {\n"
"    @Override\n"
"    public <PRESENTATION, MODEL> Converter<PRESENTATION, MODEL>\n"
"            createConverter(Class<PRESENTATION> presentationType,\n"
"                            Class<MODEL> modelType) {\n"
"        // Handle one particular type conversion\n"
"        if (String.class == presentationType &&\n"
"            Complex.class == modelType)\n"
"            return (Converter<PRESENTATION, MODEL>)\n"
"                   new ComplexConverter();\n"
"\n"
"        // Default to the supertype\n"
"        return super.createConverter(presentationType,\n"
"                                     modelType);\n"
"    }\n"
"}\n"
"\n"
"// Use the factory globally in the application\n"
"Application.getCurrentApplication().setConverterFactory(\n"
"        new MyConverterFactory());]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:404
#, no-c-format
msgid "Implementing the <classname>Property</classname> Interface"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:406
#, no-c-format
msgid "Implementation of the <classname>Property</classname> interface requires defining setters and getters for the value and the <emphasis>read-only</emphasis> mode. Only a getter is needed for the property type, as the type is often fixed in property implementations."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:413
#, no-c-format
msgid "The following example shows a simple implementation of the <classname>Property</classname> interface:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:418
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyProperty implements Property {\n"
"    Integer data     = 0;\n"
"    boolean readOnly = false;\n"
"    \n"
"    // Return the data type of the model\n"
"    public Class<?> getType() {\n"
"        return Integer.class;\n"
"    }\n"
"\n"
"    public Object getValue() {\n"
"        return data;\n"
"    }\n"
"    \n"
"    // Override the default implementation in Object\n"
"    @Override\n"
"    public String toString() {\n"
"        return Integer.toHexString(data);\n"
"    }\n"
"\n"
"    public boolean isReadOnly() {\n"
"        return readOnly;\n"
"    }\n"
"\n"
"    public void setReadOnly(boolean newStatus) {\n"
"        readOnly = newStatus;\n"
"    }\n"
"\n"
"    public void setValue(Object newValue)\n"
"            throws ReadOnlyException, ConversionException {\n"
"        if (readOnly)\n"
"            throw new ReadOnlyException();\n"
"            \n"
"        // Already the same type as the internal representation\n"
"        if (newValue instanceof Integer)\n"
"            data = (Integer) newValue;\n"
"        \n"
"        // Conversion from a string is required\n"
"        else if (newValue instanceof String)\n"
"            try {\n"
"                data = Integer.parseInt((String) newValue, 16);\n"
"            } catch (NumberFormatException e) {\n"
"                throw new ConversionException();\n"
"            }\n"
"        else\n"
"             // Don't know how to convert any other types\n"
"            throw new ConversionException();\n"
"\n"
"        // Reverse decode the hexadecimal value\n"
"    }\n"
"}\n"
"        \n"
"// Instantiate the property and set its data\n"
"MyProperty property = new MyProperty();\n"
"property.setValue(42);\n"
"        \n"
"// Bind it to a component\n"
"final TextField tf = new TextField(\"Name\", property);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:420
#, no-c-format
msgid "The components get the displayed value by the <methodname>toString()</methodname> method, so it is necessary to override it. To allow editing the value, value returned in the <methodname>toString()</methodname> must be in a format that is accepted by the <methodname>setValue()</methodname> method, unless the property is read-only. The <methodname>toString()</methodname> can perform any type conversion necessary to make the internal type a string, and the <methodname>setValue()</methodname> must be able to make a reverse conversion."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:432
#, no-c-format
msgid "The implementation example does not notify about changes in the property value or in the read-only mode. You should normally also implement at least the <classname>Property.ValueChangeNotifier</classname> and <classname>Property.ReadOnlyStatusChangeNotifier</classname>. See the <classname>ObjectProperty</classname> class for an example of the implementation."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:444
#, no-c-format
msgid "Holding properties in Items"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:446
#, no-c-format
msgid "The <classname>Item</classname> interface provides access to a set of named properties. Each property is identified by a <emphasis>property identifier</emphasis> (PID) and a reference to such a property can be queried from an <classname>Item</classname> with <methodname>getItemProperty()</methodname> using the identifier."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:454
#, no-c-format
msgid "Examples on the use of items include rows in a <classname>Table</classname>, with the properties corresponding to table columns, nodes in a <classname>Tree</classname>, and the the data bound to a <classname>Form</classname>, with item's properties bound to individual form fields."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:462
#, no-c-format
msgid "Items are generally equivalent to objects in the object-oriented model, but with the exception that they are configurable and provide an event handling mechanism. The simplest way to utilize <classname>Item</classname> interface is to use existing implementations. Provided utility classes include a configurable property set (<classname>PropertysetItem</classname>) and a bean-to-item adapter (<classname>BeanItem</classname>). Also, a <classname>Form</classname> implements the interface and can therefore be used directly as an item."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:473
#, no-c-format
msgid "In addition to being used indirectly by many user interface components, items provide the basic data model underlying the <classname>Form</classname> component. In simple cases, forms can even be generated automatically from items. The properties of the item correspond to the fields of the form."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:480
#, no-c-format
msgid "The <classname>Item</classname> interface defines inner interfaces for maintaining the item property set and listening changes made to it. <classname>PropertySetChangeEvent</classname> events can be emitted by a class implementing the <classname>PropertySetChangeNotifier</classname> interface. They can be received through the <classname>PropertySetChangeListener</classname> interface."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:490
#, no-c-format
msgid "The <classname>PropertysetItem</classname> Implementation"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:492
#, no-c-format
msgid "The <classname>PropertysetItem</classname> is a generic implementation of the <classname>Item</classname> interface that allows storing properties. The properties are added with <methodname>addItemProperty()</methodname>, which takes a name and the property as parameters."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:500
#, no-c-format
msgid "The following example demonstrates a typical case of collecting <classname>ObjectProperty</classname> properties in an item:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:505
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty(\"Zaphod\"));\n"
"item.addItemProperty(\"age\", new ObjectProperty(42));\n"
"        \n"
"// Bind it to a component\n"
"Form form = new Form();\n"
"form.setItemDataSource(item);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:510
#, no-c-format
msgid "Wrapping a Bean in a <classname>BeanItem</classname>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:512
#, no-c-format
msgid "The <classname>BeanItem</classname> implementation of the <classname>Item</classname> interface is a wrapper for Java Bean objects. In fact, only the setters and getters are required while serialization and other bean features are not, so you can wrap almost any POJOs with minimal requirements."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:520
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a bean (or more exactly a POJO)\n"
"class Person {\n"
"    String name;\n"
"    int    age;\n"
"    \n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"    \n"
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
"    \n"
"    public Integer getAge() {\n"
"        return age;\n"
"    }\n"
"    \n"
"    public void setAge(Integer age) {\n"
"        this.age = age.intValue();\n"
"    }\n"
"}\n"
"\n"
"// Create an instance of the bean\n"
"Person bean = new Person();\n"
"        \n"
"// Wrap it in a BeanItem\n"
"BeanItem<Person> item = new BeanItem<Person>(bean);\n"
"        \n"
"// Bind it to a component\n"
"Form form = new Form();\n"
"form.setItemDataSource(item);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:522
#, no-c-format
msgid "You can use the <methodname>getBean()</methodname> method to get a reference to the underlying bean."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:528
#, no-c-format
msgid "Nested Beans"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:530
#, no-c-format
msgid "You may often have composite classes where one class \"has a\" another class. For example, consider the following <classname>Planet</classname> class which \"has a\" discoverer:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:536
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a bean with two nested beans\n"
"public class Planet implements Serializable {\n"
"    String name;\n"
"    Person discoverer;\n"
"    \n"
"    public Planet(String name, Person discoverer) {\n"
"        this.name = name;\n"
"        this.discoverer = discoverer;\n"
"    }\n"
"\n"
"    ... getters and setters ...\n"
"}\n"
"\n"
"...\n"
"// Create an instance of the bean\n"
"Planet planet = new Planet(\"Uranus\",\n"
"                    new Person(\"William Herschel\", 1738));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:538
#, no-c-format
msgid "When shown in a <classname>Form</classname>, for example, you would want to list the properties of the nested bean along the properties of the composite bean. You can do that by binding the properties of the nested bean individually with a <classname>MethodProperty</classname> or <classname>NestedMethodProperty</classname>. You should usually hide the nested bean from binding as a property by listing only the bound properties in the constructor."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:548
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Wrap it in a BeanItem and hide the nested bean property\n"
"BeanItem<Planet> item = new BeanItem<Planet>(planet,\n"
"        new String[]{\"name\"});\n"
"    \n"
"// Bind the nested properties.\n"
"// Use NestedMethodProperty to bind using dot notation.\n"
"item.addItemProperty(\"discoverername\",\n"
"    new NestedMethodProperty(planet, \"discoverer.name\"));\n"
"    \n"
"// The other way is to use regular MethodProperty.\n"
"item.addItemProperty(\"discovererborn\",\n"
"     new MethodProperty<Person>(planet.getDiscoverer(),\n"
"                                \"born\"));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:550
#, no-c-format
msgid "The difference is that <classname>NestedMethodProperty</classname> does not access the nested bean immediately but only when accessing the property values, while when using <classname>MethodProperty</classname> the nested bean is accessed when creating the method property. The difference is only significant if the nested bean can be null or be changed later."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:559
#, no-c-format
msgid "You can use such a bean item for example in a <classname>Form</classname> as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:564
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Bind it to a component\n"
"Form form = new Form();\n"
"form.setItemDataSource(item);\n"
"    \n"
"// Nicer captions\n"
"form.getField(\"discoverername\").setCaption(\"Discoverer\");\n"
"form.getField(\"discovererborn\").setCaption(\"Born\");]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:567
#, no-c-format
msgid "A <classname>Form</classname> with Nested Bean Properties"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:575
#, no-c-format
msgid "The <classname>BeanContainer</classname> and <classname>BeanItemContainer</classname> allow easy definition of nested bean properties with <methodname>addNestedContainerProperty()</methodname>, as described in <xref linkend=\"datamodel.container.beancontainer.nestedproperties\"/>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:588
#, no-c-format
msgid "Creating Forms by Binding Fields to Items"
msgstr ""

#. Tag: emphasis
#: chapter-datamodel.xml:591
#, no-c-format
msgid "Because of pressing release schedules to get this edition to your hands, we were unable to completely update this chapter. Some form handling is still under work, especially form validation."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:596
#, no-c-format
msgid "Most applications in existence have forms of some sort. Forms contain fields, which you want to bind to a data source, an item in the Vaadin data model. <classname>FieldGroup</classname> provides an easy way to bind fields to the properties of an item. You can use it by first creating a layout with some fields, and then call it to bind the fields to the data source. You can also let the <classname>FieldGroup</classname> create the fields using a field factory. It can also handle commits. Notice that <classname>FieldGroup</classname> is not a user interface component, so you can not add it to a layout."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:609
#, no-c-format
msgid "Simple Binding"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:612
#, no-c-format
msgid "Let us start with a data model that has an item with a couple of properties. The item could be any item type, as described earlier."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:617
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an item\n"
"PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty<String>(\"Zaphod\"));\n"
"item.addItemProperty(\"age\", new ObjectProperty<Integer>(42));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:619
#, no-c-format
msgid "Next, you would design a form for editing the data. The <classname>FormLayout</classname> (<xref linkend=\"layout.formlayout\"/> is ideal for forms, but you could use any other layout as well."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:625
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have some layout and create the fields\n"
"FormLayout form = new FormLayout();\n"
"\n"
"TextField nameField = new TextField(\"Name\");\n"
"form.addComponent(nameField);\n"
"\n"
"TextField ageField = new TextField(\"Age\");\n"
"form.addComponent(ageField);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:627
#, no-c-format
msgid "Then, we can bind the fields to the data as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:631
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Now create the binder and bind the fields\n"
"FieldGroup binder = new FieldGroup(item);\n"
"binder.bind(nameField, \"name\");\n"
"binder.bind(ageField, \"age\");]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:633
#, no-c-format
msgid "The above way of binding is not different from simply calling <methodname>setPropertyDataSource()</methodname> for the fields. It does, however, register the fields in the field group, which for example enables buffering or validation of the fields using the field group, as described in <xref linkend=\"datamodel.itembinding.buffering\"/>."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:641
#, no-c-format
msgid "Next, we consider more practical uses for a <classname>FieldGroup</classname>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:650
#, no-c-format
msgid "Using a <interfacename>FieldFactory</interfacename> to Build and Bind Fields"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:652
#, no-c-format
msgid "Using the <methodname>buildAndBind()</methodname> methods, <classname>FieldGroup</classname> can create fields for you using a <interfacename>FieldGroupFieldFactory</interfacename>, but you still have to add them to the correct position in your layout."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:659
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Have some layout\n"
"FormLayout form = new FormLayout();\n"
"        \n"
"// Now create a binder that can also create the fields\n"
"// using the default field factory\n"
"FieldGroup binder = new FieldGroup(item);\n"
"form.addComponent(binder.buildAndBind(\"Name\", \"name\"));\n"
"form.addComponent(binder.buildAndBind(\"Age\", \"age\"));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:663
#, no-c-format
msgid "Binding Member Fields"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:665
#, no-c-format
msgid "The <methodname>bindMemberFields()</methodname> method in <classname>FieldGroup</classname> uses reflection to bind the properties of an item to field components that are member variables of a class. Hence, if you implement a form as a class with the fields stored as member variables, you can use this method to bind them super-easy."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:673
#, no-c-format
msgid "The item properties are mapped to the members by the property ID and the name of the member variable. If you want to map a property with a different ID to a member, you can use the <literal>@PropertyId</literal> annotation for the member, with the property ID as the parameter."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:680
#, no-c-format
msgid "For example:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:685
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an item\n"
"PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty<String>(\"Zaphod\"));\n"
"item.addItemProperty(\"age\", new ObjectProperty<Integer>(42));\n"
"\n"
"// Define a form as a class that extends some layout\n"
"class MyForm extends FormLayout {\n"
"    // Member that will bind to the \"name\" property\n"
"    TextField name = new TextField(\"Name\");\n"
"    \n"
"    // Member that will bind to the \"age\" property \n"
"    @PropertyId(\"age\")\n"
"    TextField ageField = new TextField(\"Age\");\n"
"    \n"
"    public MyForm() {\n"
"        // Customize the layout a bit\n"
"        setSpacing(true);\n"
"        \n"
"        // Add the fields\n"
"        addComponent(name);\n"
"        addComponent(ageField);\n"
"    }\n"
"}\n"
"        \n"
"// Create one\n"
"MyForm form = new MyForm();\n"
"        \n"
"// Now create a binder that can also creates the fields\n"
"// using the default field factory\n"
"FieldGroup binder = new FieldGroup(item);\n"
"binder.bindMemberFields(form);\n"
"\n"
"// And the form can be used in an higher-level layout\n"
"layout.addComponent(form);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:688
#, no-c-format
msgid "Encapsulating in <classname>CustomComponent</classname>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:690
#, no-c-format
msgid "Using a <classname>CustomComponent</classname> can be better for hiding the implementation details than extending a layout. Also, the use of the <classname>FieldGroup</classname> can be encapsulated in the form class."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:696
#, no-c-format
msgid "Consider the following as an alternative for the form implementation presented earlier:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:702
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// A form component that allows editing an item\n"
"class MyForm extends CustomComponent {\n"
"    // Member that will bind to the \"name\" property\n"
"    TextField name = new TextField(\"Name\");\n"
"    \n"
"    // Member that will bind to the \"age\" property \n"
"    @PropertyId(\"age\")\n"
"    TextField ageField = new TextField(\"Age\");\n"
"    \n"
"    public MyForm(Item item) {\n"
"        FormLayout layout = new FormLayout();\n"
"        layout.addComponent(name);\n"
"        layout.addComponent(ageField);\n"
"        \n"
"        // Now use a binder to bind the members\n"
"        FieldGroup binder = new FieldGroup(item);\n"
"        binder.bindMemberFields(this);\n"
"\n"
"        setCompositionRoot(layout);\n"
"    }\n"
"}\n"
"        \n"
"// And the form can be used as a component\n"
"layout.addComponent(new MyForm(item));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:707
#, no-c-format
msgid "Buffering Forms"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:709
#, no-c-format
msgid "Just like for individual fields, as described in <xref linkend=\"components.fields.buffering\"/>, a <classname>FieldGroup</classname> can handle buffering the form content so that it is written to the item data source only when <methodname>commit()</methodname> is called for the group. It runs validation for all fields in the group and writes their values to the item data source only if all fields pass the validation. Edits can be discarded, so that the field values are reloaded from the data source, by calling <methodname>discard()</methodname>. Buffering is enabled by default, but can be disabled by calling <methodname>setBuffered(false)</methodname> for the <classname>FieldGroup</classname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:725
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have an item of some sort\n"
"final PropertysetItem item = new PropertysetItem();\n"
"item.addItemProperty(\"name\", new ObjectProperty<String>(\"Q\"));\n"
"item.addItemProperty(\"age\",  new ObjectProperty<Integer>(42));\n"
"\n"
"// Have some layout and create the fields\n"
"Panel form = new Panel(\"Buffered Form\");\n"
"form.setContent(new FormLayout());\n"
"\n"
"// Build and bind the fields using the default field factory\n"
"final FieldGroup binder = new FieldGroup(item);\n"
"form.addComponent(binder.buildAndBind(\"Name\", \"name\"));\n"
"form.addComponent(binder.buildAndBind(\"Age\",  \"age\"));\n"
"\n"
"// Enable buffering (actually enabled by default)\n"
"binder.setBuffered(true);\n"
"        \n"
"// A button to commit the buffer\n"
"form.addComponent(new Button(\"OK\", new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        try {\n"
"            binder.commit();\n"
"            Notification.show(\"Thanks!\");\n"
"        } catch (CommitException e) {\n"
"            Notification.show(\"You fail!\");\n"
"        }\n"
"    }\n"
"}));\n"
"\n"
"// A button to discard the buffer\n"
"form.addComponent(new Button(\"Discard\", new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        binder.discard();\n"
"        Notification.show(\"Discarded!\");\n"
"    }\n"
"}));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:729
#, no-c-format
msgid "Binding Fields to a Bean"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:731
#, no-c-format
msgid "The <classname>BeanFieldGroup</classname> makes it easier to bind fields to a bean. It also handles binding to nested beans properties. The build a field bound to a nested bean property, identify the property with dot notation. For example, if a <classname>Person</classname> bean has a <literal>address</literal> property with an <classname>Address</classname> type, which in turn has a <literal>street</literal> property, you could build a field bound to the property with <methodname>buildAndBind(\"Street\", \"address.street\")</methodname>."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:742
#, no-c-format
msgid "The input to fields bound to a bean can be validated using the Java Bean Validation API, as described in <xref linkend=\"datamodel.itembinding.beanvalidation\"/>. The <classname>BeanFieldGroup</classname> automatically adds a <classname>BeanValidator</classname> to every field if a bean validation implementation is included in the classpath."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:753
#, no-c-format
msgid "Bean Validation"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:755
#, no-c-format
msgid "Vaadin allows using the Java Bean Validation API 1.0 (JSR-303) for validating input from fields bound to bean properties before the values are committed to the bean. The validation is done based on annotations on the bean properties, which are used for creating the actual validators automatically. See <xref linkend=\"components.fields.validation\"/> for general information about validation."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:764
#, no-c-format
msgid "Using bean validation requires an implementation of the Bean Validation API, such as Hibernate Validator (<filename>hibernate-validator-4.2.0.Final.jar</filename> or later) or Apache Bean Validation. The implementation JAR must be included in the project classpath when using the bean validation, or otherwise an internal error is thrown."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:773
#, no-c-format
msgid "Bean validation is especially useful when persisting entity beans with the Vaadin JPAContainer, described in <xref linkend=\"jpacontainer\"/>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:779
#, no-c-format
msgid "Annotations"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:781
#, no-c-format
msgid "The validation constraints are defined as annotations. For example, consider the following bean:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:786
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a bean\n"
"public class Person implements Serializable {\n"
"    @NotNull\n"
"    @javax.validation.constraints.Size(min=2, max=10)\n"
"    String name;\n"
"    \n"
"    @Min(1)\n"
"    @Max(130)\n"
"    int age;\n"
"    \n"
"    // ... setters and getters ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:788
#, no-c-format
msgid "For a complete list of allowed constraints for different data types, please see the <link xlink:href=\"http://docs.oracle.com/javaee/6/tutorial/doc/gircz.html\">Bean Validation API documentation</link>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:797
#, no-c-format
msgid "Validating the Beans"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:799
#, no-c-format
msgid "Validating a bean is done with a <classname>BeanValidator</classname>, which you initialize with the name of the bean property it should validate and add it the the editor field."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:805
#, no-c-format
msgid "In the following example, we validate a single unbuffered field:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:809
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[Person bean = new Person(\"Mung bean\", 100);\n"
"BeanItem<Person> item = new BeanItem<Person> (bean);\n"
"    \n"
"// Create an editor bound to a bean field\n"
"TextField firstName = new TextField(\"First Name\",\n"
"        item.getItemProperty(\"name\"));\n"
"    \n"
"// Add the bean validator\n"
"firstName.addValidator(new BeanValidator(Person.class, \"name\"));\n"
"    \n"
"firstName.setImmediate(true);\n"
"layout.addComponent(firstName);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:811
#, no-c-format
msgid "In this case, the validation is done immediately after focus leaves the field. You could do the same for the other field as well."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:816
#, no-c-format
msgid "Bean validators are automatically created when using a <classname>BeanFieldGroup</classname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:821
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Have a bean\n"
"Person bean = new Person(\"Mung bean\", 100);\n"
"        \n"
"// Form for editing the bean\n"
"final BeanFieldGroup<Person> binder =\n"
"        new BeanFieldGroup<Person>(Person.class);\n"
"binder.setItemDataSource(bean);\n"
"layout.addComponent(binder.buildAndBind(\"Name\", \"name\"));\n"
"layout.addComponent(binder.buildAndBind(\"Age\", \"age\"));\n"
"\n"
"// Buffer the form content\n"
"binder.setBuffered(true);\n"
"layout.addComponent(new Button(\"OK\", new ClickListener() {\n"
"    @Override\n"
"    public void buttonClick(ClickEvent event) {\n"
"        try {\n"
"            binder.commit();\n"
"        } catch (CommitException e) {\n"
"        }\n"
"    }\n"
"}));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:825
#, no-c-format
msgid "Locale Setting for Bean Validation"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:827
#, no-c-format
msgid "The validation error messages are defined in the bean validation implementation, in a <filename>ValidationMessages.properties</filename> file. The message is shown in the language specified with the locale setting for the form. The default language is English, but for example Hibernate Validator contains translations of the messages for a number of languages. If other languages are needed, you need to provide a translation of the properties file."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:842
#, no-c-format
msgid "Collecting Items in Containers"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:845
#, no-c-format
msgid "<classname>Container</classname>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:848
#, no-c-format
msgid "The <classname>Container</classname> interface is the highest containment level of the Vaadin data model, for containing items (rows) which in turn contain properties (columns). Containers can therefore represent tabular data, which can be viewed in a <classname>Table</classname> or some other selection component, as well as hierarchical data."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:856
#, no-c-format
msgid "The items contained in a container are identified by an <emphasis>item identifier</emphasis> or <emphasis>IID</emphasis>, and the properties by a <emphasis>property identifier</emphasis> or <emphasis>PID</emphasis>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:863
#, no-c-format
msgid "Basic Use of Containers"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:865
#, no-c-format
msgid "The basic use of containers involves creating one, adding items to it, and binding it as a container data source of a component."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:871
#, no-c-format
msgid "Default Containers and Delegation"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:873
#, no-c-format
msgid "Before saying anything about creation of containers, it should be noted that all components that can be bound to a container data source are by default bound to a default container. For example, <classname>Table</classname> is bound to a <classname>IndexedContainer</classname>, <classname>Tree</classname> to a <classname>HierarchicalContainer</classname>, and so forth."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:882
#, no-c-format
msgid "All of the user interface components using containers also implement the relevant container interfaces themselves, so that the access to the underlying data source is delegated through the component."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:888
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create a table with one column\n"
"Table table = new Table(\"My Table\");\n"
"table.addContainerProperty(\"col1\", String.class, null);\n"
"\n"
"// Access items and properties through the component\n"
"table.addItem(\"row1\"); // Create item by explicit ID\n"
"Item item1 = table.getItem(\"row1\");\n"
"Property property1 = table.getItemProperty(\"col1\");\n"
"property1.setValue(\"some given value\");\n"
"\n"
"// Equivant access through the container\n"
"Container container = table.getContainerDataSource();\n"
"container.addItem(\"row2\");\n"
"Item item2 = container.getItem(\"row2\");\n"
"Property property2 = table.getItemProperty(\"col1\");\n"
"property2.setValue(\"another given value\");]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:892
#, no-c-format
msgid "Creating and Binding a Container"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:894
#, no-c-format
msgid "A container is created and bound to a component as follows:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:898
#, no-c-format
msgid ""
"<?pocket-size 70% ?><![CDATA[// Create a container\n"
"Container container = new IndexedContainer();\n"
"\n"
"// Define the properties (columns) if required by container\n"
"container.addContainerProperty(\"name\", String.class, \"none\");\n"
"container.addContainerProperty(\"volume\", Double.class, 0.0);\n"
"\n"
"... add items ...\n"
"\n"
"// Bind it to a component\n"
"Table table = new Table(\"My Table\");\n"
"table.setContainerDataSource(container);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:900
#, no-c-format
msgid "Most components also allow passing the container in the constructor. Creation depends on the container type. For some containers, such as the <classname>IndexedContainer</classname>, you need to define the contained properties (columns) as was done above, while some others determine them otherwise. The definition of a property with <methodname>addContainerProperty()</methodname> requires a unique property ID, type, and a default value. You can also give <parameter>null</parameter>."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:911
#, no-c-format
msgid "Vaadin has a several built-in in-memory container implementations, such as <classname>IndexedContainer</classname> and <classname>BeanItemContainer</classname>, which are easy to use for setting up nonpersistent data storages. For persistent data, either the built-in <classname>SQLContainer</classname> or the <classname>JPAContainer</classname> add-on container can be used."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:922
#, no-c-format
msgid "Adding Items and Accessing Properties"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:924
#, no-c-format
msgid "Items can be added to a container with the <methodname>addItem()</methodname> method. The parameterless version of the method automatically generates the item ID."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:930
#, no-c-format
msgid ""
"<![CDATA[// Create an item\n"
"Object itemId = container.addItem();]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:932
#, no-c-format
msgid "Properties can be requested from container by first requesting an item with <methodname>getItem()</methodname> and then getting the properties from the item with <methodname>getItemProperty()</methodname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:940
#, no-c-format
msgid ""
"<![CDATA[// Get the item object\n"
"Item item = container.getItem(itemId);\n"
"\n"
"// Access a property in the item\n"
"Property<String> nameProperty =\n"
"        item.getItemProperty(\"name\");\n"
"\n"
"// Do something with the property\n"
"nameProperty.setValue(\"box\");]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:942
#, no-c-format
msgid "You can also get a property directly by the item and property ids with <methodname>getContainerProperty()</methodname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:947
#, no-c-format
msgid "<?pocket-size 65% ?><![CDATA[container.getContainerProperty(itemId, \"volume\").setValue(5.0);]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:951
#, no-c-format
msgid "Adding Items by Given ID"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:953
#, no-c-format
msgid "Some containers, such as <classname>IndexedContainer</classname> and <classname>HierarchicalContainer</classname>, allow adding items by a given ID, which can be any <classname>Object</classname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:959
#, no-c-format
msgid ""
"<![CDATA[Item item = container.addItem(\"agivenid\");\n"
"item.getItemProperty(\"name\").setValue(\"barrel\");\n"
"Item.getItemProperty(\"volume\").setValue(119.2);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:961
#, no-c-format
msgid "Notice that the actual item <emphasis>is not</emphasis> given as a parameter to the method, only its ID, as the interface assumes that the container itself creates all the items it contains. Some container implementations can provide methods to add externally created items, and they can even assume that the item ID object is also the item itself. Lazy containers might not create the item immediately, but lazily when it is accessed by its ID."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:974
#, no-c-format
msgid "Container Subinterfaces"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:976
#, no-c-format
msgid "The <classname>Container</classname> interface contains inner interfaces that container implementations can implement to fulfill different features required by components that present container data."
msgstr ""

#. Tag: interfacename
#: chapter-datamodel.xml:984
#, no-c-format
msgid "Container.Filterable"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:986
#, no-c-format
msgid "Filterable containers allow filtering the contained items by filters, as described in <xref linkend=\"datamodel.container.filtered\"/>."
msgstr ""

#. Tag: interfacename
#: chapter-datamodel.xml:994
#, no-c-format
msgid "Container.Hierarchical"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:996
#, no-c-format
msgid "Hierarchical containers allow representing hierarchical relationships between items and are required by the <classname>Tree</classname> and <classname>TreeTable</classname> components. The <classname>HierarchicalContainer</classname> is a built-in in-memory container for hierarchical data, and is used as the default container for the tree components. The <classname>FilesystemContainer</classname> provides access to browsing the content of a file system. Also <classname>JPAContainer</classname> is hierarchical, as described in <xref linkend=\"jpacontainer.usage.hierarchical\"/>."
msgstr ""

#. Tag: interfacename
#: chapter-datamodel.xml:1013
#, no-c-format
msgid "Container.Indexed"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1015
#, no-c-format
msgid "An indexed container allows accessing items by an index number, not just their item ID. This feature is required by some components, especially <classname>Table</classname>, which needs to provide lazy access to large containers. The <classname>IndexedContainer</classname> is a basic in-memory implementation, as described in <xref linkend=\"datamodel.container.indexedcontainer\"/>."
msgstr ""

#. Tag: interfacename
#: chapter-datamodel.xml:1027
#, no-c-format
msgid "Container.Ordered"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1029
#, no-c-format
msgid "An ordered container allows traversing the items in successive order in either direction. Most built-in containers are ordered."
msgstr ""

#. Tag: interfacename
#: chapter-datamodel.xml:1037
#, no-c-format
msgid "Container.SimpleFilterable"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1039
#, no-c-format
msgid "This interface enables filtering a container by string matching with <methodname>addContainerFilter()</methodname>. The filtering is done by either searching the given string anywhere in a property value, or as its prefix."
msgstr ""

#. Tag: interfacename
#: chapter-datamodel.xml:1049
#, no-c-format
msgid "Container.Sortable"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1051
#, no-c-format
msgid "A sortable container is required by some components that allow sorting the content, such as <classname>Table</classname>, where the user can click a column header to sort the table by the column. Some other components, such as <classname>Calendar</classname>, may require that the content is sorted to be able to display it properly. Depending on the implementation, sorting can be done only when the <methodname>sort()</methodname> method is called, or the container is automatically kept in order according to the last call of the method."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1067
#, no-c-format
msgid "See the API documentation for a detailed description of the interfaces."
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1073 chapter-datamodel.xml:1359
#, no-c-format
msgid "IndexedContainer"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1075
#, no-c-format
msgid "The <classname>IndexedContainer</classname> is an in-memory container that implements the <interfacename>Indexed</interfacename> interface to allow referencing the items by an index. <classname>IndexedContainer</classname> is used as the default container in most selection components in Vaadin."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1082
#, no-c-format
msgid "The properties need to be defined with <methodname>addContainerProperty()</methodname>, which takes the property ID, type, and a default value. This must be done before any items are added to the container."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1089
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create the container\n"
"IndexedContainer container = new IndexedContainer();\n"
"        \n"
"// Define the properties (columns)\n"
"container.addContainerProperty(\"name\", String.class, \"noname\");\n"
"container.addContainerProperty(\"volume\", Double.class, -1.0d);\n"
"\n"
"// Add some items\n"
"Object content[][] = {{\"jar\", 2.0}, {\"bottle\", 0.75},\n"
"                      {\"can\", 1.5}};\n"
"for (Object[] row: content) {\n"
"    Item newItem = container.getItem(container.addItem());\n"
"    newItem.getItemProperty(\"name\").setValue(row[0]);\n"
"    newItem.getItemProperty(\"volume\").setValue(row[1]);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1091
#, no-c-format
msgid "New items are added with <methodname>addItem()</methodname>, which returns the item ID of the new item, or by giving the item ID as a parameter as was described earlier. Note that the <classname>Table</classname> component, which has <classname>IndexedContainer</classname> as its default container, has a conveniency <methodname>addItem()</methodname> method that allows adding items as object vectors containing the property values."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1101
#, no-c-format
msgid "The container implements the <interfacename>Container.Indexed</interfacename> feature to allow accessing the item IDs by their index number, with <methodname>getIdByIndex()</methodname>, etc. The feature is required mainly for internal purposes of some components, such as <classname>Table</classname>, which uses it to enable lazy transmission of table data to the client-side."
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1113
#, no-c-format
msgid "BeanContainer"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1115
#, no-c-format
msgid "The <classname>BeanContainer</classname> is an in-memory container for JavaBean objects. Each contained bean is wrapped inside a <classname>BeanItem</classname> wrapper. The item properties are determined automatically by inspecting the getter and setter methods of the class. This requires that the bean class has public visibility, local classes for example are not allowed. Only beans of the same type can be added to the container."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1125
#, no-c-format
msgid "The generic has two parameters: a bean type and an item identifier type. The item identifiers can be obtained by defining a custom resolver, using a specific item property for the IDs, or by giving item IDs explicitly. As such, it is more general than the <classname>BeanItemContainer</classname>, which uses the bean object itself as the item identifier, making the use usually simpler. Managing the item IDs makes <classname>BeanContainer</classname> more complex to use, but it is necessary in some cases where the <methodname>equals()</methodname> or <methodname>hashCode()</methodname> methods have been reimplemented in the bean."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1139
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Here is a JavaBean\n"
"public class Bean implements Serializable {\n"
"    String name;\n"
"    double energy; // Energy content in kJ/100g\n"
"    \n"
"    public Bean(String name, double energy) {\n"
"        this.name   = name;\n"
"        this.energy = energy;\n"
"    }\n"
"    \n"
"    public String getName() {\n"
"        return name;\n"
"    }\n"
"    \n"
"    public void setName(String name) {\n"
"        this.name = name;\n"
"    }\n"
"    \n"
"    public double getEnergy() {\n"
"        return energy;\n"
"    }\n"
"    \n"
"    public void setEnergy(double energy) {\n"
"        this.energy = energy;\n"
"    }\n"
"}\n"
"\n"
"void basic(VerticalLayout layout) {\n"
"    // Create a container for such beans with\n"
"    // strings as item IDs.\n"
"    BeanContainer<String, Bean> beans =\n"
"        new BeanContainer<String, Bean>(Bean.class);\n"
"    \n"
"    // Use the name property as the item ID of the bean\n"
"    beans.setBeanIdProperty(\"name\");\n"
"\n"
"    // Add some beans to it\n"
"    beans.addBean(new Bean(\"Mung bean\",   1452.0));\n"
"    beans.addBean(new Bean(\"Chickpea\",    686.0));\n"
"    beans.addBean(new Bean(\"Lentil\",      1477.0));\n"
"    beans.addBean(new Bean(\"Common bean\", 129.0));\n"
"    beans.addBean(new Bean(\"Soybean\",     1866.0));\n"
"\n"
"    // Bind a table to it\n"
"    Table table = new Table(\"Beans of All Sorts\", beans);\n"
"    layout.addComponent(table);\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1141
#, no-c-format
msgid "To use explicit item IDs, use the methods <methodname>addItem(Object, Object)</methodname>, <methodname>addItemAfter(Object, Object, Object)</methodname>, and <methodname>addItemAt(int, Object, Object)</methodname>."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1148
#, no-c-format
msgid "It is not possible to add additional properties to the container, except properties in a nested bean."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1154
#, no-c-format
msgid "Nested Properties"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1157 chapter-datamodel.xml:1307
#, no-c-format
msgid "nested bean properties"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1160
#, no-c-format
msgid "If you have a nested bean with a 1:1 relationship inside a bean type contained in a <classname>BeanContainer</classname> or <classname>BeanItemContainer</classname>, you can add its properties to the container by specifying them with <methodname>addNestedContainerProperty()</methodname>. The feature is defined at the level of <classname>AbstractBeanContainer</classname>."
msgstr ""

#. Tag: methodname
#: chapter-datamodel.xml:1168
#, no-c-format
msgid "addNestedContainerProperty()"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1171
#, no-c-format
msgid "As with a top-level bean in a bean container, also a nested bean must have public visibility or otherwise an access exception is thrown. Intermediary getters returning a nested bean must always return a non-null value."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1178
#, no-c-format
msgid "For example, assume that we have the following two beans with the first one nested inside the second one."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1184
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[/** Bean to be nested */\n"
"public class EqCoord implements Serializable {\n"
"    double rightAscension; /* In angle hours */\n"
"    double declination;    /* In degrees     */\n"
"\n"
"    ... constructor and setters and getters for the properties ...\n"
"}\n"
"\n"
"/** Bean containing a nested bean */\n"
"public class Star implements Serializable {\n"
"    String  name;\n"
"    EqCoord equatorial; /* Nested bean */\n"
"\n"
"    ... constructor and setters and getters for the properties ...\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1186
#, no-c-format
msgid "After creating the container, you can declare the nested properties by specifying their property identifiers with the <methodname>addNestedContainerProperty()</methodname> in dot notation."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1194
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Create a container for beans\n"
"final BeanItemContainer<Star> stars =\n"
"    new BeanItemContainer<Star>(Star.class);\n"
"\n"
"// Declare the nested properties to be used in the container\n"
"stars.addNestedContainerProperty(\"equatorial.rightAscension\");\n"
"stars.addNestedContainerProperty(\"equatorial.declination\");\n"
"\n"
"// Add some items\n"
"stars.addBean(new Star(\"Sirius\",  new EqCoord(6.75, 16.71611)));\n"
"stars.addBean(new Star(\"Polaris\", new EqCoord(2.52, 89.26417)));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1196
#, no-c-format
msgid "If you bind such a container to a <classname>Table</classname>, you probably also need to set the column headers. Notice that the entire nested bean itself is still a property in the container and would be displayed in its own column. The <methodname>toString()</methodname> method is used for obtaining the displayed value, which is by default an object reference. You normally do not want this, so you can hide the column with <methodname>setVisibleColumns()</methodname>."
msgstr ""

#. Tag: methodname
#: chapter-datamodel.xml:1205
#, no-c-format
msgid "setVisibleColumns()"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1209
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Put them in a table\n"
"Table table = new Table(\"Stars\", stars);\n"
"table.setColumnHeader(\"equatorial.rightAscension\", \"RA\");\n"
"table.setColumnHeader(\"equatorial.declination\",    \"Decl\");\n"
"table.setPageLength(table.size());\n"
"\n"
"// Have to set explicitly to hide the \"equatorial\" property\n"
"table.setVisibleColumns(new Object[]{\"name\",\n"
"    \"equatorial.rightAscension\", \"equatorial.declination\"});]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1211
#, no-c-format
msgid "The resulting table is shown in <xref linkend=\"figure.datamodel.container.beancontainer.nestedproperties\"/>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1217
#, no-c-format
msgid "<classname>Table</classname> Bound to a <classname>BeanContainer</classname> with Nested Properties"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1228
#, no-c-format
msgid "The bean binding in <classname>AbstractBeanContainer</classname> normally uses the <classname>MethodProperty</classname> implementation of the <classname>Property</classname> interface to access the bean properties using the setter and getter methods. For nested properties, the <classname>NestedMethodProperty</classname> implementation is used."
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1236
#, no-c-format
msgid "MethodProperty"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1237
#, no-c-format
msgid "NestedMethodProperty"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1244
#, no-c-format
msgid "Defining a Bean ID Resolver"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1246
#, no-c-format
msgid "If a bean ID resolver is set using <methodname>setBeanIdResolver()</methodname> or <methodname>setBeanIdProperty()</methodname>, the methods <methodname>addBean()</methodname>, <methodname>addBeanAfter()</methodname>, <methodname>addBeanAt()</methodname> and <methodname>addAll()</methodname> can be used to add items to the container. If one of these methods is called, the resolver is used to generate an identifier for the item (must not return <parameter>null</parameter>)."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1259
#, no-c-format
msgid "Note that explicit item identifiers can also be used when a resolver has been set by calling the <methodname>addItem*()</methodname> methods - the resolver is only used when adding beans using the <methodname>addBean*()</methodname> or <methodname>addAll(Collection)</methodname> methods."
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1270
#, no-c-format
msgid "BeanItemContainer"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1272
#, no-c-format
msgid "<classname>BeanItemContainer</classname> is a container for JavaBean objects where each bean is wrapped inside a <classname>BeanItem</classname> wrapper. The item properties are determined automatically by inspecting the getter and setter methods of the class. This requires that the bean class has public visibility, local classes for example are not allowed. Only beans of the same type can be added to the container."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1282
#, no-c-format
msgid "<classname>BeanItemContainer</classname> is a specialized version of the <classname>BeanContainer</classname> described in <xref linkend=\"datamodel.container.beancontainer\"/>. It uses the bean itself as the item identifier, which makes it a bit easier to use than <classname>BeanContainer</classname> in many cases. The latter is, however, needed if the bean has reimplemented the <methodname>equals()</methodname> or <methodname>hashCode()</methodname> methods."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1293
#, no-c-format
msgid "Let us revisit the example given in <xref linkend=\"datamodel.container.beancontainer\"/> using the <classname>BeanItemContainer</classname>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1300
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[// Create a container for the beans\n"
"BeanItemContainer<Bean> beans =\n"
"    new BeanItemContainer<Bean>(Bean.class);\n"
"    \n"
"// Add some beans to it\n"
"beans.addBean(new Bean(\"Mung bean\",   1452.0));\n"
"beans.addBean(new Bean(\"Chickpea\",    686.0));\n"
"beans.addBean(new Bean(\"Lentil\",      1477.0));\n"
"beans.addBean(new Bean(\"Common bean\", 129.0));\n"
"beans.addBean(new Bean(\"Soybean\",     1866.0));\n"
"\n"
"// Bind a table to it\n"
"Table table = new Table(\"Beans of All Sorts\", beans);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1302
#, no-c-format
msgid "It is not possible to add additional properties to a <classname>BeanItemContainer</classname>, except properties in a nested bean, as described in <xref linkend=\"datamodel.container.beancontainer\"/>."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1312
#, no-c-format
msgid "Iterating Over a Container"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1314
#, no-c-format
msgid "As the items in a <classname>Container</classname> are not necessarily indexed, iterating over the items has to be done using an <classname>Iterator</classname>. The <methodname>getItemIds()</methodname> method of <classname>Container</classname> returns a <classname>Collection</classname> of item identifiers over which you can iterate. The following example demonstrates a typical case where you iterate over the values of check boxes in a column of a <classname>Table</classname> component. The context of the example is the example used in <xref linkend=\"components.table\"/>."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1326
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[// Collect the results of the iteration into this string.\n"
"String items = \"\";\n"
"\n"
"// Iterate over the item identifiers of the table.\n"
"for (Iterator i = table.getItemIds().iterator(); i.hasNext();) {\n"
"    // Get the current item identifier, which is an integer.\n"
"    int iid = (Integer) i.next();\n"
"    \n"
"    // Now get the actual item from the table.\n"
"    Item item = table.getItem(iid);\n"
"    \n"
"    // And now we can get to the actual checkbox object.\n"
"    Button button = (Button)\n"
"            (item.getItemProperty(\"ismember\").getValue());\n"
"    \n"
"    // If the checkbox is selected.\n"
"    if ((Boolean)button.getValue() == true) {\n"
"        // Do something with the selected item; collect the\n"
"        // first names in a string.\n"
"        items += item.getItemProperty(\"First Name\")\n"
"                     .getValue() + \" \";\n"
"    }\n"
"}\n"
"\n"
"// Do something with the results; display the selected items.\n"
"layout.addComponent (new Label(\"Selected items: \" + items));]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1328
#, no-c-format
msgid "Notice that the <methodname>getItemIds()</methodname> returns an <emphasis>unmodifiable collection</emphasis>, so the <classname>Container</classname> may not be modified during iteration. You can not, for example, remove items from the <classname>Container</classname> during iteration. The modification includes modification in another thread. If the <classname>Container</classname> is modified during iteration, a <classname>ConcurrentModificationException</classname> is thrown and the iterator may be left in an undefined state."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1342
#, no-c-format
msgid "<classname>Filterable</classname> Containers"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1345
#, no-c-format
msgid "<primary>Container</primary>"
msgstr ""

#. Tag: secondary
#: chapter-datamodel.xml:1346
#, no-c-format
msgid "Filterable"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1349
#, no-c-format
msgid "<classname>Filter</classname> (in <classname>Container</classname>)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1352
#, no-c-format
msgid "Containers that implement the <classname>Container.Filterable</classname> interface can be filtered. For example, the built-in <classname>IndexedContainer</classname> and the bean item containers implement it. Filtering is typically used for filtering the content of a <classname>Table</classname>."
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1360
#, no-c-format
msgid "Table"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1363
#, no-c-format
msgid "Filters implement the <classname>Filter</classname> interface and you add them to a filterable container with the <methodname>addContainerFilter()</methodname> method. Container items that pass the filter condition are kept and shown in the filterable component."
msgstr ""

#. Tag: methodname
#: chapter-datamodel.xml:1369
#, no-c-format
msgid "addContainerFilter()"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1374
#, no-c-format
msgid ""
"<![CDATA[Filter filter = new SimpleStringFilter(\"name\",\n"
"        \"Douglas\", true, false);\n"
"table.addContainerFilter(filter);]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1376
#, no-c-format
msgid "If multiple filters are added to a container, they are evaluated using the logical AND operator so that only items that are passed by all the filters are kept."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1383
#, no-c-format
msgid "Atomic and Composite Filters"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1385
#, no-c-format
msgid "Filters can be classified as <emphasis>atomic</emphasis> and <emphasis>composite</emphasis>. Atomic filters, such as <classname>SimpleStringFilter</classname>, define a single condition, usually for a specific container property. Composite filters make filtering decisions based on the result of one or more other filters. The built-in composite filters implement the logical operators AND, OR, or NOT."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1395
#, no-c-format
msgid "For example, the following composite filter would filter out items where the <literal>name</literal> property contains the name \"Douglas\" somewhere <emphasis>and</emphasis> where the <literal>age</literal> property has value less than 42. The properties must have <classname>String</classname> and <classname>Integer</classname> types, respectively."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1403
#, no-c-format
msgid ""
"<![CDATA[\n"
"filter = new Or(new SimpleStringFilter(\"name\",\n"
"        \"Douglas\", true, false),\n"
"        new Compare.Less(\"age\", 42));]]>"
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1407
#, no-c-format
msgid "Built-In Filter Types"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1409
#, no-c-format
msgid "The built-in filter types are the following:"
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1415 chapter-datamodel.xml:1417
#, no-c-format
msgid "SimpleStringFilter"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1418
#, no-c-format
msgid "Passes items where the specified property, that must be of <classname>String</classname> type, contains the given <parameter>filterString</parameter> as a substring. If <parameter>ignoreCase</parameter> is <parameter>true</parameter>, the search is case insensitive. If the <parameter>onlyMatchPrefix</parameter> is <parameter>true</parameter>, the substring may only be in the beginning of the string, otherwise it may be elsewhere as well."
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1432
#, no-c-format
msgid "IsNull"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1434
#, no-c-format
msgid "<classname>IsNull</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1435
#, no-c-format
msgid "Passes items where the specified property has null value. For in-memory filtering, a simple <literal>==</literal> check is performed. For other containers, the comparison implementation is container dependent, but should correspond to the in-memory null check."
msgstr ""

#. Tag: term
#: chapter-datamodel.xml:1445
#, no-c-format
msgid "<classname>Equal</classname>, <classname>Greater</classname>, <classname>Less</classname>, <classname>GreaterOrEqual</classname>, and <classname>LessOrEqual</classname>"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1451
#, no-c-format
msgid "<classname>Equal</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1452
#, no-c-format
msgid "<classname>Greater</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1453
#, no-c-format
msgid "<classname>Less</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1454
#, no-c-format
msgid "<classname>GreaterOrEqual</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1455
#, no-c-format
msgid "<classname>LessOrEqual</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1456
#, no-c-format
msgid "The comparison filter implementations compare the specified property value to the given constant and pass items for which the comparison result is true. The comparison operators are included in the abstract <classname>Compare</classname> class."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1462
#, no-c-format
msgid "For the <classname>Equal</classname> filter, the <methodname>equals()</methodname> method for the property is used in built-in in-memory containers. In other types of containers, the comparison is container dependent and may use, for example, database comparison operations."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1469
#, no-c-format
msgid "For the other filters, the property value type must implement the <classname>Comparable</classname> interface to work with the built-in in-memory containers. Again for the other types of containers, the comparison is container dependent."
msgstr ""

#. Tag: term
#: chapter-datamodel.xml:1478
#, no-c-format
msgid "<classname>And</classname> and <classname>Or</classname>"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1480
#, no-c-format
msgid "<classname>And</classname> (filter)"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1481
#, no-c-format
msgid "<classname>Or</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1482
#, no-c-format
msgid "These logical operator filters are composite filters that combine multiple other filters."
msgstr ""

#. Tag: classname
#: chapter-datamodel.xml:1489
#, no-c-format
msgid "<classname>Not</classname>"
msgstr ""

#. Tag: primary
#: chapter-datamodel.xml:1491
#, no-c-format
msgid "<classname>Not</classname> (filter)"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1492
#, no-c-format
msgid "The logical unary operator filter negates which items are passed by the filter given as the parameter."
msgstr ""

#. Tag: title
#: chapter-datamodel.xml:1502
#, no-c-format
msgid "Implementing Custom Filters"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1504
#, no-c-format
msgid "A custom filter needs to implement the <classname>Container.Filter</classname> interface."
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1509
#, no-c-format
msgid "A filter can use a single or multiple properties for the filtering logic. The properties used by the filter must be returned with the <methodname>appliesToProperty()</methodname> method. If the filter applies to a user-defined property or properties, it is customary to give the properties as the first argument for the constructor of the filter."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1519
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[class MyCustomFilter implements Container.Filter {\n"
"    protected String propertyId;\n"
"    protected String regex;\n"
"    \n"
"    public MyCustomFilter(String propertyId, String regex) {\n"
"        this.propertyId = propertyId;\n"
"        this.regex      = regex;\n"
"    }\n"
"\n"
"    /** Tells if this filter works on the given property. */\n"
"    @Override\n"
"    public boolean appliesToProperty(Object propertyId) {\n"
"        return propertyId != null &&\n"
"               propertyId.equals(this.propertyId);\n"
"    }]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1521
#, no-c-format
msgid "The actual filtering logic is done in the <methodname>passesFilter()</methodname> method, which simply returns <literal>true</literal> if the item should pass the filter and <literal>false</literal> if it should be filtered out."
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1529
#, no-c-format
msgid ""
"<?pocket-size 65% ?><![CDATA[    /** Apply the filter on an item to check if it passes. */\n"
"    @Override\n"
"    public boolean passesFilter(Object itemId, Item item)\n"
"            throws UnsupportedOperationException {\n"
"        // Acquire the relevant property from the item object\n"
"        Property p = item.getItemProperty(propertyId);\n"
"        \n"
"        // Should always check validity\n"
"        if (p == null || !p.getType().equals(String.class))\n"
"            return false;\n"
"        String value = (String) p.getValue();\n"
"        \n"
"        // The actual filter logic\n"
"        return value.matches(regex);\n"
"    }\n"
"}]]>"
msgstr ""

#. Tag: para
#: chapter-datamodel.xml:1532
#, no-c-format
msgid "You can use such a custom filter just like any other:"
msgstr ""

#. Tag: programlisting
#: chapter-datamodel.xml:1536
#, no-c-format
msgid ""
"<?pocket-size 75% ?><![CDATA[c.addContainerFilter(\n"
"    new MyCustomFilter(\"Name\", (String) tf.getValue()));]]>"
msgstr ""
